
samd20_21_dev_module.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00009210  00000000  00000000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     00000090  20000000  00009210  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000008d8  20000090  000092a0  00020090  2**2
                  ALLOC
  3 .stack        00002000  20000968  00009b78  00020090  2**0
                  ALLOC
  4 .ARM.attributes 00000028  00000000  00000000  00020090  2**0
                  CONTENTS, READONLY
  5 .comment      00000059  00000000  00000000  000200b8  2**0
                  CONTENTS, READONLY
  6 .debug_info   000bb3f8  00000000  00000000  00020111  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00004c88  00000000  00000000  000db509  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    00019098  00000000  00000000  000e0191  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_aranges 00003d78  00000000  00000000  000f9229  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00003ae8  00000000  00000000  000fcfa1  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_macro  000152a8  00000000  00000000  00100a89  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   0001acc1  00000000  00000000  00115d31  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    000765c6  00000000  00000000  001309f2  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  0000ed38  00000000  00000000  001a6fb8  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <exception_table>:
       0:	68 29 00 20 fd 2e 00 00 89 2f 00 00 89 2f 00 00     h). ...../.../..
	...
      2c:	89 2f 00 00 00 00 00 00 00 00 00 00 89 2f 00 00     ./.........../..
      3c:	89 2f 00 00 89 2f 00 00 89 2f 00 00 89 2f 00 00     ./.../.../.../..
      4c:	89 2f 00 00 f9 48 00 00 89 2f 00 00 89 2f 00 00     ./...H.../.../..
      5c:	89 2f 00 00 89 2f 00 00 89 2f 00 00 89 2f 00 00     ./.../.../.../..
      6c:	89 2f 00 00 89 2f 00 00 89 2f 00 00 89 2f 00 00     ./.../.../.../..
      7c:	89 2f 00 00 89 2f 00 00 89 2f 00 00 89 2f 00 00     ./.../.../.../..
      8c:	89 2f 00 00 89 2f 00 00 89 2f 00 00 89 2f 00 00     ./.../.../.../..
      9c:	89 2f 00 00 89 2f 00 00                             ./.../..

000000a4 <__do_global_dtors_aux>:
      a4:	b510      	push	{r4, lr}
      a6:	4c06      	ldr	r4, [pc, #24]	; (c0 <__do_global_dtors_aux+0x1c>)
      a8:	7823      	ldrb	r3, [r4, #0]
      aa:	2b00      	cmp	r3, #0
      ac:	d107      	bne.n	be <__do_global_dtors_aux+0x1a>
      ae:	4b05      	ldr	r3, [pc, #20]	; (c4 <__do_global_dtors_aux+0x20>)
      b0:	2b00      	cmp	r3, #0
      b2:	d002      	beq.n	ba <__do_global_dtors_aux+0x16>
      b4:	4804      	ldr	r0, [pc, #16]	; (c8 <__do_global_dtors_aux+0x24>)
      b6:	e000      	b.n	ba <__do_global_dtors_aux+0x16>
      b8:	bf00      	nop
      ba:	2301      	movs	r3, #1
      bc:	7023      	strb	r3, [r4, #0]
      be:	bd10      	pop	{r4, pc}
      c0:	20000090 	.word	0x20000090
      c4:	00000000 	.word	0x00000000
      c8:	00009210 	.word	0x00009210

000000cc <frame_dummy>:
      cc:	4b08      	ldr	r3, [pc, #32]	; (f0 <frame_dummy+0x24>)
      ce:	b510      	push	{r4, lr}
      d0:	2b00      	cmp	r3, #0
      d2:	d003      	beq.n	dc <frame_dummy+0x10>
      d4:	4907      	ldr	r1, [pc, #28]	; (f4 <frame_dummy+0x28>)
      d6:	4808      	ldr	r0, [pc, #32]	; (f8 <frame_dummy+0x2c>)
      d8:	e000      	b.n	dc <frame_dummy+0x10>
      da:	bf00      	nop
      dc:	4807      	ldr	r0, [pc, #28]	; (fc <frame_dummy+0x30>)
      de:	6803      	ldr	r3, [r0, #0]
      e0:	2b00      	cmp	r3, #0
      e2:	d100      	bne.n	e6 <frame_dummy+0x1a>
      e4:	bd10      	pop	{r4, pc}
      e6:	4b06      	ldr	r3, [pc, #24]	; (100 <frame_dummy+0x34>)
      e8:	2b00      	cmp	r3, #0
      ea:	d0fb      	beq.n	e4 <frame_dummy+0x18>
      ec:	4798      	blx	r3
      ee:	e7f9      	b.n	e4 <frame_dummy+0x18>
      f0:	00000000 	.word	0x00000000
      f4:	20000094 	.word	0x20000094
      f8:	00009210 	.word	0x00009210
      fc:	00009210 	.word	0x00009210
     100:	00000000 	.word	0x00000000

00000104 <atmel_start_init>:

/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
     104:	b580      	push	{r7, lr}
     106:	af00      	add	r7, sp, #0
	system_init();
     108:	f003 fc08 	bl	391c <system_init>
}
     10c:	46c0      	nop			; (mov r8, r8)
     10e:	46bd      	mov	sp, r7
     110:	bd80      	pop	{r7, pc}

00000112 <u8g2_DrawRFrame>:
  xr -= r;
  xr -= 1;
  
  yl = y;
  yl += h;
  yl -= r; 
     112:	b5b0      	push	{r4, r5, r7, lr}
  yl -= 1;
     114:	b08a      	sub	sp, #40	; 0x28
     116:	af02      	add	r7, sp, #8
     118:	60f8      	str	r0, [r7, #12]
     11a:	000c      	movs	r4, r1
     11c:	0010      	movs	r0, r2
     11e:	0019      	movs	r1, r3
     120:	230a      	movs	r3, #10

  u8g2_DrawDisc(u8g2, xl, yu, r, U8G2_DRAW_UPPER_LEFT);
     122:	18fb      	adds	r3, r7, r3
     124:	1c22      	adds	r2, r4, #0
     126:	801a      	strh	r2, [r3, #0]
     128:	2308      	movs	r3, #8
     12a:	18fb      	adds	r3, r7, r3
     12c:	1c02      	adds	r2, r0, #0
     12e:	801a      	strh	r2, [r3, #0]
     130:	1dbb      	adds	r3, r7, #6
     132:	1c0a      	adds	r2, r1, #0
     134:	801a      	strh	r2, [r3, #0]
     136:	230a      	movs	r3, #10
     138:	18fa      	adds	r2, r7, r3
     13a:	1dbb      	adds	r3, r7, #6
     13c:	8812      	ldrh	r2, [r2, #0]
     13e:	881b      	ldrh	r3, [r3, #0]
  u8g2_DrawDisc(u8g2, xr, yu, r, U8G2_DRAW_UPPER_RIGHT);
     140:	18d3      	adds	r3, r2, r3
     142:	b29d      	uxth	r5, r3
     144:	2308      	movs	r3, #8
     146:	18fb      	adds	r3, r7, r3
     148:	2230      	movs	r2, #48	; 0x30
     14a:	18b9      	adds	r1, r7, r2
     14c:	881a      	ldrh	r2, [r3, #0]
     14e:	880b      	ldrh	r3, [r1, #0]
     150:	18d3      	adds	r3, r2, r3
     152:	b29b      	uxth	r3, r3
     154:	2208      	movs	r2, #8
     156:	18ba      	adds	r2, r7, r2
     158:	8814      	ldrh	r4, [r2, #0]
     15a:	220a      	movs	r2, #10
     15c:	18ba      	adds	r2, r7, r2
  u8g2_DrawDisc(u8g2, xl, yl, r, U8G2_DRAW_LOWER_LEFT);
     15e:	8811      	ldrh	r1, [r2, #0]
     160:	68f8      	ldr	r0, [r7, #12]
     162:	9300      	str	r3, [sp, #0]
     164:	002b      	movs	r3, r5
     166:	0022      	movs	r2, r4
     168:	f001 fdbd 	bl	1ce6 <u8g2_IsIntersection>
     16c:	1e03      	subs	r3, r0, #0
     16e:	d100      	bne.n	172 <u8g2_DrawRFrame+0x60>
     170:	e13f      	b.n	3f2 <u8g2_DrawRFrame+0x2e0>
     172:	231e      	movs	r3, #30
     174:	18fb      	adds	r3, r7, r3
     176:	220a      	movs	r2, #10
     178:	18ba      	adds	r2, r7, r2
     17a:	8812      	ldrh	r2, [r2, #0]
  u8g2_DrawDisc(u8g2, xr, yl, r, U8G2_DRAW_LOWER_RIGHT);
     17c:	801a      	strh	r2, [r3, #0]
     17e:	231e      	movs	r3, #30
     180:	18fb      	adds	r3, r7, r3
     182:	221e      	movs	r2, #30
     184:	18b9      	adds	r1, r7, r2
     186:	2234      	movs	r2, #52	; 0x34
     188:	18ba      	adds	r2, r7, r2
     18a:	8809      	ldrh	r1, [r1, #0]
     18c:	8812      	ldrh	r2, [r2, #0]
     18e:	188a      	adds	r2, r1, r2
     190:	801a      	strh	r2, [r3, #0]
     192:	231c      	movs	r3, #28
     194:	18fb      	adds	r3, r7, r3
     196:	2208      	movs	r2, #8
     198:	18ba      	adds	r2, r7, r2

  {
    u8g2_uint_t ww, hh;

    ww = w;
     19a:	8812      	ldrh	r2, [r2, #0]
     19c:	801a      	strh	r2, [r3, #0]
     19e:	231c      	movs	r3, #28
     1a0:	18fb      	adds	r3, r7, r3
     1a2:	221c      	movs	r2, #28
    ww -= r;
     1a4:	18b9      	adds	r1, r7, r2
     1a6:	2234      	movs	r2, #52	; 0x34
     1a8:	18ba      	adds	r2, r7, r2
     1aa:	8809      	ldrh	r1, [r1, #0]
     1ac:	8812      	ldrh	r2, [r2, #0]
     1ae:	188a      	adds	r2, r1, r2
     1b0:	801a      	strh	r2, [r3, #0]
     1b2:	231a      	movs	r3, #26
     1b4:	18fb      	adds	r3, r7, r3
     1b6:	220a      	movs	r2, #10
    ww -= r;
     1b8:	18ba      	adds	r2, r7, r2
     1ba:	8812      	ldrh	r2, [r2, #0]
     1bc:	801a      	strh	r2, [r3, #0]
     1be:	231a      	movs	r3, #26
     1c0:	18fb      	adds	r3, r7, r3
     1c2:	221a      	movs	r2, #26
     1c4:	18b9      	adds	r1, r7, r2
     1c6:	1dba      	adds	r2, r7, #6
     1c8:	8809      	ldrh	r1, [r1, #0]
     1ca:	8812      	ldrh	r2, [r2, #0]
    xl++;
     1cc:	188a      	adds	r2, r1, r2
     1ce:	801a      	strh	r2, [r3, #0]
     1d0:	231a      	movs	r3, #26
     1d2:	18fb      	adds	r3, r7, r3
     1d4:	221a      	movs	r2, #26
     1d6:	18b9      	adds	r1, r7, r2
     1d8:	2234      	movs	r2, #52	; 0x34
    yu++;
     1da:	18ba      	adds	r2, r7, r2
     1dc:	8809      	ldrh	r1, [r1, #0]
     1de:	8812      	ldrh	r2, [r2, #0]
     1e0:	1a8a      	subs	r2, r1, r2
     1e2:	801a      	strh	r2, [r3, #0]
     1e4:	231a      	movs	r3, #26
     1e6:	18fb      	adds	r3, r7, r3
    
    if ( ww >= 3 )
     1e8:	221a      	movs	r2, #26
     1ea:	18ba      	adds	r2, r7, r2
     1ec:	8812      	ldrh	r2, [r2, #0]
     1ee:	3a01      	subs	r2, #1
     1f0:	801a      	strh	r2, [r3, #0]
    {
      ww -= 2;
     1f2:	2318      	movs	r3, #24
     1f4:	18fb      	adds	r3, r7, r3
     1f6:	2208      	movs	r2, #8
     1f8:	18ba      	adds	r2, r7, r2
     1fa:	8812      	ldrh	r2, [r2, #0]
     1fc:	801a      	strh	r2, [r3, #0]
     1fe:	2318      	movs	r3, #24
      u8g2_DrawBox(u8g2, xl, y, ww, r+1);
     200:	18fb      	adds	r3, r7, r3
     202:	2218      	movs	r2, #24
     204:	18ba      	adds	r2, r7, r2
     206:	2130      	movs	r1, #48	; 0x30
     208:	1878      	adds	r0, r7, r1
     20a:	8811      	ldrh	r1, [r2, #0]
     20c:	8802      	ldrh	r2, [r0, #0]
     20e:	188a      	adds	r2, r1, r2
     210:	801a      	strh	r2, [r3, #0]
     212:	2318      	movs	r3, #24
     214:	18fb      	adds	r3, r7, r3
     216:	2218      	movs	r2, #24
     218:	18b9      	adds	r1, r7, r2
     21a:	2234      	movs	r2, #52	; 0x34
     21c:	18ba      	adds	r2, r7, r2
     21e:	8809      	ldrh	r1, [r1, #0]
     220:	8812      	ldrh	r2, [r2, #0]
     222:	1a8a      	subs	r2, r1, r2
     224:	801a      	strh	r2, [r3, #0]
     226:	2318      	movs	r3, #24
      u8g2_DrawBox(u8g2, xl, yl, ww, r+1);
     228:	18fb      	adds	r3, r7, r3
     22a:	2218      	movs	r2, #24
     22c:	18ba      	adds	r2, r7, r2
     22e:	8812      	ldrh	r2, [r2, #0]
     230:	3a01      	subs	r2, #1
     232:	801a      	strh	r2, [r3, #0]
     234:	2334      	movs	r3, #52	; 0x34
     236:	18fb      	adds	r3, r7, r3
     238:	881c      	ldrh	r4, [r3, #0]
     23a:	231c      	movs	r3, #28
     23c:	18fb      	adds	r3, r7, r3
     23e:	881a      	ldrh	r2, [r3, #0]
     240:	231e      	movs	r3, #30
     242:	18fb      	adds	r3, r7, r3
     244:	8819      	ldrh	r1, [r3, #0]
     246:	68f8      	ldr	r0, [r7, #12]
     248:	2302      	movs	r3, #2
     24a:	9300      	str	r3, [sp, #0]
     24c:	0023      	movs	r3, r4
     24e:	f000 fb03 	bl	858 <u8g2_DrawCircle>
    }
    
    hh = h;
     252:	2334      	movs	r3, #52	; 0x34
     254:	18fb      	adds	r3, r7, r3
     256:	881c      	ldrh	r4, [r3, #0]
     258:	231c      	movs	r3, #28
     25a:	18fb      	adds	r3, r7, r3
    hh -= r;
     25c:	881a      	ldrh	r2, [r3, #0]
     25e:	231a      	movs	r3, #26
     260:	18fb      	adds	r3, r7, r3
     262:	8819      	ldrh	r1, [r3, #0]
     264:	68f8      	ldr	r0, [r7, #12]
     266:	2301      	movs	r3, #1
     268:	9300      	str	r3, [sp, #0]
     26a:	0023      	movs	r3, r4
     26c:	f000 faf4 	bl	858 <u8g2_DrawCircle>
    hh -= r;
     270:	2334      	movs	r3, #52	; 0x34
     272:	18fb      	adds	r3, r7, r3
     274:	881c      	ldrh	r4, [r3, #0]
     276:	2318      	movs	r3, #24
     278:	18fb      	adds	r3, r7, r3
     27a:	881a      	ldrh	r2, [r3, #0]
     27c:	231e      	movs	r3, #30
     27e:	18fb      	adds	r3, r7, r3
     280:	8819      	ldrh	r1, [r3, #0]
     282:	68f8      	ldr	r0, [r7, #12]
    //h--;
    if ( hh >= 3 )
     284:	2304      	movs	r3, #4
     286:	9300      	str	r3, [sp, #0]
     288:	0023      	movs	r3, r4
     28a:	f000 fae5 	bl	858 <u8g2_DrawCircle>
    {
      hh -= 2;
     28e:	2334      	movs	r3, #52	; 0x34
     290:	18fb      	adds	r3, r7, r3
     292:	881c      	ldrh	r4, [r3, #0]
     294:	2318      	movs	r3, #24
     296:	18fb      	adds	r3, r7, r3
     298:	881a      	ldrh	r2, [r3, #0]
     29a:	231a      	movs	r3, #26
      u8g2_DrawBox(u8g2, x, yu, w, hh);
     29c:	18fb      	adds	r3, r7, r3
     29e:	8819      	ldrh	r1, [r3, #0]
     2a0:	68f8      	ldr	r0, [r7, #12]
     2a2:	2308      	movs	r3, #8
     2a4:	9300      	str	r3, [sp, #0]
     2a6:	0023      	movs	r3, r4
     2a8:	f000 fad6 	bl	858 <u8g2_DrawCircle>
     2ac:	2316      	movs	r3, #22
     2ae:	18fb      	adds	r3, r7, r3
     2b0:	1dba      	adds	r2, r7, #6
     2b2:	8812      	ldrh	r2, [r2, #0]
     2b4:	801a      	strh	r2, [r3, #0]
     2b6:	2316      	movs	r3, #22
     2b8:	18fb      	adds	r3, r7, r3
     2ba:	2216      	movs	r2, #22
     2bc:	18b9      	adds	r1, r7, r2
    return;
     2be:	2234      	movs	r2, #52	; 0x34
    }
  }
}
     2c0:	18ba      	adds	r2, r7, r2
     2c2:	8809      	ldrh	r1, [r1, #0]
     2c4:	8812      	ldrh	r2, [r2, #0]

  {
    u8g2_uint_t ww, hh;

    ww = w;
    ww -= r;
     2c6:	1a8a      	subs	r2, r1, r2
     2c8:	801a      	strh	r2, [r3, #0]
    ww -= r;
     2ca:	2316      	movs	r3, #22
     2cc:	18fb      	adds	r3, r7, r3
     2ce:	2216      	movs	r2, #22
     2d0:	18b9      	adds	r1, r7, r2
     2d2:	2234      	movs	r2, #52	; 0x34
     2d4:	18ba      	adds	r2, r7, r2
     2d6:	8809      	ldrh	r1, [r1, #0]
     2d8:	8812      	ldrh	r2, [r2, #0]
     2da:	1a8a      	subs	r2, r1, r2
     2dc:	801a      	strh	r2, [r3, #0]
    hh = h;
     2de:	2314      	movs	r3, #20
     2e0:	18fb      	adds	r3, r7, r3
     2e2:	2230      	movs	r2, #48	; 0x30
     2e4:	18ba      	adds	r2, r7, r2
     2e6:	8812      	ldrh	r2, [r2, #0]
     2e8:	801a      	strh	r2, [r3, #0]
    hh -= r;
     2ea:	2314      	movs	r3, #20
     2ec:	18fb      	adds	r3, r7, r3
     2ee:	2214      	movs	r2, #20
     2f0:	18b9      	adds	r1, r7, r2
     2f2:	2234      	movs	r2, #52	; 0x34
     2f4:	18ba      	adds	r2, r7, r2
     2f6:	8809      	ldrh	r1, [r1, #0]
     2f8:	8812      	ldrh	r2, [r2, #0]
     2fa:	1a8a      	subs	r2, r1, r2
     2fc:	801a      	strh	r2, [r3, #0]
    hh -= r;
     2fe:	2314      	movs	r3, #20
     300:	18fb      	adds	r3, r7, r3
     302:	2214      	movs	r2, #20
     304:	18b9      	adds	r1, r7, r2
     306:	2234      	movs	r2, #52	; 0x34
     308:	18ba      	adds	r2, r7, r2
     30a:	8809      	ldrh	r1, [r1, #0]
     30c:	8812      	ldrh	r2, [r2, #0]
     30e:	1a8a      	subs	r2, r1, r2
     310:	801a      	strh	r2, [r3, #0]
    
    xl++;
     312:	231e      	movs	r3, #30
     314:	18fb      	adds	r3, r7, r3
     316:	881a      	ldrh	r2, [r3, #0]
     318:	231e      	movs	r3, #30
     31a:	18fb      	adds	r3, r7, r3
     31c:	3201      	adds	r2, #1
     31e:	801a      	strh	r2, [r3, #0]
    yu++;
     320:	231c      	movs	r3, #28
     322:	18fb      	adds	r3, r7, r3
     324:	881a      	ldrh	r2, [r3, #0]
     326:	231c      	movs	r3, #28
     328:	18fb      	adds	r3, r7, r3
     32a:	3201      	adds	r2, #1
     32c:	801a      	strh	r2, [r3, #0]
    
    if ( ww >= 3 )
     32e:	2316      	movs	r3, #22
     330:	18fb      	adds	r3, r7, r3
     332:	881b      	ldrh	r3, [r3, #0]
     334:	2b02      	cmp	r3, #2
     336:	d92c      	bls.n	392 <u8g2_DrawRFrame+0x280>
    {
      ww -= 2;
     338:	2316      	movs	r3, #22
     33a:	18fb      	adds	r3, r7, r3
     33c:	2216      	movs	r2, #22
     33e:	18ba      	adds	r2, r7, r2
     340:	8812      	ldrh	r2, [r2, #0]
     342:	3a02      	subs	r2, #2
     344:	801a      	strh	r2, [r3, #0]
      h--;
     346:	2330      	movs	r3, #48	; 0x30
     348:	18fb      	adds	r3, r7, r3
     34a:	881b      	ldrh	r3, [r3, #0]
     34c:	2230      	movs	r2, #48	; 0x30
     34e:	18ba      	adds	r2, r7, r2
     350:	3b01      	subs	r3, #1
     352:	8013      	strh	r3, [r2, #0]
      u8g2_DrawHLine(u8g2, xl, y, ww);
     354:	2316      	movs	r3, #22
     356:	18fb      	adds	r3, r7, r3
     358:	881c      	ldrh	r4, [r3, #0]
     35a:	2308      	movs	r3, #8
     35c:	18fb      	adds	r3, r7, r3
     35e:	881a      	ldrh	r2, [r3, #0]
     360:	231e      	movs	r3, #30
     362:	18fb      	adds	r3, r7, r3
     364:	8819      	ldrh	r1, [r3, #0]
     366:	68f8      	ldr	r0, [r7, #12]
     368:	0023      	movs	r3, r4
     36a:	f001 fbf7 	bl	1b5c <u8g2_DrawHLine>
      u8g2_DrawHLine(u8g2, xl, y+h, ww);
     36e:	2308      	movs	r3, #8
     370:	18fb      	adds	r3, r7, r3
     372:	2230      	movs	r2, #48	; 0x30
     374:	18b9      	adds	r1, r7, r2
     376:	881a      	ldrh	r2, [r3, #0]
     378:	880b      	ldrh	r3, [r1, #0]
     37a:	18d3      	adds	r3, r2, r3
     37c:	b29a      	uxth	r2, r3
     37e:	2316      	movs	r3, #22
     380:	18fb      	adds	r3, r7, r3
     382:	881c      	ldrh	r4, [r3, #0]
     384:	231e      	movs	r3, #30
     386:	18fb      	adds	r3, r7, r3
     388:	8819      	ldrh	r1, [r3, #0]
     38a:	68f8      	ldr	r0, [r7, #12]
     38c:	0023      	movs	r3, r4
     38e:	f001 fbe5 	bl	1b5c <u8g2_DrawHLine>
    }
    
    if ( hh >= 3 )
     392:	2314      	movs	r3, #20
     394:	18fb      	adds	r3, r7, r3
     396:	881b      	ldrh	r3, [r3, #0]
     398:	2b02      	cmp	r3, #2
     39a:	d92b      	bls.n	3f4 <u8g2_DrawRFrame+0x2e2>
    {
      hh -= 2;
     39c:	2314      	movs	r3, #20
     39e:	18fb      	adds	r3, r7, r3
     3a0:	2214      	movs	r2, #20
     3a2:	18ba      	adds	r2, r7, r2
     3a4:	8812      	ldrh	r2, [r2, #0]
     3a6:	3a02      	subs	r2, #2
     3a8:	801a      	strh	r2, [r3, #0]
      w--;
     3aa:	1dbb      	adds	r3, r7, #6
     3ac:	881a      	ldrh	r2, [r3, #0]
     3ae:	1dbb      	adds	r3, r7, #6
     3b0:	3a01      	subs	r2, #1
     3b2:	801a      	strh	r2, [r3, #0]
      u8g2_DrawVLine(u8g2, x, yu, hh);
     3b4:	2314      	movs	r3, #20
     3b6:	18fb      	adds	r3, r7, r3
     3b8:	881c      	ldrh	r4, [r3, #0]
     3ba:	231c      	movs	r3, #28
     3bc:	18fb      	adds	r3, r7, r3
     3be:	881a      	ldrh	r2, [r3, #0]
     3c0:	230a      	movs	r3, #10
     3c2:	18fb      	adds	r3, r7, r3
     3c4:	8819      	ldrh	r1, [r3, #0]
     3c6:	68f8      	ldr	r0, [r7, #12]
     3c8:	0023      	movs	r3, r4
     3ca:	f001 fbeb 	bl	1ba4 <u8g2_DrawVLine>
      u8g2_DrawVLine(u8g2, x+w, yu, hh);
     3ce:	230a      	movs	r3, #10
     3d0:	18fa      	adds	r2, r7, r3
     3d2:	1dbb      	adds	r3, r7, #6
     3d4:	8812      	ldrh	r2, [r2, #0]
     3d6:	881b      	ldrh	r3, [r3, #0]
     3d8:	18d3      	adds	r3, r2, r3
     3da:	b299      	uxth	r1, r3
     3dc:	2314      	movs	r3, #20
     3de:	18fb      	adds	r3, r7, r3
     3e0:	881c      	ldrh	r4, [r3, #0]
     3e2:	231c      	movs	r3, #28
     3e4:	18fb      	adds	r3, r7, r3
     3e6:	881a      	ldrh	r2, [r3, #0]
     3e8:	68f8      	ldr	r0, [r7, #12]
     3ea:	0023      	movs	r3, r4
     3ec:	f001 fbda 	bl	1ba4 <u8g2_DrawVLine>
     3f0:	e000      	b.n	3f4 <u8g2_DrawRFrame+0x2e2>
    return;
     3f2:	46c0      	nop			; (mov r8, r8)
    }
  }
}
     3f4:	46bd      	mov	sp, r7
     3f6:	b008      	add	sp, #32
     3f8:	bdb0      	pop	{r4, r5, r7, pc}

000003fa <u8g2_ClearBuffer>:
#include "u8g2.h"
#include <string.h>

/*============================================*/
void u8g2_ClearBuffer(u8g2_t *u8g2)
{
     3fa:	b580      	push	{r7, lr}
     3fc:	b084      	sub	sp, #16
     3fe:	af00      	add	r7, sp, #0
     400:	6078      	str	r0, [r7, #4]
  size_t cnt;
  cnt = u8g2_GetU8x8(u8g2)->display_info->tile_width;
     402:	687b      	ldr	r3, [r7, #4]
     404:	681b      	ldr	r3, [r3, #0]
     406:	7c1b      	ldrb	r3, [r3, #16]
     408:	60fb      	str	r3, [r7, #12]
  cnt *= u8g2->tile_buf_height;
     40a:	687b      	ldr	r3, [r7, #4]
     40c:	2238      	movs	r2, #56	; 0x38
     40e:	5c9b      	ldrb	r3, [r3, r2]
     410:	001a      	movs	r2, r3
     412:	68fb      	ldr	r3, [r7, #12]
     414:	4353      	muls	r3, r2
     416:	60fb      	str	r3, [r7, #12]
  cnt *= 8;
     418:	68fb      	ldr	r3, [r7, #12]
     41a:	00db      	lsls	r3, r3, #3
     41c:	60fb      	str	r3, [r7, #12]
  memset(u8g2->tile_buf_ptr, 0, cnt);
     41e:	687b      	ldr	r3, [r7, #4]
     420:	6b5b      	ldr	r3, [r3, #52]	; 0x34
     422:	68fa      	ldr	r2, [r7, #12]
     424:	2100      	movs	r1, #0
     426:	0018      	movs	r0, r3
     428:	f007 fe88 	bl	813c <memset>
}
     42c:	46c0      	nop			; (mov r8, r8)
     42e:	46bd      	mov	sp, r7
     430:	b004      	add	sp, #16
     432:	bd80      	pop	{r7, pc}

00000434 <u8g2_send_tile_row>:

/*============================================*/

static void u8g2_send_tile_row(u8g2_t *u8g2, uint8_t src_tile_row, uint8_t dest_tile_row)
{
     434:	b580      	push	{r7, lr}
     436:	b086      	sub	sp, #24
     438:	af02      	add	r7, sp, #8
     43a:	6078      	str	r0, [r7, #4]
     43c:	0008      	movs	r0, r1
     43e:	0011      	movs	r1, r2
     440:	1cfb      	adds	r3, r7, #3
     442:	1c02      	adds	r2, r0, #0
     444:	701a      	strb	r2, [r3, #0]
     446:	1cbb      	adds	r3, r7, #2
     448:	1c0a      	adds	r2, r1, #0
     44a:	701a      	strb	r2, [r3, #0]
  uint8_t *ptr;
  uint16_t offset;
  uint8_t w;
  
  w = u8g2_GetU8x8(u8g2)->display_info->tile_width;
     44c:	687b      	ldr	r3, [r7, #4]
     44e:	681a      	ldr	r2, [r3, #0]
     450:	230f      	movs	r3, #15
     452:	18fb      	adds	r3, r7, r3
     454:	7c12      	ldrb	r2, [r2, #16]
     456:	701a      	strb	r2, [r3, #0]
  offset = src_tile_row;
     458:	230c      	movs	r3, #12
     45a:	18fb      	adds	r3, r7, r3
     45c:	1cfa      	adds	r2, r7, #3
     45e:	7812      	ldrb	r2, [r2, #0]
     460:	801a      	strh	r2, [r3, #0]
  ptr = u8g2->tile_buf_ptr;
     462:	687b      	ldr	r3, [r7, #4]
     464:	6b5b      	ldr	r3, [r3, #52]	; 0x34
     466:	60bb      	str	r3, [r7, #8]
  offset *= w;
     468:	230f      	movs	r3, #15
     46a:	18fb      	adds	r3, r7, r3
     46c:	781b      	ldrb	r3, [r3, #0]
     46e:	b29a      	uxth	r2, r3
     470:	230c      	movs	r3, #12
     472:	18fb      	adds	r3, r7, r3
     474:	210c      	movs	r1, #12
     476:	1879      	adds	r1, r7, r1
     478:	8809      	ldrh	r1, [r1, #0]
     47a:	434a      	muls	r2, r1
     47c:	801a      	strh	r2, [r3, #0]
  offset *= 8;
     47e:	230c      	movs	r3, #12
     480:	18fb      	adds	r3, r7, r3
     482:	220c      	movs	r2, #12
     484:	18ba      	adds	r2, r7, r2
     486:	8812      	ldrh	r2, [r2, #0]
     488:	00d2      	lsls	r2, r2, #3
     48a:	801a      	strh	r2, [r3, #0]
  ptr += offset;
     48c:	230c      	movs	r3, #12
     48e:	18fb      	adds	r3, r7, r3
     490:	881b      	ldrh	r3, [r3, #0]
     492:	68ba      	ldr	r2, [r7, #8]
     494:	18d3      	adds	r3, r2, r3
     496:	60bb      	str	r3, [r7, #8]
  u8x8_DrawTile(u8g2_GetU8x8(u8g2), 0, dest_tile_row, w, ptr);
     498:	230f      	movs	r3, #15
     49a:	18fb      	adds	r3, r7, r3
     49c:	7819      	ldrb	r1, [r3, #0]
     49e:	1cbb      	adds	r3, r7, #2
     4a0:	781a      	ldrb	r2, [r3, #0]
     4a2:	6878      	ldr	r0, [r7, #4]
     4a4:	68bb      	ldr	r3, [r7, #8]
     4a6:	9300      	str	r3, [sp, #0]
     4a8:	000b      	movs	r3, r1
     4aa:	2100      	movs	r1, #0
     4ac:	f002 f9c4 	bl	2838 <u8x8_DrawTile>
}
     4b0:	46c0      	nop			; (mov r8, r8)
     4b2:	46bd      	mov	sp, r7
     4b4:	b004      	add	sp, #16
     4b6:	bd80      	pop	{r7, pc}

000004b8 <u8g2_send_buffer>:
  For most displays, this will make the content visible to the user.
  Some displays (like the SSD1606) require a u8x8_RefreshDisplay()
*/
static void u8g2_send_buffer(u8g2_t *u8g2) U8X8_NOINLINE;
static void u8g2_send_buffer(u8g2_t *u8g2)
{
     4b8:	b580      	push	{r7, lr}
     4ba:	b084      	sub	sp, #16
     4bc:	af00      	add	r7, sp, #0
     4be:	6078      	str	r0, [r7, #4]
  uint8_t src_row;
  uint8_t src_max;
  uint8_t dest_row;
  uint8_t dest_max;

  src_row = 0;
     4c0:	230f      	movs	r3, #15
     4c2:	18fb      	adds	r3, r7, r3
     4c4:	2200      	movs	r2, #0
     4c6:	701a      	strb	r2, [r3, #0]
  src_max = u8g2->tile_buf_height;
     4c8:	230d      	movs	r3, #13
     4ca:	18fb      	adds	r3, r7, r3
     4cc:	687a      	ldr	r2, [r7, #4]
     4ce:	2138      	movs	r1, #56	; 0x38
     4d0:	5c52      	ldrb	r2, [r2, r1]
     4d2:	701a      	strb	r2, [r3, #0]
  dest_row = u8g2->tile_curr_row;
     4d4:	230e      	movs	r3, #14
     4d6:	18fb      	adds	r3, r7, r3
     4d8:	687a      	ldr	r2, [r7, #4]
     4da:	2139      	movs	r1, #57	; 0x39
     4dc:	5c52      	ldrb	r2, [r2, r1]
     4de:	701a      	strb	r2, [r3, #0]
  dest_max = u8g2_GetU8x8(u8g2)->display_info->tile_height;
     4e0:	687b      	ldr	r3, [r7, #4]
     4e2:	681a      	ldr	r2, [r3, #0]
     4e4:	230c      	movs	r3, #12
     4e6:	18fb      	adds	r3, r7, r3
     4e8:	7c52      	ldrb	r2, [r2, #17]
     4ea:	701a      	strb	r2, [r3, #0]
  
  do
  {
    u8g2_send_tile_row(u8g2, src_row, dest_row);
     4ec:	230e      	movs	r3, #14
     4ee:	18fb      	adds	r3, r7, r3
     4f0:	781a      	ldrb	r2, [r3, #0]
     4f2:	230f      	movs	r3, #15
     4f4:	18fb      	adds	r3, r7, r3
     4f6:	7819      	ldrb	r1, [r3, #0]
     4f8:	687b      	ldr	r3, [r7, #4]
     4fa:	0018      	movs	r0, r3
     4fc:	f7ff ff9a 	bl	434 <u8g2_send_tile_row>
    src_row++;
     500:	230f      	movs	r3, #15
     502:	18fb      	adds	r3, r7, r3
     504:	781a      	ldrb	r2, [r3, #0]
     506:	230f      	movs	r3, #15
     508:	18fb      	adds	r3, r7, r3
     50a:	3201      	adds	r2, #1
     50c:	701a      	strb	r2, [r3, #0]
    dest_row++;
     50e:	230e      	movs	r3, #14
     510:	18fb      	adds	r3, r7, r3
     512:	781a      	ldrb	r2, [r3, #0]
     514:	230e      	movs	r3, #14
     516:	18fb      	adds	r3, r7, r3
     518:	3201      	adds	r2, #1
     51a:	701a      	strb	r2, [r3, #0]
  } while( src_row < src_max && dest_row < dest_max );
     51c:	230f      	movs	r3, #15
     51e:	18fa      	adds	r2, r7, r3
     520:	230d      	movs	r3, #13
     522:	18fb      	adds	r3, r7, r3
     524:	7812      	ldrb	r2, [r2, #0]
     526:	781b      	ldrb	r3, [r3, #0]
     528:	429a      	cmp	r2, r3
     52a:	d207      	bcs.n	53c <u8g2_send_buffer+0x84>
     52c:	230e      	movs	r3, #14
     52e:	18fa      	adds	r2, r7, r3
     530:	230c      	movs	r3, #12
     532:	18fb      	adds	r3, r7, r3
     534:	7812      	ldrb	r2, [r2, #0]
     536:	781b      	ldrb	r3, [r3, #0]
     538:	429a      	cmp	r2, r3
     53a:	d3d7      	bcc.n	4ec <u8g2_send_buffer+0x34>
}
     53c:	46c0      	nop			; (mov r8, r8)
     53e:	46bd      	mov	sp, r7
     540:	b004      	add	sp, #16
     542:	bd80      	pop	{r7, pc}

00000544 <u8g2_SendBuffer>:

/* same as u8g2_send_buffer but also send the DISPLAY_REFRESH message (used by SSD1606) */
void u8g2_SendBuffer(u8g2_t *u8g2)
{
     544:	b580      	push	{r7, lr}
     546:	b082      	sub	sp, #8
     548:	af00      	add	r7, sp, #0
     54a:	6078      	str	r0, [r7, #4]
  u8g2_send_buffer(u8g2);
     54c:	687b      	ldr	r3, [r7, #4]
     54e:	0018      	movs	r0, r3
     550:	f7ff ffb2 	bl	4b8 <u8g2_send_buffer>
  u8x8_RefreshDisplay( u8g2_GetU8x8(u8g2) );  
     554:	687b      	ldr	r3, [r7, #4]
     556:	0018      	movs	r0, r3
     558:	f002 f9e2 	bl	2920 <u8x8_RefreshDisplay>
}
     55c:	46c0      	nop			; (mov r8, r8)
     55e:	46bd      	mov	sp, r7
     560:	b002      	add	sp, #8
     562:	bd80      	pop	{r7, pc}

00000564 <u8g2_draw_circle_section>:
/* Circle */

static void u8g2_draw_circle_section(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t x0, u8g2_uint_t y0, uint8_t option) U8G2_NOINLINE;

static void u8g2_draw_circle_section(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t x0, u8g2_uint_t y0, uint8_t option)
{
     564:	b590      	push	{r4, r7, lr}
     566:	b085      	sub	sp, #20
     568:	af00      	add	r7, sp, #0
     56a:	60f8      	str	r0, [r7, #12]
     56c:	000c      	movs	r4, r1
     56e:	0010      	movs	r0, r2
     570:	0019      	movs	r1, r3
     572:	230a      	movs	r3, #10
     574:	18fb      	adds	r3, r7, r3
     576:	1c22      	adds	r2, r4, #0
     578:	801a      	strh	r2, [r3, #0]
     57a:	2308      	movs	r3, #8
     57c:	18fb      	adds	r3, r7, r3
     57e:	1c02      	adds	r2, r0, #0
     580:	801a      	strh	r2, [r3, #0]
     582:	1dbb      	adds	r3, r7, #6
     584:	1c0a      	adds	r2, r1, #0
     586:	801a      	strh	r2, [r3, #0]
    /* upper right */
    if ( option & U8G2_DRAW_UPPER_RIGHT )
     588:	2324      	movs	r3, #36	; 0x24
     58a:	18fb      	adds	r3, r7, r3
     58c:	781b      	ldrb	r3, [r3, #0]
     58e:	2201      	movs	r2, #1
     590:	4013      	ands	r3, r2
     592:	d025      	beq.n	5e0 <u8g2_draw_circle_section+0x7c>
    {
      u8g2_DrawPixel(u8g2, x0 + x, y0 - y);
     594:	1dba      	adds	r2, r7, #6
     596:	230a      	movs	r3, #10
     598:	18fb      	adds	r3, r7, r3
     59a:	8812      	ldrh	r2, [r2, #0]
     59c:	881b      	ldrh	r3, [r3, #0]
     59e:	18d3      	adds	r3, r2, r3
     5a0:	b299      	uxth	r1, r3
     5a2:	2320      	movs	r3, #32
     5a4:	18fa      	adds	r2, r7, r3
     5a6:	2308      	movs	r3, #8
     5a8:	18fb      	adds	r3, r7, r3
     5aa:	8812      	ldrh	r2, [r2, #0]
     5ac:	881b      	ldrh	r3, [r3, #0]
     5ae:	1ad3      	subs	r3, r2, r3
     5b0:	b29a      	uxth	r2, r3
     5b2:	68fb      	ldr	r3, [r7, #12]
     5b4:	0018      	movs	r0, r3
     5b6:	f001 fb19 	bl	1bec <u8g2_DrawPixel>
      u8g2_DrawPixel(u8g2, x0 + y, y0 - x);
     5ba:	1dba      	adds	r2, r7, #6
     5bc:	2308      	movs	r3, #8
     5be:	18fb      	adds	r3, r7, r3
     5c0:	8812      	ldrh	r2, [r2, #0]
     5c2:	881b      	ldrh	r3, [r3, #0]
     5c4:	18d3      	adds	r3, r2, r3
     5c6:	b299      	uxth	r1, r3
     5c8:	2320      	movs	r3, #32
     5ca:	18fa      	adds	r2, r7, r3
     5cc:	230a      	movs	r3, #10
     5ce:	18fb      	adds	r3, r7, r3
     5d0:	8812      	ldrh	r2, [r2, #0]
     5d2:	881b      	ldrh	r3, [r3, #0]
     5d4:	1ad3      	subs	r3, r2, r3
     5d6:	b29a      	uxth	r2, r3
     5d8:	68fb      	ldr	r3, [r7, #12]
     5da:	0018      	movs	r0, r3
     5dc:	f001 fb06 	bl	1bec <u8g2_DrawPixel>
    }
    
    /* upper left */
    if ( option & U8G2_DRAW_UPPER_LEFT )
     5e0:	2324      	movs	r3, #36	; 0x24
     5e2:	18fb      	adds	r3, r7, r3
     5e4:	781b      	ldrb	r3, [r3, #0]
     5e6:	2202      	movs	r2, #2
     5e8:	4013      	ands	r3, r2
     5ea:	d025      	beq.n	638 <u8g2_draw_circle_section+0xd4>
    {
      u8g2_DrawPixel(u8g2, x0 - x, y0 - y);
     5ec:	1dba      	adds	r2, r7, #6
     5ee:	230a      	movs	r3, #10
     5f0:	18fb      	adds	r3, r7, r3
     5f2:	8812      	ldrh	r2, [r2, #0]
     5f4:	881b      	ldrh	r3, [r3, #0]
     5f6:	1ad3      	subs	r3, r2, r3
     5f8:	b299      	uxth	r1, r3
     5fa:	2320      	movs	r3, #32
     5fc:	18fa      	adds	r2, r7, r3
     5fe:	2308      	movs	r3, #8
     600:	18fb      	adds	r3, r7, r3
     602:	8812      	ldrh	r2, [r2, #0]
     604:	881b      	ldrh	r3, [r3, #0]
     606:	1ad3      	subs	r3, r2, r3
     608:	b29a      	uxth	r2, r3
     60a:	68fb      	ldr	r3, [r7, #12]
     60c:	0018      	movs	r0, r3
     60e:	f001 faed 	bl	1bec <u8g2_DrawPixel>
      u8g2_DrawPixel(u8g2, x0 - y, y0 - x);
     612:	1dba      	adds	r2, r7, #6
     614:	2308      	movs	r3, #8
     616:	18fb      	adds	r3, r7, r3
     618:	8812      	ldrh	r2, [r2, #0]
     61a:	881b      	ldrh	r3, [r3, #0]
     61c:	1ad3      	subs	r3, r2, r3
     61e:	b299      	uxth	r1, r3
     620:	2320      	movs	r3, #32
     622:	18fa      	adds	r2, r7, r3
     624:	230a      	movs	r3, #10
     626:	18fb      	adds	r3, r7, r3
     628:	8812      	ldrh	r2, [r2, #0]
     62a:	881b      	ldrh	r3, [r3, #0]
     62c:	1ad3      	subs	r3, r2, r3
     62e:	b29a      	uxth	r2, r3
     630:	68fb      	ldr	r3, [r7, #12]
     632:	0018      	movs	r0, r3
     634:	f001 fada 	bl	1bec <u8g2_DrawPixel>
    }
    
    /* lower right */
    if ( option & U8G2_DRAW_LOWER_RIGHT )
     638:	2324      	movs	r3, #36	; 0x24
     63a:	18fb      	adds	r3, r7, r3
     63c:	781b      	ldrb	r3, [r3, #0]
     63e:	2208      	movs	r2, #8
     640:	4013      	ands	r3, r2
     642:	d025      	beq.n	690 <u8g2_draw_circle_section+0x12c>
    {
      u8g2_DrawPixel(u8g2, x0 + x, y0 + y);
     644:	1dba      	adds	r2, r7, #6
     646:	230a      	movs	r3, #10
     648:	18fb      	adds	r3, r7, r3
     64a:	8812      	ldrh	r2, [r2, #0]
     64c:	881b      	ldrh	r3, [r3, #0]
     64e:	18d3      	adds	r3, r2, r3
     650:	b299      	uxth	r1, r3
     652:	2320      	movs	r3, #32
     654:	18fa      	adds	r2, r7, r3
     656:	2308      	movs	r3, #8
     658:	18fb      	adds	r3, r7, r3
     65a:	8812      	ldrh	r2, [r2, #0]
     65c:	881b      	ldrh	r3, [r3, #0]
     65e:	18d3      	adds	r3, r2, r3
     660:	b29a      	uxth	r2, r3
     662:	68fb      	ldr	r3, [r7, #12]
     664:	0018      	movs	r0, r3
     666:	f001 fac1 	bl	1bec <u8g2_DrawPixel>
      u8g2_DrawPixel(u8g2, x0 + y, y0 + x);
     66a:	1dba      	adds	r2, r7, #6
     66c:	2308      	movs	r3, #8
     66e:	18fb      	adds	r3, r7, r3
     670:	8812      	ldrh	r2, [r2, #0]
     672:	881b      	ldrh	r3, [r3, #0]
     674:	18d3      	adds	r3, r2, r3
     676:	b299      	uxth	r1, r3
     678:	2320      	movs	r3, #32
     67a:	18fa      	adds	r2, r7, r3
     67c:	230a      	movs	r3, #10
     67e:	18fb      	adds	r3, r7, r3
     680:	8812      	ldrh	r2, [r2, #0]
     682:	881b      	ldrh	r3, [r3, #0]
     684:	18d3      	adds	r3, r2, r3
     686:	b29a      	uxth	r2, r3
     688:	68fb      	ldr	r3, [r7, #12]
     68a:	0018      	movs	r0, r3
     68c:	f001 faae 	bl	1bec <u8g2_DrawPixel>
    }
    
    /* lower left */
    if ( option & U8G2_DRAW_LOWER_LEFT )
     690:	2324      	movs	r3, #36	; 0x24
     692:	18fb      	adds	r3, r7, r3
     694:	781b      	ldrb	r3, [r3, #0]
     696:	2204      	movs	r2, #4
     698:	4013      	ands	r3, r2
     69a:	d025      	beq.n	6e8 <u8g2_draw_circle_section+0x184>
    {
      u8g2_DrawPixel(u8g2, x0 - x, y0 + y);
     69c:	1dba      	adds	r2, r7, #6
     69e:	230a      	movs	r3, #10
     6a0:	18fb      	adds	r3, r7, r3
     6a2:	8812      	ldrh	r2, [r2, #0]
     6a4:	881b      	ldrh	r3, [r3, #0]
     6a6:	1ad3      	subs	r3, r2, r3
     6a8:	b299      	uxth	r1, r3
     6aa:	2320      	movs	r3, #32
     6ac:	18fa      	adds	r2, r7, r3
     6ae:	2308      	movs	r3, #8
     6b0:	18fb      	adds	r3, r7, r3
     6b2:	8812      	ldrh	r2, [r2, #0]
     6b4:	881b      	ldrh	r3, [r3, #0]
     6b6:	18d3      	adds	r3, r2, r3
     6b8:	b29a      	uxth	r2, r3
     6ba:	68fb      	ldr	r3, [r7, #12]
     6bc:	0018      	movs	r0, r3
     6be:	f001 fa95 	bl	1bec <u8g2_DrawPixel>
      u8g2_DrawPixel(u8g2, x0 - y, y0 + x);
     6c2:	1dba      	adds	r2, r7, #6
     6c4:	2308      	movs	r3, #8
     6c6:	18fb      	adds	r3, r7, r3
     6c8:	8812      	ldrh	r2, [r2, #0]
     6ca:	881b      	ldrh	r3, [r3, #0]
     6cc:	1ad3      	subs	r3, r2, r3
     6ce:	b299      	uxth	r1, r3
     6d0:	2320      	movs	r3, #32
     6d2:	18fa      	adds	r2, r7, r3
     6d4:	230a      	movs	r3, #10
     6d6:	18fb      	adds	r3, r7, r3
     6d8:	8812      	ldrh	r2, [r2, #0]
     6da:	881b      	ldrh	r3, [r3, #0]
     6dc:	18d3      	adds	r3, r2, r3
     6de:	b29a      	uxth	r2, r3
     6e0:	68fb      	ldr	r3, [r7, #12]
     6e2:	0018      	movs	r0, r3
     6e4:	f001 fa82 	bl	1bec <u8g2_DrawPixel>
    }
}
     6e8:	46c0      	nop			; (mov r8, r8)
     6ea:	46bd      	mov	sp, r7
     6ec:	b005      	add	sp, #20
     6ee:	bd90      	pop	{r4, r7, pc}

000006f0 <u8g2_draw_circle>:

static void u8g2_draw_circle(u8g2_t *u8g2, u8g2_uint_t x0, u8g2_uint_t y0, u8g2_uint_t rad, uint8_t option)
{
     6f0:	b590      	push	{r4, r7, lr}
     6f2:	b08b      	sub	sp, #44	; 0x2c
     6f4:	af02      	add	r7, sp, #8
     6f6:	60f8      	str	r0, [r7, #12]
     6f8:	000c      	movs	r4, r1
     6fa:	0010      	movs	r0, r2
     6fc:	0019      	movs	r1, r3
     6fe:	230a      	movs	r3, #10
     700:	18fb      	adds	r3, r7, r3
     702:	1c22      	adds	r2, r4, #0
     704:	801a      	strh	r2, [r3, #0]
     706:	2308      	movs	r3, #8
     708:	18fb      	adds	r3, r7, r3
     70a:	1c02      	adds	r2, r0, #0
     70c:	801a      	strh	r2, [r3, #0]
     70e:	1dbb      	adds	r3, r7, #6
     710:	1c0a      	adds	r2, r1, #0
     712:	801a      	strh	r2, [r3, #0]
    u8g2_int_t ddF_x;
    u8g2_int_t ddF_y;
    u8g2_uint_t x;
    u8g2_uint_t y;

    f = 1;
     714:	231e      	movs	r3, #30
     716:	18fb      	adds	r3, r7, r3
     718:	2201      	movs	r2, #1
     71a:	801a      	strh	r2, [r3, #0]
    f -= rad;
     71c:	231e      	movs	r3, #30
     71e:	18fb      	adds	r3, r7, r3
     720:	881a      	ldrh	r2, [r3, #0]
     722:	1dbb      	adds	r3, r7, #6
     724:	881b      	ldrh	r3, [r3, #0]
     726:	1ad3      	subs	r3, r2, r3
     728:	b29a      	uxth	r2, r3
     72a:	231e      	movs	r3, #30
     72c:	18fb      	adds	r3, r7, r3
     72e:	801a      	strh	r2, [r3, #0]
    ddF_x = 1;
     730:	231c      	movs	r3, #28
     732:	18fb      	adds	r3, r7, r3
     734:	2201      	movs	r2, #1
     736:	801a      	strh	r2, [r3, #0]
    ddF_y = 0;
     738:	231a      	movs	r3, #26
     73a:	18fb      	adds	r3, r7, r3
     73c:	2200      	movs	r2, #0
     73e:	801a      	strh	r2, [r3, #0]
    ddF_y -= rad;
     740:	231a      	movs	r3, #26
     742:	18fb      	adds	r3, r7, r3
     744:	881a      	ldrh	r2, [r3, #0]
     746:	1dbb      	adds	r3, r7, #6
     748:	881b      	ldrh	r3, [r3, #0]
     74a:	1ad3      	subs	r3, r2, r3
     74c:	b29a      	uxth	r2, r3
     74e:	231a      	movs	r3, #26
     750:	18fb      	adds	r3, r7, r3
     752:	801a      	strh	r2, [r3, #0]
    ddF_y *= 2;
     754:	231a      	movs	r3, #26
     756:	18fb      	adds	r3, r7, r3
     758:	881b      	ldrh	r3, [r3, #0]
     75a:	18db      	adds	r3, r3, r3
     75c:	b29a      	uxth	r2, r3
     75e:	231a      	movs	r3, #26
     760:	18fb      	adds	r3, r7, r3
     762:	801a      	strh	r2, [r3, #0]
    x = 0;
     764:	2318      	movs	r3, #24
     766:	18fb      	adds	r3, r7, r3
     768:	2200      	movs	r2, #0
     76a:	801a      	strh	r2, [r3, #0]
    y = rad;
     76c:	2316      	movs	r3, #22
     76e:	18fb      	adds	r3, r7, r3
     770:	1dba      	adds	r2, r7, #6
     772:	8812      	ldrh	r2, [r2, #0]
     774:	801a      	strh	r2, [r3, #0]

    u8g2_draw_circle_section(u8g2, x, y, x0, y0, option);
     776:	230a      	movs	r3, #10
     778:	18fb      	adds	r3, r7, r3
     77a:	881c      	ldrh	r4, [r3, #0]
     77c:	2316      	movs	r3, #22
     77e:	18fb      	adds	r3, r7, r3
     780:	881a      	ldrh	r2, [r3, #0]
     782:	2318      	movs	r3, #24
     784:	18fb      	adds	r3, r7, r3
     786:	8819      	ldrh	r1, [r3, #0]
     788:	68f8      	ldr	r0, [r7, #12]
     78a:	2330      	movs	r3, #48	; 0x30
     78c:	18fb      	adds	r3, r7, r3
     78e:	781b      	ldrb	r3, [r3, #0]
     790:	9301      	str	r3, [sp, #4]
     792:	2308      	movs	r3, #8
     794:	18fb      	adds	r3, r7, r3
     796:	881b      	ldrh	r3, [r3, #0]
     798:	9300      	str	r3, [sp, #0]
     79a:	0023      	movs	r3, r4
     79c:	f7ff fee2 	bl	564 <u8g2_draw_circle_section>
    
    while ( x < y )
     7a0:	e04e      	b.n	840 <u8g2_draw_circle+0x150>
    {
      if (f >= 0) 
     7a2:	231e      	movs	r3, #30
     7a4:	18fb      	adds	r3, r7, r3
     7a6:	2200      	movs	r2, #0
     7a8:	5e9b      	ldrsh	r3, [r3, r2]
     7aa:	2b00      	cmp	r3, #0
     7ac:	db19      	blt.n	7e2 <u8g2_draw_circle+0xf2>
      {
        y--;
     7ae:	2316      	movs	r3, #22
     7b0:	18fb      	adds	r3, r7, r3
     7b2:	881a      	ldrh	r2, [r3, #0]
     7b4:	2316      	movs	r3, #22
     7b6:	18fb      	adds	r3, r7, r3
     7b8:	3a01      	subs	r2, #1
     7ba:	801a      	strh	r2, [r3, #0]
        ddF_y += 2;
     7bc:	231a      	movs	r3, #26
     7be:	18fb      	adds	r3, r7, r3
     7c0:	881b      	ldrh	r3, [r3, #0]
     7c2:	3302      	adds	r3, #2
     7c4:	b29a      	uxth	r2, r3
     7c6:	231a      	movs	r3, #26
     7c8:	18fb      	adds	r3, r7, r3
     7ca:	801a      	strh	r2, [r3, #0]
        f += ddF_y;
     7cc:	231e      	movs	r3, #30
     7ce:	18fb      	adds	r3, r7, r3
     7d0:	881a      	ldrh	r2, [r3, #0]
     7d2:	231a      	movs	r3, #26
     7d4:	18fb      	adds	r3, r7, r3
     7d6:	881b      	ldrh	r3, [r3, #0]
     7d8:	18d3      	adds	r3, r2, r3
     7da:	b29a      	uxth	r2, r3
     7dc:	231e      	movs	r3, #30
     7de:	18fb      	adds	r3, r7, r3
     7e0:	801a      	strh	r2, [r3, #0]
      }
      x++;
     7e2:	2318      	movs	r3, #24
     7e4:	18fb      	adds	r3, r7, r3
     7e6:	881a      	ldrh	r2, [r3, #0]
     7e8:	2318      	movs	r3, #24
     7ea:	18fb      	adds	r3, r7, r3
     7ec:	3201      	adds	r2, #1
     7ee:	801a      	strh	r2, [r3, #0]
      ddF_x += 2;
     7f0:	231c      	movs	r3, #28
     7f2:	18fb      	adds	r3, r7, r3
     7f4:	881b      	ldrh	r3, [r3, #0]
     7f6:	3302      	adds	r3, #2
     7f8:	b29a      	uxth	r2, r3
     7fa:	231c      	movs	r3, #28
     7fc:	18fb      	adds	r3, r7, r3
     7fe:	801a      	strh	r2, [r3, #0]
      f += ddF_x;
     800:	231e      	movs	r3, #30
     802:	18fb      	adds	r3, r7, r3
     804:	881a      	ldrh	r2, [r3, #0]
     806:	231c      	movs	r3, #28
     808:	18fb      	adds	r3, r7, r3
     80a:	881b      	ldrh	r3, [r3, #0]
     80c:	18d3      	adds	r3, r2, r3
     80e:	b29a      	uxth	r2, r3
     810:	231e      	movs	r3, #30
     812:	18fb      	adds	r3, r7, r3
     814:	801a      	strh	r2, [r3, #0]

      u8g2_draw_circle_section(u8g2, x, y, x0, y0, option);    
     816:	230a      	movs	r3, #10
     818:	18fb      	adds	r3, r7, r3
     81a:	881c      	ldrh	r4, [r3, #0]
     81c:	2316      	movs	r3, #22
     81e:	18fb      	adds	r3, r7, r3
     820:	881a      	ldrh	r2, [r3, #0]
     822:	2318      	movs	r3, #24
     824:	18fb      	adds	r3, r7, r3
     826:	8819      	ldrh	r1, [r3, #0]
     828:	68f8      	ldr	r0, [r7, #12]
     82a:	2330      	movs	r3, #48	; 0x30
     82c:	18fb      	adds	r3, r7, r3
     82e:	781b      	ldrb	r3, [r3, #0]
     830:	9301      	str	r3, [sp, #4]
     832:	2308      	movs	r3, #8
     834:	18fb      	adds	r3, r7, r3
     836:	881b      	ldrh	r3, [r3, #0]
     838:	9300      	str	r3, [sp, #0]
     83a:	0023      	movs	r3, r4
     83c:	f7ff fe92 	bl	564 <u8g2_draw_circle_section>
    while ( x < y )
     840:	2318      	movs	r3, #24
     842:	18fa      	adds	r2, r7, r3
     844:	2316      	movs	r3, #22
     846:	18fb      	adds	r3, r7, r3
     848:	8812      	ldrh	r2, [r2, #0]
     84a:	881b      	ldrh	r3, [r3, #0]
     84c:	429a      	cmp	r2, r3
     84e:	d3a8      	bcc.n	7a2 <u8g2_draw_circle+0xb2>
    }
}
     850:	46c0      	nop			; (mov r8, r8)
     852:	46bd      	mov	sp, r7
     854:	b009      	add	sp, #36	; 0x24
     856:	bd90      	pop	{r4, r7, pc}

00000858 <u8g2_DrawCircle>:

void u8g2_DrawCircle(u8g2_t *u8g2, u8g2_uint_t x0, u8g2_uint_t y0, u8g2_uint_t rad, uint8_t option)
{
     858:	b5b0      	push	{r4, r5, r7, lr}
     85a:	b086      	sub	sp, #24
     85c:	af02      	add	r7, sp, #8
     85e:	60f8      	str	r0, [r7, #12]
     860:	000c      	movs	r4, r1
     862:	0010      	movs	r0, r2
     864:	0019      	movs	r1, r3
     866:	230a      	movs	r3, #10
     868:	18fb      	adds	r3, r7, r3
     86a:	1c22      	adds	r2, r4, #0
     86c:	801a      	strh	r2, [r3, #0]
     86e:	2308      	movs	r3, #8
     870:	18fb      	adds	r3, r7, r3
     872:	1c02      	adds	r2, r0, #0
     874:	801a      	strh	r2, [r3, #0]
     876:	1dbb      	adds	r3, r7, #6
     878:	1c0a      	adds	r2, r1, #0
     87a:	801a      	strh	r2, [r3, #0]
  /* check for bounding box */
#ifdef U8G2_WITH_INTERSECTION
  {
    if ( u8g2_IsIntersection(u8g2, x0-rad, y0-rad, x0+rad+1, y0+rad+1) == 0 ) 
     87c:	230a      	movs	r3, #10
     87e:	18fa      	adds	r2, r7, r3
     880:	1dbb      	adds	r3, r7, #6
     882:	8812      	ldrh	r2, [r2, #0]
     884:	881b      	ldrh	r3, [r3, #0]
     886:	1ad3      	subs	r3, r2, r3
     888:	b299      	uxth	r1, r3
     88a:	2308      	movs	r3, #8
     88c:	18fa      	adds	r2, r7, r3
     88e:	1dbb      	adds	r3, r7, #6
     890:	8812      	ldrh	r2, [r2, #0]
     892:	881b      	ldrh	r3, [r3, #0]
     894:	1ad3      	subs	r3, r2, r3
     896:	b29c      	uxth	r4, r3
     898:	230a      	movs	r3, #10
     89a:	18fa      	adds	r2, r7, r3
     89c:	1dbb      	adds	r3, r7, #6
     89e:	8812      	ldrh	r2, [r2, #0]
     8a0:	881b      	ldrh	r3, [r3, #0]
     8a2:	18d3      	adds	r3, r2, r3
     8a4:	b29b      	uxth	r3, r3
     8a6:	3301      	adds	r3, #1
     8a8:	b29d      	uxth	r5, r3
     8aa:	2308      	movs	r3, #8
     8ac:	18fa      	adds	r2, r7, r3
     8ae:	1dbb      	adds	r3, r7, #6
     8b0:	8812      	ldrh	r2, [r2, #0]
     8b2:	881b      	ldrh	r3, [r3, #0]
     8b4:	18d3      	adds	r3, r2, r3
     8b6:	b29b      	uxth	r3, r3
     8b8:	3301      	adds	r3, #1
     8ba:	b29b      	uxth	r3, r3
     8bc:	68f8      	ldr	r0, [r7, #12]
     8be:	9300      	str	r3, [sp, #0]
     8c0:	002b      	movs	r3, r5
     8c2:	0022      	movs	r2, r4
     8c4:	f001 fa0f 	bl	1ce6 <u8g2_IsIntersection>
     8c8:	1e03      	subs	r3, r0, #0
     8ca:	d010      	beq.n	8ee <u8g2_DrawCircle+0x96>
  }
#endif /* U8G2_WITH_INTERSECTION */
  
  
  /* draw circle */
  u8g2_draw_circle(u8g2, x0, y0, rad, option);
     8cc:	1dbb      	adds	r3, r7, #6
     8ce:	881c      	ldrh	r4, [r3, #0]
     8d0:	2308      	movs	r3, #8
     8d2:	18fb      	adds	r3, r7, r3
     8d4:	881a      	ldrh	r2, [r3, #0]
     8d6:	230a      	movs	r3, #10
     8d8:	18fb      	adds	r3, r7, r3
     8da:	8819      	ldrh	r1, [r3, #0]
     8dc:	68f8      	ldr	r0, [r7, #12]
     8de:	2320      	movs	r3, #32
     8e0:	18fb      	adds	r3, r7, r3
     8e2:	781b      	ldrb	r3, [r3, #0]
     8e4:	9300      	str	r3, [sp, #0]
     8e6:	0023      	movs	r3, r4
     8e8:	f7ff ff02 	bl	6f0 <u8g2_draw_circle>
     8ec:	e000      	b.n	8f0 <u8g2_DrawCircle+0x98>
      return;
     8ee:	46c0      	nop			; (mov r8, r8)
}
     8f0:	46bd      	mov	sp, r7
     8f2:	b004      	add	sp, #16
     8f4:	bdb0      	pop	{r4, r5, r7, pc}
	...

000008f8 <u8g2_m_32_7_f>:
  *page_cnt = 2;
  return buf;
  #endif
}
uint8_t *u8g2_m_32_7_f(uint8_t *page_cnt)
{
     8f8:	b580      	push	{r7, lr}
     8fa:	b082      	sub	sp, #8
     8fc:	af00      	add	r7, sp, #0
     8fe:	6078      	str	r0, [r7, #4]
  #ifdef U8G2_USE_DYNAMIC_ALLOC
  *page_cnt = 7;
  return 0;
  #else
  static uint8_t buf[1792];
  *page_cnt = 7;
     900:	687b      	ldr	r3, [r7, #4]
     902:	2207      	movs	r2, #7
     904:	701a      	strb	r2, [r3, #0]
  return buf;
     906:	4b02      	ldr	r3, [pc, #8]	; (910 <u8g2_m_32_7_f+0x18>)
  #endif
}
     908:	0018      	movs	r0, r3
     90a:	46bd      	mov	sp, r7
     90c:	b002      	add	sp, #8
     90e:	bd80      	pop	{r7, pc}
     910:	200000ac 	.word	0x200000ac

00000914 <u8g2_Setup_gp1287ai_256x50_f>:
  buf = u8g2_m_32_7_2(&tile_buf_height);
  u8g2_SetupBuffer(u8g2, buf, tile_buf_height, u8g2_ll_hvline_vertical_top_lsb, rotation);
}
/* gp1287ai f */
void u8g2_Setup_gp1287ai_256x50_f(u8g2_t *u8g2, const u8g2_cb_t *rotation, u8x8_msg_cb byte_cb, u8x8_msg_cb gpio_and_delay_cb)
{
     914:	b590      	push	{r4, r7, lr}
     916:	b089      	sub	sp, #36	; 0x24
     918:	af02      	add	r7, sp, #8
     91a:	60f8      	str	r0, [r7, #12]
     91c:	60b9      	str	r1, [r7, #8]
     91e:	607a      	str	r2, [r7, #4]
     920:	603b      	str	r3, [r7, #0]
  uint8_t tile_buf_height;
  uint8_t *buf;
  u8g2_SetupDisplay(u8g2, u8x8_d_gp1287ai_256x50, u8x8_cad_empty, byte_cb, gpio_and_delay_cb);
     922:	687c      	ldr	r4, [r7, #4]
     924:	4a0e      	ldr	r2, [pc, #56]	; (960 <u8g2_Setup_gp1287ai_256x50_f+0x4c>)
     926:	490f      	ldr	r1, [pc, #60]	; (964 <u8g2_Setup_gp1287ai_256x50_f+0x50>)
     928:	68f8      	ldr	r0, [r7, #12]
     92a:	683b      	ldr	r3, [r7, #0]
     92c:	9300      	str	r3, [sp, #0]
     92e:	0023      	movs	r3, r4
     930:	f002 fac4 	bl	2ebc <u8x8_Setup>
  buf = u8g2_m_32_7_f(&tile_buf_height);
     934:	2313      	movs	r3, #19
     936:	18fb      	adds	r3, r7, r3
     938:	0018      	movs	r0, r3
     93a:	f7ff ffdd 	bl	8f8 <u8g2_m_32_7_f>
     93e:	0003      	movs	r3, r0
     940:	617b      	str	r3, [r7, #20]
  u8g2_SetupBuffer(u8g2, buf, tile_buf_height, u8g2_ll_hvline_vertical_top_lsb, rotation);
     942:	2313      	movs	r3, #19
     944:	18fb      	adds	r3, r7, r3
     946:	781a      	ldrb	r2, [r3, #0]
     948:	4c07      	ldr	r4, [pc, #28]	; (968 <u8g2_Setup_gp1287ai_256x50_f+0x54>)
     94a:	6979      	ldr	r1, [r7, #20]
     94c:	68f8      	ldr	r0, [r7, #12]
     94e:	68bb      	ldr	r3, [r7, #8]
     950:	9300      	str	r3, [sp, #0]
     952:	0023      	movs	r3, r4
     954:	f001 fc4e 	bl	21f4 <u8g2_SetupBuffer>
}
     958:	46c0      	nop			; (mov r8, r8)
     95a:	46bd      	mov	sp, r7
     95c:	b007      	add	sp, #28
     95e:	bd90      	pop	{r4, r7, pc}
     960:	0000270d 	.word	0x0000270d
     964:	00002d89 	.word	0x00002d89
     968:	00001fd1 	.word	0x00001fd1

0000096c <u8g2_font_get_byte>:
/* low level byte and word access */

/* removed NOINLINE, because it leads to smaller code, might also be faster */
//static uint8_t u8g2_font_get_byte(const uint8_t *font, uint8_t offset) U8G2_NOINLINE;
static uint8_t u8g2_font_get_byte(const uint8_t *font, uint8_t offset)
{
     96c:	b580      	push	{r7, lr}
     96e:	b082      	sub	sp, #8
     970:	af00      	add	r7, sp, #0
     972:	6078      	str	r0, [r7, #4]
     974:	000a      	movs	r2, r1
     976:	1cfb      	adds	r3, r7, #3
     978:	701a      	strb	r2, [r3, #0]
  font += offset;
     97a:	1cfb      	adds	r3, r7, #3
     97c:	781b      	ldrb	r3, [r3, #0]
     97e:	687a      	ldr	r2, [r7, #4]
     980:	18d3      	adds	r3, r2, r3
     982:	607b      	str	r3, [r7, #4]
  return u8x8_pgm_read( font );  
     984:	687b      	ldr	r3, [r7, #4]
     986:	781b      	ldrb	r3, [r3, #0]
}
     988:	0018      	movs	r0, r3
     98a:	46bd      	mov	sp, r7
     98c:	b002      	add	sp, #8
     98e:	bd80      	pop	{r7, pc}

00000990 <u8g2_font_get_word>:

static uint16_t u8g2_font_get_word(const uint8_t *font, uint8_t offset) U8G2_NOINLINE; 
static uint16_t u8g2_font_get_word(const uint8_t *font, uint8_t offset)
{
     990:	b580      	push	{r7, lr}
     992:	b084      	sub	sp, #16
     994:	af00      	add	r7, sp, #0
     996:	6078      	str	r0, [r7, #4]
     998:	000a      	movs	r2, r1
     99a:	1cfb      	adds	r3, r7, #3
     99c:	701a      	strb	r2, [r3, #0]
    uint16_t pos;
    font += offset;
     99e:	1cfb      	adds	r3, r7, #3
     9a0:	781b      	ldrb	r3, [r3, #0]
     9a2:	687a      	ldr	r2, [r7, #4]
     9a4:	18d3      	adds	r3, r2, r3
     9a6:	607b      	str	r3, [r7, #4]
    pos = u8x8_pgm_read( font );
     9a8:	687b      	ldr	r3, [r7, #4]
     9aa:	781a      	ldrb	r2, [r3, #0]
     9ac:	230e      	movs	r3, #14
     9ae:	18fb      	adds	r3, r7, r3
     9b0:	801a      	strh	r2, [r3, #0]
    font++;
     9b2:	687b      	ldr	r3, [r7, #4]
     9b4:	3301      	adds	r3, #1
     9b6:	607b      	str	r3, [r7, #4]
    pos <<= 8;
     9b8:	230e      	movs	r3, #14
     9ba:	18fb      	adds	r3, r7, r3
     9bc:	220e      	movs	r2, #14
     9be:	18ba      	adds	r2, r7, r2
     9c0:	8812      	ldrh	r2, [r2, #0]
     9c2:	0212      	lsls	r2, r2, #8
     9c4:	801a      	strh	r2, [r3, #0]
    pos += u8x8_pgm_read( font);
     9c6:	687b      	ldr	r3, [r7, #4]
     9c8:	781b      	ldrb	r3, [r3, #0]
     9ca:	b299      	uxth	r1, r3
     9cc:	230e      	movs	r3, #14
     9ce:	18fb      	adds	r3, r7, r3
     9d0:	220e      	movs	r2, #14
     9d2:	18ba      	adds	r2, r7, r2
     9d4:	8812      	ldrh	r2, [r2, #0]
     9d6:	188a      	adds	r2, r1, r2
     9d8:	801a      	strh	r2, [r3, #0]
    return pos;
     9da:	230e      	movs	r3, #14
     9dc:	18fb      	adds	r3, r7, r3
     9de:	881b      	ldrh	r3, [r3, #0]
}
     9e0:	0018      	movs	r0, r3
     9e2:	46bd      	mov	sp, r7
     9e4:	b004      	add	sp, #16
     9e6:	bd80      	pop	{r7, pc}

000009e8 <u8g2_read_font_info>:

/*========================================================================*/
/* new font format */
void u8g2_read_font_info(u8g2_font_info_t *font_info, const uint8_t *font)
{
     9e8:	b580      	push	{r7, lr}
     9ea:	b082      	sub	sp, #8
     9ec:	af00      	add	r7, sp, #0
     9ee:	6078      	str	r0, [r7, #4]
     9f0:	6039      	str	r1, [r7, #0]
  /* offset 0 */
  font_info->glyph_cnt = u8g2_font_get_byte(font, 0);
     9f2:	683b      	ldr	r3, [r7, #0]
     9f4:	2100      	movs	r1, #0
     9f6:	0018      	movs	r0, r3
     9f8:	f7ff ffb8 	bl	96c <u8g2_font_get_byte>
     9fc:	0003      	movs	r3, r0
     9fe:	001a      	movs	r2, r3
     a00:	687b      	ldr	r3, [r7, #4]
     a02:	701a      	strb	r2, [r3, #0]
  font_info->bbx_mode = u8g2_font_get_byte(font, 1);
     a04:	683b      	ldr	r3, [r7, #0]
     a06:	2101      	movs	r1, #1
     a08:	0018      	movs	r0, r3
     a0a:	f7ff ffaf 	bl	96c <u8g2_font_get_byte>
     a0e:	0003      	movs	r3, r0
     a10:	001a      	movs	r2, r3
     a12:	687b      	ldr	r3, [r7, #4]
     a14:	705a      	strb	r2, [r3, #1]
  font_info->bits_per_0 = u8g2_font_get_byte(font, 2);
     a16:	683b      	ldr	r3, [r7, #0]
     a18:	2102      	movs	r1, #2
     a1a:	0018      	movs	r0, r3
     a1c:	f7ff ffa6 	bl	96c <u8g2_font_get_byte>
     a20:	0003      	movs	r3, r0
     a22:	001a      	movs	r2, r3
     a24:	687b      	ldr	r3, [r7, #4]
     a26:	709a      	strb	r2, [r3, #2]
  font_info->bits_per_1 = u8g2_font_get_byte(font, 3);
     a28:	683b      	ldr	r3, [r7, #0]
     a2a:	2103      	movs	r1, #3
     a2c:	0018      	movs	r0, r3
     a2e:	f7ff ff9d 	bl	96c <u8g2_font_get_byte>
     a32:	0003      	movs	r3, r0
     a34:	001a      	movs	r2, r3
     a36:	687b      	ldr	r3, [r7, #4]
     a38:	70da      	strb	r2, [r3, #3]
  
  /* offset 4 */
  font_info->bits_per_char_width = u8g2_font_get_byte(font, 4);
     a3a:	683b      	ldr	r3, [r7, #0]
     a3c:	2104      	movs	r1, #4
     a3e:	0018      	movs	r0, r3
     a40:	f7ff ff94 	bl	96c <u8g2_font_get_byte>
     a44:	0003      	movs	r3, r0
     a46:	001a      	movs	r2, r3
     a48:	687b      	ldr	r3, [r7, #4]
     a4a:	711a      	strb	r2, [r3, #4]
  font_info->bits_per_char_height = u8g2_font_get_byte(font, 5);
     a4c:	683b      	ldr	r3, [r7, #0]
     a4e:	2105      	movs	r1, #5
     a50:	0018      	movs	r0, r3
     a52:	f7ff ff8b 	bl	96c <u8g2_font_get_byte>
     a56:	0003      	movs	r3, r0
     a58:	001a      	movs	r2, r3
     a5a:	687b      	ldr	r3, [r7, #4]
     a5c:	715a      	strb	r2, [r3, #5]
  font_info->bits_per_char_x = u8g2_font_get_byte(font, 6);
     a5e:	683b      	ldr	r3, [r7, #0]
     a60:	2106      	movs	r1, #6
     a62:	0018      	movs	r0, r3
     a64:	f7ff ff82 	bl	96c <u8g2_font_get_byte>
     a68:	0003      	movs	r3, r0
     a6a:	001a      	movs	r2, r3
     a6c:	687b      	ldr	r3, [r7, #4]
     a6e:	719a      	strb	r2, [r3, #6]
  font_info->bits_per_char_y = u8g2_font_get_byte(font, 7);
     a70:	683b      	ldr	r3, [r7, #0]
     a72:	2107      	movs	r1, #7
     a74:	0018      	movs	r0, r3
     a76:	f7ff ff79 	bl	96c <u8g2_font_get_byte>
     a7a:	0003      	movs	r3, r0
     a7c:	001a      	movs	r2, r3
     a7e:	687b      	ldr	r3, [r7, #4]
     a80:	71da      	strb	r2, [r3, #7]
  font_info->bits_per_delta_x = u8g2_font_get_byte(font, 8);
     a82:	683b      	ldr	r3, [r7, #0]
     a84:	2108      	movs	r1, #8
     a86:	0018      	movs	r0, r3
     a88:	f7ff ff70 	bl	96c <u8g2_font_get_byte>
     a8c:	0003      	movs	r3, r0
     a8e:	001a      	movs	r2, r3
     a90:	687b      	ldr	r3, [r7, #4]
     a92:	721a      	strb	r2, [r3, #8]
  
  /* offset 9 */
  font_info->max_char_width = u8g2_font_get_byte(font, 9);
     a94:	683b      	ldr	r3, [r7, #0]
     a96:	2109      	movs	r1, #9
     a98:	0018      	movs	r0, r3
     a9a:	f7ff ff67 	bl	96c <u8g2_font_get_byte>
     a9e:	0003      	movs	r3, r0
     aa0:	b25a      	sxtb	r2, r3
     aa2:	687b      	ldr	r3, [r7, #4]
     aa4:	725a      	strb	r2, [r3, #9]
  font_info->max_char_height = u8g2_font_get_byte(font, 10);
     aa6:	683b      	ldr	r3, [r7, #0]
     aa8:	210a      	movs	r1, #10
     aaa:	0018      	movs	r0, r3
     aac:	f7ff ff5e 	bl	96c <u8g2_font_get_byte>
     ab0:	0003      	movs	r3, r0
     ab2:	b25a      	sxtb	r2, r3
     ab4:	687b      	ldr	r3, [r7, #4]
     ab6:	729a      	strb	r2, [r3, #10]
  font_info->x_offset = u8g2_font_get_byte(font, 11);
     ab8:	683b      	ldr	r3, [r7, #0]
     aba:	210b      	movs	r1, #11
     abc:	0018      	movs	r0, r3
     abe:	f7ff ff55 	bl	96c <u8g2_font_get_byte>
     ac2:	0003      	movs	r3, r0
     ac4:	b25a      	sxtb	r2, r3
     ac6:	687b      	ldr	r3, [r7, #4]
     ac8:	72da      	strb	r2, [r3, #11]
  font_info->y_offset = u8g2_font_get_byte(font, 12);
     aca:	683b      	ldr	r3, [r7, #0]
     acc:	210c      	movs	r1, #12
     ace:	0018      	movs	r0, r3
     ad0:	f7ff ff4c 	bl	96c <u8g2_font_get_byte>
     ad4:	0003      	movs	r3, r0
     ad6:	b25a      	sxtb	r2, r3
     ad8:	687b      	ldr	r3, [r7, #4]
     ada:	731a      	strb	r2, [r3, #12]
  
  /* offset 13 */
  font_info->ascent_A = u8g2_font_get_byte(font, 13);
     adc:	683b      	ldr	r3, [r7, #0]
     ade:	210d      	movs	r1, #13
     ae0:	0018      	movs	r0, r3
     ae2:	f7ff ff43 	bl	96c <u8g2_font_get_byte>
     ae6:	0003      	movs	r3, r0
     ae8:	b25a      	sxtb	r2, r3
     aea:	687b      	ldr	r3, [r7, #4]
     aec:	735a      	strb	r2, [r3, #13]
  font_info->descent_g = u8g2_font_get_byte(font, 14);
     aee:	683b      	ldr	r3, [r7, #0]
     af0:	210e      	movs	r1, #14
     af2:	0018      	movs	r0, r3
     af4:	f7ff ff3a 	bl	96c <u8g2_font_get_byte>
     af8:	0003      	movs	r3, r0
     afa:	b25a      	sxtb	r2, r3
     afc:	687b      	ldr	r3, [r7, #4]
     afe:	739a      	strb	r2, [r3, #14]
  font_info->ascent_para = u8g2_font_get_byte(font, 15);
     b00:	683b      	ldr	r3, [r7, #0]
     b02:	210f      	movs	r1, #15
     b04:	0018      	movs	r0, r3
     b06:	f7ff ff31 	bl	96c <u8g2_font_get_byte>
     b0a:	0003      	movs	r3, r0
     b0c:	b25a      	sxtb	r2, r3
     b0e:	687b      	ldr	r3, [r7, #4]
     b10:	73da      	strb	r2, [r3, #15]
  font_info->descent_para = u8g2_font_get_byte(font, 16);
     b12:	683b      	ldr	r3, [r7, #0]
     b14:	2110      	movs	r1, #16
     b16:	0018      	movs	r0, r3
     b18:	f7ff ff28 	bl	96c <u8g2_font_get_byte>
     b1c:	0003      	movs	r3, r0
     b1e:	b25a      	sxtb	r2, r3
     b20:	687b      	ldr	r3, [r7, #4]
     b22:	741a      	strb	r2, [r3, #16]
  
  /* offset 17 */
  font_info->start_pos_upper_A = u8g2_font_get_word(font, 17);
     b24:	683b      	ldr	r3, [r7, #0]
     b26:	2111      	movs	r1, #17
     b28:	0018      	movs	r0, r3
     b2a:	f7ff ff31 	bl	990 <u8g2_font_get_word>
     b2e:	0003      	movs	r3, r0
     b30:	001a      	movs	r2, r3
     b32:	687b      	ldr	r3, [r7, #4]
     b34:	825a      	strh	r2, [r3, #18]
  font_info->start_pos_lower_a = u8g2_font_get_word(font, 19); 
     b36:	683b      	ldr	r3, [r7, #0]
     b38:	2113      	movs	r1, #19
     b3a:	0018      	movs	r0, r3
     b3c:	f7ff ff28 	bl	990 <u8g2_font_get_word>
     b40:	0003      	movs	r3, r0
     b42:	001a      	movs	r2, r3
     b44:	687b      	ldr	r3, [r7, #4]
     b46:	829a      	strh	r2, [r3, #20]
  
  /* offset 21 */
#ifdef U8G2_WITH_UNICODE
  font_info->start_pos_unicode = u8g2_font_get_word(font, 21); 
     b48:	683b      	ldr	r3, [r7, #0]
     b4a:	2115      	movs	r1, #21
     b4c:	0018      	movs	r0, r3
     b4e:	f7ff ff1f 	bl	990 <u8g2_font_get_word>
     b52:	0003      	movs	r3, r0
     b54:	001a      	movs	r2, r3
     b56:	687b      	ldr	r3, [r7, #4]
     b58:	82da      	strh	r2, [r3, #22]
#endif
}
     b5a:	46c0      	nop			; (mov r8, r8)
     b5c:	46bd      	mov	sp, r7
     b5e:	b002      	add	sp, #8
     b60:	bd80      	pop	{r7, pc}

00000b62 <u8g2_font_decode_get_unsigned_bits>:
/*========================================================================*/
/* glyph handling */

/* optimized */
uint8_t u8g2_font_decode_get_unsigned_bits(u8g2_font_decode_t *f, uint8_t cnt) 
{
     b62:	b580      	push	{r7, lr}
     b64:	b084      	sub	sp, #16
     b66:	af00      	add	r7, sp, #0
     b68:	6078      	str	r0, [r7, #4]
     b6a:	000a      	movs	r2, r1
     b6c:	1cfb      	adds	r3, r7, #3
     b6e:	701a      	strb	r2, [r3, #0]
  uint8_t val;
  uint8_t bit_pos = f->decode_bit_pos;
     b70:	230d      	movs	r3, #13
     b72:	18fb      	adds	r3, r7, r3
     b74:	687a      	ldr	r2, [r7, #4]
     b76:	7b12      	ldrb	r2, [r2, #12]
     b78:	701a      	strb	r2, [r3, #0]
  uint8_t bit_pos_plus_cnt;
  
  //val = *(f->decode_ptr);
  val = u8x8_pgm_read( f->decode_ptr );  
     b7a:	687b      	ldr	r3, [r7, #4]
     b7c:	681a      	ldr	r2, [r3, #0]
     b7e:	230f      	movs	r3, #15
     b80:	18fb      	adds	r3, r7, r3
     b82:	7812      	ldrb	r2, [r2, #0]
     b84:	701a      	strb	r2, [r3, #0]
  
  val >>= bit_pos;
     b86:	230f      	movs	r3, #15
     b88:	18fb      	adds	r3, r7, r3
     b8a:	781a      	ldrb	r2, [r3, #0]
     b8c:	230d      	movs	r3, #13
     b8e:	18fb      	adds	r3, r7, r3
     b90:	781b      	ldrb	r3, [r3, #0]
     b92:	411a      	asrs	r2, r3
     b94:	230f      	movs	r3, #15
     b96:	18fb      	adds	r3, r7, r3
     b98:	701a      	strb	r2, [r3, #0]
  bit_pos_plus_cnt = bit_pos;
     b9a:	230e      	movs	r3, #14
     b9c:	18fb      	adds	r3, r7, r3
     b9e:	220d      	movs	r2, #13
     ba0:	18ba      	adds	r2, r7, r2
     ba2:	7812      	ldrb	r2, [r2, #0]
     ba4:	701a      	strb	r2, [r3, #0]
  bit_pos_plus_cnt += cnt;
     ba6:	230e      	movs	r3, #14
     ba8:	18fb      	adds	r3, r7, r3
     baa:	220e      	movs	r2, #14
     bac:	18b9      	adds	r1, r7, r2
     bae:	1cfa      	adds	r2, r7, #3
     bb0:	7809      	ldrb	r1, [r1, #0]
     bb2:	7812      	ldrb	r2, [r2, #0]
     bb4:	188a      	adds	r2, r1, r2
     bb6:	701a      	strb	r2, [r3, #0]
  if ( bit_pos_plus_cnt >= 8 )
     bb8:	230e      	movs	r3, #14
     bba:	18fb      	adds	r3, r7, r3
     bbc:	781b      	ldrb	r3, [r3, #0]
     bbe:	2b07      	cmp	r3, #7
     bc0:	d92c      	bls.n	c1c <u8g2_font_decode_get_unsigned_bits+0xba>
  {
    uint8_t s = 8;
     bc2:	230c      	movs	r3, #12
     bc4:	18fb      	adds	r3, r7, r3
     bc6:	2208      	movs	r2, #8
     bc8:	701a      	strb	r2, [r3, #0]
    s -= bit_pos;
     bca:	230c      	movs	r3, #12
     bcc:	18fb      	adds	r3, r7, r3
     bce:	220c      	movs	r2, #12
     bd0:	18b9      	adds	r1, r7, r2
     bd2:	220d      	movs	r2, #13
     bd4:	18ba      	adds	r2, r7, r2
     bd6:	7809      	ldrb	r1, [r1, #0]
     bd8:	7812      	ldrb	r2, [r2, #0]
     bda:	1a8a      	subs	r2, r1, r2
     bdc:	701a      	strb	r2, [r3, #0]
    f->decode_ptr++;
     bde:	687b      	ldr	r3, [r7, #4]
     be0:	681b      	ldr	r3, [r3, #0]
     be2:	1c5a      	adds	r2, r3, #1
     be4:	687b      	ldr	r3, [r7, #4]
     be6:	601a      	str	r2, [r3, #0]
    //val |= *(f->decode_ptr) << (8-bit_pos);
    val |= u8x8_pgm_read( f->decode_ptr ) << (s);
     be8:	687b      	ldr	r3, [r7, #4]
     bea:	681b      	ldr	r3, [r3, #0]
     bec:	781b      	ldrb	r3, [r3, #0]
     bee:	001a      	movs	r2, r3
     bf0:	230c      	movs	r3, #12
     bf2:	18fb      	adds	r3, r7, r3
     bf4:	781b      	ldrb	r3, [r3, #0]
     bf6:	409a      	lsls	r2, r3
     bf8:	0013      	movs	r3, r2
     bfa:	b25a      	sxtb	r2, r3
     bfc:	230f      	movs	r3, #15
     bfe:	18fb      	adds	r3, r7, r3
     c00:	781b      	ldrb	r3, [r3, #0]
     c02:	b25b      	sxtb	r3, r3
     c04:	4313      	orrs	r3, r2
     c06:	b25a      	sxtb	r2, r3
     c08:	230f      	movs	r3, #15
     c0a:	18fb      	adds	r3, r7, r3
     c0c:	701a      	strb	r2, [r3, #0]
    //bit_pos -= 8;
    bit_pos_plus_cnt -= 8;
     c0e:	230e      	movs	r3, #14
     c10:	18fb      	adds	r3, r7, r3
     c12:	220e      	movs	r2, #14
     c14:	18ba      	adds	r2, r7, r2
     c16:	7812      	ldrb	r2, [r2, #0]
     c18:	3a08      	subs	r2, #8
     c1a:	701a      	strb	r2, [r3, #0]
  }
  val &= (1U<<cnt)-1;
     c1c:	1cfb      	adds	r3, r7, #3
     c1e:	781b      	ldrb	r3, [r3, #0]
     c20:	2201      	movs	r2, #1
     c22:	409a      	lsls	r2, r3
     c24:	0013      	movs	r3, r2
     c26:	b2db      	uxtb	r3, r3
     c28:	3b01      	subs	r3, #1
     c2a:	b2da      	uxtb	r2, r3
     c2c:	230f      	movs	r3, #15
     c2e:	18fb      	adds	r3, r7, r3
     c30:	210f      	movs	r1, #15
     c32:	1879      	adds	r1, r7, r1
     c34:	7809      	ldrb	r1, [r1, #0]
     c36:	400a      	ands	r2, r1
     c38:	701a      	strb	r2, [r3, #0]
  //bit_pos += cnt;
  
  f->decode_bit_pos = bit_pos_plus_cnt;
     c3a:	687b      	ldr	r3, [r7, #4]
     c3c:	220e      	movs	r2, #14
     c3e:	18ba      	adds	r2, r7, r2
     c40:	7812      	ldrb	r2, [r2, #0]
     c42:	731a      	strb	r2, [r3, #12]
  return val;
     c44:	230f      	movs	r3, #15
     c46:	18fb      	adds	r3, r7, r3
     c48:	781b      	ldrb	r3, [r3, #0]
}
     c4a:	0018      	movs	r0, r3
     c4c:	46bd      	mov	sp, r7
     c4e:	b004      	add	sp, #16
     c50:	bd80      	pop	{r7, pc}

00000c52 <u8g2_font_decode_get_signed_bits>:
	r = bits(x)+1;

*/
/* optimized */
int8_t u8g2_font_decode_get_signed_bits(u8g2_font_decode_t *f, uint8_t cnt)
{
     c52:	b580      	push	{r7, lr}
     c54:	b084      	sub	sp, #16
     c56:	af00      	add	r7, sp, #0
     c58:	6078      	str	r0, [r7, #4]
     c5a:	000a      	movs	r2, r1
     c5c:	1cfb      	adds	r3, r7, #3
     c5e:	701a      	strb	r2, [r3, #0]
  int8_t v, d;
  v = (int8_t)u8g2_font_decode_get_unsigned_bits(f, cnt);
     c60:	1cfb      	adds	r3, r7, #3
     c62:	781a      	ldrb	r2, [r3, #0]
     c64:	687b      	ldr	r3, [r7, #4]
     c66:	0011      	movs	r1, r2
     c68:	0018      	movs	r0, r3
     c6a:	f7ff ff7a 	bl	b62 <u8g2_font_decode_get_unsigned_bits>
     c6e:	0003      	movs	r3, r0
     c70:	001a      	movs	r2, r3
     c72:	230f      	movs	r3, #15
     c74:	18fb      	adds	r3, r7, r3
     c76:	701a      	strb	r2, [r3, #0]
  d = 1;
     c78:	230e      	movs	r3, #14
     c7a:	18fb      	adds	r3, r7, r3
     c7c:	2201      	movs	r2, #1
     c7e:	701a      	strb	r2, [r3, #0]
  cnt--;
     c80:	1cfb      	adds	r3, r7, #3
     c82:	781a      	ldrb	r2, [r3, #0]
     c84:	1cfb      	adds	r3, r7, #3
     c86:	3a01      	subs	r2, #1
     c88:	701a      	strb	r2, [r3, #0]
  d <<= cnt;
     c8a:	230e      	movs	r3, #14
     c8c:	18fb      	adds	r3, r7, r3
     c8e:	2200      	movs	r2, #0
     c90:	569a      	ldrsb	r2, [r3, r2]
     c92:	1cfb      	adds	r3, r7, #3
     c94:	781b      	ldrb	r3, [r3, #0]
     c96:	409a      	lsls	r2, r3
     c98:	230e      	movs	r3, #14
     c9a:	18fb      	adds	r3, r7, r3
     c9c:	701a      	strb	r2, [r3, #0]
  v -= d;
     c9e:	230f      	movs	r3, #15
     ca0:	18fb      	adds	r3, r7, r3
     ca2:	781a      	ldrb	r2, [r3, #0]
     ca4:	230e      	movs	r3, #14
     ca6:	18fb      	adds	r3, r7, r3
     ca8:	781b      	ldrb	r3, [r3, #0]
     caa:	1ad3      	subs	r3, r2, r3
     cac:	b2da      	uxtb	r2, r3
     cae:	230f      	movs	r3, #15
     cb0:	18fb      	adds	r3, r7, r3
     cb2:	701a      	strb	r2, [r3, #0]
  return v;
     cb4:	230f      	movs	r3, #15
     cb6:	18fb      	adds	r3, r7, r3
     cb8:	781b      	ldrb	r3, [r3, #0]
     cba:	b25b      	sxtb	r3, r3
  //return (int8_t)u8g2_font_decode_get_unsigned_bits(f, cnt) - ((1<<cnt)>>1);
}
     cbc:	0018      	movs	r0, r3
     cbe:	46bd      	mov	sp, r7
     cc0:	b004      	add	sp, #16
     cc2:	bd80      	pop	{r7, pc}

00000cc4 <u8g2_add_vector_y>:


#ifdef U8G2_WITH_FONT_ROTATION
u8g2_uint_t u8g2_add_vector_y(u8g2_uint_t dy, int8_t x, int8_t y, uint8_t dir)
{
     cc4:	b5b0      	push	{r4, r5, r7, lr}
     cc6:	b082      	sub	sp, #8
     cc8:	af00      	add	r7, sp, #0
     cca:	0005      	movs	r5, r0
     ccc:	000c      	movs	r4, r1
     cce:	0010      	movs	r0, r2
     cd0:	0019      	movs	r1, r3
     cd2:	1dbb      	adds	r3, r7, #6
     cd4:	1c2a      	adds	r2, r5, #0
     cd6:	801a      	strh	r2, [r3, #0]
     cd8:	1d7b      	adds	r3, r7, #5
     cda:	1c22      	adds	r2, r4, #0
     cdc:	701a      	strb	r2, [r3, #0]
     cde:	1d3b      	adds	r3, r7, #4
     ce0:	1c02      	adds	r2, r0, #0
     ce2:	701a      	strb	r2, [r3, #0]
     ce4:	1cfb      	adds	r3, r7, #3
     ce6:	1c0a      	adds	r2, r1, #0
     ce8:	701a      	strb	r2, [r3, #0]
  switch(dir)
     cea:	1cfb      	adds	r3, r7, #3
     cec:	781b      	ldrb	r3, [r3, #0]
     cee:	2b01      	cmp	r3, #1
     cf0:	d00d      	beq.n	d0e <u8g2_add_vector_y+0x4a>
     cf2:	2b02      	cmp	r3, #2
     cf4:	d015      	beq.n	d22 <u8g2_add_vector_y+0x5e>
     cf6:	2b00      	cmp	r3, #0
     cf8:	d11d      	bne.n	d36 <u8g2_add_vector_y+0x72>
  {
    case 0:
      dy += y;
     cfa:	1d3b      	adds	r3, r7, #4
     cfc:	781b      	ldrb	r3, [r3, #0]
     cfe:	b25b      	sxtb	r3, r3
     d00:	b299      	uxth	r1, r3
     d02:	1dbb      	adds	r3, r7, #6
     d04:	1dba      	adds	r2, r7, #6
     d06:	8812      	ldrh	r2, [r2, #0]
     d08:	188a      	adds	r2, r1, r2
     d0a:	801a      	strh	r2, [r3, #0]
      break;
     d0c:	e01d      	b.n	d4a <u8g2_add_vector_y+0x86>
    case 1:
      dy += x;
     d0e:	1d7b      	adds	r3, r7, #5
     d10:	781b      	ldrb	r3, [r3, #0]
     d12:	b25b      	sxtb	r3, r3
     d14:	b299      	uxth	r1, r3
     d16:	1dbb      	adds	r3, r7, #6
     d18:	1dba      	adds	r2, r7, #6
     d1a:	8812      	ldrh	r2, [r2, #0]
     d1c:	188a      	adds	r2, r1, r2
     d1e:	801a      	strh	r2, [r3, #0]
      break;
     d20:	e013      	b.n	d4a <u8g2_add_vector_y+0x86>
    case 2:
      dy -= y;
     d22:	1d3b      	adds	r3, r7, #4
     d24:	781b      	ldrb	r3, [r3, #0]
     d26:	b25b      	sxtb	r3, r3
     d28:	b29a      	uxth	r2, r3
     d2a:	1dbb      	adds	r3, r7, #6
     d2c:	1db9      	adds	r1, r7, #6
     d2e:	8809      	ldrh	r1, [r1, #0]
     d30:	1a8a      	subs	r2, r1, r2
     d32:	801a      	strh	r2, [r3, #0]
      break;
     d34:	e009      	b.n	d4a <u8g2_add_vector_y+0x86>
    default:
      dy -= x;
     d36:	1d7b      	adds	r3, r7, #5
     d38:	781b      	ldrb	r3, [r3, #0]
     d3a:	b25b      	sxtb	r3, r3
     d3c:	b29a      	uxth	r2, r3
     d3e:	1dbb      	adds	r3, r7, #6
     d40:	1db9      	adds	r1, r7, #6
     d42:	8809      	ldrh	r1, [r1, #0]
     d44:	1a8a      	subs	r2, r1, r2
     d46:	801a      	strh	r2, [r3, #0]
      break;      
     d48:	46c0      	nop			; (mov r8, r8)
  }
  return dy;
     d4a:	1dbb      	adds	r3, r7, #6
     d4c:	881b      	ldrh	r3, [r3, #0]
}
     d4e:	0018      	movs	r0, r3
     d50:	46bd      	mov	sp, r7
     d52:	b002      	add	sp, #8
     d54:	bdb0      	pop	{r4, r5, r7, pc}

00000d56 <u8g2_add_vector_x>:

u8g2_uint_t u8g2_add_vector_x(u8g2_uint_t dx, int8_t x, int8_t y, uint8_t dir)
{
     d56:	b5b0      	push	{r4, r5, r7, lr}
     d58:	b082      	sub	sp, #8
     d5a:	af00      	add	r7, sp, #0
     d5c:	0005      	movs	r5, r0
     d5e:	000c      	movs	r4, r1
     d60:	0010      	movs	r0, r2
     d62:	0019      	movs	r1, r3
     d64:	1dbb      	adds	r3, r7, #6
     d66:	1c2a      	adds	r2, r5, #0
     d68:	801a      	strh	r2, [r3, #0]
     d6a:	1d7b      	adds	r3, r7, #5
     d6c:	1c22      	adds	r2, r4, #0
     d6e:	701a      	strb	r2, [r3, #0]
     d70:	1d3b      	adds	r3, r7, #4
     d72:	1c02      	adds	r2, r0, #0
     d74:	701a      	strb	r2, [r3, #0]
     d76:	1cfb      	adds	r3, r7, #3
     d78:	1c0a      	adds	r2, r1, #0
     d7a:	701a      	strb	r2, [r3, #0]
  switch(dir)
     d7c:	1cfb      	adds	r3, r7, #3
     d7e:	781b      	ldrb	r3, [r3, #0]
     d80:	2b01      	cmp	r3, #1
     d82:	d00d      	beq.n	da0 <u8g2_add_vector_x+0x4a>
     d84:	2b02      	cmp	r3, #2
     d86:	d015      	beq.n	db4 <u8g2_add_vector_x+0x5e>
     d88:	2b00      	cmp	r3, #0
     d8a:	d11d      	bne.n	dc8 <u8g2_add_vector_x+0x72>
  {
    case 0:
      dx += x;
     d8c:	1d7b      	adds	r3, r7, #5
     d8e:	781b      	ldrb	r3, [r3, #0]
     d90:	b25b      	sxtb	r3, r3
     d92:	b299      	uxth	r1, r3
     d94:	1dbb      	adds	r3, r7, #6
     d96:	1dba      	adds	r2, r7, #6
     d98:	8812      	ldrh	r2, [r2, #0]
     d9a:	188a      	adds	r2, r1, r2
     d9c:	801a      	strh	r2, [r3, #0]
      break;
     d9e:	e01d      	b.n	ddc <u8g2_add_vector_x+0x86>
    case 1:
      dx -= y;
     da0:	1d3b      	adds	r3, r7, #4
     da2:	781b      	ldrb	r3, [r3, #0]
     da4:	b25b      	sxtb	r3, r3
     da6:	b29a      	uxth	r2, r3
     da8:	1dbb      	adds	r3, r7, #6
     daa:	1db9      	adds	r1, r7, #6
     dac:	8809      	ldrh	r1, [r1, #0]
     dae:	1a8a      	subs	r2, r1, r2
     db0:	801a      	strh	r2, [r3, #0]
      break;
     db2:	e013      	b.n	ddc <u8g2_add_vector_x+0x86>
    case 2:
      dx -= x;
     db4:	1d7b      	adds	r3, r7, #5
     db6:	781b      	ldrb	r3, [r3, #0]
     db8:	b25b      	sxtb	r3, r3
     dba:	b29a      	uxth	r2, r3
     dbc:	1dbb      	adds	r3, r7, #6
     dbe:	1db9      	adds	r1, r7, #6
     dc0:	8809      	ldrh	r1, [r1, #0]
     dc2:	1a8a      	subs	r2, r1, r2
     dc4:	801a      	strh	r2, [r3, #0]
      break;
     dc6:	e009      	b.n	ddc <u8g2_add_vector_x+0x86>
    default:
      dx += y;
     dc8:	1d3b      	adds	r3, r7, #4
     dca:	781b      	ldrb	r3, [r3, #0]
     dcc:	b25b      	sxtb	r3, r3
     dce:	b299      	uxth	r1, r3
     dd0:	1dbb      	adds	r3, r7, #6
     dd2:	1dba      	adds	r2, r7, #6
     dd4:	8812      	ldrh	r2, [r2, #0]
     dd6:	188a      	adds	r2, r1, r2
     dd8:	801a      	strh	r2, [r3, #0]
      break;      
     dda:	46c0      	nop			; (mov r8, r8)
  }
  return dx;
     ddc:	1dbb      	adds	r3, r7, #6
     dde:	881b      	ldrh	r3, [r3, #0]
}
     de0:	0018      	movs	r0, r3
     de2:	46bd      	mov	sp, r7
     de4:	b002      	add	sp, #8
     de6:	bdb0      	pop	{r4, r5, r7, pc}

00000de8 <u8g2_font_decode_len>:
  Called by:
    u8g2_font_decode_glyph()
*/
/* optimized */
void u8g2_font_decode_len(u8g2_t *u8g2, uint8_t len, uint8_t is_foreground)
{
     de8:	b5b0      	push	{r4, r5, r7, lr}
     dea:	b088      	sub	sp, #32
     dec:	af02      	add	r7, sp, #8
     dee:	6078      	str	r0, [r7, #4]
     df0:	0008      	movs	r0, r1
     df2:	0011      	movs	r1, r2
     df4:	1cfb      	adds	r3, r7, #3
     df6:	1c02      	adds	r2, r0, #0
     df8:	701a      	strb	r2, [r3, #0]
     dfa:	1cbb      	adds	r3, r7, #2
     dfc:	1c0a      	adds	r2, r1, #0
     dfe:	701a      	strb	r2, [r3, #0]
  uint8_t lx,ly;
  
  /* target position on the screen */
  u8g2_uint_t x, y;
  
  u8g2_font_decode_t *decode = &(u8g2->font_decode);
     e00:	687b      	ldr	r3, [r7, #4]
     e02:	3360      	adds	r3, #96	; 0x60
     e04:	613b      	str	r3, [r7, #16]
  
  cnt = len;
     e06:	2317      	movs	r3, #23
     e08:	18fb      	adds	r3, r7, r3
     e0a:	1cfa      	adds	r2, r7, #3
     e0c:	7812      	ldrb	r2, [r2, #0]
     e0e:	701a      	strb	r2, [r3, #0]
  
  /* get the local position */
  lx = decode->x;
     e10:	693b      	ldr	r3, [r7, #16]
     e12:	2208      	movs	r2, #8
     e14:	569a      	ldrsb	r2, [r3, r2]
     e16:	2315      	movs	r3, #21
     e18:	18fb      	adds	r3, r7, r3
     e1a:	701a      	strb	r2, [r3, #0]
  ly = decode->y;
     e1c:	693b      	ldr	r3, [r7, #16]
     e1e:	2209      	movs	r2, #9
     e20:	569a      	ldrsb	r2, [r3, r2]
     e22:	2314      	movs	r3, #20
     e24:	18fb      	adds	r3, r7, r3
     e26:	701a      	strb	r2, [r3, #0]
  
  for(;;)
  {
    /* calculate the number of pixel to the right edge of the glyph */
    rem = decode->glyph_width;
     e28:	693b      	ldr	r3, [r7, #16]
     e2a:	220a      	movs	r2, #10
     e2c:	569a      	ldrsb	r2, [r3, r2]
     e2e:	230f      	movs	r3, #15
     e30:	18fb      	adds	r3, r7, r3
     e32:	701a      	strb	r2, [r3, #0]
    rem -= lx;
     e34:	230f      	movs	r3, #15
     e36:	18fb      	adds	r3, r7, r3
     e38:	220f      	movs	r2, #15
     e3a:	18b9      	adds	r1, r7, r2
     e3c:	2215      	movs	r2, #21
     e3e:	18ba      	adds	r2, r7, r2
     e40:	7809      	ldrb	r1, [r1, #0]
     e42:	7812      	ldrb	r2, [r2, #0]
     e44:	1a8a      	subs	r2, r1, r2
     e46:	701a      	strb	r2, [r3, #0]
    
    /* calculate how many pixel to draw. This is either to the right edge */
    /* or lesser, if not enough pixel are left */
    current = rem;
     e48:	2316      	movs	r3, #22
     e4a:	18fb      	adds	r3, r7, r3
     e4c:	220f      	movs	r2, #15
     e4e:	18ba      	adds	r2, r7, r2
     e50:	7812      	ldrb	r2, [r2, #0]
     e52:	701a      	strb	r2, [r3, #0]
    if ( cnt < rem )
     e54:	2317      	movs	r3, #23
     e56:	18fa      	adds	r2, r7, r3
     e58:	230f      	movs	r3, #15
     e5a:	18fb      	adds	r3, r7, r3
     e5c:	7812      	ldrb	r2, [r2, #0]
     e5e:	781b      	ldrb	r3, [r3, #0]
     e60:	429a      	cmp	r2, r3
     e62:	d205      	bcs.n	e70 <u8g2_font_decode_len+0x88>
      current = cnt;
     e64:	2316      	movs	r3, #22
     e66:	18fb      	adds	r3, r7, r3
     e68:	2217      	movs	r2, #23
     e6a:	18ba      	adds	r2, r7, r2
     e6c:	7812      	ldrb	r2, [r2, #0]
     e6e:	701a      	strb	r2, [r3, #0]
    
    /* now draw the line, but apply the rotation around the glyph target position */
    //u8g2_font_decode_draw_pixel(u8g2, lx,ly,current, is_foreground);

    /* get target position */
    x = decode->target_x;
     e70:	230c      	movs	r3, #12
     e72:	18fb      	adds	r3, r7, r3
     e74:	693a      	ldr	r2, [r7, #16]
     e76:	8892      	ldrh	r2, [r2, #4]
     e78:	801a      	strh	r2, [r3, #0]
    y = decode->target_y;
     e7a:	230a      	movs	r3, #10
     e7c:	18fb      	adds	r3, r7, r3
     e7e:	693a      	ldr	r2, [r7, #16]
     e80:	88d2      	ldrh	r2, [r2, #6]
     e82:	801a      	strh	r2, [r3, #0]

    /* apply rotation */
#ifdef U8G2_WITH_FONT_ROTATION
    
    x = u8g2_add_vector_x(x, lx, ly, decode->dir);
     e84:	2315      	movs	r3, #21
     e86:	18fb      	adds	r3, r7, r3
     e88:	2100      	movs	r1, #0
     e8a:	5659      	ldrsb	r1, [r3, r1]
     e8c:	2314      	movs	r3, #20
     e8e:	18fb      	adds	r3, r7, r3
     e90:	2200      	movs	r2, #0
     e92:	569a      	ldrsb	r2, [r3, r2]
     e94:	693b      	ldr	r3, [r7, #16]
     e96:	7c1d      	ldrb	r5, [r3, #16]
     e98:	230c      	movs	r3, #12
     e9a:	18fc      	adds	r4, r7, r3
     e9c:	230c      	movs	r3, #12
     e9e:	18fb      	adds	r3, r7, r3
     ea0:	8818      	ldrh	r0, [r3, #0]
     ea2:	002b      	movs	r3, r5
     ea4:	f7ff ff57 	bl	d56 <u8g2_add_vector_x>
     ea8:	0003      	movs	r3, r0
     eaa:	8023      	strh	r3, [r4, #0]
    y = u8g2_add_vector_y(y, lx, ly, decode->dir);
     eac:	2315      	movs	r3, #21
     eae:	18fb      	adds	r3, r7, r3
     eb0:	2100      	movs	r1, #0
     eb2:	5659      	ldrsb	r1, [r3, r1]
     eb4:	2314      	movs	r3, #20
     eb6:	18fb      	adds	r3, r7, r3
     eb8:	2200      	movs	r2, #0
     eba:	569a      	ldrsb	r2, [r3, r2]
     ebc:	693b      	ldr	r3, [r7, #16]
     ebe:	7c1d      	ldrb	r5, [r3, #16]
     ec0:	230a      	movs	r3, #10
     ec2:	18fc      	adds	r4, r7, r3
     ec4:	230a      	movs	r3, #10
     ec6:	18fb      	adds	r3, r7, r3
     ec8:	8818      	ldrh	r0, [r3, #0]
     eca:	002b      	movs	r3, r5
     ecc:	f7ff fefa 	bl	cc4 <u8g2_add_vector_y>
     ed0:	0003      	movs	r3, r0
     ed2:	8023      	strh	r3, [r4, #0]
    x += lx;
    y += ly;
#endif
    
    /* draw foreground and background (if required) */
    if ( is_foreground )
     ed4:	1cbb      	adds	r3, r7, #2
     ed6:	781b      	ldrb	r3, [r3, #0]
     ed8:	2b00      	cmp	r3, #0
     eda:	d017      	beq.n	f0c <u8g2_font_decode_len+0x124>
    {
      u8g2->draw_color = decode->fg_color;			/* draw_color will be restored later */
     edc:	693b      	ldr	r3, [r7, #16]
     ede:	7b99      	ldrb	r1, [r3, #14]
     ee0:	687b      	ldr	r3, [r7, #4]
     ee2:	2292      	movs	r2, #146	; 0x92
     ee4:	5499      	strb	r1, [r3, r2]
      u8g2_DrawHVLine(u8g2, 
     ee6:	2316      	movs	r3, #22
     ee8:	18fb      	adds	r3, r7, r3
     eea:	781b      	ldrb	r3, [r3, #0]
     eec:	b29d      	uxth	r5, r3
     eee:	693b      	ldr	r3, [r7, #16]
     ef0:	7c1b      	ldrb	r3, [r3, #16]
     ef2:	220a      	movs	r2, #10
     ef4:	18ba      	adds	r2, r7, r2
     ef6:	8814      	ldrh	r4, [r2, #0]
     ef8:	220c      	movs	r2, #12
     efa:	18ba      	adds	r2, r7, r2
     efc:	8811      	ldrh	r1, [r2, #0]
     efe:	6878      	ldr	r0, [r7, #4]
     f00:	9300      	str	r3, [sp, #0]
     f02:	002b      	movs	r3, r5
     f04:	0022      	movs	r2, r4
     f06:	f000 fd70 	bl	19ea <u8g2_DrawHVLine>
     f0a:	e01a      	b.n	f42 <u8g2_font_decode_len+0x15a>
#else
	0
#endif
      );
    }
    else if ( decode->is_transparent == 0 )    
     f0c:	693b      	ldr	r3, [r7, #16]
     f0e:	7b5b      	ldrb	r3, [r3, #13]
     f10:	2b00      	cmp	r3, #0
     f12:	d116      	bne.n	f42 <u8g2_font_decode_len+0x15a>
    {
      u8g2->draw_color = decode->bg_color;			/* draw_color will be restored later */
     f14:	693b      	ldr	r3, [r7, #16]
     f16:	7bd9      	ldrb	r1, [r3, #15]
     f18:	687b      	ldr	r3, [r7, #4]
     f1a:	2292      	movs	r2, #146	; 0x92
     f1c:	5499      	strb	r1, [r3, r2]
      u8g2_DrawHVLine(u8g2, 
     f1e:	2316      	movs	r3, #22
     f20:	18fb      	adds	r3, r7, r3
     f22:	781b      	ldrb	r3, [r3, #0]
     f24:	b29d      	uxth	r5, r3
     f26:	693b      	ldr	r3, [r7, #16]
     f28:	7c1b      	ldrb	r3, [r3, #16]
     f2a:	220a      	movs	r2, #10
     f2c:	18ba      	adds	r2, r7, r2
     f2e:	8814      	ldrh	r4, [r2, #0]
     f30:	220c      	movs	r2, #12
     f32:	18ba      	adds	r2, r7, r2
     f34:	8811      	ldrh	r1, [r2, #0]
     f36:	6878      	ldr	r0, [r7, #4]
     f38:	9300      	str	r3, [sp, #0]
     f3a:	002b      	movs	r3, r5
     f3c:	0022      	movs	r2, r4
     f3e:	f000 fd54 	bl	19ea <u8g2_DrawHVLine>
#endif
      );   
    }
    
    /* check, whether the end of the run length code has been reached */
    if ( cnt < rem )
     f42:	2317      	movs	r3, #23
     f44:	18fa      	adds	r2, r7, r3
     f46:	230f      	movs	r3, #15
     f48:	18fb      	adds	r3, r7, r3
     f4a:	7812      	ldrb	r2, [r2, #0]
     f4c:	781b      	ldrb	r3, [r3, #0]
     f4e:	429a      	cmp	r2, r3
     f50:	d315      	bcc.n	f7e <u8g2_font_decode_len+0x196>
      break;
    cnt -= rem;
     f52:	2317      	movs	r3, #23
     f54:	18fb      	adds	r3, r7, r3
     f56:	2217      	movs	r2, #23
     f58:	18b9      	adds	r1, r7, r2
     f5a:	220f      	movs	r2, #15
     f5c:	18ba      	adds	r2, r7, r2
     f5e:	7809      	ldrb	r1, [r1, #0]
     f60:	7812      	ldrb	r2, [r2, #0]
     f62:	1a8a      	subs	r2, r1, r2
     f64:	701a      	strb	r2, [r3, #0]
    lx = 0;
     f66:	2315      	movs	r3, #21
     f68:	18fb      	adds	r3, r7, r3
     f6a:	2200      	movs	r2, #0
     f6c:	701a      	strb	r2, [r3, #0]
    ly++;
     f6e:	2314      	movs	r3, #20
     f70:	18fb      	adds	r3, r7, r3
     f72:	781a      	ldrb	r2, [r3, #0]
     f74:	2314      	movs	r3, #20
     f76:	18fb      	adds	r3, r7, r3
     f78:	3201      	adds	r2, #1
     f7a:	701a      	strb	r2, [r3, #0]
    rem = decode->glyph_width;
     f7c:	e754      	b.n	e28 <u8g2_font_decode_len+0x40>
      break;
     f7e:	46c0      	nop			; (mov r8, r8)
  }
  lx += cnt;
     f80:	2315      	movs	r3, #21
     f82:	18fb      	adds	r3, r7, r3
     f84:	2215      	movs	r2, #21
     f86:	18b9      	adds	r1, r7, r2
     f88:	2217      	movs	r2, #23
     f8a:	18ba      	adds	r2, r7, r2
     f8c:	7809      	ldrb	r1, [r1, #0]
     f8e:	7812      	ldrb	r2, [r2, #0]
     f90:	188a      	adds	r2, r1, r2
     f92:	701a      	strb	r2, [r3, #0]
  
  decode->x = lx;
     f94:	2315      	movs	r3, #21
     f96:	18fb      	adds	r3, r7, r3
     f98:	2200      	movs	r2, #0
     f9a:	569a      	ldrsb	r2, [r3, r2]
     f9c:	693b      	ldr	r3, [r7, #16]
     f9e:	721a      	strb	r2, [r3, #8]
  decode->y = ly;  
     fa0:	2314      	movs	r3, #20
     fa2:	18fb      	adds	r3, r7, r3
     fa4:	2200      	movs	r2, #0
     fa6:	569a      	ldrsb	r2, [r3, r2]
     fa8:	693b      	ldr	r3, [r7, #16]
     faa:	725a      	strb	r2, [r3, #9]
}
     fac:	46c0      	nop			; (mov r8, r8)
     fae:	46bd      	mov	sp, r7
     fb0:	b006      	add	sp, #24
     fb2:	bdb0      	pop	{r4, r5, r7, pc}

00000fb4 <u8g2_font_setup_decode>:
  
}


static void u8g2_font_setup_decode(u8g2_t *u8g2, const uint8_t *glyph_data)
{
     fb4:	b580      	push	{r7, lr}
     fb6:	b084      	sub	sp, #16
     fb8:	af00      	add	r7, sp, #0
     fba:	6078      	str	r0, [r7, #4]
     fbc:	6039      	str	r1, [r7, #0]
  u8g2_font_decode_t *decode = &(u8g2->font_decode);
     fbe:	687b      	ldr	r3, [r7, #4]
     fc0:	3360      	adds	r3, #96	; 0x60
     fc2:	60fb      	str	r3, [r7, #12]
  decode->decode_ptr = glyph_data;
     fc4:	68fb      	ldr	r3, [r7, #12]
     fc6:	683a      	ldr	r2, [r7, #0]
     fc8:	601a      	str	r2, [r3, #0]
  decode->decode_bit_pos = 0;
     fca:	68fb      	ldr	r3, [r7, #12]
     fcc:	2200      	movs	r2, #0
     fce:	731a      	strb	r2, [r3, #12]
  /*
  decode->decode_ptr += 1;
  decode->decode_ptr += 1;
  */
  
  decode->glyph_width = u8g2_font_decode_get_unsigned_bits(decode, u8g2->font_info.bits_per_char_width);
     fd0:	687b      	ldr	r3, [r7, #4]
     fd2:	2278      	movs	r2, #120	; 0x78
     fd4:	5c9a      	ldrb	r2, [r3, r2]
     fd6:	68fb      	ldr	r3, [r7, #12]
     fd8:	0011      	movs	r1, r2
     fda:	0018      	movs	r0, r3
     fdc:	f7ff fdc1 	bl	b62 <u8g2_font_decode_get_unsigned_bits>
     fe0:	0003      	movs	r3, r0
     fe2:	b25a      	sxtb	r2, r3
     fe4:	68fb      	ldr	r3, [r7, #12]
     fe6:	729a      	strb	r2, [r3, #10]
  decode->glyph_height = u8g2_font_decode_get_unsigned_bits(decode,u8g2->font_info.bits_per_char_height);
     fe8:	687b      	ldr	r3, [r7, #4]
     fea:	2279      	movs	r2, #121	; 0x79
     fec:	5c9a      	ldrb	r2, [r3, r2]
     fee:	68fb      	ldr	r3, [r7, #12]
     ff0:	0011      	movs	r1, r2
     ff2:	0018      	movs	r0, r3
     ff4:	f7ff fdb5 	bl	b62 <u8g2_font_decode_get_unsigned_bits>
     ff8:	0003      	movs	r3, r0
     ffa:	b25a      	sxtb	r2, r3
     ffc:	68fb      	ldr	r3, [r7, #12]
     ffe:	72da      	strb	r2, [r3, #11]
  
  decode->fg_color = u8g2->draw_color;
    1000:	687b      	ldr	r3, [r7, #4]
    1002:	2292      	movs	r2, #146	; 0x92
    1004:	5c9a      	ldrb	r2, [r3, r2]
    1006:	68fb      	ldr	r3, [r7, #12]
    1008:	739a      	strb	r2, [r3, #14]
  decode->bg_color = (decode->fg_color == 0 ? 1 : 0);
    100a:	68fb      	ldr	r3, [r7, #12]
    100c:	7b9b      	ldrb	r3, [r3, #14]
    100e:	425a      	negs	r2, r3
    1010:	4153      	adcs	r3, r2
    1012:	b2db      	uxtb	r3, r3
    1014:	001a      	movs	r2, r3
    1016:	68fb      	ldr	r3, [r7, #12]
    1018:	73da      	strb	r2, [r3, #15]
}
    101a:	46c0      	nop			; (mov r8, r8)
    101c:	46bd      	mov	sp, r7
    101e:	b004      	add	sp, #16
    1020:	bd80      	pop	{r7, pc}

00001022 <u8g2_font_decode_glyph>:
  Calls:
    u8g2_font_decode_len()
*/
/* optimized */
int8_t u8g2_font_decode_glyph(u8g2_t *u8g2, const uint8_t *glyph_data)
{
    1022:	b590      	push	{r4, r7, lr}
    1024:	b08b      	sub	sp, #44	; 0x2c
    1026:	af02      	add	r7, sp, #8
    1028:	6078      	str	r0, [r7, #4]
    102a:	6039      	str	r1, [r7, #0]
  uint8_t a, b;
  int8_t x, y;
  int8_t d;
  int8_t h;
  u8g2_font_decode_t *decode = &(u8g2->font_decode);
    102c:	687b      	ldr	r3, [r7, #4]
    102e:	3360      	adds	r3, #96	; 0x60
    1030:	617b      	str	r3, [r7, #20]
    
  u8g2_font_setup_decode(u8g2, glyph_data);     /* set values in u8g2->font_decode data structure */
    1032:	683a      	ldr	r2, [r7, #0]
    1034:	687b      	ldr	r3, [r7, #4]
    1036:	0011      	movs	r1, r2
    1038:	0018      	movs	r0, r3
    103a:	f7ff ffbb 	bl	fb4 <u8g2_font_setup_decode>
  h = u8g2->font_decode.glyph_height;
    103e:	2313      	movs	r3, #19
    1040:	18fb      	adds	r3, r7, r3
    1042:	687a      	ldr	r2, [r7, #4]
    1044:	216b      	movs	r1, #107	; 0x6b
    1046:	5c52      	ldrb	r2, [r2, r1]
    1048:	701a      	strb	r2, [r3, #0]
  
  x = u8g2_font_decode_get_signed_bits(decode, u8g2->font_info.bits_per_char_x);
    104a:	687b      	ldr	r3, [r7, #4]
    104c:	227a      	movs	r2, #122	; 0x7a
    104e:	5c9a      	ldrb	r2, [r3, r2]
    1050:	2312      	movs	r3, #18
    1052:	18fc      	adds	r4, r7, r3
    1054:	697b      	ldr	r3, [r7, #20]
    1056:	0011      	movs	r1, r2
    1058:	0018      	movs	r0, r3
    105a:	f7ff fdfa 	bl	c52 <u8g2_font_decode_get_signed_bits>
    105e:	0003      	movs	r3, r0
    1060:	7023      	strb	r3, [r4, #0]
  y = u8g2_font_decode_get_signed_bits(decode, u8g2->font_info.bits_per_char_y);
    1062:	687b      	ldr	r3, [r7, #4]
    1064:	227b      	movs	r2, #123	; 0x7b
    1066:	5c9a      	ldrb	r2, [r3, r2]
    1068:	2311      	movs	r3, #17
    106a:	18fc      	adds	r4, r7, r3
    106c:	697b      	ldr	r3, [r7, #20]
    106e:	0011      	movs	r1, r2
    1070:	0018      	movs	r0, r3
    1072:	f7ff fdee 	bl	c52 <u8g2_font_decode_get_signed_bits>
    1076:	0003      	movs	r3, r0
    1078:	7023      	strb	r3, [r4, #0]
  d = u8g2_font_decode_get_signed_bits(decode, u8g2->font_info.bits_per_delta_x);
    107a:	687b      	ldr	r3, [r7, #4]
    107c:	227c      	movs	r2, #124	; 0x7c
    107e:	5c9a      	ldrb	r2, [r3, r2]
    1080:	2310      	movs	r3, #16
    1082:	18fc      	adds	r4, r7, r3
    1084:	697b      	ldr	r3, [r7, #20]
    1086:	0011      	movs	r1, r2
    1088:	0018      	movs	r0, r3
    108a:	f7ff fde2 	bl	c52 <u8g2_font_decode_get_signed_bits>
    108e:	0003      	movs	r3, r0
    1090:	7023      	strb	r3, [r4, #0]
  
  if ( decode->glyph_width > 0 )
    1092:	697b      	ldr	r3, [r7, #20]
    1094:	7a9b      	ldrb	r3, [r3, #10]
    1096:	b25b      	sxtb	r3, r3
    1098:	2b00      	cmp	r3, #0
    109a:	dc00      	bgt.n	109e <u8g2_font_decode_glyph+0x7c>
    109c:	e14c      	b.n	1338 <u8g2_font_decode_glyph+0x316>
  {
#ifdef U8G2_WITH_FONT_ROTATION
    decode->target_x = u8g2_add_vector_x(decode->target_x, x, -(h+y), decode->dir);
    109e:	697b      	ldr	r3, [r7, #20]
    10a0:	8898      	ldrh	r0, [r3, #4]
    10a2:	2313      	movs	r3, #19
    10a4:	18fb      	adds	r3, r7, r3
    10a6:	781a      	ldrb	r2, [r3, #0]
    10a8:	2311      	movs	r3, #17
    10aa:	18fb      	adds	r3, r7, r3
    10ac:	781b      	ldrb	r3, [r3, #0]
    10ae:	18d3      	adds	r3, r2, r3
    10b0:	b2db      	uxtb	r3, r3
    10b2:	425b      	negs	r3, r3
    10b4:	b2db      	uxtb	r3, r3
    10b6:	b25a      	sxtb	r2, r3
    10b8:	697b      	ldr	r3, [r7, #20]
    10ba:	7c1c      	ldrb	r4, [r3, #16]
    10bc:	2312      	movs	r3, #18
    10be:	18fb      	adds	r3, r7, r3
    10c0:	2100      	movs	r1, #0
    10c2:	5659      	ldrsb	r1, [r3, r1]
    10c4:	0023      	movs	r3, r4
    10c6:	f7ff fe46 	bl	d56 <u8g2_add_vector_x>
    10ca:	0003      	movs	r3, r0
    10cc:	001a      	movs	r2, r3
    10ce:	697b      	ldr	r3, [r7, #20]
    10d0:	809a      	strh	r2, [r3, #4]
    decode->target_y = u8g2_add_vector_y(decode->target_y, x, -(h+y), decode->dir);
    10d2:	697b      	ldr	r3, [r7, #20]
    10d4:	88d8      	ldrh	r0, [r3, #6]
    10d6:	2313      	movs	r3, #19
    10d8:	18fb      	adds	r3, r7, r3
    10da:	781a      	ldrb	r2, [r3, #0]
    10dc:	2311      	movs	r3, #17
    10de:	18fb      	adds	r3, r7, r3
    10e0:	781b      	ldrb	r3, [r3, #0]
    10e2:	18d3      	adds	r3, r2, r3
    10e4:	b2db      	uxtb	r3, r3
    10e6:	425b      	negs	r3, r3
    10e8:	b2db      	uxtb	r3, r3
    10ea:	b25a      	sxtb	r2, r3
    10ec:	697b      	ldr	r3, [r7, #20]
    10ee:	7c1c      	ldrb	r4, [r3, #16]
    10f0:	2312      	movs	r3, #18
    10f2:	18fb      	adds	r3, r7, r3
    10f4:	2100      	movs	r1, #0
    10f6:	5659      	ldrsb	r1, [r3, r1]
    10f8:	0023      	movs	r3, r4
    10fa:	f7ff fde3 	bl	cc4 <u8g2_add_vector_y>
    10fe:	0003      	movs	r3, r0
    1100:	001a      	movs	r2, r3
    1102:	697b      	ldr	r3, [r7, #20]
    1104:	80da      	strh	r2, [r3, #6]
    //u8g2_add_vector(&(decode->target_x), &(decode->target_y), x, -(h+y), decode->dir);

#ifdef U8G2_WITH_INTERSECTION
    {
      u8g2_uint_t x0, x1, y0, y1;
      x0 = decode->target_x;
    1106:	231e      	movs	r3, #30
    1108:	18fb      	adds	r3, r7, r3
    110a:	697a      	ldr	r2, [r7, #20]
    110c:	8892      	ldrh	r2, [r2, #4]
    110e:	801a      	strh	r2, [r3, #0]
      y0 = decode->target_y;
    1110:	231a      	movs	r3, #26
    1112:	18fb      	adds	r3, r7, r3
    1114:	697a      	ldr	r2, [r7, #20]
    1116:	88d2      	ldrh	r2, [r2, #6]
    1118:	801a      	strh	r2, [r3, #0]
      x1 = x0;
    111a:	231c      	movs	r3, #28
    111c:	18fb      	adds	r3, r7, r3
    111e:	221e      	movs	r2, #30
    1120:	18ba      	adds	r2, r7, r2
    1122:	8812      	ldrh	r2, [r2, #0]
    1124:	801a      	strh	r2, [r3, #0]
      y1 = y0;
    1126:	2318      	movs	r3, #24
    1128:	18fb      	adds	r3, r7, r3
    112a:	221a      	movs	r2, #26
    112c:	18ba      	adds	r2, r7, r2
    112e:	8812      	ldrh	r2, [r2, #0]
    1130:	801a      	strh	r2, [r3, #0]
      
#ifdef U8G2_WITH_FONT_ROTATION
      switch(decode->dir)
    1132:	697b      	ldr	r3, [r7, #20]
    1134:	7c1b      	ldrb	r3, [r3, #16]
    1136:	2b01      	cmp	r3, #1
    1138:	d021      	beq.n	117e <u8g2_font_decode_glyph+0x15c>
    113a:	dc02      	bgt.n	1142 <u8g2_font_decode_glyph+0x120>
    113c:	2b00      	cmp	r3, #0
    113e:	d006      	beq.n	114e <u8g2_font_decode_glyph+0x12c>
    1140:	e09d      	b.n	127e <u8g2_font_decode_glyph+0x25c>
    1142:	2b02      	cmp	r3, #2
    1144:	d041      	beq.n	11ca <u8g2_font_decode_glyph+0x1a8>
    1146:	2b03      	cmp	r3, #3
    1148:	d100      	bne.n	114c <u8g2_font_decode_glyph+0x12a>
    114a:	e072      	b.n	1232 <u8g2_font_decode_glyph+0x210>
    114c:	e097      	b.n	127e <u8g2_font_decode_glyph+0x25c>
      {
	case 0:
	    x1 += decode->glyph_width;
    114e:	697b      	ldr	r3, [r7, #20]
    1150:	7a9b      	ldrb	r3, [r3, #10]
    1152:	b25b      	sxtb	r3, r3
    1154:	b299      	uxth	r1, r3
    1156:	231c      	movs	r3, #28
    1158:	18fb      	adds	r3, r7, r3
    115a:	221c      	movs	r2, #28
    115c:	18ba      	adds	r2, r7, r2
    115e:	8812      	ldrh	r2, [r2, #0]
    1160:	188a      	adds	r2, r1, r2
    1162:	801a      	strh	r2, [r3, #0]
	    y1 += h;
    1164:	2313      	movs	r3, #19
    1166:	18fb      	adds	r3, r7, r3
    1168:	781b      	ldrb	r3, [r3, #0]
    116a:	b25b      	sxtb	r3, r3
    116c:	b299      	uxth	r1, r3
    116e:	2318      	movs	r3, #24
    1170:	18fb      	adds	r3, r7, r3
    1172:	2218      	movs	r2, #24
    1174:	18ba      	adds	r2, r7, r2
    1176:	8812      	ldrh	r2, [r2, #0]
    1178:	188a      	adds	r2, r1, r2
    117a:	801a      	strh	r2, [r3, #0]
	    break;
    117c:	e07f      	b.n	127e <u8g2_font_decode_glyph+0x25c>
	case 1:
	    x0 -= h;
    117e:	2313      	movs	r3, #19
    1180:	18fb      	adds	r3, r7, r3
    1182:	781b      	ldrb	r3, [r3, #0]
    1184:	b25b      	sxtb	r3, r3
    1186:	b29a      	uxth	r2, r3
    1188:	231e      	movs	r3, #30
    118a:	18fb      	adds	r3, r7, r3
    118c:	211e      	movs	r1, #30
    118e:	1879      	adds	r1, r7, r1
    1190:	8809      	ldrh	r1, [r1, #0]
    1192:	1a8a      	subs	r2, r1, r2
    1194:	801a      	strh	r2, [r3, #0]
	    x0++;	/* shift down, because of assymetric boundaries for the interseciton test */
    1196:	231e      	movs	r3, #30
    1198:	18fb      	adds	r3, r7, r3
    119a:	881a      	ldrh	r2, [r3, #0]
    119c:	231e      	movs	r3, #30
    119e:	18fb      	adds	r3, r7, r3
    11a0:	3201      	adds	r2, #1
    11a2:	801a      	strh	r2, [r3, #0]
	    x1++;
    11a4:	231c      	movs	r3, #28
    11a6:	18fb      	adds	r3, r7, r3
    11a8:	881a      	ldrh	r2, [r3, #0]
    11aa:	231c      	movs	r3, #28
    11ac:	18fb      	adds	r3, r7, r3
    11ae:	3201      	adds	r2, #1
    11b0:	801a      	strh	r2, [r3, #0]
	    y1 += decode->glyph_width;
    11b2:	697b      	ldr	r3, [r7, #20]
    11b4:	7a9b      	ldrb	r3, [r3, #10]
    11b6:	b25b      	sxtb	r3, r3
    11b8:	b299      	uxth	r1, r3
    11ba:	2318      	movs	r3, #24
    11bc:	18fb      	adds	r3, r7, r3
    11be:	2218      	movs	r2, #24
    11c0:	18ba      	adds	r2, r7, r2
    11c2:	8812      	ldrh	r2, [r2, #0]
    11c4:	188a      	adds	r2, r1, r2
    11c6:	801a      	strh	r2, [r3, #0]
	    break;
    11c8:	e059      	b.n	127e <u8g2_font_decode_glyph+0x25c>
	case 2:
	    x0 -= decode->glyph_width;
    11ca:	697b      	ldr	r3, [r7, #20]
    11cc:	7a9b      	ldrb	r3, [r3, #10]
    11ce:	b25b      	sxtb	r3, r3
    11d0:	b29a      	uxth	r2, r3
    11d2:	231e      	movs	r3, #30
    11d4:	18fb      	adds	r3, r7, r3
    11d6:	211e      	movs	r1, #30
    11d8:	1879      	adds	r1, r7, r1
    11da:	8809      	ldrh	r1, [r1, #0]
    11dc:	1a8a      	subs	r2, r1, r2
    11de:	801a      	strh	r2, [r3, #0]
	    x0++;	/* shift down, because of assymetric boundaries for the interseciton test */
    11e0:	231e      	movs	r3, #30
    11e2:	18fb      	adds	r3, r7, r3
    11e4:	881a      	ldrh	r2, [r3, #0]
    11e6:	231e      	movs	r3, #30
    11e8:	18fb      	adds	r3, r7, r3
    11ea:	3201      	adds	r2, #1
    11ec:	801a      	strh	r2, [r3, #0]
	    x1++;
    11ee:	231c      	movs	r3, #28
    11f0:	18fb      	adds	r3, r7, r3
    11f2:	881a      	ldrh	r2, [r3, #0]
    11f4:	231c      	movs	r3, #28
    11f6:	18fb      	adds	r3, r7, r3
    11f8:	3201      	adds	r2, #1
    11fa:	801a      	strh	r2, [r3, #0]
	    y0 -= h;
    11fc:	2313      	movs	r3, #19
    11fe:	18fb      	adds	r3, r7, r3
    1200:	781b      	ldrb	r3, [r3, #0]
    1202:	b25b      	sxtb	r3, r3
    1204:	b29a      	uxth	r2, r3
    1206:	231a      	movs	r3, #26
    1208:	18fb      	adds	r3, r7, r3
    120a:	211a      	movs	r1, #26
    120c:	1879      	adds	r1, r7, r1
    120e:	8809      	ldrh	r1, [r1, #0]
    1210:	1a8a      	subs	r2, r1, r2
    1212:	801a      	strh	r2, [r3, #0]
	    y0++;	/* shift down, because of assymetric boundaries for the interseciton test */
    1214:	231a      	movs	r3, #26
    1216:	18fb      	adds	r3, r7, r3
    1218:	881a      	ldrh	r2, [r3, #0]
    121a:	231a      	movs	r3, #26
    121c:	18fb      	adds	r3, r7, r3
    121e:	3201      	adds	r2, #1
    1220:	801a      	strh	r2, [r3, #0]
	    y1++;
    1222:	2318      	movs	r3, #24
    1224:	18fb      	adds	r3, r7, r3
    1226:	881a      	ldrh	r2, [r3, #0]
    1228:	2318      	movs	r3, #24
    122a:	18fb      	adds	r3, r7, r3
    122c:	3201      	adds	r2, #1
    122e:	801a      	strh	r2, [r3, #0]
	    break;	  
    1230:	e025      	b.n	127e <u8g2_font_decode_glyph+0x25c>
	case 3:
	    x1 += h;
    1232:	2313      	movs	r3, #19
    1234:	18fb      	adds	r3, r7, r3
    1236:	781b      	ldrb	r3, [r3, #0]
    1238:	b25b      	sxtb	r3, r3
    123a:	b299      	uxth	r1, r3
    123c:	231c      	movs	r3, #28
    123e:	18fb      	adds	r3, r7, r3
    1240:	221c      	movs	r2, #28
    1242:	18ba      	adds	r2, r7, r2
    1244:	8812      	ldrh	r2, [r2, #0]
    1246:	188a      	adds	r2, r1, r2
    1248:	801a      	strh	r2, [r3, #0]
	    y0 -= decode->glyph_width;
    124a:	697b      	ldr	r3, [r7, #20]
    124c:	7a9b      	ldrb	r3, [r3, #10]
    124e:	b25b      	sxtb	r3, r3
    1250:	b29a      	uxth	r2, r3
    1252:	231a      	movs	r3, #26
    1254:	18fb      	adds	r3, r7, r3
    1256:	211a      	movs	r1, #26
    1258:	1879      	adds	r1, r7, r1
    125a:	8809      	ldrh	r1, [r1, #0]
    125c:	1a8a      	subs	r2, r1, r2
    125e:	801a      	strh	r2, [r3, #0]
	    y0++;	/* shift down, because of assymetric boundaries for the interseciton test */
    1260:	231a      	movs	r3, #26
    1262:	18fb      	adds	r3, r7, r3
    1264:	881a      	ldrh	r2, [r3, #0]
    1266:	231a      	movs	r3, #26
    1268:	18fb      	adds	r3, r7, r3
    126a:	3201      	adds	r2, #1
    126c:	801a      	strh	r2, [r3, #0]
	    y1++;
    126e:	2318      	movs	r3, #24
    1270:	18fb      	adds	r3, r7, r3
    1272:	881a      	ldrh	r2, [r3, #0]
    1274:	2318      	movs	r3, #24
    1276:	18fb      	adds	r3, r7, r3
    1278:	3201      	adds	r2, #1
    127a:	801a      	strh	r2, [r3, #0]
	    break;	  
    127c:	46c0      	nop			; (mov r8, r8)
#else /* U8G2_WITH_FONT_ROTATION */
      x1 += decode->glyph_width;
      y1 += h;      
#endif
      
      if ( u8g2_IsIntersection(u8g2, x0, y0, x1, y1) == 0 ) 
    127e:	231c      	movs	r3, #28
    1280:	18fb      	adds	r3, r7, r3
    1282:	881c      	ldrh	r4, [r3, #0]
    1284:	231a      	movs	r3, #26
    1286:	18fb      	adds	r3, r7, r3
    1288:	881a      	ldrh	r2, [r3, #0]
    128a:	231e      	movs	r3, #30
    128c:	18fb      	adds	r3, r7, r3
    128e:	8819      	ldrh	r1, [r3, #0]
    1290:	6878      	ldr	r0, [r7, #4]
    1292:	2318      	movs	r3, #24
    1294:	18fb      	adds	r3, r7, r3
    1296:	881b      	ldrh	r3, [r3, #0]
    1298:	9300      	str	r3, [sp, #0]
    129a:	0023      	movs	r3, r4
    129c:	f000 fd23 	bl	1ce6 <u8g2_IsIntersection>
    12a0:	1e03      	subs	r3, r0, #0
    12a2:	d104      	bne.n	12ae <u8g2_font_decode_glyph+0x28c>
	return d;
    12a4:	2310      	movs	r3, #16
    12a6:	18fb      	adds	r3, r7, r3
    12a8:	781b      	ldrb	r3, [r3, #0]
    12aa:	b25b      	sxtb	r3, r3
    12ac:	e048      	b.n	1340 <u8g2_font_decode_glyph+0x31e>
    }
#endif /* U8G2_WITH_INTERSECTION */
   
    /* reset local x/y position */
    decode->x = 0;
    12ae:	697b      	ldr	r3, [r7, #20]
    12b0:	2200      	movs	r2, #0
    12b2:	721a      	strb	r2, [r3, #8]
    decode->y = 0;
    12b4:	697b      	ldr	r3, [r7, #20]
    12b6:	2200      	movs	r2, #0
    12b8:	725a      	strb	r2, [r3, #9]
    
    /* decode glyph */
    for(;;)
    {
      a = u8g2_font_decode_get_unsigned_bits(decode, u8g2->font_info.bits_per_0);
    12ba:	687b      	ldr	r3, [r7, #4]
    12bc:	2276      	movs	r2, #118	; 0x76
    12be:	5c9a      	ldrb	r2, [r3, r2]
    12c0:	230f      	movs	r3, #15
    12c2:	18fc      	adds	r4, r7, r3
    12c4:	697b      	ldr	r3, [r7, #20]
    12c6:	0011      	movs	r1, r2
    12c8:	0018      	movs	r0, r3
    12ca:	f7ff fc4a 	bl	b62 <u8g2_font_decode_get_unsigned_bits>
    12ce:	0003      	movs	r3, r0
    12d0:	7023      	strb	r3, [r4, #0]
      b = u8g2_font_decode_get_unsigned_bits(decode, u8g2->font_info.bits_per_1);
    12d2:	687b      	ldr	r3, [r7, #4]
    12d4:	2277      	movs	r2, #119	; 0x77
    12d6:	5c9a      	ldrb	r2, [r3, r2]
    12d8:	230e      	movs	r3, #14
    12da:	18fc      	adds	r4, r7, r3
    12dc:	697b      	ldr	r3, [r7, #20]
    12de:	0011      	movs	r1, r2
    12e0:	0018      	movs	r0, r3
    12e2:	f7ff fc3e 	bl	b62 <u8g2_font_decode_get_unsigned_bits>
    12e6:	0003      	movs	r3, r0
    12e8:	7023      	strb	r3, [r4, #0]
      do
      {
	u8g2_font_decode_len(u8g2, a, 0);
    12ea:	230f      	movs	r3, #15
    12ec:	18fb      	adds	r3, r7, r3
    12ee:	7819      	ldrb	r1, [r3, #0]
    12f0:	687b      	ldr	r3, [r7, #4]
    12f2:	2200      	movs	r2, #0
    12f4:	0018      	movs	r0, r3
    12f6:	f7ff fd77 	bl	de8 <u8g2_font_decode_len>
	u8g2_font_decode_len(u8g2, b, 1);
    12fa:	230e      	movs	r3, #14
    12fc:	18fb      	adds	r3, r7, r3
    12fe:	7819      	ldrb	r1, [r3, #0]
    1300:	687b      	ldr	r3, [r7, #4]
    1302:	2201      	movs	r2, #1
    1304:	0018      	movs	r0, r3
    1306:	f7ff fd6f 	bl	de8 <u8g2_font_decode_len>
      } while( u8g2_font_decode_get_unsigned_bits(decode, 1) != 0 );
    130a:	697b      	ldr	r3, [r7, #20]
    130c:	2101      	movs	r1, #1
    130e:	0018      	movs	r0, r3
    1310:	f7ff fc27 	bl	b62 <u8g2_font_decode_get_unsigned_bits>
    1314:	1e03      	subs	r3, r0, #0
    1316:	d1e8      	bne.n	12ea <u8g2_font_decode_glyph+0x2c8>

      if ( decode->y >= h )
    1318:	697b      	ldr	r3, [r7, #20]
    131a:	7a5b      	ldrb	r3, [r3, #9]
    131c:	b25b      	sxtb	r3, r3
    131e:	2213      	movs	r2, #19
    1320:	18ba      	adds	r2, r7, r2
    1322:	7812      	ldrb	r2, [r2, #0]
    1324:	b252      	sxtb	r2, r2
    1326:	429a      	cmp	r2, r3
    1328:	dd00      	ble.n	132c <u8g2_font_decode_glyph+0x30a>
      a = u8g2_font_decode_get_unsigned_bits(decode, u8g2->font_info.bits_per_0);
    132a:	e7c6      	b.n	12ba <u8g2_font_decode_glyph+0x298>
	break;
    132c:	46c0      	nop			; (mov r8, r8)
    }
    
    /* restore the u8g2 draw color, because this is modified by the decode algo */
    u8g2->draw_color = decode->fg_color;
    132e:	697b      	ldr	r3, [r7, #20]
    1330:	7b99      	ldrb	r1, [r3, #14]
    1332:	687b      	ldr	r3, [r7, #4]
    1334:	2292      	movs	r2, #146	; 0x92
    1336:	5499      	strb	r1, [r3, r2]
  }
  return d;
    1338:	2310      	movs	r3, #16
    133a:	18fb      	adds	r3, r7, r3
    133c:	781b      	ldrb	r3, [r3, #0]
    133e:	b25b      	sxtb	r3, r3
}
    1340:	0018      	movs	r0, r3
    1342:	46bd      	mov	sp, r7
    1344:	b009      	add	sp, #36	; 0x24
    1346:	bd90      	pop	{r4, r7, pc}

00001348 <u8g2_font_get_glyph_data>:
    encoding: Encoding (ASCII or Unicode) of the glyph
  Return:
    Address of the glyph data or NULL, if the encoding is not avialable in the font.
*/
const uint8_t *u8g2_font_get_glyph_data(u8g2_t *u8g2, uint16_t encoding)
{
    1348:	b590      	push	{r4, r7, lr}
    134a:	b087      	sub	sp, #28
    134c:	af00      	add	r7, sp, #0
    134e:	6078      	str	r0, [r7, #4]
    1350:	000a      	movs	r2, r1
    1352:	1cbb      	adds	r3, r7, #2
    1354:	801a      	strh	r2, [r3, #0]
  const uint8_t *font = u8g2->font;
    1356:	687b      	ldr	r3, [r7, #4]
    1358:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    135a:	617b      	str	r3, [r7, #20]
  font += U8G2_FONT_DATA_STRUCT_SIZE;
    135c:	697b      	ldr	r3, [r7, #20]
    135e:	3317      	adds	r3, #23
    1360:	617b      	str	r3, [r7, #20]

  
  if ( encoding <= 255 )
    1362:	1cbb      	adds	r3, r7, #2
    1364:	881b      	ldrh	r3, [r3, #0]
    1366:	2bff      	cmp	r3, #255	; 0xff
    1368:	d82d      	bhi.n	13c6 <u8g2_font_get_glyph_data+0x7e>
  {
    if ( encoding >= 'a' )
    136a:	1cbb      	adds	r3, r7, #2
    136c:	881b      	ldrh	r3, [r3, #0]
    136e:	2b60      	cmp	r3, #96	; 0x60
    1370:	d907      	bls.n	1382 <u8g2_font_get_glyph_data+0x3a>
    {
      font += u8g2->font_info.start_pos_lower_a;
    1372:	687b      	ldr	r3, [r7, #4]
    1374:	2288      	movs	r2, #136	; 0x88
    1376:	5a9b      	ldrh	r3, [r3, r2]
    1378:	001a      	movs	r2, r3
    137a:	697b      	ldr	r3, [r7, #20]
    137c:	189b      	adds	r3, r3, r2
    137e:	617b      	str	r3, [r7, #20]
    1380:	e00a      	b.n	1398 <u8g2_font_get_glyph_data+0x50>
    }
    else if ( encoding >= 'A' )
    1382:	1cbb      	adds	r3, r7, #2
    1384:	881b      	ldrh	r3, [r3, #0]
    1386:	2b40      	cmp	r3, #64	; 0x40
    1388:	d906      	bls.n	1398 <u8g2_font_get_glyph_data+0x50>
    {
      font += u8g2->font_info.start_pos_upper_A;
    138a:	687b      	ldr	r3, [r7, #4]
    138c:	2286      	movs	r2, #134	; 0x86
    138e:	5a9b      	ldrh	r3, [r3, r2]
    1390:	001a      	movs	r2, r3
    1392:	697b      	ldr	r3, [r7, #20]
    1394:	189b      	adds	r3, r3, r2
    1396:	617b      	str	r3, [r7, #20]
    }
    
    for(;;)
    {
      if ( u8x8_pgm_read( font + 1 ) == 0 )
    1398:	697b      	ldr	r3, [r7, #20]
    139a:	3301      	adds	r3, #1
    139c:	781b      	ldrb	r3, [r3, #0]
    139e:	2b00      	cmp	r3, #0
    13a0:	d065      	beq.n	146e <u8g2_font_get_glyph_data+0x126>
	break;
      if ( u8x8_pgm_read( font ) == encoding )
    13a2:	697b      	ldr	r3, [r7, #20]
    13a4:	781b      	ldrb	r3, [r3, #0]
    13a6:	b29b      	uxth	r3, r3
    13a8:	1cba      	adds	r2, r7, #2
    13aa:	8812      	ldrh	r2, [r2, #0]
    13ac:	429a      	cmp	r2, r3
    13ae:	d102      	bne.n	13b6 <u8g2_font_get_glyph_data+0x6e>
      {
	return font+2;	/* skip encoding and glyph size */
    13b0:	697b      	ldr	r3, [r7, #20]
    13b2:	3302      	adds	r3, #2
    13b4:	e05f      	b.n	1476 <u8g2_font_get_glyph_data+0x12e>
      }
      font += u8x8_pgm_read( font + 1 );
    13b6:	697b      	ldr	r3, [r7, #20]
    13b8:	3301      	adds	r3, #1
    13ba:	781b      	ldrb	r3, [r3, #0]
    13bc:	001a      	movs	r2, r3
    13be:	697b      	ldr	r3, [r7, #20]
    13c0:	189b      	adds	r3, r3, r2
    13c2:	617b      	str	r3, [r7, #20]
      if ( u8x8_pgm_read( font + 1 ) == 0 )
    13c4:	e7e8      	b.n	1398 <u8g2_font_get_glyph_data+0x50>
//	font = u8g2->last_font_data;
//    }
//    else
//#endif 

    font += u8g2->font_info.start_pos_unicode;
    13c6:	687b      	ldr	r3, [r7, #4]
    13c8:	228a      	movs	r2, #138	; 0x8a
    13ca:	5a9b      	ldrh	r3, [r3, r2]
    13cc:	001a      	movs	r2, r3
    13ce:	697b      	ldr	r3, [r7, #20]
    13d0:	189b      	adds	r3, r3, r2
    13d2:	617b      	str	r3, [r7, #20]
    unicode_lookup_table = font; 
    13d4:	697b      	ldr	r3, [r7, #20]
    13d6:	613b      	str	r3, [r7, #16]
  
    /* issue 596: search for the glyph start in the unicode lookup table */
    do
    {
      font += u8g2_font_get_word(unicode_lookup_table, 0);
    13d8:	693b      	ldr	r3, [r7, #16]
    13da:	2100      	movs	r1, #0
    13dc:	0018      	movs	r0, r3
    13de:	f7ff fad7 	bl	990 <u8g2_font_get_word>
    13e2:	0003      	movs	r3, r0
    13e4:	001a      	movs	r2, r3
    13e6:	697b      	ldr	r3, [r7, #20]
    13e8:	189b      	adds	r3, r3, r2
    13ea:	617b      	str	r3, [r7, #20]
      e = u8g2_font_get_word(unicode_lookup_table, 2);
    13ec:	230e      	movs	r3, #14
    13ee:	18fc      	adds	r4, r7, r3
    13f0:	693b      	ldr	r3, [r7, #16]
    13f2:	2102      	movs	r1, #2
    13f4:	0018      	movs	r0, r3
    13f6:	f7ff facb 	bl	990 <u8g2_font_get_word>
    13fa:	0003      	movs	r3, r0
    13fc:	8023      	strh	r3, [r4, #0]
      unicode_lookup_table+=4;
    13fe:	693b      	ldr	r3, [r7, #16]
    1400:	3304      	adds	r3, #4
    1402:	613b      	str	r3, [r7, #16]
    } while( e < encoding );
    1404:	230e      	movs	r3, #14
    1406:	18fa      	adds	r2, r7, r3
    1408:	1cbb      	adds	r3, r7, #2
    140a:	8812      	ldrh	r2, [r2, #0]
    140c:	881b      	ldrh	r3, [r3, #0]
    140e:	429a      	cmp	r2, r3
    1410:	d3e2      	bcc.n	13d8 <u8g2_font_get_glyph_data+0x90>
    
  
    for(;;)
    {
      e = u8x8_pgm_read( font );
    1412:	697b      	ldr	r3, [r7, #20]
    1414:	781a      	ldrb	r2, [r3, #0]
    1416:	230e      	movs	r3, #14
    1418:	18fb      	adds	r3, r7, r3
    141a:	801a      	strh	r2, [r3, #0]
      e <<= 8;
    141c:	230e      	movs	r3, #14
    141e:	18fb      	adds	r3, r7, r3
    1420:	220e      	movs	r2, #14
    1422:	18ba      	adds	r2, r7, r2
    1424:	8812      	ldrh	r2, [r2, #0]
    1426:	0212      	lsls	r2, r2, #8
    1428:	801a      	strh	r2, [r3, #0]
      e |= u8x8_pgm_read( font + 1 );
    142a:	697b      	ldr	r3, [r7, #20]
    142c:	3301      	adds	r3, #1
    142e:	781b      	ldrb	r3, [r3, #0]
    1430:	b299      	uxth	r1, r3
    1432:	230e      	movs	r3, #14
    1434:	18fb      	adds	r3, r7, r3
    1436:	220e      	movs	r2, #14
    1438:	18ba      	adds	r2, r7, r2
    143a:	8812      	ldrh	r2, [r2, #0]
    143c:	430a      	orrs	r2, r1
    143e:	801a      	strh	r2, [r3, #0]
//#ifdef  __unix__
//      if ( encoding < e )
//        break;
//#endif 

      if ( e == 0 )
    1440:	230e      	movs	r3, #14
    1442:	18fb      	adds	r3, r7, r3
    1444:	881b      	ldrh	r3, [r3, #0]
    1446:	2b00      	cmp	r3, #0
    1448:	d013      	beq.n	1472 <u8g2_font_get_glyph_data+0x12a>
	break;
  
      if ( e == encoding )
    144a:	230e      	movs	r3, #14
    144c:	18fa      	adds	r2, r7, r3
    144e:	1cbb      	adds	r3, r7, #2
    1450:	8812      	ldrh	r2, [r2, #0]
    1452:	881b      	ldrh	r3, [r3, #0]
    1454:	429a      	cmp	r2, r3
    1456:	d102      	bne.n	145e <u8g2_font_get_glyph_data+0x116>
// removed, there is now the new index table
//#ifdef  __unix__
//	u8g2->last_font_data = font;
//	u8g2->last_unicode = encoding;
//#endif 
	return font+3;	/* skip encoding and glyph size */
    1458:	697b      	ldr	r3, [r7, #20]
    145a:	3303      	adds	r3, #3
    145c:	e00b      	b.n	1476 <u8g2_font_get_glyph_data+0x12e>
      }
      font += u8x8_pgm_read( font + 2 );
    145e:	697b      	ldr	r3, [r7, #20]
    1460:	3302      	adds	r3, #2
    1462:	781b      	ldrb	r3, [r3, #0]
    1464:	001a      	movs	r2, r3
    1466:	697b      	ldr	r3, [r7, #20]
    1468:	189b      	adds	r3, r3, r2
    146a:	617b      	str	r3, [r7, #20]
      e = u8x8_pgm_read( font );
    146c:	e7d1      	b.n	1412 <u8g2_font_get_glyph_data+0xca>
	break;
    146e:	46c0      	nop			; (mov r8, r8)
    1470:	e000      	b.n	1474 <u8g2_font_get_glyph_data+0x12c>
	break;
    1472:	46c0      	nop			; (mov r8, r8)
    }  
  }
#endif
  
  return NULL;
    1474:	2300      	movs	r3, #0
}
    1476:	0018      	movs	r0, r3
    1478:	46bd      	mov	sp, r7
    147a:	b007      	add	sp, #28
    147c:	bd90      	pop	{r4, r7, pc}

0000147e <u8g2_font_draw_glyph>:

static u8g2_uint_t u8g2_font_draw_glyph(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, uint16_t encoding)
{
    147e:	b590      	push	{r4, r7, lr}
    1480:	b087      	sub	sp, #28
    1482:	af00      	add	r7, sp, #0
    1484:	60f8      	str	r0, [r7, #12]
    1486:	000c      	movs	r4, r1
    1488:	0010      	movs	r0, r2
    148a:	0019      	movs	r1, r3
    148c:	230a      	movs	r3, #10
    148e:	18fb      	adds	r3, r7, r3
    1490:	1c22      	adds	r2, r4, #0
    1492:	801a      	strh	r2, [r3, #0]
    1494:	2308      	movs	r3, #8
    1496:	18fb      	adds	r3, r7, r3
    1498:	1c02      	adds	r2, r0, #0
    149a:	801a      	strh	r2, [r3, #0]
    149c:	1dbb      	adds	r3, r7, #6
    149e:	1c0a      	adds	r2, r1, #0
    14a0:	801a      	strh	r2, [r3, #0]
  u8g2_uint_t dx = 0;
    14a2:	2316      	movs	r3, #22
    14a4:	18fb      	adds	r3, r7, r3
    14a6:	2200      	movs	r2, #0
    14a8:	801a      	strh	r2, [r3, #0]
  u8g2->font_decode.target_x = x;
    14aa:	68fb      	ldr	r3, [r7, #12]
    14ac:	220a      	movs	r2, #10
    14ae:	18ba      	adds	r2, r7, r2
    14b0:	2164      	movs	r1, #100	; 0x64
    14b2:	8812      	ldrh	r2, [r2, #0]
    14b4:	525a      	strh	r2, [r3, r1]
  u8g2->font_decode.target_y = y;
    14b6:	68fb      	ldr	r3, [r7, #12]
    14b8:	2208      	movs	r2, #8
    14ba:	18ba      	adds	r2, r7, r2
    14bc:	2166      	movs	r1, #102	; 0x66
    14be:	8812      	ldrh	r2, [r2, #0]
    14c0:	525a      	strh	r2, [r3, r1]
  //u8g2->font_decode.is_transparent = is_transparent; this is already set
  //u8g2->font_decode.dir = dir;
  const uint8_t *glyph_data = u8g2_font_get_glyph_data(u8g2, encoding);
    14c2:	1dbb      	adds	r3, r7, #6
    14c4:	881a      	ldrh	r2, [r3, #0]
    14c6:	68fb      	ldr	r3, [r7, #12]
    14c8:	0011      	movs	r1, r2
    14ca:	0018      	movs	r0, r3
    14cc:	f7ff ff3c 	bl	1348 <u8g2_font_get_glyph_data>
    14d0:	0003      	movs	r3, r0
    14d2:	613b      	str	r3, [r7, #16]
  if ( glyph_data != NULL )
    14d4:	693b      	ldr	r3, [r7, #16]
    14d6:	2b00      	cmp	r3, #0
    14d8:	d00a      	beq.n	14f0 <u8g2_font_draw_glyph+0x72>
  {
    dx = u8g2_font_decode_glyph(u8g2, glyph_data);
    14da:	693a      	ldr	r2, [r7, #16]
    14dc:	68fb      	ldr	r3, [r7, #12]
    14de:	0011      	movs	r1, r2
    14e0:	0018      	movs	r0, r3
    14e2:	f7ff fd9e 	bl	1022 <u8g2_font_decode_glyph>
    14e6:	0003      	movs	r3, r0
    14e8:	001a      	movs	r2, r3
    14ea:	2316      	movs	r3, #22
    14ec:	18fb      	adds	r3, r7, r3
    14ee:	801a      	strh	r2, [r3, #0]
  }
  return dx;
    14f0:	2316      	movs	r3, #22
    14f2:	18fb      	adds	r3, r7, r3
    14f4:	881b      	ldrh	r3, [r3, #0]
}
    14f6:	0018      	movs	r0, r3
    14f8:	46bd      	mov	sp, r7
    14fa:	b007      	add	sp, #28
    14fc:	bd90      	pop	{r4, r7, pc}

000014fe <u8g2_DrawGlyph>:
{
  u8g2->font_decode.is_transparent = is_transparent;		// new font procedures
}

u8g2_uint_t u8g2_DrawGlyph(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, uint16_t encoding)
{
    14fe:	b590      	push	{r4, r7, lr}
    1500:	b085      	sub	sp, #20
    1502:	af00      	add	r7, sp, #0
    1504:	60f8      	str	r0, [r7, #12]
    1506:	000c      	movs	r4, r1
    1508:	0010      	movs	r0, r2
    150a:	0019      	movs	r1, r3
    150c:	230a      	movs	r3, #10
    150e:	18fb      	adds	r3, r7, r3
    1510:	1c22      	adds	r2, r4, #0
    1512:	801a      	strh	r2, [r3, #0]
    1514:	2308      	movs	r3, #8
    1516:	18fb      	adds	r3, r7, r3
    1518:	1c02      	adds	r2, r0, #0
    151a:	801a      	strh	r2, [r3, #0]
    151c:	1dbb      	adds	r3, r7, #6
    151e:	1c0a      	adds	r2, r1, #0
    1520:	801a      	strh	r2, [r3, #0]
#ifdef U8G2_WITH_FONT_ROTATION
  switch(u8g2->font_decode.dir)
    1522:	68fb      	ldr	r3, [r7, #12]
    1524:	2270      	movs	r2, #112	; 0x70
    1526:	5c9b      	ldrb	r3, [r3, r2]
    1528:	2b01      	cmp	r3, #1
    152a:	d017      	beq.n	155c <u8g2_DrawGlyph+0x5e>
    152c:	dc02      	bgt.n	1534 <u8g2_DrawGlyph+0x36>
    152e:	2b00      	cmp	r3, #0
    1530:	d005      	beq.n	153e <u8g2_DrawGlyph+0x40>
    1532:	e040      	b.n	15b6 <u8g2_DrawGlyph+0xb8>
    1534:	2b02      	cmp	r3, #2
    1536:	d020      	beq.n	157a <u8g2_DrawGlyph+0x7c>
    1538:	2b03      	cmp	r3, #3
    153a:	d02d      	beq.n	1598 <u8g2_DrawGlyph+0x9a>
    153c:	e03b      	b.n	15b6 <u8g2_DrawGlyph+0xb8>
  {
    case 0:
      y += u8g2->font_calc_vref(u8g2);
    153e:	68fb      	ldr	r3, [r7, #12]
    1540:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
    1542:	68fa      	ldr	r2, [r7, #12]
    1544:	0010      	movs	r0, r2
    1546:	4798      	blx	r3
    1548:	0003      	movs	r3, r0
    154a:	0019      	movs	r1, r3
    154c:	2308      	movs	r3, #8
    154e:	18fb      	adds	r3, r7, r3
    1550:	2208      	movs	r2, #8
    1552:	18ba      	adds	r2, r7, r2
    1554:	8812      	ldrh	r2, [r2, #0]
    1556:	188a      	adds	r2, r1, r2
    1558:	801a      	strh	r2, [r3, #0]
      break;
    155a:	e02c      	b.n	15b6 <u8g2_DrawGlyph+0xb8>
    case 1:
      x -= u8g2->font_calc_vref(u8g2);
    155c:	68fb      	ldr	r3, [r7, #12]
    155e:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
    1560:	68fa      	ldr	r2, [r7, #12]
    1562:	0010      	movs	r0, r2
    1564:	4798      	blx	r3
    1566:	0003      	movs	r3, r0
    1568:	0019      	movs	r1, r3
    156a:	230a      	movs	r3, #10
    156c:	18fb      	adds	r3, r7, r3
    156e:	220a      	movs	r2, #10
    1570:	18ba      	adds	r2, r7, r2
    1572:	8812      	ldrh	r2, [r2, #0]
    1574:	1a52      	subs	r2, r2, r1
    1576:	801a      	strh	r2, [r3, #0]
      break;
    1578:	e01d      	b.n	15b6 <u8g2_DrawGlyph+0xb8>
    case 2:
      y -= u8g2->font_calc_vref(u8g2);
    157a:	68fb      	ldr	r3, [r7, #12]
    157c:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
    157e:	68fa      	ldr	r2, [r7, #12]
    1580:	0010      	movs	r0, r2
    1582:	4798      	blx	r3
    1584:	0003      	movs	r3, r0
    1586:	0019      	movs	r1, r3
    1588:	2308      	movs	r3, #8
    158a:	18fb      	adds	r3, r7, r3
    158c:	2208      	movs	r2, #8
    158e:	18ba      	adds	r2, r7, r2
    1590:	8812      	ldrh	r2, [r2, #0]
    1592:	1a52      	subs	r2, r2, r1
    1594:	801a      	strh	r2, [r3, #0]
      break;
    1596:	e00e      	b.n	15b6 <u8g2_DrawGlyph+0xb8>
    case 3:
      x += u8g2->font_calc_vref(u8g2);
    1598:	68fb      	ldr	r3, [r7, #12]
    159a:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
    159c:	68fa      	ldr	r2, [r7, #12]
    159e:	0010      	movs	r0, r2
    15a0:	4798      	blx	r3
    15a2:	0003      	movs	r3, r0
    15a4:	0019      	movs	r1, r3
    15a6:	230a      	movs	r3, #10
    15a8:	18fb      	adds	r3, r7, r3
    15aa:	220a      	movs	r2, #10
    15ac:	18ba      	adds	r2, r7, r2
    15ae:	8812      	ldrh	r2, [r2, #0]
    15b0:	188a      	adds	r2, r1, r2
    15b2:	801a      	strh	r2, [r3, #0]
      break;
    15b4:	46c0      	nop			; (mov r8, r8)
  }
#else
  y += u8g2->font_calc_vref(u8g2);
#endif
  return u8g2_font_draw_glyph(u8g2, x, y, encoding);
    15b6:	1dbb      	adds	r3, r7, #6
    15b8:	881c      	ldrh	r4, [r3, #0]
    15ba:	2308      	movs	r3, #8
    15bc:	18fb      	adds	r3, r7, r3
    15be:	881a      	ldrh	r2, [r3, #0]
    15c0:	230a      	movs	r3, #10
    15c2:	18fb      	adds	r3, r7, r3
    15c4:	8819      	ldrh	r1, [r3, #0]
    15c6:	68f8      	ldr	r0, [r7, #12]
    15c8:	0023      	movs	r3, r4
    15ca:	f7ff ff58 	bl	147e <u8g2_font_draw_glyph>
    15ce:	0003      	movs	r3, r0
}
    15d0:	0018      	movs	r0, r3
    15d2:	46bd      	mov	sp, r7
    15d4:	b005      	add	sp, #20
    15d6:	bd90      	pop	{r4, r7, pc}

000015d8 <u8g2_draw_string>:
  return u8g2_font_2x_draw_glyph(u8g2, x, y, encoding);
}

static u8g2_uint_t u8g2_draw_string(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, const char *str) U8G2_NOINLINE;
static u8g2_uint_t u8g2_draw_string(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, const char *str)
{
    15d8:	b5b0      	push	{r4, r5, r7, lr}
    15da:	b086      	sub	sp, #24
    15dc:	af00      	add	r7, sp, #0
    15de:	60f8      	str	r0, [r7, #12]
    15e0:	0008      	movs	r0, r1
    15e2:	0011      	movs	r1, r2
    15e4:	607b      	str	r3, [r7, #4]
    15e6:	230a      	movs	r3, #10
    15e8:	18fb      	adds	r3, r7, r3
    15ea:	1c02      	adds	r2, r0, #0
    15ec:	801a      	strh	r2, [r3, #0]
    15ee:	2308      	movs	r3, #8
    15f0:	18fb      	adds	r3, r7, r3
    15f2:	1c0a      	adds	r2, r1, #0
    15f4:	801a      	strh	r2, [r3, #0]
  uint16_t e;
  u8g2_uint_t delta, sum;
  u8x8_utf8_init(u8g2_GetU8x8(u8g2));
    15f6:	68fb      	ldr	r3, [r7, #12]
    15f8:	0018      	movs	r0, r3
    15fa:	f000 ff76 	bl	24ea <u8x8_utf8_init>
  sum = 0;
    15fe:	2316      	movs	r3, #22
    1600:	18fb      	adds	r3, r7, r3
    1602:	2200      	movs	r2, #0
    1604:	801a      	strh	r2, [r3, #0]
  for(;;)
  {
    e = u8g2->u8x8.next_cb(u8g2_GetU8x8(u8g2), (uint8_t)*str);
    1606:	68fb      	ldr	r3, [r7, #12]
    1608:	685b      	ldr	r3, [r3, #4]
    160a:	687a      	ldr	r2, [r7, #4]
    160c:	7811      	ldrb	r1, [r2, #0]
    160e:	2214      	movs	r2, #20
    1610:	18bc      	adds	r4, r7, r2
    1612:	68fa      	ldr	r2, [r7, #12]
    1614:	0010      	movs	r0, r2
    1616:	4798      	blx	r3
    1618:	0003      	movs	r3, r0
    161a:	8023      	strh	r3, [r4, #0]
    if ( e == 0x0ffff )
    161c:	2314      	movs	r3, #20
    161e:	18fb      	adds	r3, r7, r3
    1620:	881b      	ldrh	r3, [r3, #0]
    1622:	4a35      	ldr	r2, [pc, #212]	; (16f8 <u8g2_draw_string+0x120>)
    1624:	4293      	cmp	r3, r2
    1626:	d05e      	beq.n	16e6 <u8g2_draw_string+0x10e>
      break;
    str++;
    1628:	687b      	ldr	r3, [r7, #4]
    162a:	3301      	adds	r3, #1
    162c:	607b      	str	r3, [r7, #4]
    if ( e != 0x0fffe )
    162e:	2314      	movs	r3, #20
    1630:	18fb      	adds	r3, r7, r3
    1632:	881b      	ldrh	r3, [r3, #0]
    1634:	4a31      	ldr	r2, [pc, #196]	; (16fc <u8g2_draw_string+0x124>)
    1636:	4293      	cmp	r3, r2
    1638:	d0e5      	beq.n	1606 <u8g2_draw_string+0x2e>
    {
      delta = u8g2_DrawGlyph(u8g2, x, y, e);
    163a:	2312      	movs	r3, #18
    163c:	18fc      	adds	r4, r7, r3
    163e:	2314      	movs	r3, #20
    1640:	18fb      	adds	r3, r7, r3
    1642:	881d      	ldrh	r5, [r3, #0]
    1644:	2308      	movs	r3, #8
    1646:	18fb      	adds	r3, r7, r3
    1648:	881a      	ldrh	r2, [r3, #0]
    164a:	230a      	movs	r3, #10
    164c:	18fb      	adds	r3, r7, r3
    164e:	8819      	ldrh	r1, [r3, #0]
    1650:	68f8      	ldr	r0, [r7, #12]
    1652:	002b      	movs	r3, r5
    1654:	f7ff ff53 	bl	14fe <u8g2_DrawGlyph>
    1658:	0003      	movs	r3, r0
    165a:	8023      	strh	r3, [r4, #0]
    
#ifdef U8G2_WITH_FONT_ROTATION
      switch(u8g2->font_decode.dir)
    165c:	68fb      	ldr	r3, [r7, #12]
    165e:	2270      	movs	r2, #112	; 0x70
    1660:	5c9b      	ldrb	r3, [r3, r2]
    1662:	2b01      	cmp	r3, #1
    1664:	d013      	beq.n	168e <u8g2_draw_string+0xb6>
    1666:	dc02      	bgt.n	166e <u8g2_draw_string+0x96>
    1668:	2b00      	cmp	r3, #0
    166a:	d005      	beq.n	1678 <u8g2_draw_string+0xa0>
    166c:	e030      	b.n	16d0 <u8g2_draw_string+0xf8>
    166e:	2b02      	cmp	r3, #2
    1670:	d018      	beq.n	16a4 <u8g2_draw_string+0xcc>
    1672:	2b03      	cmp	r3, #3
    1674:	d021      	beq.n	16ba <u8g2_draw_string+0xe2>
    1676:	e02b      	b.n	16d0 <u8g2_draw_string+0xf8>
      {
	case 0:
	  x += delta;
    1678:	230a      	movs	r3, #10
    167a:	18fb      	adds	r3, r7, r3
    167c:	220a      	movs	r2, #10
    167e:	18b9      	adds	r1, r7, r2
    1680:	2212      	movs	r2, #18
    1682:	18ba      	adds	r2, r7, r2
    1684:	8809      	ldrh	r1, [r1, #0]
    1686:	8812      	ldrh	r2, [r2, #0]
    1688:	188a      	adds	r2, r1, r2
    168a:	801a      	strh	r2, [r3, #0]
	  break;
    168c:	e020      	b.n	16d0 <u8g2_draw_string+0xf8>
	case 1:
	  y += delta;
    168e:	2308      	movs	r3, #8
    1690:	18fb      	adds	r3, r7, r3
    1692:	2208      	movs	r2, #8
    1694:	18b9      	adds	r1, r7, r2
    1696:	2212      	movs	r2, #18
    1698:	18ba      	adds	r2, r7, r2
    169a:	8809      	ldrh	r1, [r1, #0]
    169c:	8812      	ldrh	r2, [r2, #0]
    169e:	188a      	adds	r2, r1, r2
    16a0:	801a      	strh	r2, [r3, #0]
	  break;
    16a2:	e015      	b.n	16d0 <u8g2_draw_string+0xf8>
	case 2:
	  x -= delta;
    16a4:	230a      	movs	r3, #10
    16a6:	18fb      	adds	r3, r7, r3
    16a8:	220a      	movs	r2, #10
    16aa:	18b9      	adds	r1, r7, r2
    16ac:	2212      	movs	r2, #18
    16ae:	18ba      	adds	r2, r7, r2
    16b0:	8809      	ldrh	r1, [r1, #0]
    16b2:	8812      	ldrh	r2, [r2, #0]
    16b4:	1a8a      	subs	r2, r1, r2
    16b6:	801a      	strh	r2, [r3, #0]
	  break;
    16b8:	e00a      	b.n	16d0 <u8g2_draw_string+0xf8>
	case 3:
	  y -= delta;
    16ba:	2308      	movs	r3, #8
    16bc:	18fb      	adds	r3, r7, r3
    16be:	2208      	movs	r2, #8
    16c0:	18b9      	adds	r1, r7, r2
    16c2:	2212      	movs	r2, #18
    16c4:	18ba      	adds	r2, r7, r2
    16c6:	8809      	ldrh	r1, [r1, #0]
    16c8:	8812      	ldrh	r2, [r2, #0]
    16ca:	1a8a      	subs	r2, r1, r2
    16cc:	801a      	strh	r2, [r3, #0]
	  break;
    16ce:	46c0      	nop			; (mov r8, r8)

#else
      x += delta;
#endif

      sum += delta;    
    16d0:	2316      	movs	r3, #22
    16d2:	18fb      	adds	r3, r7, r3
    16d4:	2216      	movs	r2, #22
    16d6:	18b9      	adds	r1, r7, r2
    16d8:	2212      	movs	r2, #18
    16da:	18ba      	adds	r2, r7, r2
    16dc:	8809      	ldrh	r1, [r1, #0]
    16de:	8812      	ldrh	r2, [r2, #0]
    16e0:	188a      	adds	r2, r1, r2
    16e2:	801a      	strh	r2, [r3, #0]
    e = u8g2->u8x8.next_cb(u8g2_GetU8x8(u8g2), (uint8_t)*str);
    16e4:	e78f      	b.n	1606 <u8g2_draw_string+0x2e>
      break;
    16e6:	46c0      	nop			; (mov r8, r8)
    }
  }
  return sum;
    16e8:	2316      	movs	r3, #22
    16ea:	18fb      	adds	r3, r7, r3
    16ec:	881b      	ldrh	r3, [r3, #0]
}
    16ee:	0018      	movs	r0, r3
    16f0:	46bd      	mov	sp, r7
    16f2:	b006      	add	sp, #24
    16f4:	bdb0      	pop	{r4, r5, r7, pc}
    16f6:	46c0      	nop			; (mov r8, r8)
    16f8:	0000ffff 	.word	0x0000ffff
    16fc:	0000fffe 	.word	0x0000fffe

00001700 <u8g2_DrawStr>:
  }
  return sum;
}

u8g2_uint_t u8g2_DrawStr(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, const char *str)
{
    1700:	b590      	push	{r4, r7, lr}
    1702:	b085      	sub	sp, #20
    1704:	af00      	add	r7, sp, #0
    1706:	60f8      	str	r0, [r7, #12]
    1708:	0008      	movs	r0, r1
    170a:	0011      	movs	r1, r2
    170c:	607b      	str	r3, [r7, #4]
    170e:	230a      	movs	r3, #10
    1710:	18fb      	adds	r3, r7, r3
    1712:	1c02      	adds	r2, r0, #0
    1714:	801a      	strh	r2, [r3, #0]
    1716:	2308      	movs	r3, #8
    1718:	18fb      	adds	r3, r7, r3
    171a:	1c0a      	adds	r2, r1, #0
    171c:	801a      	strh	r2, [r3, #0]
  u8g2->u8x8.next_cb = u8x8_ascii_next;
    171e:	68fb      	ldr	r3, [r7, #12]
    1720:	4a08      	ldr	r2, [pc, #32]	; (1744 <u8g2_DrawStr+0x44>)
    1722:	605a      	str	r2, [r3, #4]
  return u8g2_draw_string(u8g2, x, y, str);
    1724:	687c      	ldr	r4, [r7, #4]
    1726:	2308      	movs	r3, #8
    1728:	18fb      	adds	r3, r7, r3
    172a:	881a      	ldrh	r2, [r3, #0]
    172c:	230a      	movs	r3, #10
    172e:	18fb      	adds	r3, r7, r3
    1730:	8819      	ldrh	r1, [r3, #0]
    1732:	68f8      	ldr	r0, [r7, #12]
    1734:	0023      	movs	r3, r4
    1736:	f7ff ff4f 	bl	15d8 <u8g2_draw_string>
    173a:	0003      	movs	r3, r0
}
    173c:	0018      	movs	r0, r3
    173e:	46bd      	mov	sp, r7
    1740:	b005      	add	sp, #20
    1742:	bd90      	pop	{r4, r7, pc}
    1744:	00002505 	.word	0x00002505

00001748 <u8g2_UpdateRefHeight>:
/*===============================================*/

/* set ascent/descent for reference point calculation */

void u8g2_UpdateRefHeight(u8g2_t *u8g2)
{
    1748:	b580      	push	{r7, lr}
    174a:	b082      	sub	sp, #8
    174c:	af00      	add	r7, sp, #0
    174e:	6078      	str	r0, [r7, #4]
  if ( u8g2->font == NULL )
    1750:	687b      	ldr	r3, [r7, #4]
    1752:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    1754:	2b00      	cmp	r3, #0
    1756:	d05d      	beq.n	1814 <u8g2_UpdateRefHeight+0xcc>
    return;
  u8g2->font_ref_ascent = u8g2->font_info.ascent_A;
    1758:	687b      	ldr	r3, [r7, #4]
    175a:	2281      	movs	r2, #129	; 0x81
    175c:	5699      	ldrsb	r1, [r3, r2]
    175e:	687b      	ldr	r3, [r7, #4]
    1760:	228e      	movs	r2, #142	; 0x8e
    1762:	5499      	strb	r1, [r3, r2]
  u8g2->font_ref_descent = u8g2->font_info.descent_g;
    1764:	687b      	ldr	r3, [r7, #4]
    1766:	2282      	movs	r2, #130	; 0x82
    1768:	5699      	ldrsb	r1, [r3, r2]
    176a:	687b      	ldr	r3, [r7, #4]
    176c:	228f      	movs	r2, #143	; 0x8f
    176e:	5499      	strb	r1, [r3, r2]
  if ( u8g2->font_height_mode == U8G2_FONT_HEIGHT_MODE_TEXT )
    1770:	687b      	ldr	r3, [r7, #4]
    1772:	228d      	movs	r2, #141	; 0x8d
    1774:	5c9b      	ldrb	r3, [r3, r2]
    1776:	2b00      	cmp	r3, #0
    1778:	d04d      	beq.n	1816 <u8g2_UpdateRefHeight+0xce>
  {
  }
  else if ( u8g2->font_height_mode == U8G2_FONT_HEIGHT_MODE_XTEXT )
    177a:	687b      	ldr	r3, [r7, #4]
    177c:	228d      	movs	r2, #141	; 0x8d
    177e:	5c9b      	ldrb	r3, [r3, r2]
    1780:	2b01      	cmp	r3, #1
    1782:	d11c      	bne.n	17be <u8g2_UpdateRefHeight+0x76>
  {
    if ( u8g2->font_ref_ascent < u8g2->font_info.ascent_para )
    1784:	687b      	ldr	r3, [r7, #4]
    1786:	228e      	movs	r2, #142	; 0x8e
    1788:	569a      	ldrsb	r2, [r3, r2]
    178a:	687b      	ldr	r3, [r7, #4]
    178c:	2183      	movs	r1, #131	; 0x83
    178e:	565b      	ldrsb	r3, [r3, r1]
    1790:	429a      	cmp	r2, r3
    1792:	da05      	bge.n	17a0 <u8g2_UpdateRefHeight+0x58>
      u8g2->font_ref_ascent = u8g2->font_info.ascent_para;
    1794:	687b      	ldr	r3, [r7, #4]
    1796:	2283      	movs	r2, #131	; 0x83
    1798:	5699      	ldrsb	r1, [r3, r2]
    179a:	687b      	ldr	r3, [r7, #4]
    179c:	228e      	movs	r2, #142	; 0x8e
    179e:	5499      	strb	r1, [r3, r2]
    if ( u8g2->font_ref_descent > u8g2->font_info.descent_para )
    17a0:	687b      	ldr	r3, [r7, #4]
    17a2:	228f      	movs	r2, #143	; 0x8f
    17a4:	569a      	ldrsb	r2, [r3, r2]
    17a6:	687b      	ldr	r3, [r7, #4]
    17a8:	2184      	movs	r1, #132	; 0x84
    17aa:	565b      	ldrsb	r3, [r3, r1]
    17ac:	429a      	cmp	r2, r3
    17ae:	dd32      	ble.n	1816 <u8g2_UpdateRefHeight+0xce>
      u8g2->font_ref_descent = u8g2->font_info.descent_para;
    17b0:	687b      	ldr	r3, [r7, #4]
    17b2:	2284      	movs	r2, #132	; 0x84
    17b4:	5699      	ldrsb	r1, [r3, r2]
    17b6:	687b      	ldr	r3, [r7, #4]
    17b8:	228f      	movs	r2, #143	; 0x8f
    17ba:	5499      	strb	r1, [r3, r2]
    17bc:	e02b      	b.n	1816 <u8g2_UpdateRefHeight+0xce>
  }
  else
  {
    if ( u8g2->font_ref_ascent < u8g2->font_info.max_char_height+u8g2->font_info.y_offset )
    17be:	687b      	ldr	r3, [r7, #4]
    17c0:	228e      	movs	r2, #142	; 0x8e
    17c2:	569b      	ldrsb	r3, [r3, r2]
    17c4:	0019      	movs	r1, r3
    17c6:	687b      	ldr	r3, [r7, #4]
    17c8:	227e      	movs	r2, #126	; 0x7e
    17ca:	569b      	ldrsb	r3, [r3, r2]
    17cc:	0018      	movs	r0, r3
    17ce:	687b      	ldr	r3, [r7, #4]
    17d0:	2280      	movs	r2, #128	; 0x80
    17d2:	569b      	ldrsb	r3, [r3, r2]
    17d4:	18c3      	adds	r3, r0, r3
    17d6:	4299      	cmp	r1, r3
    17d8:	da0d      	bge.n	17f6 <u8g2_UpdateRefHeight+0xae>
      u8g2->font_ref_ascent = u8g2->font_info.max_char_height+u8g2->font_info.y_offset;
    17da:	687b      	ldr	r3, [r7, #4]
    17dc:	227e      	movs	r2, #126	; 0x7e
    17de:	569b      	ldrsb	r3, [r3, r2]
    17e0:	b2da      	uxtb	r2, r3
    17e2:	687b      	ldr	r3, [r7, #4]
    17e4:	2180      	movs	r1, #128	; 0x80
    17e6:	565b      	ldrsb	r3, [r3, r1]
    17e8:	b2db      	uxtb	r3, r3
    17ea:	18d3      	adds	r3, r2, r3
    17ec:	b2db      	uxtb	r3, r3
    17ee:	b259      	sxtb	r1, r3
    17f0:	687b      	ldr	r3, [r7, #4]
    17f2:	228e      	movs	r2, #142	; 0x8e
    17f4:	5499      	strb	r1, [r3, r2]
    if ( u8g2->font_ref_descent > u8g2->font_info.y_offset )
    17f6:	687b      	ldr	r3, [r7, #4]
    17f8:	228f      	movs	r2, #143	; 0x8f
    17fa:	569a      	ldrsb	r2, [r3, r2]
    17fc:	687b      	ldr	r3, [r7, #4]
    17fe:	2180      	movs	r1, #128	; 0x80
    1800:	565b      	ldrsb	r3, [r3, r1]
    1802:	429a      	cmp	r2, r3
    1804:	dd07      	ble.n	1816 <u8g2_UpdateRefHeight+0xce>
      u8g2->font_ref_descent = u8g2->font_info.y_offset;
    1806:	687b      	ldr	r3, [r7, #4]
    1808:	2280      	movs	r2, #128	; 0x80
    180a:	5699      	ldrsb	r1, [r3, r2]
    180c:	687b      	ldr	r3, [r7, #4]
    180e:	228f      	movs	r2, #143	; 0x8f
    1810:	5499      	strb	r1, [r3, r2]
    1812:	e000      	b.n	1816 <u8g2_UpdateRefHeight+0xce>
    return;
    1814:	46c0      	nop			; (mov r8, r8)
  }  
}
    1816:	46bd      	mov	sp, r7
    1818:	b002      	add	sp, #8
    181a:	bd80      	pop	{r7, pc}

0000181c <u8g2_font_calc_vref_font>:

/*===============================================*/
/* callback procedures to correct the y position */

u8g2_uint_t u8g2_font_calc_vref_font(U8X8_UNUSED u8g2_t *u8g2)
{
    181c:	b580      	push	{r7, lr}
    181e:	b082      	sub	sp, #8
    1820:	af00      	add	r7, sp, #0
    1822:	6078      	str	r0, [r7, #4]
  return 0;
    1824:	2300      	movs	r3, #0
}
    1826:	0018      	movs	r0, r3
    1828:	46bd      	mov	sp, r7
    182a:	b002      	add	sp, #8
    182c:	bd80      	pop	{r7, pc}
	...

00001830 <u8g2_SetFontPosBaseline>:

void u8g2_SetFontPosBaseline(u8g2_t *u8g2)
{
    1830:	b580      	push	{r7, lr}
    1832:	b082      	sub	sp, #8
    1834:	af00      	add	r7, sp, #0
    1836:	6078      	str	r0, [r7, #4]
  u8g2->font_calc_vref = u8g2_font_calc_vref_font;
    1838:	687b      	ldr	r3, [r7, #4]
    183a:	4a03      	ldr	r2, [pc, #12]	; (1848 <u8g2_SetFontPosBaseline+0x18>)
    183c:	65da      	str	r2, [r3, #92]	; 0x5c
}
    183e:	46c0      	nop			; (mov r8, r8)
    1840:	46bd      	mov	sp, r7
    1842:	b002      	add	sp, #8
    1844:	bd80      	pop	{r7, pc}
    1846:	46c0      	nop			; (mov r8, r8)
    1848:	0000181d 	.word	0x0000181d

0000184c <u8g2_SetFont>:
}

/*===============================================*/

void u8g2_SetFont(u8g2_t *u8g2, const uint8_t  *font)
{
    184c:	b580      	push	{r7, lr}
    184e:	b082      	sub	sp, #8
    1850:	af00      	add	r7, sp, #0
    1852:	6078      	str	r0, [r7, #4]
    1854:	6039      	str	r1, [r7, #0]
  if ( u8g2->font != font )
    1856:	687b      	ldr	r3, [r7, #4]
    1858:	6d9a      	ldr	r2, [r3, #88]	; 0x58
    185a:	683b      	ldr	r3, [r7, #0]
    185c:	429a      	cmp	r2, r3
    185e:	d00d      	beq.n	187c <u8g2_SetFont+0x30>
  {
//#ifdef  __unix__
//	u8g2->last_font_data = NULL;
//	u8g2->last_unicode = 0x0ffff;
//#endif 
    u8g2->font = font;
    1860:	687b      	ldr	r3, [r7, #4]
    1862:	683a      	ldr	r2, [r7, #0]
    1864:	659a      	str	r2, [r3, #88]	; 0x58
    u8g2_read_font_info(&(u8g2->font_info), font);
    1866:	687b      	ldr	r3, [r7, #4]
    1868:	3374      	adds	r3, #116	; 0x74
    186a:	683a      	ldr	r2, [r7, #0]
    186c:	0011      	movs	r1, r2
    186e:	0018      	movs	r0, r3
    1870:	f7ff f8ba 	bl	9e8 <u8g2_read_font_info>
    u8g2_UpdateRefHeight(u8g2);
    1874:	687b      	ldr	r3, [r7, #4]
    1876:	0018      	movs	r0, r3
    1878:	f7ff ff66 	bl	1748 <u8g2_UpdateRefHeight>
    /* u8g2_SetFontPosBaseline(u8g2); */ /* removed with issue 195 */
  }
}
    187c:	46c0      	nop			; (mov r8, r8)
    187e:	46bd      	mov	sp, r7
    1880:	b002      	add	sp, #8
    1882:	bd80      	pop	{r7, pc}

00001884 <u8g2_clip_intersection2>:
  will return 0 if there is no intersection and if a > b

*/

static uint8_t u8g2_clip_intersection2(u8g2_uint_t *ap, u8g2_uint_t *len, u8g2_uint_t c, u8g2_uint_t d)
{
    1884:	b580      	push	{r7, lr}
    1886:	b086      	sub	sp, #24
    1888:	af00      	add	r7, sp, #0
    188a:	60f8      	str	r0, [r7, #12]
    188c:	60b9      	str	r1, [r7, #8]
    188e:	0019      	movs	r1, r3
    1890:	1dbb      	adds	r3, r7, #6
    1892:	801a      	strh	r2, [r3, #0]
    1894:	1d3b      	adds	r3, r7, #4
    1896:	1c0a      	adds	r2, r1, #0
    1898:	801a      	strh	r2, [r3, #0]
  u8g2_uint_t a = *ap;
    189a:	2316      	movs	r3, #22
    189c:	18fb      	adds	r3, r7, r3
    189e:	68fa      	ldr	r2, [r7, #12]
    18a0:	8812      	ldrh	r2, [r2, #0]
    18a2:	801a      	strh	r2, [r3, #0]
  u8g2_uint_t b;
  b  = a;
    18a4:	2314      	movs	r3, #20
    18a6:	18fb      	adds	r3, r7, r3
    18a8:	2216      	movs	r2, #22
    18aa:	18ba      	adds	r2, r7, r2
    18ac:	8812      	ldrh	r2, [r2, #0]
    18ae:	801a      	strh	r2, [r3, #0]
  b += *len;
    18b0:	68bb      	ldr	r3, [r7, #8]
    18b2:	8819      	ldrh	r1, [r3, #0]
    18b4:	2314      	movs	r3, #20
    18b6:	18fb      	adds	r3, r7, r3
    18b8:	2214      	movs	r2, #20
    18ba:	18ba      	adds	r2, r7, r2
    18bc:	8812      	ldrh	r2, [r2, #0]
    18be:	188a      	adds	r2, r1, r2
    18c0:	801a      	strh	r2, [r3, #0]
  /* be removed completly (be aware about memory curruption for wrong */
  /* arguments) or return 0 for a>b (will lead to skipped lines for wrong */
  /* arguments) */  
  
  /* removing the following if clause completly may lead to memory corruption of a>b */
  if ( a > b )
    18c2:	2316      	movs	r3, #22
    18c4:	18fa      	adds	r2, r7, r3
    18c6:	2314      	movs	r3, #20
    18c8:	18fb      	adds	r3, r7, r3
    18ca:	8812      	ldrh	r2, [r2, #0]
    18cc:	881b      	ldrh	r3, [r3, #0]
    18ce:	429a      	cmp	r2, r3
    18d0:	d918      	bls.n	1904 <u8g2_clip_intersection2+0x80>
  {    
    /* replacing this if with a simple "return 0;" will not handle the case with negative a */    
    if ( a < d )
    18d2:	2316      	movs	r3, #22
    18d4:	18fa      	adds	r2, r7, r3
    18d6:	1d3b      	adds	r3, r7, #4
    18d8:	8812      	ldrh	r2, [r2, #0]
    18da:	881b      	ldrh	r3, [r3, #0]
    18dc:	429a      	cmp	r2, r3
    18de:	d20c      	bcs.n	18fa <u8g2_clip_intersection2+0x76>
    {
      b = d;
    18e0:	2314      	movs	r3, #20
    18e2:	18fb      	adds	r3, r7, r3
    18e4:	1d3a      	adds	r2, r7, #4
    18e6:	8812      	ldrh	r2, [r2, #0]
    18e8:	801a      	strh	r2, [r3, #0]
      b--;
    18ea:	2314      	movs	r3, #20
    18ec:	18fb      	adds	r3, r7, r3
    18ee:	881a      	ldrh	r2, [r3, #0]
    18f0:	2314      	movs	r3, #20
    18f2:	18fb      	adds	r3, r7, r3
    18f4:	3a01      	subs	r2, #1
    18f6:	801a      	strh	r2, [r3, #0]
    18f8:	e004      	b.n	1904 <u8g2_clip_intersection2+0x80>
    }
    else
    {
      a = c;
    18fa:	2316      	movs	r3, #22
    18fc:	18fb      	adds	r3, r7, r3
    18fe:	1dba      	adds	r2, r7, #6
    1900:	8812      	ldrh	r2, [r2, #0]
    1902:	801a      	strh	r2, [r3, #0]
    }
  }
  
  /* from now on, the asumption a <= b is ok */
  
  if ( a >= d )
    1904:	2316      	movs	r3, #22
    1906:	18fa      	adds	r2, r7, r3
    1908:	1d3b      	adds	r3, r7, #4
    190a:	8812      	ldrh	r2, [r2, #0]
    190c:	881b      	ldrh	r3, [r3, #0]
    190e:	429a      	cmp	r2, r3
    1910:	d301      	bcc.n	1916 <u8g2_clip_intersection2+0x92>
    return 0;
    1912:	2300      	movs	r3, #0
    1914:	e035      	b.n	1982 <u8g2_clip_intersection2+0xfe>
  if ( b <= c )
    1916:	2314      	movs	r3, #20
    1918:	18fa      	adds	r2, r7, r3
    191a:	1dbb      	adds	r3, r7, #6
    191c:	8812      	ldrh	r2, [r2, #0]
    191e:	881b      	ldrh	r3, [r3, #0]
    1920:	429a      	cmp	r2, r3
    1922:	d801      	bhi.n	1928 <u8g2_clip_intersection2+0xa4>
    return 0;
    1924:	2300      	movs	r3, #0
    1926:	e02c      	b.n	1982 <u8g2_clip_intersection2+0xfe>
  if ( a < c )		
    1928:	2316      	movs	r3, #22
    192a:	18fa      	adds	r2, r7, r3
    192c:	1dbb      	adds	r3, r7, #6
    192e:	8812      	ldrh	r2, [r2, #0]
    1930:	881b      	ldrh	r3, [r3, #0]
    1932:	429a      	cmp	r2, r3
    1934:	d204      	bcs.n	1940 <u8g2_clip_intersection2+0xbc>
    a = c;
    1936:	2316      	movs	r3, #22
    1938:	18fb      	adds	r3, r7, r3
    193a:	1dba      	adds	r2, r7, #6
    193c:	8812      	ldrh	r2, [r2, #0]
    193e:	801a      	strh	r2, [r3, #0]
  if ( b > d )
    1940:	2314      	movs	r3, #20
    1942:	18fa      	adds	r2, r7, r3
    1944:	1d3b      	adds	r3, r7, #4
    1946:	8812      	ldrh	r2, [r2, #0]
    1948:	881b      	ldrh	r3, [r3, #0]
    194a:	429a      	cmp	r2, r3
    194c:	d904      	bls.n	1958 <u8g2_clip_intersection2+0xd4>
    b = d;
    194e:	2314      	movs	r3, #20
    1950:	18fb      	adds	r3, r7, r3
    1952:	1d3a      	adds	r2, r7, #4
    1954:	8812      	ldrh	r2, [r2, #0]
    1956:	801a      	strh	r2, [r3, #0]
  
  *ap = a;
    1958:	68fb      	ldr	r3, [r7, #12]
    195a:	2216      	movs	r2, #22
    195c:	18ba      	adds	r2, r7, r2
    195e:	8812      	ldrh	r2, [r2, #0]
    1960:	801a      	strh	r2, [r3, #0]
  b -= a;
    1962:	2314      	movs	r3, #20
    1964:	18fb      	adds	r3, r7, r3
    1966:	2214      	movs	r2, #20
    1968:	18b9      	adds	r1, r7, r2
    196a:	2216      	movs	r2, #22
    196c:	18ba      	adds	r2, r7, r2
    196e:	8809      	ldrh	r1, [r1, #0]
    1970:	8812      	ldrh	r2, [r2, #0]
    1972:	1a8a      	subs	r2, r1, r2
    1974:	801a      	strh	r2, [r3, #0]
  *len = b;
    1976:	68bb      	ldr	r3, [r7, #8]
    1978:	2214      	movs	r2, #20
    197a:	18ba      	adds	r2, r7, r2
    197c:	8812      	ldrh	r2, [r2, #0]
    197e:	801a      	strh	r2, [r3, #0]
  return 1;
    1980:	2301      	movs	r3, #1
}
    1982:	0018      	movs	r0, r3
    1984:	46bd      	mov	sp, r7
    1986:	b006      	add	sp, #24
    1988:	bd80      	pop	{r7, pc}

0000198a <u8g2_draw_hv_line_2dir>:
  This function first adjusts the y position to the local buffer. Then it
  will clip the line and call u8g2_draw_low_level_hv_line()

*/
void u8g2_draw_hv_line_2dir(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t len, uint8_t dir)
{
    198a:	b5b0      	push	{r4, r5, r7, lr}
    198c:	b086      	sub	sp, #24
    198e:	af02      	add	r7, sp, #8
    1990:	60f8      	str	r0, [r7, #12]
    1992:	000c      	movs	r4, r1
    1994:	0010      	movs	r0, r2
    1996:	0019      	movs	r1, r3
    1998:	230a      	movs	r3, #10
    199a:	18fb      	adds	r3, r7, r3
    199c:	1c22      	adds	r2, r4, #0
    199e:	801a      	strh	r2, [r3, #0]
    19a0:	2308      	movs	r3, #8
    19a2:	18fb      	adds	r3, r7, r3
    19a4:	1c02      	adds	r2, r0, #0
    19a6:	801a      	strh	r2, [r3, #0]
    19a8:	1dbb      	adds	r3, r7, #6
    19aa:	1c0a      	adds	r2, r1, #0
    19ac:	801a      	strh	r2, [r3, #0]

  /* clipping happens before the display rotation */

  /* transform to pixel buffer coordinates */
  y -= u8g2->pixel_curr_row;
    19ae:	68fb      	ldr	r3, [r7, #12]
    19b0:	8fda      	ldrh	r2, [r3, #62]	; 0x3e
    19b2:	2308      	movs	r3, #8
    19b4:	18fb      	adds	r3, r7, r3
    19b6:	2108      	movs	r1, #8
    19b8:	1879      	adds	r1, r7, r1
    19ba:	8809      	ldrh	r1, [r1, #0]
    19bc:	1a8a      	subs	r2, r1, r2
    19be:	801a      	strh	r2, [r3, #0]
  
  u8g2->ll_hvline(u8g2, x, y, len, dir);
    19c0:	68fb      	ldr	r3, [r7, #12]
    19c2:	6adc      	ldr	r4, [r3, #44]	; 0x2c
    19c4:	1dbb      	adds	r3, r7, #6
    19c6:	881d      	ldrh	r5, [r3, #0]
    19c8:	2308      	movs	r3, #8
    19ca:	18fb      	adds	r3, r7, r3
    19cc:	881a      	ldrh	r2, [r3, #0]
    19ce:	230a      	movs	r3, #10
    19d0:	18fb      	adds	r3, r7, r3
    19d2:	8819      	ldrh	r1, [r3, #0]
    19d4:	68f8      	ldr	r0, [r7, #12]
    19d6:	2320      	movs	r3, #32
    19d8:	18fb      	adds	r3, r7, r3
    19da:	781b      	ldrb	r3, [r3, #0]
    19dc:	9300      	str	r3, [sp, #0]
    19de:	002b      	movs	r3, r5
    19e0:	47a0      	blx	r4
}
    19e2:	46c0      	nop			; (mov r8, r8)
    19e4:	46bd      	mov	sp, r7
    19e6:	b004      	add	sp, #16
    19e8:	bdb0      	pop	{r4, r5, r7, pc}

000019ea <u8g2_DrawHVLine>:
  This function should be called by the user.
  
  "dir" may have 4 directions: 0 (left to right), 1, 2, 3 (down up)
*/
void u8g2_DrawHVLine(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t len, uint8_t dir)
{
    19ea:	b5b0      	push	{r4, r5, r7, lr}
    19ec:	b086      	sub	sp, #24
    19ee:	af02      	add	r7, sp, #8
    19f0:	60f8      	str	r0, [r7, #12]
    19f2:	000c      	movs	r4, r1
    19f4:	0010      	movs	r0, r2
    19f6:	0019      	movs	r1, r3
    19f8:	230a      	movs	r3, #10
    19fa:	18fb      	adds	r3, r7, r3
    19fc:	1c22      	adds	r2, r4, #0
    19fe:	801a      	strh	r2, [r3, #0]
    1a00:	2308      	movs	r3, #8
    1a02:	18fb      	adds	r3, r7, r3
    1a04:	1c02      	adds	r2, r0, #0
    1a06:	801a      	strh	r2, [r3, #0]
    1a08:	1dbb      	adds	r3, r7, #6
    1a0a:	1c0a      	adds	r2, r1, #0
    1a0c:	801a      	strh	r2, [r3, #0]
  /* Make a call to the callback function (e.g. u8g2_draw_l90_r0). */
  /* The callback may rotate the hv line */
  /* after rotation this will call u8g2_draw_hv_line_4dir() */
  
#ifdef U8G2_WITH_CLIP_WINDOW_SUPPORT
  if ( u8g2->is_page_clip_window_intersection != 0 )
    1a0e:	68fb      	ldr	r3, [r7, #12]
    1a10:	228c      	movs	r2, #140	; 0x8c
    1a12:	5c9b      	ldrb	r3, [r3, r2]
    1a14:	2b00      	cmp	r3, #0
    1a16:	d100      	bne.n	1a1a <u8g2_DrawHVLine+0x30>
    1a18:	e09d      	b.n	1b56 <u8g2_DrawHVLine+0x16c>
#endif /* U8G2_WITH_CLIP_WINDOW_SUPPORT */
    if ( len != 0 )
    1a1a:	1dbb      	adds	r3, r7, #6
    1a1c:	881b      	ldrh	r3, [r3, #0]
    1a1e:	2b00      	cmp	r3, #0
    1a20:	d100      	bne.n	1a24 <u8g2_DrawHVLine+0x3a>
    1a22:	e098      	b.n	1b56 <u8g2_DrawHVLine+0x16c>
    {
    
      /* convert to two directions */    
      if ( len > 1 )
    1a24:	1dbb      	adds	r3, r7, #6
    1a26:	881b      	ldrh	r3, [r3, #0]
    1a28:	2b01      	cmp	r3, #1
    1a2a:	d92e      	bls.n	1a8a <u8g2_DrawHVLine+0xa0>
      {
	if ( dir == 2 )
    1a2c:	2320      	movs	r3, #32
    1a2e:	18fb      	adds	r3, r7, r3
    1a30:	781b      	ldrb	r3, [r3, #0]
    1a32:	2b02      	cmp	r3, #2
    1a34:	d112      	bne.n	1a5c <u8g2_DrawHVLine+0x72>
	{
	  x -= len;
    1a36:	230a      	movs	r3, #10
    1a38:	18fb      	adds	r3, r7, r3
    1a3a:	881a      	ldrh	r2, [r3, #0]
    1a3c:	1dbb      	adds	r3, r7, #6
    1a3e:	881b      	ldrh	r3, [r3, #0]
    1a40:	1ad3      	subs	r3, r2, r3
    1a42:	b29a      	uxth	r2, r3
    1a44:	230a      	movs	r3, #10
    1a46:	18fb      	adds	r3, r7, r3
    1a48:	801a      	strh	r2, [r3, #0]
	  x++;
    1a4a:	230a      	movs	r3, #10
    1a4c:	18fb      	adds	r3, r7, r3
    1a4e:	881b      	ldrh	r3, [r3, #0]
    1a50:	3301      	adds	r3, #1
    1a52:	b29a      	uxth	r2, r3
    1a54:	230a      	movs	r3, #10
    1a56:	18fb      	adds	r3, r7, r3
    1a58:	801a      	strh	r2, [r3, #0]
    1a5a:	e016      	b.n	1a8a <u8g2_DrawHVLine+0xa0>
	}
	else if ( dir == 3 )
    1a5c:	2320      	movs	r3, #32
    1a5e:	18fb      	adds	r3, r7, r3
    1a60:	781b      	ldrb	r3, [r3, #0]
    1a62:	2b03      	cmp	r3, #3
    1a64:	d111      	bne.n	1a8a <u8g2_DrawHVLine+0xa0>
	{
	  y -= len;
    1a66:	2308      	movs	r3, #8
    1a68:	18fb      	adds	r3, r7, r3
    1a6a:	881a      	ldrh	r2, [r3, #0]
    1a6c:	1dbb      	adds	r3, r7, #6
    1a6e:	881b      	ldrh	r3, [r3, #0]
    1a70:	1ad3      	subs	r3, r2, r3
    1a72:	b29a      	uxth	r2, r3
    1a74:	2308      	movs	r3, #8
    1a76:	18fb      	adds	r3, r7, r3
    1a78:	801a      	strh	r2, [r3, #0]
	  y++;
    1a7a:	2308      	movs	r3, #8
    1a7c:	18fb      	adds	r3, r7, r3
    1a7e:	881b      	ldrh	r3, [r3, #0]
    1a80:	3301      	adds	r3, #1
    1a82:	b29a      	uxth	r2, r3
    1a84:	2308      	movs	r3, #8
    1a86:	18fb      	adds	r3, r7, r3
    1a88:	801a      	strh	r2, [r3, #0]
	}
      }
      dir &= 1;  
    1a8a:	2320      	movs	r3, #32
    1a8c:	18f9      	adds	r1, r7, r3
    1a8e:	2320      	movs	r3, #32
    1a90:	18fb      	adds	r3, r7, r3
    1a92:	781b      	ldrb	r3, [r3, #0]
    1a94:	2201      	movs	r2, #1
    1a96:	4013      	ands	r3, r2
    1a98:	700b      	strb	r3, [r1, #0]
      
      /* clip against the user window */
      if ( dir == 0 )
    1a9a:	2320      	movs	r3, #32
    1a9c:	18fb      	adds	r3, r7, r3
    1a9e:	781b      	ldrb	r3, [r3, #0]
    1aa0:	2b00      	cmp	r3, #0
    1aa2:	d11e      	bne.n	1ae2 <u8g2_DrawHVLine+0xf8>
      {
	if ( y < u8g2->user_y0 )
    1aa4:	68fb      	ldr	r3, [r7, #12]
    1aa6:	224c      	movs	r2, #76	; 0x4c
    1aa8:	5a9a      	ldrh	r2, [r3, r2]
    1aaa:	2308      	movs	r3, #8
    1aac:	18fb      	adds	r3, r7, r3
    1aae:	881b      	ldrh	r3, [r3, #0]
    1ab0:	429a      	cmp	r2, r3
    1ab2:	d847      	bhi.n	1b44 <u8g2_DrawHVLine+0x15a>
	  return;
	if ( y >= u8g2->user_y1 )
    1ab4:	68fb      	ldr	r3, [r7, #12]
    1ab6:	224e      	movs	r2, #78	; 0x4e
    1ab8:	5a9a      	ldrh	r2, [r3, r2]
    1aba:	2308      	movs	r3, #8
    1abc:	18fb      	adds	r3, r7, r3
    1abe:	881b      	ldrh	r3, [r3, #0]
    1ac0:	429a      	cmp	r2, r3
    1ac2:	d941      	bls.n	1b48 <u8g2_DrawHVLine+0x15e>
	  return;
	if ( u8g2_clip_intersection2(&x, &len, u8g2->user_x0, u8g2->user_x1) == 0 )
    1ac4:	68fb      	ldr	r3, [r7, #12]
    1ac6:	2248      	movs	r2, #72	; 0x48
    1ac8:	5a9c      	ldrh	r4, [r3, r2]
    1aca:	68fb      	ldr	r3, [r7, #12]
    1acc:	224a      	movs	r2, #74	; 0x4a
    1ace:	5a9b      	ldrh	r3, [r3, r2]
    1ad0:	1db9      	adds	r1, r7, #6
    1ad2:	220a      	movs	r2, #10
    1ad4:	18b8      	adds	r0, r7, r2
    1ad6:	0022      	movs	r2, r4
    1ad8:	f7ff fed4 	bl	1884 <u8g2_clip_intersection2>
    1adc:	1e03      	subs	r3, r0, #0
    1ade:	d11e      	bne.n	1b1e <u8g2_DrawHVLine+0x134>
	  return;
    1ae0:	e039      	b.n	1b56 <u8g2_DrawHVLine+0x16c>
      }
      else
      {
	if ( x < u8g2->user_x0 )
    1ae2:	68fb      	ldr	r3, [r7, #12]
    1ae4:	2248      	movs	r2, #72	; 0x48
    1ae6:	5a9a      	ldrh	r2, [r3, r2]
    1ae8:	230a      	movs	r3, #10
    1aea:	18fb      	adds	r3, r7, r3
    1aec:	881b      	ldrh	r3, [r3, #0]
    1aee:	429a      	cmp	r2, r3
    1af0:	d82c      	bhi.n	1b4c <u8g2_DrawHVLine+0x162>
	  return;
	if ( x >= u8g2->user_x1 )
    1af2:	68fb      	ldr	r3, [r7, #12]
    1af4:	224a      	movs	r2, #74	; 0x4a
    1af6:	5a9a      	ldrh	r2, [r3, r2]
    1af8:	230a      	movs	r3, #10
    1afa:	18fb      	adds	r3, r7, r3
    1afc:	881b      	ldrh	r3, [r3, #0]
    1afe:	429a      	cmp	r2, r3
    1b00:	d926      	bls.n	1b50 <u8g2_DrawHVLine+0x166>
	  return;
	if ( u8g2_clip_intersection2(&y, &len, u8g2->user_y0, u8g2->user_y1) == 0 )
    1b02:	68fb      	ldr	r3, [r7, #12]
    1b04:	224c      	movs	r2, #76	; 0x4c
    1b06:	5a9c      	ldrh	r4, [r3, r2]
    1b08:	68fb      	ldr	r3, [r7, #12]
    1b0a:	224e      	movs	r2, #78	; 0x4e
    1b0c:	5a9b      	ldrh	r3, [r3, r2]
    1b0e:	1db9      	adds	r1, r7, #6
    1b10:	2208      	movs	r2, #8
    1b12:	18b8      	adds	r0, r7, r2
    1b14:	0022      	movs	r2, r4
    1b16:	f7ff feb5 	bl	1884 <u8g2_clip_intersection2>
    1b1a:	1e03      	subs	r3, r0, #0
    1b1c:	d01a      	beq.n	1b54 <u8g2_DrawHVLine+0x16a>
	  return;
      }
      
      
      u8g2->cb->draw_l90(u8g2, x, y, len, dir);
    1b1e:	68fb      	ldr	r3, [r7, #12]
    1b20:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    1b22:	689c      	ldr	r4, [r3, #8]
    1b24:	230a      	movs	r3, #10
    1b26:	18fb      	adds	r3, r7, r3
    1b28:	8819      	ldrh	r1, [r3, #0]
    1b2a:	2308      	movs	r3, #8
    1b2c:	18fb      	adds	r3, r7, r3
    1b2e:	881a      	ldrh	r2, [r3, #0]
    1b30:	1dbb      	adds	r3, r7, #6
    1b32:	881d      	ldrh	r5, [r3, #0]
    1b34:	68f8      	ldr	r0, [r7, #12]
    1b36:	2320      	movs	r3, #32
    1b38:	18fb      	adds	r3, r7, r3
    1b3a:	781b      	ldrb	r3, [r3, #0]
    1b3c:	9300      	str	r3, [sp, #0]
    1b3e:	002b      	movs	r3, r5
    1b40:	47a0      	blx	r4
    1b42:	e008      	b.n	1b56 <u8g2_DrawHVLine+0x16c>
	  return;
    1b44:	46c0      	nop			; (mov r8, r8)
    1b46:	e006      	b.n	1b56 <u8g2_DrawHVLine+0x16c>
	  return;
    1b48:	46c0      	nop			; (mov r8, r8)
    1b4a:	e004      	b.n	1b56 <u8g2_DrawHVLine+0x16c>
	  return;
    1b4c:	46c0      	nop			; (mov r8, r8)
    1b4e:	e002      	b.n	1b56 <u8g2_DrawHVLine+0x16c>
	  return;
    1b50:	46c0      	nop			; (mov r8, r8)
    1b52:	e000      	b.n	1b56 <u8g2_DrawHVLine+0x16c>
	  return;
    1b54:	46c0      	nop			; (mov r8, r8)
    }
}
    1b56:	46bd      	mov	sp, r7
    1b58:	b004      	add	sp, #16
    1b5a:	bdb0      	pop	{r4, r5, r7, pc}

00001b5c <u8g2_DrawHLine>:

void u8g2_DrawHLine(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t len)
{
    1b5c:	b590      	push	{r4, r7, lr}
    1b5e:	b087      	sub	sp, #28
    1b60:	af02      	add	r7, sp, #8
    1b62:	60f8      	str	r0, [r7, #12]
    1b64:	000c      	movs	r4, r1
    1b66:	0010      	movs	r0, r2
    1b68:	0019      	movs	r1, r3
    1b6a:	230a      	movs	r3, #10
    1b6c:	18fb      	adds	r3, r7, r3
    1b6e:	1c22      	adds	r2, r4, #0
    1b70:	801a      	strh	r2, [r3, #0]
    1b72:	2308      	movs	r3, #8
    1b74:	18fb      	adds	r3, r7, r3
    1b76:	1c02      	adds	r2, r0, #0
    1b78:	801a      	strh	r2, [r3, #0]
    1b7a:	1dbb      	adds	r3, r7, #6
    1b7c:	1c0a      	adds	r2, r1, #0
    1b7e:	801a      	strh	r2, [r3, #0]
// #ifdef U8G2_WITH_INTERSECTION
//   if ( u8g2_IsIntersection(u8g2, x, y, x+len, y+1) == 0 ) 
//     return;
// #endif /* U8G2_WITH_INTERSECTION */
  u8g2_DrawHVLine(u8g2, x, y, len, 0);
    1b80:	1dbb      	adds	r3, r7, #6
    1b82:	881c      	ldrh	r4, [r3, #0]
    1b84:	2308      	movs	r3, #8
    1b86:	18fb      	adds	r3, r7, r3
    1b88:	881a      	ldrh	r2, [r3, #0]
    1b8a:	230a      	movs	r3, #10
    1b8c:	18fb      	adds	r3, r7, r3
    1b8e:	8819      	ldrh	r1, [r3, #0]
    1b90:	68f8      	ldr	r0, [r7, #12]
    1b92:	2300      	movs	r3, #0
    1b94:	9300      	str	r3, [sp, #0]
    1b96:	0023      	movs	r3, r4
    1b98:	f7ff ff27 	bl	19ea <u8g2_DrawHVLine>
}
    1b9c:	46c0      	nop			; (mov r8, r8)
    1b9e:	46bd      	mov	sp, r7
    1ba0:	b005      	add	sp, #20
    1ba2:	bd90      	pop	{r4, r7, pc}

00001ba4 <u8g2_DrawVLine>:

void u8g2_DrawVLine(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t len)
{
    1ba4:	b590      	push	{r4, r7, lr}
    1ba6:	b087      	sub	sp, #28
    1ba8:	af02      	add	r7, sp, #8
    1baa:	60f8      	str	r0, [r7, #12]
    1bac:	000c      	movs	r4, r1
    1bae:	0010      	movs	r0, r2
    1bb0:	0019      	movs	r1, r3
    1bb2:	230a      	movs	r3, #10
    1bb4:	18fb      	adds	r3, r7, r3
    1bb6:	1c22      	adds	r2, r4, #0
    1bb8:	801a      	strh	r2, [r3, #0]
    1bba:	2308      	movs	r3, #8
    1bbc:	18fb      	adds	r3, r7, r3
    1bbe:	1c02      	adds	r2, r0, #0
    1bc0:	801a      	strh	r2, [r3, #0]
    1bc2:	1dbb      	adds	r3, r7, #6
    1bc4:	1c0a      	adds	r2, r1, #0
    1bc6:	801a      	strh	r2, [r3, #0]
// #ifdef U8G2_WITH_INTERSECTION
//   if ( u8g2_IsIntersection(u8g2, x, y, x+1, y+len) == 0 ) 
//     return;
// #endif /* U8G2_WITH_INTERSECTION */
  u8g2_DrawHVLine(u8g2, x, y, len, 1);
    1bc8:	1dbb      	adds	r3, r7, #6
    1bca:	881c      	ldrh	r4, [r3, #0]
    1bcc:	2308      	movs	r3, #8
    1bce:	18fb      	adds	r3, r7, r3
    1bd0:	881a      	ldrh	r2, [r3, #0]
    1bd2:	230a      	movs	r3, #10
    1bd4:	18fb      	adds	r3, r7, r3
    1bd6:	8819      	ldrh	r1, [r3, #0]
    1bd8:	68f8      	ldr	r0, [r7, #12]
    1bda:	2301      	movs	r3, #1
    1bdc:	9300      	str	r3, [sp, #0]
    1bde:	0023      	movs	r3, r4
    1be0:	f7ff ff03 	bl	19ea <u8g2_DrawHVLine>
}
    1be4:	46c0      	nop			; (mov r8, r8)
    1be6:	46bd      	mov	sp, r7
    1be8:	b005      	add	sp, #20
    1bea:	bd90      	pop	{r4, r7, pc}

00001bec <u8g2_DrawPixel>:

void u8g2_DrawPixel(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y)
{
    1bec:	b580      	push	{r7, lr}
    1bee:	b084      	sub	sp, #16
    1bf0:	af02      	add	r7, sp, #8
    1bf2:	6078      	str	r0, [r7, #4]
    1bf4:	0008      	movs	r0, r1
    1bf6:	0011      	movs	r1, r2
    1bf8:	1cbb      	adds	r3, r7, #2
    1bfa:	1c02      	adds	r2, r0, #0
    1bfc:	801a      	strh	r2, [r3, #0]
    1bfe:	003b      	movs	r3, r7
    1c00:	1c0a      	adds	r2, r1, #0
    1c02:	801a      	strh	r2, [r3, #0]
#ifdef U8G2_WITH_INTERSECTION
  if ( y < u8g2->user_y0 )
    1c04:	687b      	ldr	r3, [r7, #4]
    1c06:	224c      	movs	r2, #76	; 0x4c
    1c08:	5a9b      	ldrh	r3, [r3, r2]
    1c0a:	003a      	movs	r2, r7
    1c0c:	8812      	ldrh	r2, [r2, #0]
    1c0e:	429a      	cmp	r2, r3
    1c10:	d31f      	bcc.n	1c52 <u8g2_DrawPixel+0x66>
    return;
  if ( y >= u8g2->user_y1 )
    1c12:	687b      	ldr	r3, [r7, #4]
    1c14:	224e      	movs	r2, #78	; 0x4e
    1c16:	5a9b      	ldrh	r3, [r3, r2]
    1c18:	003a      	movs	r2, r7
    1c1a:	8812      	ldrh	r2, [r2, #0]
    1c1c:	429a      	cmp	r2, r3
    1c1e:	d21a      	bcs.n	1c56 <u8g2_DrawPixel+0x6a>
    return;
  if ( x < u8g2->user_x0 )
    1c20:	687b      	ldr	r3, [r7, #4]
    1c22:	2248      	movs	r2, #72	; 0x48
    1c24:	5a9b      	ldrh	r3, [r3, r2]
    1c26:	1cba      	adds	r2, r7, #2
    1c28:	8812      	ldrh	r2, [r2, #0]
    1c2a:	429a      	cmp	r2, r3
    1c2c:	d315      	bcc.n	1c5a <u8g2_DrawPixel+0x6e>
    return;
  if ( x >= u8g2->user_x1 )
    1c2e:	687b      	ldr	r3, [r7, #4]
    1c30:	224a      	movs	r2, #74	; 0x4a
    1c32:	5a9b      	ldrh	r3, [r3, r2]
    1c34:	1cba      	adds	r2, r7, #2
    1c36:	8812      	ldrh	r2, [r2, #0]
    1c38:	429a      	cmp	r2, r3
    1c3a:	d210      	bcs.n	1c5e <u8g2_DrawPixel+0x72>
    return;
#endif /* U8G2_WITH_INTERSECTION */
  u8g2_DrawHVLine(u8g2, x, y, 1, 0);
    1c3c:	003b      	movs	r3, r7
    1c3e:	881a      	ldrh	r2, [r3, #0]
    1c40:	1cbb      	adds	r3, r7, #2
    1c42:	8819      	ldrh	r1, [r3, #0]
    1c44:	6878      	ldr	r0, [r7, #4]
    1c46:	2300      	movs	r3, #0
    1c48:	9300      	str	r3, [sp, #0]
    1c4a:	2301      	movs	r3, #1
    1c4c:	f7ff fecd 	bl	19ea <u8g2_DrawHVLine>
    1c50:	e006      	b.n	1c60 <u8g2_DrawPixel+0x74>
    return;
    1c52:	46c0      	nop			; (mov r8, r8)
    1c54:	e004      	b.n	1c60 <u8g2_DrawPixel+0x74>
    return;
    1c56:	46c0      	nop			; (mov r8, r8)
    1c58:	e002      	b.n	1c60 <u8g2_DrawPixel+0x74>
    return;
    1c5a:	46c0      	nop			; (mov r8, r8)
    1c5c:	e000      	b.n	1c60 <u8g2_DrawPixel+0x74>
    return;
    1c5e:	46c0      	nop			; (mov r8, r8)
}
    1c60:	46bd      	mov	sp, r7
    1c62:	b002      	add	sp, #8
    1c64:	bd80      	pop	{r7, pc}

00001c66 <u8g2_is_intersection_decision_tree>:
  version with asymetric boundaries.
  a1 and v1 are excluded
  v0 == v1 is not support end return 1
*/
uint8_t u8g2_is_intersection_decision_tree(u8g2_uint_t a0, u8g2_uint_t a1, u8g2_uint_t v0, u8g2_uint_t v1)
{
    1c66:	b5b0      	push	{r4, r5, r7, lr}
    1c68:	b082      	sub	sp, #8
    1c6a:	af00      	add	r7, sp, #0
    1c6c:	0005      	movs	r5, r0
    1c6e:	000c      	movs	r4, r1
    1c70:	0010      	movs	r0, r2
    1c72:	0019      	movs	r1, r3
    1c74:	1dbb      	adds	r3, r7, #6
    1c76:	1c2a      	adds	r2, r5, #0
    1c78:	801a      	strh	r2, [r3, #0]
    1c7a:	1d3b      	adds	r3, r7, #4
    1c7c:	1c22      	adds	r2, r4, #0
    1c7e:	801a      	strh	r2, [r3, #0]
    1c80:	1cbb      	adds	r3, r7, #2
    1c82:	1c02      	adds	r2, r0, #0
    1c84:	801a      	strh	r2, [r3, #0]
    1c86:	003b      	movs	r3, r7
    1c88:	1c0a      	adds	r2, r1, #0
    1c8a:	801a      	strh	r2, [r3, #0]
  if ( v0 < a1 )		// v0 <= a1
    1c8c:	1cba      	adds	r2, r7, #2
    1c8e:	1d3b      	adds	r3, r7, #4
    1c90:	8812      	ldrh	r2, [r2, #0]
    1c92:	881b      	ldrh	r3, [r3, #0]
    1c94:	429a      	cmp	r2, r3
    1c96:	d211      	bcs.n	1cbc <u8g2_is_intersection_decision_tree+0x56>
  {
    if ( v1 > a0 )	// v1 >= a0
    1c98:	003a      	movs	r2, r7
    1c9a:	1dbb      	adds	r3, r7, #6
    1c9c:	8812      	ldrh	r2, [r2, #0]
    1c9e:	881b      	ldrh	r3, [r3, #0]
    1ca0:	429a      	cmp	r2, r3
    1ca2:	d901      	bls.n	1ca8 <u8g2_is_intersection_decision_tree+0x42>
    {
      return 1;
    1ca4:	2301      	movs	r3, #1
    1ca6:	e01a      	b.n	1cde <u8g2_is_intersection_decision_tree+0x78>
    }
    else
    {
      if ( v0 > v1 )	// v0 > v1
    1ca8:	1cba      	adds	r2, r7, #2
    1caa:	003b      	movs	r3, r7
    1cac:	8812      	ldrh	r2, [r2, #0]
    1cae:	881b      	ldrh	r3, [r3, #0]
    1cb0:	429a      	cmp	r2, r3
    1cb2:	d901      	bls.n	1cb8 <u8g2_is_intersection_decision_tree+0x52>
      {
	return 1;
    1cb4:	2301      	movs	r3, #1
    1cb6:	e012      	b.n	1cde <u8g2_is_intersection_decision_tree+0x78>
      }
      else
      {
	return 0;
    1cb8:	2300      	movs	r3, #0
    1cba:	e010      	b.n	1cde <u8g2_is_intersection_decision_tree+0x78>
      }
    }
  }
  else
  {
    if ( v1 > a0 )	// v1 >= a0
    1cbc:	003a      	movs	r2, r7
    1cbe:	1dbb      	adds	r3, r7, #6
    1cc0:	8812      	ldrh	r2, [r2, #0]
    1cc2:	881b      	ldrh	r3, [r3, #0]
    1cc4:	429a      	cmp	r2, r3
    1cc6:	d909      	bls.n	1cdc <u8g2_is_intersection_decision_tree+0x76>
    {
      if ( v0 > v1 )	// v0 > v1
    1cc8:	1cba      	adds	r2, r7, #2
    1cca:	003b      	movs	r3, r7
    1ccc:	8812      	ldrh	r2, [r2, #0]
    1cce:	881b      	ldrh	r3, [r3, #0]
    1cd0:	429a      	cmp	r2, r3
    1cd2:	d901      	bls.n	1cd8 <u8g2_is_intersection_decision_tree+0x72>
      {
	return 1;
    1cd4:	2301      	movs	r3, #1
    1cd6:	e002      	b.n	1cde <u8g2_is_intersection_decision_tree+0x78>
      }
      else
      {
	return 0;
    1cd8:	2300      	movs	r3, #0
    1cda:	e000      	b.n	1cde <u8g2_is_intersection_decision_tree+0x78>
      }
    }
    else
    {
      return 0;
    1cdc:	2300      	movs	r3, #0
    }
  }
}
    1cde:	0018      	movs	r0, r3
    1ce0:	46bd      	mov	sp, r7
    1ce2:	b002      	add	sp, #8
    1ce4:	bdb0      	pop	{r4, r5, r7, pc}

00001ce6 <u8g2_IsIntersection>:



/* upper limits are not included (asymetric boundaries) */
uint8_t u8g2_IsIntersection(u8g2_t *u8g2, u8g2_uint_t x0, u8g2_uint_t y0, u8g2_uint_t x1, u8g2_uint_t y1)
{
    1ce6:	b590      	push	{r4, r7, lr}
    1ce8:	b085      	sub	sp, #20
    1cea:	af00      	add	r7, sp, #0
    1cec:	60f8      	str	r0, [r7, #12]
    1cee:	000c      	movs	r4, r1
    1cf0:	0010      	movs	r0, r2
    1cf2:	0019      	movs	r1, r3
    1cf4:	230a      	movs	r3, #10
    1cf6:	18fb      	adds	r3, r7, r3
    1cf8:	1c22      	adds	r2, r4, #0
    1cfa:	801a      	strh	r2, [r3, #0]
    1cfc:	2308      	movs	r3, #8
    1cfe:	18fb      	adds	r3, r7, r3
    1d00:	1c02      	adds	r2, r0, #0
    1d02:	801a      	strh	r2, [r3, #0]
    1d04:	1dbb      	adds	r3, r7, #6
    1d06:	1c0a      	adds	r2, r1, #0
    1d08:	801a      	strh	r2, [r3, #0]
  if ( u8g2_is_intersection_decision_tree(u8g2->user_y0, u8g2->user_y1, y0, y1) == 0 )
    1d0a:	68fb      	ldr	r3, [r7, #12]
    1d0c:	224c      	movs	r2, #76	; 0x4c
    1d0e:	5a98      	ldrh	r0, [r3, r2]
    1d10:	68fb      	ldr	r3, [r7, #12]
    1d12:	224e      	movs	r2, #78	; 0x4e
    1d14:	5a99      	ldrh	r1, [r3, r2]
    1d16:	2320      	movs	r3, #32
    1d18:	18fb      	adds	r3, r7, r3
    1d1a:	881c      	ldrh	r4, [r3, #0]
    1d1c:	2308      	movs	r3, #8
    1d1e:	18fb      	adds	r3, r7, r3
    1d20:	881a      	ldrh	r2, [r3, #0]
    1d22:	0023      	movs	r3, r4
    1d24:	f7ff ff9f 	bl	1c66 <u8g2_is_intersection_decision_tree>
    1d28:	1e03      	subs	r3, r0, #0
    1d2a:	d101      	bne.n	1d30 <u8g2_IsIntersection+0x4a>
    return 0; 
    1d2c:	2300      	movs	r3, #0
    1d2e:	e00e      	b.n	1d4e <u8g2_IsIntersection+0x68>
  
  return u8g2_is_intersection_decision_tree(u8g2->user_x0, u8g2->user_x1, x0, x1);
    1d30:	68fb      	ldr	r3, [r7, #12]
    1d32:	2248      	movs	r2, #72	; 0x48
    1d34:	5a98      	ldrh	r0, [r3, r2]
    1d36:	68fb      	ldr	r3, [r7, #12]
    1d38:	224a      	movs	r2, #74	; 0x4a
    1d3a:	5a99      	ldrh	r1, [r3, r2]
    1d3c:	1dbb      	adds	r3, r7, #6
    1d3e:	881c      	ldrh	r4, [r3, #0]
    1d40:	230a      	movs	r3, #10
    1d42:	18fb      	adds	r3, r7, r3
    1d44:	881a      	ldrh	r2, [r3, #0]
    1d46:	0023      	movs	r3, r4
    1d48:	f7ff ff8d 	bl	1c66 <u8g2_is_intersection_decision_tree>
    1d4c:	0003      	movs	r3, r0
}
    1d4e:	0018      	movs	r0, r3
    1d50:	46bd      	mov	sp, r7
    1d52:	b005      	add	sp, #20
    1d54:	bd90      	pop	{r4, r7, pc}
	...

00001d58 <u8g2_DrawLine>:

#include "u8g2.h"


void u8g2_DrawLine(u8g2_t *u8g2, u8g2_uint_t x1, u8g2_uint_t y1, u8g2_uint_t x2, u8g2_uint_t y2)
{
    1d58:	b590      	push	{r4, r7, lr}
    1d5a:	b089      	sub	sp, #36	; 0x24
    1d5c:	af00      	add	r7, sp, #0
    1d5e:	60f8      	str	r0, [r7, #12]
    1d60:	000c      	movs	r4, r1
    1d62:	0010      	movs	r0, r2
    1d64:	0019      	movs	r1, r3
    1d66:	230a      	movs	r3, #10
    1d68:	18fb      	adds	r3, r7, r3
    1d6a:	1c22      	adds	r2, r4, #0
    1d6c:	801a      	strh	r2, [r3, #0]
    1d6e:	2308      	movs	r3, #8
    1d70:	18fb      	adds	r3, r7, r3
    1d72:	1c02      	adds	r2, r0, #0
    1d74:	801a      	strh	r2, [r3, #0]
    1d76:	1dbb      	adds	r3, r7, #6
    1d78:	1c0a      	adds	r2, r1, #0
    1d7a:	801a      	strh	r2, [r3, #0]
  u8g2_uint_t x,y;
  u8g2_uint_t dx, dy;
  u8g2_int_t err;
  u8g2_int_t ystep;

  uint8_t swapxy = 0;
    1d7c:	2313      	movs	r3, #19
    1d7e:	18fb      	adds	r3, r7, r3
    1d80:	2200      	movs	r2, #0
    1d82:	701a      	strb	r2, [r3, #0]
  
  /* no intersection check at the moment, should be added... */

  if ( x1 > x2 ) dx = x1-x2; else dx = x2-x1;
    1d84:	230a      	movs	r3, #10
    1d86:	18fa      	adds	r2, r7, r3
    1d88:	1dbb      	adds	r3, r7, #6
    1d8a:	8812      	ldrh	r2, [r2, #0]
    1d8c:	881b      	ldrh	r3, [r3, #0]
    1d8e:	429a      	cmp	r2, r3
    1d90:	d909      	bls.n	1da6 <u8g2_DrawLine+0x4e>
    1d92:	231a      	movs	r3, #26
    1d94:	18fb      	adds	r3, r7, r3
    1d96:	220a      	movs	r2, #10
    1d98:	18b9      	adds	r1, r7, r2
    1d9a:	1dba      	adds	r2, r7, #6
    1d9c:	8809      	ldrh	r1, [r1, #0]
    1d9e:	8812      	ldrh	r2, [r2, #0]
    1da0:	1a8a      	subs	r2, r1, r2
    1da2:	801a      	strh	r2, [r3, #0]
    1da4:	e008      	b.n	1db8 <u8g2_DrawLine+0x60>
    1da6:	231a      	movs	r3, #26
    1da8:	18fb      	adds	r3, r7, r3
    1daa:	1db9      	adds	r1, r7, #6
    1dac:	220a      	movs	r2, #10
    1dae:	18ba      	adds	r2, r7, r2
    1db0:	8809      	ldrh	r1, [r1, #0]
    1db2:	8812      	ldrh	r2, [r2, #0]
    1db4:	1a8a      	subs	r2, r1, r2
    1db6:	801a      	strh	r2, [r3, #0]
  if ( y1 > y2 ) dy = y1-y2; else dy = y2-y1;
    1db8:	2308      	movs	r3, #8
    1dba:	18fb      	adds	r3, r7, r3
    1dbc:	2230      	movs	r2, #48	; 0x30
    1dbe:	18b9      	adds	r1, r7, r2
    1dc0:	881a      	ldrh	r2, [r3, #0]
    1dc2:	880b      	ldrh	r3, [r1, #0]
    1dc4:	429a      	cmp	r2, r3
    1dc6:	d90a      	bls.n	1dde <u8g2_DrawLine+0x86>
    1dc8:	2318      	movs	r3, #24
    1dca:	18fb      	adds	r3, r7, r3
    1dcc:	2208      	movs	r2, #8
    1dce:	18ba      	adds	r2, r7, r2
    1dd0:	2130      	movs	r1, #48	; 0x30
    1dd2:	1878      	adds	r0, r7, r1
    1dd4:	8811      	ldrh	r1, [r2, #0]
    1dd6:	8802      	ldrh	r2, [r0, #0]
    1dd8:	1a8a      	subs	r2, r1, r2
    1dda:	801a      	strh	r2, [r3, #0]
    1ddc:	e009      	b.n	1df2 <u8g2_DrawLine+0x9a>
    1dde:	2318      	movs	r3, #24
    1de0:	18fb      	adds	r3, r7, r3
    1de2:	2230      	movs	r2, #48	; 0x30
    1de4:	18b9      	adds	r1, r7, r2
    1de6:	2208      	movs	r2, #8
    1de8:	18ba      	adds	r2, r7, r2
    1dea:	8809      	ldrh	r1, [r1, #0]
    1dec:	8812      	ldrh	r2, [r2, #0]
    1dee:	1a8a      	subs	r2, r1, r2
    1df0:	801a      	strh	r2, [r3, #0]

  if ( dy > dx ) 
    1df2:	2318      	movs	r3, #24
    1df4:	18fa      	adds	r2, r7, r3
    1df6:	231a      	movs	r3, #26
    1df8:	18fb      	adds	r3, r7, r3
    1dfa:	8812      	ldrh	r2, [r2, #0]
    1dfc:	881b      	ldrh	r3, [r3, #0]
    1dfe:	429a      	cmp	r2, r3
    1e00:	d937      	bls.n	1e72 <u8g2_DrawLine+0x11a>
  {
    swapxy = 1;
    1e02:	2313      	movs	r3, #19
    1e04:	18fb      	adds	r3, r7, r3
    1e06:	2201      	movs	r2, #1
    1e08:	701a      	strb	r2, [r3, #0]
    tmp = dx; dx =dy; dy = tmp;
    1e0a:	2310      	movs	r3, #16
    1e0c:	18fb      	adds	r3, r7, r3
    1e0e:	221a      	movs	r2, #26
    1e10:	18ba      	adds	r2, r7, r2
    1e12:	8812      	ldrh	r2, [r2, #0]
    1e14:	801a      	strh	r2, [r3, #0]
    1e16:	231a      	movs	r3, #26
    1e18:	18fb      	adds	r3, r7, r3
    1e1a:	2218      	movs	r2, #24
    1e1c:	18ba      	adds	r2, r7, r2
    1e1e:	8812      	ldrh	r2, [r2, #0]
    1e20:	801a      	strh	r2, [r3, #0]
    1e22:	2318      	movs	r3, #24
    1e24:	18fb      	adds	r3, r7, r3
    1e26:	2210      	movs	r2, #16
    1e28:	18ba      	adds	r2, r7, r2
    1e2a:	8812      	ldrh	r2, [r2, #0]
    1e2c:	801a      	strh	r2, [r3, #0]
    tmp = x1; x1 =y1; y1 = tmp;
    1e2e:	2310      	movs	r3, #16
    1e30:	18fb      	adds	r3, r7, r3
    1e32:	220a      	movs	r2, #10
    1e34:	18ba      	adds	r2, r7, r2
    1e36:	8812      	ldrh	r2, [r2, #0]
    1e38:	801a      	strh	r2, [r3, #0]
    1e3a:	230a      	movs	r3, #10
    1e3c:	18fb      	adds	r3, r7, r3
    1e3e:	2208      	movs	r2, #8
    1e40:	18ba      	adds	r2, r7, r2
    1e42:	8812      	ldrh	r2, [r2, #0]
    1e44:	801a      	strh	r2, [r3, #0]
    1e46:	2308      	movs	r3, #8
    1e48:	18fb      	adds	r3, r7, r3
    1e4a:	2210      	movs	r2, #16
    1e4c:	18ba      	adds	r2, r7, r2
    1e4e:	8812      	ldrh	r2, [r2, #0]
    1e50:	801a      	strh	r2, [r3, #0]
    tmp = x2; x2 =y2; y2 = tmp;
    1e52:	2310      	movs	r3, #16
    1e54:	18fb      	adds	r3, r7, r3
    1e56:	1dba      	adds	r2, r7, #6
    1e58:	8812      	ldrh	r2, [r2, #0]
    1e5a:	801a      	strh	r2, [r3, #0]
    1e5c:	1dbb      	adds	r3, r7, #6
    1e5e:	2230      	movs	r2, #48	; 0x30
    1e60:	18ba      	adds	r2, r7, r2
    1e62:	8812      	ldrh	r2, [r2, #0]
    1e64:	801a      	strh	r2, [r3, #0]
    1e66:	2330      	movs	r3, #48	; 0x30
    1e68:	18fa      	adds	r2, r7, r3
    1e6a:	2310      	movs	r3, #16
    1e6c:	18fb      	adds	r3, r7, r3
    1e6e:	881b      	ldrh	r3, [r3, #0]
    1e70:	8013      	strh	r3, [r2, #0]
  }
  if ( x1 > x2 ) 
    1e72:	230a      	movs	r3, #10
    1e74:	18fa      	adds	r2, r7, r3
    1e76:	1dbb      	adds	r3, r7, #6
    1e78:	8812      	ldrh	r2, [r2, #0]
    1e7a:	881b      	ldrh	r3, [r3, #0]
    1e7c:	429a      	cmp	r2, r3
    1e7e:	d921      	bls.n	1ec4 <u8g2_DrawLine+0x16c>
  {
    tmp = x1; x1 =x2; x2 = tmp;
    1e80:	2310      	movs	r3, #16
    1e82:	18fb      	adds	r3, r7, r3
    1e84:	220a      	movs	r2, #10
    1e86:	18ba      	adds	r2, r7, r2
    1e88:	8812      	ldrh	r2, [r2, #0]
    1e8a:	801a      	strh	r2, [r3, #0]
    1e8c:	230a      	movs	r3, #10
    1e8e:	18fb      	adds	r3, r7, r3
    1e90:	1dba      	adds	r2, r7, #6
    1e92:	8812      	ldrh	r2, [r2, #0]
    1e94:	801a      	strh	r2, [r3, #0]
    1e96:	1dbb      	adds	r3, r7, #6
    1e98:	2210      	movs	r2, #16
    1e9a:	18ba      	adds	r2, r7, r2
    1e9c:	8812      	ldrh	r2, [r2, #0]
    1e9e:	801a      	strh	r2, [r3, #0]
    tmp = y1; y1 =y2; y2 = tmp;
    1ea0:	2310      	movs	r3, #16
    1ea2:	18fb      	adds	r3, r7, r3
    1ea4:	2208      	movs	r2, #8
    1ea6:	18ba      	adds	r2, r7, r2
    1ea8:	8812      	ldrh	r2, [r2, #0]
    1eaa:	801a      	strh	r2, [r3, #0]
    1eac:	2308      	movs	r3, #8
    1eae:	18fb      	adds	r3, r7, r3
    1eb0:	2230      	movs	r2, #48	; 0x30
    1eb2:	18ba      	adds	r2, r7, r2
    1eb4:	8812      	ldrh	r2, [r2, #0]
    1eb6:	801a      	strh	r2, [r3, #0]
    1eb8:	2330      	movs	r3, #48	; 0x30
    1eba:	18fa      	adds	r2, r7, r3
    1ebc:	2310      	movs	r3, #16
    1ebe:	18fb      	adds	r3, r7, r3
    1ec0:	881b      	ldrh	r3, [r3, #0]
    1ec2:	8013      	strh	r3, [r2, #0]
  }
  err = dx >> 1;
    1ec4:	231a      	movs	r3, #26
    1ec6:	18fb      	adds	r3, r7, r3
    1ec8:	881b      	ldrh	r3, [r3, #0]
    1eca:	085b      	lsrs	r3, r3, #1
    1ecc:	b29a      	uxth	r2, r3
    1ece:	2316      	movs	r3, #22
    1ed0:	18fb      	adds	r3, r7, r3
    1ed2:	801a      	strh	r2, [r3, #0]
  if ( y2 > y1 ) ystep = 1; else ystep = -1;
    1ed4:	2330      	movs	r3, #48	; 0x30
    1ed6:	18fa      	adds	r2, r7, r3
    1ed8:	2308      	movs	r3, #8
    1eda:	18fb      	adds	r3, r7, r3
    1edc:	8812      	ldrh	r2, [r2, #0]
    1ede:	881b      	ldrh	r3, [r3, #0]
    1ee0:	429a      	cmp	r2, r3
    1ee2:	d904      	bls.n	1eee <u8g2_DrawLine+0x196>
    1ee4:	2314      	movs	r3, #20
    1ee6:	18fb      	adds	r3, r7, r3
    1ee8:	2201      	movs	r2, #1
    1eea:	801a      	strh	r2, [r3, #0]
    1eec:	e004      	b.n	1ef8 <u8g2_DrawLine+0x1a0>
    1eee:	2314      	movs	r3, #20
    1ef0:	18fb      	adds	r3, r7, r3
    1ef2:	2201      	movs	r2, #1
    1ef4:	4252      	negs	r2, r2
    1ef6:	801a      	strh	r2, [r3, #0]
  y = y1;
    1ef8:	231c      	movs	r3, #28
    1efa:	18fb      	adds	r3, r7, r3
    1efc:	2208      	movs	r2, #8
    1efe:	18ba      	adds	r2, r7, r2
    1f00:	8812      	ldrh	r2, [r2, #0]
    1f02:	801a      	strh	r2, [r3, #0]

#ifndef  U8G2_16BIT
  if ( x2 == 255 )
    x2--;
#else
  if ( x2 == 0xffff )
    1f04:	1dbb      	adds	r3, r7, #6
    1f06:	881b      	ldrh	r3, [r3, #0]
    1f08:	4a30      	ldr	r2, [pc, #192]	; (1fcc <u8g2_DrawLine+0x274>)
    1f0a:	4293      	cmp	r3, r2
    1f0c:	d104      	bne.n	1f18 <u8g2_DrawLine+0x1c0>
    x2--;
    1f0e:	1dbb      	adds	r3, r7, #6
    1f10:	881a      	ldrh	r2, [r3, #0]
    1f12:	1dbb      	adds	r3, r7, #6
    1f14:	3a01      	subs	r2, #1
    1f16:	801a      	strh	r2, [r3, #0]
#endif

  for( x = x1; x <= x2; x++ )
    1f18:	231e      	movs	r3, #30
    1f1a:	18fb      	adds	r3, r7, r3
    1f1c:	220a      	movs	r2, #10
    1f1e:	18ba      	adds	r2, r7, r2
    1f20:	8812      	ldrh	r2, [r2, #0]
    1f22:	801a      	strh	r2, [r3, #0]
    1f24:	e046      	b.n	1fb4 <u8g2_DrawLine+0x25c>
  {
    if ( swapxy == 0 ) 
    1f26:	2313      	movs	r3, #19
    1f28:	18fb      	adds	r3, r7, r3
    1f2a:	781b      	ldrb	r3, [r3, #0]
    1f2c:	2b00      	cmp	r3, #0
    1f2e:	d10a      	bne.n	1f46 <u8g2_DrawLine+0x1ee>
      u8g2_DrawPixel(u8g2, x, y); 
    1f30:	231c      	movs	r3, #28
    1f32:	18fb      	adds	r3, r7, r3
    1f34:	881a      	ldrh	r2, [r3, #0]
    1f36:	231e      	movs	r3, #30
    1f38:	18fb      	adds	r3, r7, r3
    1f3a:	8819      	ldrh	r1, [r3, #0]
    1f3c:	68fb      	ldr	r3, [r7, #12]
    1f3e:	0018      	movs	r0, r3
    1f40:	f7ff fe54 	bl	1bec <u8g2_DrawPixel>
    1f44:	e009      	b.n	1f5a <u8g2_DrawLine+0x202>
    else 
      u8g2_DrawPixel(u8g2, y, x); 
    1f46:	231e      	movs	r3, #30
    1f48:	18fb      	adds	r3, r7, r3
    1f4a:	881a      	ldrh	r2, [r3, #0]
    1f4c:	231c      	movs	r3, #28
    1f4e:	18fb      	adds	r3, r7, r3
    1f50:	8819      	ldrh	r1, [r3, #0]
    1f52:	68fb      	ldr	r3, [r7, #12]
    1f54:	0018      	movs	r0, r3
    1f56:	f7ff fe49 	bl	1bec <u8g2_DrawPixel>
    err -= (u8g2_uint_t)dy;
    1f5a:	2316      	movs	r3, #22
    1f5c:	18fb      	adds	r3, r7, r3
    1f5e:	881a      	ldrh	r2, [r3, #0]
    1f60:	2318      	movs	r3, #24
    1f62:	18fb      	adds	r3, r7, r3
    1f64:	881b      	ldrh	r3, [r3, #0]
    1f66:	1ad3      	subs	r3, r2, r3
    1f68:	b29a      	uxth	r2, r3
    1f6a:	2316      	movs	r3, #22
    1f6c:	18fb      	adds	r3, r7, r3
    1f6e:	801a      	strh	r2, [r3, #0]
    if ( err < 0 ) 
    1f70:	2316      	movs	r3, #22
    1f72:	18fb      	adds	r3, r7, r3
    1f74:	2200      	movs	r2, #0
    1f76:	5e9b      	ldrsh	r3, [r3, r2]
    1f78:	2b00      	cmp	r3, #0
    1f7a:	da14      	bge.n	1fa6 <u8g2_DrawLine+0x24e>
    {
      y += (u8g2_uint_t)ystep;
    1f7c:	2314      	movs	r3, #20
    1f7e:	18fb      	adds	r3, r7, r3
    1f80:	8819      	ldrh	r1, [r3, #0]
    1f82:	231c      	movs	r3, #28
    1f84:	18fb      	adds	r3, r7, r3
    1f86:	221c      	movs	r2, #28
    1f88:	18ba      	adds	r2, r7, r2
    1f8a:	8812      	ldrh	r2, [r2, #0]
    1f8c:	188a      	adds	r2, r1, r2
    1f8e:	801a      	strh	r2, [r3, #0]
      err += (u8g2_uint_t)dx;
    1f90:	2316      	movs	r3, #22
    1f92:	18fb      	adds	r3, r7, r3
    1f94:	881a      	ldrh	r2, [r3, #0]
    1f96:	231a      	movs	r3, #26
    1f98:	18fb      	adds	r3, r7, r3
    1f9a:	881b      	ldrh	r3, [r3, #0]
    1f9c:	18d3      	adds	r3, r2, r3
    1f9e:	b29a      	uxth	r2, r3
    1fa0:	2316      	movs	r3, #22
    1fa2:	18fb      	adds	r3, r7, r3
    1fa4:	801a      	strh	r2, [r3, #0]
  for( x = x1; x <= x2; x++ )
    1fa6:	231e      	movs	r3, #30
    1fa8:	18fb      	adds	r3, r7, r3
    1faa:	881a      	ldrh	r2, [r3, #0]
    1fac:	231e      	movs	r3, #30
    1fae:	18fb      	adds	r3, r7, r3
    1fb0:	3201      	adds	r2, #1
    1fb2:	801a      	strh	r2, [r3, #0]
    1fb4:	231e      	movs	r3, #30
    1fb6:	18fa      	adds	r2, r7, r3
    1fb8:	1dbb      	adds	r3, r7, #6
    1fba:	8812      	ldrh	r2, [r2, #0]
    1fbc:	881b      	ldrh	r3, [r3, #0]
    1fbe:	429a      	cmp	r2, r3
    1fc0:	d9b1      	bls.n	1f26 <u8g2_DrawLine+0x1ce>
    }
  }
}
    1fc2:	46c0      	nop			; (mov r8, r8)
    1fc4:	46bd      	mov	sp, r7
    1fc6:	b009      	add	sp, #36	; 0x24
    1fc8:	bd90      	pop	{r4, r7, pc}
    1fca:	46c0      	nop			; (mov r8, r8)
    1fcc:	0000ffff 	.word	0x0000ffff

00001fd0 <u8g2_ll_hvline_vertical_top_lsb>:
		1: vertical line (top to bottom)
  asumption: 
    all clipping done
*/
void u8g2_ll_hvline_vertical_top_lsb(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t len, uint8_t dir)
{
    1fd0:	b590      	push	{r4, r7, lr}
    1fd2:	b089      	sub	sp, #36	; 0x24
    1fd4:	af00      	add	r7, sp, #0
    1fd6:	60f8      	str	r0, [r7, #12]
    1fd8:	000c      	movs	r4, r1
    1fda:	0010      	movs	r0, r2
    1fdc:	0019      	movs	r1, r3
    1fde:	230a      	movs	r3, #10
    1fe0:	18fb      	adds	r3, r7, r3
    1fe2:	1c22      	adds	r2, r4, #0
    1fe4:	801a      	strh	r2, [r3, #0]
    1fe6:	2308      	movs	r3, #8
    1fe8:	18fb      	adds	r3, r7, r3
    1fea:	1c02      	adds	r2, r0, #0
    1fec:	801a      	strh	r2, [r3, #0]
    1fee:	1dbb      	adds	r3, r7, #6
    1ff0:	1c0a      	adds	r2, r1, #0
    1ff2:	801a      	strh	r2, [r3, #0]
  //assert(x < u8g2_GetU8x8(u8g2)->display_info->tile_width*8);
  //assert(y >= u8g2->buf_y0);
  //assert(y < u8g2_GetU8x8(u8g2)->display_info->tile_height*8);
  
  /* bytes are vertical, lsb on top (y=0), msb at bottom (y=7) */
  bit_pos = y;		/* overflow truncate is ok here... */
    1ff4:	231b      	movs	r3, #27
    1ff6:	18fb      	adds	r3, r7, r3
    1ff8:	2208      	movs	r2, #8
    1ffa:	18ba      	adds	r2, r7, r2
    1ffc:	8812      	ldrh	r2, [r2, #0]
    1ffe:	701a      	strb	r2, [r3, #0]
  bit_pos &= 7; 	/* ... because only the lowest 3 bits are needed */
    2000:	231b      	movs	r3, #27
    2002:	18fb      	adds	r3, r7, r3
    2004:	221b      	movs	r2, #27
    2006:	18ba      	adds	r2, r7, r2
    2008:	7812      	ldrb	r2, [r2, #0]
    200a:	2107      	movs	r1, #7
    200c:	400a      	ands	r2, r1
    200e:	701a      	strb	r2, [r3, #0]
  mask = 1;
    2010:	2318      	movs	r3, #24
    2012:	18fb      	adds	r3, r7, r3
    2014:	2201      	movs	r2, #1
    2016:	701a      	strb	r2, [r3, #0]
  mask <<= bit_pos;
    2018:	2318      	movs	r3, #24
    201a:	18fb      	adds	r3, r7, r3
    201c:	781a      	ldrb	r2, [r3, #0]
    201e:	231b      	movs	r3, #27
    2020:	18fb      	adds	r3, r7, r3
    2022:	781b      	ldrb	r3, [r3, #0]
    2024:	409a      	lsls	r2, r3
    2026:	2318      	movs	r3, #24
    2028:	18fb      	adds	r3, r7, r3
    202a:	701a      	strb	r2, [r3, #0]

  or_mask = 0;
    202c:	231a      	movs	r3, #26
    202e:	18fb      	adds	r3, r7, r3
    2030:	2200      	movs	r2, #0
    2032:	701a      	strb	r2, [r3, #0]
  xor_mask = 0;
    2034:	2319      	movs	r3, #25
    2036:	18fb      	adds	r3, r7, r3
    2038:	2200      	movs	r2, #0
    203a:	701a      	strb	r2, [r3, #0]
  if ( u8g2->draw_color <= 1 )
    203c:	68fb      	ldr	r3, [r7, #12]
    203e:	2292      	movs	r2, #146	; 0x92
    2040:	5c9b      	ldrb	r3, [r3, r2]
    2042:	2b01      	cmp	r3, #1
    2044:	d805      	bhi.n	2052 <STACK_SIZE+0x52>
    or_mask  = mask;
    2046:	231a      	movs	r3, #26
    2048:	18fb      	adds	r3, r7, r3
    204a:	2218      	movs	r2, #24
    204c:	18ba      	adds	r2, r7, r2
    204e:	7812      	ldrb	r2, [r2, #0]
    2050:	701a      	strb	r2, [r3, #0]
  if ( u8g2->draw_color != 1 )
    2052:	68fb      	ldr	r3, [r7, #12]
    2054:	2292      	movs	r2, #146	; 0x92
    2056:	5c9b      	ldrb	r3, [r3, r2]
    2058:	2b01      	cmp	r3, #1
    205a:	d005      	beq.n	2068 <STACK_SIZE+0x68>
    xor_mask = mask;
    205c:	2319      	movs	r3, #25
    205e:	18fb      	adds	r3, r7, r3
    2060:	2218      	movs	r2, #24
    2062:	18ba      	adds	r2, r7, r2
    2064:	7812      	ldrb	r2, [r2, #0]
    2066:	701a      	strb	r2, [r3, #0]


  offset = y;		/* y might be 8 or 16 bit, but we need 16 bit, so use a 16 bit variable */
    2068:	2316      	movs	r3, #22
    206a:	18fb      	adds	r3, r7, r3
    206c:	2208      	movs	r2, #8
    206e:	18ba      	adds	r2, r7, r2
    2070:	8812      	ldrh	r2, [r2, #0]
    2072:	801a      	strh	r2, [r3, #0]
  offset &= ~7;
    2074:	2316      	movs	r3, #22
    2076:	18fb      	adds	r3, r7, r3
    2078:	2216      	movs	r2, #22
    207a:	18ba      	adds	r2, r7, r2
    207c:	8812      	ldrh	r2, [r2, #0]
    207e:	2107      	movs	r1, #7
    2080:	438a      	bics	r2, r1
    2082:	801a      	strh	r2, [r3, #0]
  offset *= u8g2_GetU8x8(u8g2)->display_info->tile_width;
    2084:	68fb      	ldr	r3, [r7, #12]
    2086:	681b      	ldr	r3, [r3, #0]
    2088:	7c1b      	ldrb	r3, [r3, #16]
    208a:	b29a      	uxth	r2, r3
    208c:	2316      	movs	r3, #22
    208e:	18fb      	adds	r3, r7, r3
    2090:	2116      	movs	r1, #22
    2092:	1879      	adds	r1, r7, r1
    2094:	8809      	ldrh	r1, [r1, #0]
    2096:	434a      	muls	r2, r1
    2098:	801a      	strh	r2, [r3, #0]
  ptr = u8g2->tile_buf_ptr;
    209a:	68fb      	ldr	r3, [r7, #12]
    209c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    209e:	61fb      	str	r3, [r7, #28]
  ptr += offset;
    20a0:	2316      	movs	r3, #22
    20a2:	18fb      	adds	r3, r7, r3
    20a4:	881b      	ldrh	r3, [r3, #0]
    20a6:	69fa      	ldr	r2, [r7, #28]
    20a8:	18d3      	adds	r3, r2, r3
    20aa:	61fb      	str	r3, [r7, #28]
  ptr += x;
    20ac:	230a      	movs	r3, #10
    20ae:	18fb      	adds	r3, r7, r3
    20b0:	881b      	ldrh	r3, [r3, #0]
    20b2:	69fa      	ldr	r2, [r7, #28]
    20b4:	18d3      	adds	r3, r2, r3
    20b6:	61fb      	str	r3, [r7, #28]
  
  if ( dir == 0 )
    20b8:	2330      	movs	r3, #48	; 0x30
    20ba:	18fb      	adds	r3, r7, r3
    20bc:	781b      	ldrb	r3, [r3, #0]
    20be:	2b00      	cmp	r3, #0
    20c0:	d11e      	bne.n	2100 <STACK_SIZE+0x100>
      do
      {
#ifdef __unix
	assert(ptr < max_ptr);
#endif
	*ptr |= or_mask;
    20c2:	69fb      	ldr	r3, [r7, #28]
    20c4:	781a      	ldrb	r2, [r3, #0]
    20c6:	231a      	movs	r3, #26
    20c8:	18fb      	adds	r3, r7, r3
    20ca:	781b      	ldrb	r3, [r3, #0]
    20cc:	4313      	orrs	r3, r2
    20ce:	b2da      	uxtb	r2, r3
    20d0:	69fb      	ldr	r3, [r7, #28]
    20d2:	701a      	strb	r2, [r3, #0]
	*ptr ^= xor_mask;
    20d4:	69fb      	ldr	r3, [r7, #28]
    20d6:	781a      	ldrb	r2, [r3, #0]
    20d8:	2319      	movs	r3, #25
    20da:	18fb      	adds	r3, r7, r3
    20dc:	781b      	ldrb	r3, [r3, #0]
    20de:	4053      	eors	r3, r2
    20e0:	b2da      	uxtb	r2, r3
    20e2:	69fb      	ldr	r3, [r7, #28]
    20e4:	701a      	strb	r2, [r3, #0]
	ptr++;
    20e6:	69fb      	ldr	r3, [r7, #28]
    20e8:	3301      	adds	r3, #1
    20ea:	61fb      	str	r3, [r7, #28]
	len--;
    20ec:	1dbb      	adds	r3, r7, #6
    20ee:	881a      	ldrh	r2, [r3, #0]
    20f0:	1dbb      	adds	r3, r7, #6
    20f2:	3a01      	subs	r2, #1
    20f4:	801a      	strh	r2, [r3, #0]
      } while( len != 0 );
    20f6:	1dbb      	adds	r3, r7, #6
    20f8:	881b      	ldrh	r3, [r3, #0]
    20fa:	2b00      	cmp	r3, #0
    20fc:	d1e1      	bne.n	20c2 <STACK_SIZE+0xc2>
	or_mask <<= 1;
	xor_mask <<= 1;
      }
    } while( len != 0 );
  }
}
    20fe:	e055      	b.n	21ac <STACK_SIZE+0x1ac>
      *ptr |= or_mask;
    2100:	69fb      	ldr	r3, [r7, #28]
    2102:	781a      	ldrb	r2, [r3, #0]
    2104:	231a      	movs	r3, #26
    2106:	18fb      	adds	r3, r7, r3
    2108:	781b      	ldrb	r3, [r3, #0]
    210a:	4313      	orrs	r3, r2
    210c:	b2da      	uxtb	r2, r3
    210e:	69fb      	ldr	r3, [r7, #28]
    2110:	701a      	strb	r2, [r3, #0]
      *ptr ^= xor_mask;
    2112:	69fb      	ldr	r3, [r7, #28]
    2114:	781a      	ldrb	r2, [r3, #0]
    2116:	2319      	movs	r3, #25
    2118:	18fb      	adds	r3, r7, r3
    211a:	781b      	ldrb	r3, [r3, #0]
    211c:	4053      	eors	r3, r2
    211e:	b2da      	uxtb	r2, r3
    2120:	69fb      	ldr	r3, [r7, #28]
    2122:	701a      	strb	r2, [r3, #0]
      bit_pos++;
    2124:	231b      	movs	r3, #27
    2126:	18fb      	adds	r3, r7, r3
    2128:	781a      	ldrb	r2, [r3, #0]
    212a:	231b      	movs	r3, #27
    212c:	18fb      	adds	r3, r7, r3
    212e:	3201      	adds	r2, #1
    2130:	701a      	strb	r2, [r3, #0]
      bit_pos &= 7;
    2132:	231b      	movs	r3, #27
    2134:	18fb      	adds	r3, r7, r3
    2136:	221b      	movs	r2, #27
    2138:	18ba      	adds	r2, r7, r2
    213a:	7812      	ldrb	r2, [r2, #0]
    213c:	2107      	movs	r1, #7
    213e:	400a      	ands	r2, r1
    2140:	701a      	strb	r2, [r3, #0]
      len--;
    2142:	1dbb      	adds	r3, r7, #6
    2144:	881a      	ldrh	r2, [r3, #0]
    2146:	1dbb      	adds	r3, r7, #6
    2148:	3a01      	subs	r2, #1
    214a:	801a      	strh	r2, [r3, #0]
      if ( bit_pos == 0 )
    214c:	231b      	movs	r3, #27
    214e:	18fb      	adds	r3, r7, r3
    2150:	781b      	ldrb	r3, [r3, #0]
    2152:	2b00      	cmp	r3, #0
    2154:	d118      	bne.n	2188 <STACK_SIZE+0x188>
	ptr+=u8g2->pixel_buf_width;	/* 6 Jan 17: Changed u8g2->width to u8g2->pixel_buf_width, issue #148 */
    2156:	68fb      	ldr	r3, [r7, #12]
    2158:	8f5b      	ldrh	r3, [r3, #58]	; 0x3a
    215a:	001a      	movs	r2, r3
    215c:	69fb      	ldr	r3, [r7, #28]
    215e:	189b      	adds	r3, r3, r2
    2160:	61fb      	str	r3, [r7, #28]
	if ( u8g2->draw_color <= 1 )
    2162:	68fb      	ldr	r3, [r7, #12]
    2164:	2292      	movs	r2, #146	; 0x92
    2166:	5c9b      	ldrb	r3, [r3, r2]
    2168:	2b01      	cmp	r3, #1
    216a:	d803      	bhi.n	2174 <STACK_SIZE+0x174>
	  or_mask  = 1;
    216c:	231a      	movs	r3, #26
    216e:	18fb      	adds	r3, r7, r3
    2170:	2201      	movs	r2, #1
    2172:	701a      	strb	r2, [r3, #0]
	if ( u8g2->draw_color != 1 )
    2174:	68fb      	ldr	r3, [r7, #12]
    2176:	2292      	movs	r2, #146	; 0x92
    2178:	5c9b      	ldrb	r3, [r3, r2]
    217a:	2b01      	cmp	r3, #1
    217c:	d012      	beq.n	21a4 <STACK_SIZE+0x1a4>
	  xor_mask = 1;
    217e:	2319      	movs	r3, #25
    2180:	18fb      	adds	r3, r7, r3
    2182:	2201      	movs	r2, #1
    2184:	701a      	strb	r2, [r3, #0]
    2186:	e00d      	b.n	21a4 <STACK_SIZE+0x1a4>
	or_mask <<= 1;
    2188:	231a      	movs	r3, #26
    218a:	18fa      	adds	r2, r7, r3
    218c:	231a      	movs	r3, #26
    218e:	18fb      	adds	r3, r7, r3
    2190:	781b      	ldrb	r3, [r3, #0]
    2192:	18db      	adds	r3, r3, r3
    2194:	7013      	strb	r3, [r2, #0]
	xor_mask <<= 1;
    2196:	2319      	movs	r3, #25
    2198:	18fa      	adds	r2, r7, r3
    219a:	2319      	movs	r3, #25
    219c:	18fb      	adds	r3, r7, r3
    219e:	781b      	ldrb	r3, [r3, #0]
    21a0:	18db      	adds	r3, r3, r3
    21a2:	7013      	strb	r3, [r2, #0]
    } while( len != 0 );
    21a4:	1dbb      	adds	r3, r7, #6
    21a6:	881b      	ldrh	r3, [r3, #0]
    21a8:	2b00      	cmp	r3, #0
    21aa:	d1a9      	bne.n	2100 <STACK_SIZE+0x100>
}
    21ac:	46c0      	nop			; (mov r8, r8)
    21ae:	46bd      	mov	sp, r7
    21b0:	b009      	add	sp, #36	; 0x24
    21b2:	bd90      	pop	{r4, r7, pc}

000021b4 <u8g2_SetMaxClipWindow>:


#ifdef U8G2_WITH_CLIP_WINDOW_SUPPORT

void u8g2_SetMaxClipWindow(u8g2_t *u8g2)
{
    21b4:	b580      	push	{r7, lr}
    21b6:	b082      	sub	sp, #8
    21b8:	af00      	add	r7, sp, #0
    21ba:	6078      	str	r0, [r7, #4]
  u8g2->clip_x0 = 0;
    21bc:	687b      	ldr	r3, [r7, #4]
    21be:	2250      	movs	r2, #80	; 0x50
    21c0:	2100      	movs	r1, #0
    21c2:	5299      	strh	r1, [r3, r2]
  u8g2->clip_y0 = 0;
    21c4:	687b      	ldr	r3, [r7, #4]
    21c6:	2254      	movs	r2, #84	; 0x54
    21c8:	2100      	movs	r1, #0
    21ca:	5299      	strh	r1, [r3, r2]
  u8g2->clip_x1 = (u8g2_uint_t)~(u8g2_uint_t)0;
    21cc:	687b      	ldr	r3, [r7, #4]
    21ce:	2252      	movs	r2, #82	; 0x52
    21d0:	2101      	movs	r1, #1
    21d2:	4249      	negs	r1, r1
    21d4:	5299      	strh	r1, [r3, r2]
  u8g2->clip_y1 = (u8g2_uint_t)~(u8g2_uint_t)0;
    21d6:	687b      	ldr	r3, [r7, #4]
    21d8:	2256      	movs	r2, #86	; 0x56
    21da:	2101      	movs	r1, #1
    21dc:	4249      	negs	r1, r1
    21de:	5299      	strh	r1, [r3, r2]
  
  u8g2->cb->update_page_win(u8g2);
    21e0:	687b      	ldr	r3, [r7, #4]
    21e2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    21e4:	685b      	ldr	r3, [r3, #4]
    21e6:	687a      	ldr	r2, [r7, #4]
    21e8:	0010      	movs	r0, r2
    21ea:	4798      	blx	r3
}
    21ec:	46c0      	nop			; (mov r8, r8)
    21ee:	46bd      	mov	sp, r7
    21f0:	b002      	add	sp, #8
    21f2:	bd80      	pop	{r7, pc}

000021f4 <u8g2_SetupBuffer>:
/*
  This procedure is called after setting up the display (u8x8 structure).
  --> This is the central init procedure for u8g2 object
*/
void u8g2_SetupBuffer(u8g2_t *u8g2, uint8_t *buf, uint8_t tile_buf_height, u8g2_draw_ll_hvline_cb ll_hvline_cb, const u8g2_cb_t *u8g2_cb)
{
    21f4:	b580      	push	{r7, lr}
    21f6:	b084      	sub	sp, #16
    21f8:	af00      	add	r7, sp, #0
    21fa:	60f8      	str	r0, [r7, #12]
    21fc:	60b9      	str	r1, [r7, #8]
    21fe:	603b      	str	r3, [r7, #0]
    2200:	1dfb      	adds	r3, r7, #7
    2202:	701a      	strb	r2, [r3, #0]
  u8g2->font = NULL;
    2204:	68fb      	ldr	r3, [r7, #12]
    2206:	2200      	movs	r2, #0
    2208:	659a      	str	r2, [r3, #88]	; 0x58
  //u8g2->kerning = NULL;
  //u8g2->get_kerning_cb = u8g2_GetNullKerning;
  
  //u8g2->ll_hvline = u8g2_ll_hvline_vertical_top_lsb;
  u8g2->ll_hvline = ll_hvline_cb;
    220a:	68fb      	ldr	r3, [r7, #12]
    220c:	683a      	ldr	r2, [r7, #0]
    220e:	62da      	str	r2, [r3, #44]	; 0x2c
  
  u8g2->tile_buf_ptr = buf;
    2210:	68fb      	ldr	r3, [r7, #12]
    2212:	68ba      	ldr	r2, [r7, #8]
    2214:	635a      	str	r2, [r3, #52]	; 0x34
  u8g2->tile_buf_height = tile_buf_height;
    2216:	68fb      	ldr	r3, [r7, #12]
    2218:	1dfa      	adds	r2, r7, #7
    221a:	2138      	movs	r1, #56	; 0x38
    221c:	7812      	ldrb	r2, [r2, #0]
    221e:	545a      	strb	r2, [r3, r1]
  
  u8g2->tile_curr_row = 0;
    2220:	68fb      	ldr	r3, [r7, #12]
    2222:	2239      	movs	r2, #57	; 0x39
    2224:	2100      	movs	r1, #0
    2226:	5499      	strb	r1, [r3, r2]
  
  u8g2->font_decode.is_transparent = 0; /* issue 443 */
    2228:	68fb      	ldr	r3, [r7, #12]
    222a:	226d      	movs	r2, #109	; 0x6d
    222c:	2100      	movs	r1, #0
    222e:	5499      	strb	r1, [r3, r2]
  u8g2->bitmap_transparency = 0;
    2230:	68fb      	ldr	r3, [r7, #12]
    2232:	2291      	movs	r2, #145	; 0x91
    2234:	2100      	movs	r1, #0
    2236:	5499      	strb	r1, [r3, r2]
  
  u8g2->font_height_mode = 0; /* issue 2046 */
    2238:	68fb      	ldr	r3, [r7, #12]
    223a:	228d      	movs	r2, #141	; 0x8d
    223c:	2100      	movs	r1, #0
    223e:	5499      	strb	r1, [r3, r2]
  u8g2->draw_color = 1;
    2240:	68fb      	ldr	r3, [r7, #12]
    2242:	2292      	movs	r2, #146	; 0x92
    2244:	2101      	movs	r1, #1
    2246:	5499      	strb	r1, [r3, r2]
  u8g2->is_auto_page_clear = 1;
    2248:	68fb      	ldr	r3, [r7, #12]
    224a:	2293      	movs	r2, #147	; 0x93
    224c:	2101      	movs	r1, #1
    224e:	5499      	strb	r1, [r3, r2]
  
  u8g2->cb = u8g2_cb;
    2250:	68fb      	ldr	r3, [r7, #12]
    2252:	69ba      	ldr	r2, [r7, #24]
    2254:	631a      	str	r2, [r3, #48]	; 0x30
  u8g2->cb->update_dimension(u8g2);
    2256:	68fb      	ldr	r3, [r7, #12]
    2258:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    225a:	681b      	ldr	r3, [r3, #0]
    225c:	68fa      	ldr	r2, [r7, #12]
    225e:	0010      	movs	r0, r2
    2260:	4798      	blx	r3
#ifdef U8G2_WITH_CLIP_WINDOW_SUPPORT
  u8g2_SetMaxClipWindow(u8g2);		/* assign a clip window and call the update() procedure */
    2262:	68fb      	ldr	r3, [r7, #12]
    2264:	0018      	movs	r0, r3
    2266:	f7ff ffa5 	bl	21b4 <u8g2_SetMaxClipWindow>
#else
  u8g2->cb->update_page_win(u8g2);
#endif

  u8g2_SetFontPosBaseline(u8g2);  /* issue 195 */
    226a:	68fb      	ldr	r3, [r7, #12]
    226c:	0018      	movs	r0, r3
    226e:	f7ff fadf 	bl	1830 <u8g2_SetFontPosBaseline>
  
#ifdef U8G2_WITH_FONT_ROTATION  
  u8g2->font_decode.dir = 0;
    2272:	68fb      	ldr	r3, [r7, #12]
    2274:	2270      	movs	r2, #112	; 0x70
    2276:	2100      	movs	r1, #0
    2278:	5499      	strb	r1, [r3, r2]
#endif
}
    227a:	46c0      	nop			; (mov r8, r8)
    227c:	46bd      	mov	sp, r7
    227e:	b004      	add	sp, #16
    2280:	bd80      	pop	{r7, pc}

00002282 <u8g2_update_dimension_common>:
    u8g2_uint_t buf_y0;
    u8g2_uint_t buf_y1; 	
*/

static void u8g2_update_dimension_common(u8g2_t *u8g2)
{
    2282:	b580      	push	{r7, lr}
    2284:	b084      	sub	sp, #16
    2286:	af00      	add	r7, sp, #0
    2288:	6078      	str	r0, [r7, #4]
  const u8x8_display_info_t *display_info = u8g2_GetU8x8(u8g2)->display_info;
    228a:	687b      	ldr	r3, [r7, #4]
    228c:	681b      	ldr	r3, [r3, #0]
    228e:	60bb      	str	r3, [r7, #8]
  u8g2_uint_t t;
  
  t = u8g2->tile_buf_height;
    2290:	687b      	ldr	r3, [r7, #4]
    2292:	2238      	movs	r2, #56	; 0x38
    2294:	5c9a      	ldrb	r2, [r3, r2]
    2296:	230e      	movs	r3, #14
    2298:	18fb      	adds	r3, r7, r3
    229a:	801a      	strh	r2, [r3, #0]
  t *= 8;
    229c:	230e      	movs	r3, #14
    229e:	18fb      	adds	r3, r7, r3
    22a0:	220e      	movs	r2, #14
    22a2:	18ba      	adds	r2, r7, r2
    22a4:	8812      	ldrh	r2, [r2, #0]
    22a6:	00d2      	lsls	r2, r2, #3
    22a8:	801a      	strh	r2, [r3, #0]
  u8g2->pixel_buf_height = t;
    22aa:	687b      	ldr	r3, [r7, #4]
    22ac:	220e      	movs	r2, #14
    22ae:	18ba      	adds	r2, r7, r2
    22b0:	8812      	ldrh	r2, [r2, #0]
    22b2:	879a      	strh	r2, [r3, #60]	; 0x3c
  
  t = display_info->tile_width;
    22b4:	68bb      	ldr	r3, [r7, #8]
    22b6:	7c1a      	ldrb	r2, [r3, #16]
    22b8:	230e      	movs	r3, #14
    22ba:	18fb      	adds	r3, r7, r3
    22bc:	801a      	strh	r2, [r3, #0]
#ifndef U8G2_16BIT
  if ( t >= 32 )
    t = 31;
#endif
  t *= 8;
    22be:	230e      	movs	r3, #14
    22c0:	18fb      	adds	r3, r7, r3
    22c2:	220e      	movs	r2, #14
    22c4:	18ba      	adds	r2, r7, r2
    22c6:	8812      	ldrh	r2, [r2, #0]
    22c8:	00d2      	lsls	r2, r2, #3
    22ca:	801a      	strh	r2, [r3, #0]
  u8g2->pixel_buf_width = t;
    22cc:	687b      	ldr	r3, [r7, #4]
    22ce:	220e      	movs	r2, #14
    22d0:	18ba      	adds	r2, r7, r2
    22d2:	8812      	ldrh	r2, [r2, #0]
    22d4:	875a      	strh	r2, [r3, #58]	; 0x3a
  
  t = u8g2->tile_curr_row;
    22d6:	687b      	ldr	r3, [r7, #4]
    22d8:	2239      	movs	r2, #57	; 0x39
    22da:	5c9a      	ldrb	r2, [r3, r2]
    22dc:	230e      	movs	r3, #14
    22de:	18fb      	adds	r3, r7, r3
    22e0:	801a      	strh	r2, [r3, #0]
  t *= 8;
    22e2:	230e      	movs	r3, #14
    22e4:	18fb      	adds	r3, r7, r3
    22e6:	220e      	movs	r2, #14
    22e8:	18ba      	adds	r2, r7, r2
    22ea:	8812      	ldrh	r2, [r2, #0]
    22ec:	00d2      	lsls	r2, r2, #3
    22ee:	801a      	strh	r2, [r3, #0]
  u8g2->pixel_curr_row = t;
    22f0:	687b      	ldr	r3, [r7, #4]
    22f2:	220e      	movs	r2, #14
    22f4:	18ba      	adds	r2, r7, r2
    22f6:	8812      	ldrh	r2, [r2, #0]
    22f8:	87da      	strh	r2, [r3, #62]	; 0x3e
  
  t = u8g2->tile_buf_height;
    22fa:	687b      	ldr	r3, [r7, #4]
    22fc:	2238      	movs	r2, #56	; 0x38
    22fe:	5c9a      	ldrb	r2, [r3, r2]
    2300:	230e      	movs	r3, #14
    2302:	18fb      	adds	r3, r7, r3
    2304:	801a      	strh	r2, [r3, #0]
  /* handle the case, where the buffer is larger than the (remaining) part of the display */
  if ( t + u8g2->tile_curr_row > display_info->tile_height )
    2306:	230e      	movs	r3, #14
    2308:	18fb      	adds	r3, r7, r3
    230a:	881b      	ldrh	r3, [r3, #0]
    230c:	687a      	ldr	r2, [r7, #4]
    230e:	2139      	movs	r1, #57	; 0x39
    2310:	5c52      	ldrb	r2, [r2, r1]
    2312:	189b      	adds	r3, r3, r2
    2314:	68ba      	ldr	r2, [r7, #8]
    2316:	7c52      	ldrb	r2, [r2, #17]
    2318:	4293      	cmp	r3, r2
    231a:	dd0a      	ble.n	2332 <u8g2_update_dimension_common+0xb0>
    t = display_info->tile_height - u8g2->tile_curr_row;
    231c:	68bb      	ldr	r3, [r7, #8]
    231e:	7c5b      	ldrb	r3, [r3, #17]
    2320:	b299      	uxth	r1, r3
    2322:	687b      	ldr	r3, [r7, #4]
    2324:	2239      	movs	r2, #57	; 0x39
    2326:	5c9b      	ldrb	r3, [r3, r2]
    2328:	b29a      	uxth	r2, r3
    232a:	230e      	movs	r3, #14
    232c:	18fb      	adds	r3, r7, r3
    232e:	1a8a      	subs	r2, r1, r2
    2330:	801a      	strh	r2, [r3, #0]
  t *= 8;
    2332:	230e      	movs	r3, #14
    2334:	18fb      	adds	r3, r7, r3
    2336:	220e      	movs	r2, #14
    2338:	18ba      	adds	r2, r7, r2
    233a:	8812      	ldrh	r2, [r2, #0]
    233c:	00d2      	lsls	r2, r2, #3
    233e:	801a      	strh	r2, [r3, #0]
  
  u8g2->buf_y0 = u8g2->pixel_curr_row;   
    2340:	687b      	ldr	r3, [r7, #4]
    2342:	8fd9      	ldrh	r1, [r3, #62]	; 0x3e
    2344:	687b      	ldr	r3, [r7, #4]
    2346:	2240      	movs	r2, #64	; 0x40
    2348:	5299      	strh	r1, [r3, r2]
  u8g2->buf_y1 = u8g2->buf_y0;
    234a:	687b      	ldr	r3, [r7, #4]
    234c:	2240      	movs	r2, #64	; 0x40
    234e:	5a99      	ldrh	r1, [r3, r2]
    2350:	687b      	ldr	r3, [r7, #4]
    2352:	2242      	movs	r2, #66	; 0x42
    2354:	5299      	strh	r1, [r3, r2]
  u8g2->buf_y1 += t;
    2356:	687b      	ldr	r3, [r7, #4]
    2358:	2242      	movs	r2, #66	; 0x42
    235a:	5a9a      	ldrh	r2, [r3, r2]
    235c:	230e      	movs	r3, #14
    235e:	18fb      	adds	r3, r7, r3
    2360:	881b      	ldrh	r3, [r3, #0]
    2362:	18d3      	adds	r3, r2, r3
    2364:	b299      	uxth	r1, r3
    2366:	687b      	ldr	r3, [r7, #4]
    2368:	2242      	movs	r2, #66	; 0x42
    236a:	5299      	strh	r1, [r3, r2]

  
#ifdef U8G2_16BIT
  u8g2->width = display_info->pixel_width;
    236c:	68bb      	ldr	r3, [r7, #8]
    236e:	8a99      	ldrh	r1, [r3, #20]
    2370:	687b      	ldr	r3, [r7, #4]
    2372:	2244      	movs	r2, #68	; 0x44
    2374:	5299      	strh	r1, [r3, r2]
  u8g2->height = display_info->pixel_height;
    2376:	68bb      	ldr	r3, [r7, #8]
    2378:	8ad9      	ldrh	r1, [r3, #22]
    237a:	687b      	ldr	r3, [r7, #4]
    237c:	2246      	movs	r2, #70	; 0x46
    237e:	5299      	strh	r1, [r3, r2]
  if ( display_info->pixel_width <= 240 )
    u8g2->width = display_info->pixel_width;
  u8g2->height = display_info->pixel_height;
#endif

}
    2380:	46c0      	nop			; (mov r8, r8)
    2382:	46bd      	mov	sp, r7
    2384:	b004      	add	sp, #16
    2386:	bd80      	pop	{r7, pc}

00002388 <u8g2_apply_clip_window>:
/*==========================================================*/
/* apply clip window */

#ifdef U8G2_WITH_CLIP_WINDOW_SUPPORT
static void u8g2_apply_clip_window(u8g2_t *u8g2)
{
    2388:	b5b0      	push	{r4, r5, r7, lr}
    238a:	b084      	sub	sp, #16
    238c:	af02      	add	r7, sp, #8
    238e:	6078      	str	r0, [r7, #4]
  /* check aganst the current user_??? window */
  if ( u8g2_IsIntersection(u8g2, u8g2->clip_x0, u8g2->clip_y0, u8g2->clip_x1, u8g2->clip_y1) == 0 ) 
    2390:	687b      	ldr	r3, [r7, #4]
    2392:	2250      	movs	r2, #80	; 0x50
    2394:	5a99      	ldrh	r1, [r3, r2]
    2396:	687b      	ldr	r3, [r7, #4]
    2398:	2254      	movs	r2, #84	; 0x54
    239a:	5a9c      	ldrh	r4, [r3, r2]
    239c:	687b      	ldr	r3, [r7, #4]
    239e:	2252      	movs	r2, #82	; 0x52
    23a0:	5a9d      	ldrh	r5, [r3, r2]
    23a2:	687b      	ldr	r3, [r7, #4]
    23a4:	2256      	movs	r2, #86	; 0x56
    23a6:	5a9b      	ldrh	r3, [r3, r2]
    23a8:	6878      	ldr	r0, [r7, #4]
    23aa:	9300      	str	r3, [sp, #0]
    23ac:	002b      	movs	r3, r5
    23ae:	0022      	movs	r2, r4
    23b0:	f7ff fc99 	bl	1ce6 <u8g2_IsIntersection>
    23b4:	1e03      	subs	r3, r0, #0
    23b6:	d104      	bne.n	23c2 <u8g2_apply_clip_window+0x3a>
  {
    u8g2->is_page_clip_window_intersection = 0;
    23b8:	687b      	ldr	r3, [r7, #4]
    23ba:	228c      	movs	r2, #140	; 0x8c
    23bc:	2100      	movs	r1, #0
    23be:	5499      	strb	r1, [r3, r2]
    if ( u8g2->user_y0 < u8g2->clip_y0 )
      u8g2->user_y0 = u8g2->clip_y0;
    if ( u8g2->user_y1 > u8g2->clip_y1 )
      u8g2->user_y1 = u8g2->clip_y1;
  }
}
    23c0:	e03b      	b.n	243a <u8g2_apply_clip_window+0xb2>
    u8g2->is_page_clip_window_intersection = 1;
    23c2:	687b      	ldr	r3, [r7, #4]
    23c4:	228c      	movs	r2, #140	; 0x8c
    23c6:	2101      	movs	r1, #1
    23c8:	5499      	strb	r1, [r3, r2]
    if ( u8g2->user_x0 < u8g2->clip_x0 )
    23ca:	687b      	ldr	r3, [r7, #4]
    23cc:	2248      	movs	r2, #72	; 0x48
    23ce:	5a9a      	ldrh	r2, [r3, r2]
    23d0:	687b      	ldr	r3, [r7, #4]
    23d2:	2150      	movs	r1, #80	; 0x50
    23d4:	5a5b      	ldrh	r3, [r3, r1]
    23d6:	429a      	cmp	r2, r3
    23d8:	d205      	bcs.n	23e6 <u8g2_apply_clip_window+0x5e>
      u8g2->user_x0 = u8g2->clip_x0;
    23da:	687b      	ldr	r3, [r7, #4]
    23dc:	2250      	movs	r2, #80	; 0x50
    23de:	5a99      	ldrh	r1, [r3, r2]
    23e0:	687b      	ldr	r3, [r7, #4]
    23e2:	2248      	movs	r2, #72	; 0x48
    23e4:	5299      	strh	r1, [r3, r2]
    if ( u8g2->user_x1 > u8g2->clip_x1 )
    23e6:	687b      	ldr	r3, [r7, #4]
    23e8:	224a      	movs	r2, #74	; 0x4a
    23ea:	5a9a      	ldrh	r2, [r3, r2]
    23ec:	687b      	ldr	r3, [r7, #4]
    23ee:	2152      	movs	r1, #82	; 0x52
    23f0:	5a5b      	ldrh	r3, [r3, r1]
    23f2:	429a      	cmp	r2, r3
    23f4:	d905      	bls.n	2402 <u8g2_apply_clip_window+0x7a>
      u8g2->user_x1 = u8g2->clip_x1;
    23f6:	687b      	ldr	r3, [r7, #4]
    23f8:	2252      	movs	r2, #82	; 0x52
    23fa:	5a99      	ldrh	r1, [r3, r2]
    23fc:	687b      	ldr	r3, [r7, #4]
    23fe:	224a      	movs	r2, #74	; 0x4a
    2400:	5299      	strh	r1, [r3, r2]
    if ( u8g2->user_y0 < u8g2->clip_y0 )
    2402:	687b      	ldr	r3, [r7, #4]
    2404:	224c      	movs	r2, #76	; 0x4c
    2406:	5a9a      	ldrh	r2, [r3, r2]
    2408:	687b      	ldr	r3, [r7, #4]
    240a:	2154      	movs	r1, #84	; 0x54
    240c:	5a5b      	ldrh	r3, [r3, r1]
    240e:	429a      	cmp	r2, r3
    2410:	d205      	bcs.n	241e <u8g2_apply_clip_window+0x96>
      u8g2->user_y0 = u8g2->clip_y0;
    2412:	687b      	ldr	r3, [r7, #4]
    2414:	2254      	movs	r2, #84	; 0x54
    2416:	5a99      	ldrh	r1, [r3, r2]
    2418:	687b      	ldr	r3, [r7, #4]
    241a:	224c      	movs	r2, #76	; 0x4c
    241c:	5299      	strh	r1, [r3, r2]
    if ( u8g2->user_y1 > u8g2->clip_y1 )
    241e:	687b      	ldr	r3, [r7, #4]
    2420:	224e      	movs	r2, #78	; 0x4e
    2422:	5a9a      	ldrh	r2, [r3, r2]
    2424:	687b      	ldr	r3, [r7, #4]
    2426:	2156      	movs	r1, #86	; 0x56
    2428:	5a5b      	ldrh	r3, [r3, r1]
    242a:	429a      	cmp	r2, r3
    242c:	d905      	bls.n	243a <u8g2_apply_clip_window+0xb2>
      u8g2->user_y1 = u8g2->clip_y1;
    242e:	687b      	ldr	r3, [r7, #4]
    2430:	2256      	movs	r2, #86	; 0x56
    2432:	5a99      	ldrh	r1, [r3, r2]
    2434:	687b      	ldr	r3, [r7, #4]
    2436:	224e      	movs	r2, #78	; 0x4e
    2438:	5299      	strh	r1, [r3, r2]
}
    243a:	46c0      	nop			; (mov r8, r8)
    243c:	46bd      	mov	sp, r7
    243e:	b002      	add	sp, #8
    2440:	bdb0      	pop	{r4, r5, r7, pc}

00002442 <u8g2_update_dimension_r0>:

/*==========================================================*/


void u8g2_update_dimension_r0(u8g2_t *u8g2)
{
    2442:	b580      	push	{r7, lr}
    2444:	b082      	sub	sp, #8
    2446:	af00      	add	r7, sp, #0
    2448:	6078      	str	r0, [r7, #4]
  u8g2_update_dimension_common(u8g2);  
    244a:	687b      	ldr	r3, [r7, #4]
    244c:	0018      	movs	r0, r3
    244e:	f7ff ff18 	bl	2282 <u8g2_update_dimension_common>
}
    2452:	46c0      	nop			; (mov r8, r8)
    2454:	46bd      	mov	sp, r7
    2456:	b002      	add	sp, #8
    2458:	bd80      	pop	{r7, pc}

0000245a <u8g2_update_page_win_r0>:

void u8g2_update_page_win_r0(u8g2_t *u8g2)
{
    245a:	b580      	push	{r7, lr}
    245c:	b082      	sub	sp, #8
    245e:	af00      	add	r7, sp, #0
    2460:	6078      	str	r0, [r7, #4]
  u8g2->user_x0 = 0;
    2462:	687b      	ldr	r3, [r7, #4]
    2464:	2248      	movs	r2, #72	; 0x48
    2466:	2100      	movs	r1, #0
    2468:	5299      	strh	r1, [r3, r2]
  u8g2->user_x1 = u8g2->width;			/* pixel_buf_width replaced with width */
    246a:	687b      	ldr	r3, [r7, #4]
    246c:	2244      	movs	r2, #68	; 0x44
    246e:	5a99      	ldrh	r1, [r3, r2]
    2470:	687b      	ldr	r3, [r7, #4]
    2472:	224a      	movs	r2, #74	; 0x4a
    2474:	5299      	strh	r1, [r3, r2]
  
  u8g2->user_y0 = u8g2->buf_y0;
    2476:	687b      	ldr	r3, [r7, #4]
    2478:	2240      	movs	r2, #64	; 0x40
    247a:	5a99      	ldrh	r1, [r3, r2]
    247c:	687b      	ldr	r3, [r7, #4]
    247e:	224c      	movs	r2, #76	; 0x4c
    2480:	5299      	strh	r1, [r3, r2]
  u8g2->user_y1 = u8g2->buf_y1;
    2482:	687b      	ldr	r3, [r7, #4]
    2484:	2242      	movs	r2, #66	; 0x42
    2486:	5a99      	ldrh	r1, [r3, r2]
    2488:	687b      	ldr	r3, [r7, #4]
    248a:	224e      	movs	r2, #78	; 0x4e
    248c:	5299      	strh	r1, [r3, r2]
  
#ifdef U8G2_WITH_CLIP_WINDOW_SUPPORT
  u8g2_apply_clip_window(u8g2);
    248e:	687b      	ldr	r3, [r7, #4]
    2490:	0018      	movs	r0, r3
    2492:	f7ff ff79 	bl	2388 <u8g2_apply_clip_window>
#endif /* U8G2_WITH_CLIP_WINDOW_SUPPORT */
}
    2496:	46c0      	nop			; (mov r8, r8)
    2498:	46bd      	mov	sp, r7
    249a:	b002      	add	sp, #8
    249c:	bd80      	pop	{r7, pc}

0000249e <u8g2_draw_l90_r0>:
/*============================================*/
extern void u8g2_draw_hv_line_2dir(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t len, uint8_t dir);


void u8g2_draw_l90_r0(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t len, uint8_t dir)
{
    249e:	b590      	push	{r4, r7, lr}
    24a0:	b087      	sub	sp, #28
    24a2:	af02      	add	r7, sp, #8
    24a4:	60f8      	str	r0, [r7, #12]
    24a6:	000c      	movs	r4, r1
    24a8:	0010      	movs	r0, r2
    24aa:	0019      	movs	r1, r3
    24ac:	230a      	movs	r3, #10
    24ae:	18fb      	adds	r3, r7, r3
    24b0:	1c22      	adds	r2, r4, #0
    24b2:	801a      	strh	r2, [r3, #0]
    24b4:	2308      	movs	r3, #8
    24b6:	18fb      	adds	r3, r7, r3
    24b8:	1c02      	adds	r2, r0, #0
    24ba:	801a      	strh	r2, [r3, #0]
    24bc:	1dbb      	adds	r3, r7, #6
    24be:	1c0a      	adds	r2, r1, #0
    24c0:	801a      	strh	r2, [r3, #0]
#ifdef __unix
  assert( dir <= 1 );
#endif
  u8g2_draw_hv_line_2dir(u8g2, x, y, len, dir);
    24c2:	1dbb      	adds	r3, r7, #6
    24c4:	881c      	ldrh	r4, [r3, #0]
    24c6:	2308      	movs	r3, #8
    24c8:	18fb      	adds	r3, r7, r3
    24ca:	881a      	ldrh	r2, [r3, #0]
    24cc:	230a      	movs	r3, #10
    24ce:	18fb      	adds	r3, r7, r3
    24d0:	8819      	ldrh	r1, [r3, #0]
    24d2:	68f8      	ldr	r0, [r7, #12]
    24d4:	2320      	movs	r3, #32
    24d6:	18fb      	adds	r3, r7, r3
    24d8:	781b      	ldrb	r3, [r3, #0]
    24da:	9300      	str	r3, [sp, #0]
    24dc:	0023      	movs	r3, r4
    24de:	f7ff fa54 	bl	198a <u8g2_draw_hv_line_2dir>
}
    24e2:	46c0      	nop			; (mov r8, r8)
    24e4:	46bd      	mov	sp, r7
    24e6:	b005      	add	sp, #20
    24e8:	bd90      	pop	{r4, r7, pc}

000024ea <u8x8_utf8_init>:

*/

/* reset the internal state machine */
void u8x8_utf8_init(u8x8_t *u8x8)
{
    24ea:	b580      	push	{r7, lr}
    24ec:	b082      	sub	sp, #8
    24ee:	af00      	add	r7, sp, #0
    24f0:	6078      	str	r0, [r7, #4]
  u8x8->utf8_state = 0;	/* also reset during u8x8_SetupDefaults() */
    24f2:	687b      	ldr	r3, [r7, #4]
    24f4:	2226      	movs	r2, #38	; 0x26
    24f6:	2100      	movs	r1, #0
    24f8:	5499      	strb	r1, [r3, r2]
}
    24fa:	46c0      	nop			; (mov r8, r8)
    24fc:	46bd      	mov	sp, r7
    24fe:	b002      	add	sp, #8
    2500:	bd80      	pop	{r7, pc}
	...

00002504 <u8x8_ascii_next>:

uint16_t u8x8_ascii_next(U8X8_UNUSED u8x8_t *u8x8, uint8_t b)
{
    2504:	b580      	push	{r7, lr}
    2506:	b082      	sub	sp, #8
    2508:	af00      	add	r7, sp, #0
    250a:	6078      	str	r0, [r7, #4]
    250c:	000a      	movs	r2, r1
    250e:	1cfb      	adds	r3, r7, #3
    2510:	701a      	strb	r2, [r3, #0]
  if ( b == 0 || b == '\n' ) /* '\n' terminates the string to support the string list procedures */
    2512:	1cfb      	adds	r3, r7, #3
    2514:	781b      	ldrb	r3, [r3, #0]
    2516:	2b00      	cmp	r3, #0
    2518:	d003      	beq.n	2522 <u8x8_ascii_next+0x1e>
    251a:	1cfb      	adds	r3, r7, #3
    251c:	781b      	ldrb	r3, [r3, #0]
    251e:	2b0a      	cmp	r3, #10
    2520:	d101      	bne.n	2526 <u8x8_ascii_next+0x22>
    return 0x0ffff;	/* end of string detected*/
    2522:	4b04      	ldr	r3, [pc, #16]	; (2534 <u8x8_ascii_next+0x30>)
    2524:	e002      	b.n	252c <u8x8_ascii_next+0x28>
  return b;
    2526:	1cfb      	adds	r3, r7, #3
    2528:	781b      	ldrb	r3, [r3, #0]
    252a:	b29b      	uxth	r3, r3
}
    252c:	0018      	movs	r0, r3
    252e:	46bd      	mov	sp, r7
    2530:	b002      	add	sp, #8
    2532:	bd80      	pop	{r7, pc}
    2534:	0000ffff 	.word	0x0000ffff

00002538 <u8x8_byte_SendBytes>:
{
  return u8x8->byte_cb(u8x8, U8X8_MSG_BYTE_SET_DC, dc, NULL);
}

uint8_t u8x8_byte_SendBytes(u8x8_t *u8x8, uint8_t cnt, uint8_t *data)
{
    2538:	b590      	push	{r4, r7, lr}
    253a:	b085      	sub	sp, #20
    253c:	af00      	add	r7, sp, #0
    253e:	60f8      	str	r0, [r7, #12]
    2540:	607a      	str	r2, [r7, #4]
    2542:	230b      	movs	r3, #11
    2544:	18fb      	adds	r3, r7, r3
    2546:	1c0a      	adds	r2, r1, #0
    2548:	701a      	strb	r2, [r3, #0]
  return u8x8->byte_cb(u8x8, U8X8_MSG_BYTE_SEND, cnt, (void *)data);
    254a:	68fb      	ldr	r3, [r7, #12]
    254c:	691c      	ldr	r4, [r3, #16]
    254e:	6879      	ldr	r1, [r7, #4]
    2550:	230b      	movs	r3, #11
    2552:	18fb      	adds	r3, r7, r3
    2554:	781a      	ldrb	r2, [r3, #0]
    2556:	68f8      	ldr	r0, [r7, #12]
    2558:	000b      	movs	r3, r1
    255a:	2117      	movs	r1, #23
    255c:	47a0      	blx	r4
    255e:	0003      	movs	r3, r0
}
    2560:	0018      	movs	r0, r3
    2562:	46bd      	mov	sp, r7
    2564:	b005      	add	sp, #20
    2566:	bd90      	pop	{r4, r7, pc}

00002568 <u8x8_byte_SendByte>:

uint8_t u8x8_byte_SendByte(u8x8_t *u8x8, uint8_t byte)
{
    2568:	b580      	push	{r7, lr}
    256a:	b082      	sub	sp, #8
    256c:	af00      	add	r7, sp, #0
    256e:	6078      	str	r0, [r7, #4]
    2570:	000a      	movs	r2, r1
    2572:	1cfb      	adds	r3, r7, #3
    2574:	701a      	strb	r2, [r3, #0]
  return u8x8_byte_SendBytes(u8x8, 1, &byte);
    2576:	1cfa      	adds	r2, r7, #3
    2578:	687b      	ldr	r3, [r7, #4]
    257a:	2101      	movs	r1, #1
    257c:	0018      	movs	r0, r3
    257e:	f7ff ffdb 	bl	2538 <u8x8_byte_SendBytes>
    2582:	0003      	movs	r3, r0
}
    2584:	0018      	movs	r0, r3
    2586:	46bd      	mov	sp, r7
    2588:	b002      	add	sp, #8
    258a:	bd80      	pop	{r7, pc}

0000258c <u8x8_cad_SendCmd>:
*/

#include "u8x8.h"

uint8_t u8x8_cad_SendCmd(u8x8_t *u8x8, uint8_t cmd)
{
    258c:	b590      	push	{r4, r7, lr}
    258e:	b083      	sub	sp, #12
    2590:	af00      	add	r7, sp, #0
    2592:	6078      	str	r0, [r7, #4]
    2594:	000a      	movs	r2, r1
    2596:	1cfb      	adds	r3, r7, #3
    2598:	701a      	strb	r2, [r3, #0]
  return u8x8->cad_cb(u8x8, U8X8_MSG_CAD_SEND_CMD, cmd, NULL);
    259a:	687b      	ldr	r3, [r7, #4]
    259c:	68dc      	ldr	r4, [r3, #12]
    259e:	1cfb      	adds	r3, r7, #3
    25a0:	781a      	ldrb	r2, [r3, #0]
    25a2:	6878      	ldr	r0, [r7, #4]
    25a4:	2300      	movs	r3, #0
    25a6:	2115      	movs	r1, #21
    25a8:	47a0      	blx	r4
    25aa:	0003      	movs	r3, r0
}
    25ac:	0018      	movs	r0, r3
    25ae:	46bd      	mov	sp, r7
    25b0:	b003      	add	sp, #12
    25b2:	bd90      	pop	{r4, r7, pc}

000025b4 <u8x8_cad_SendArg>:

uint8_t u8x8_cad_SendArg(u8x8_t *u8x8, uint8_t arg)
{
    25b4:	b590      	push	{r4, r7, lr}
    25b6:	b083      	sub	sp, #12
    25b8:	af00      	add	r7, sp, #0
    25ba:	6078      	str	r0, [r7, #4]
    25bc:	000a      	movs	r2, r1
    25be:	1cfb      	adds	r3, r7, #3
    25c0:	701a      	strb	r2, [r3, #0]
  return u8x8->cad_cb(u8x8, U8X8_MSG_CAD_SEND_ARG, arg, NULL);
    25c2:	687b      	ldr	r3, [r7, #4]
    25c4:	68dc      	ldr	r4, [r3, #12]
    25c6:	1cfb      	adds	r3, r7, #3
    25c8:	781a      	ldrb	r2, [r3, #0]
    25ca:	6878      	ldr	r0, [r7, #4]
    25cc:	2300      	movs	r3, #0
    25ce:	2116      	movs	r1, #22
    25d0:	47a0      	blx	r4
    25d2:	0003      	movs	r3, r0
}
    25d4:	0018      	movs	r0, r3
    25d6:	46bd      	mov	sp, r7
    25d8:	b003      	add	sp, #12
    25da:	bd90      	pop	{r4, r7, pc}

000025dc <u8x8_cad_SendData>:
  }
  return 1;
}

uint8_t u8x8_cad_SendData(u8x8_t *u8x8, uint8_t cnt, uint8_t *data)
{
    25dc:	b590      	push	{r4, r7, lr}
    25de:	b085      	sub	sp, #20
    25e0:	af00      	add	r7, sp, #0
    25e2:	60f8      	str	r0, [r7, #12]
    25e4:	607a      	str	r2, [r7, #4]
    25e6:	230b      	movs	r3, #11
    25e8:	18fb      	adds	r3, r7, r3
    25ea:	1c0a      	adds	r2, r1, #0
    25ec:	701a      	strb	r2, [r3, #0]
  return u8x8->cad_cb(u8x8, U8X8_MSG_CAD_SEND_DATA, cnt, data);
    25ee:	68fb      	ldr	r3, [r7, #12]
    25f0:	68dc      	ldr	r4, [r3, #12]
    25f2:	6879      	ldr	r1, [r7, #4]
    25f4:	230b      	movs	r3, #11
    25f6:	18fb      	adds	r3, r7, r3
    25f8:	781a      	ldrb	r2, [r3, #0]
    25fa:	68f8      	ldr	r0, [r7, #12]
    25fc:	000b      	movs	r3, r1
    25fe:	2117      	movs	r1, #23
    2600:	47a0      	blx	r4
    2602:	0003      	movs	r3, r0
}
    2604:	0018      	movs	r0, r3
    2606:	46bd      	mov	sp, r7
    2608:	b005      	add	sp, #20
    260a:	bd90      	pop	{r4, r7, pc}

0000260c <u8x8_cad_StartTransfer>:

uint8_t u8x8_cad_StartTransfer(u8x8_t *u8x8)
{
    260c:	b590      	push	{r4, r7, lr}
    260e:	b083      	sub	sp, #12
    2610:	af00      	add	r7, sp, #0
    2612:	6078      	str	r0, [r7, #4]
  return u8x8->cad_cb(u8x8, U8X8_MSG_CAD_START_TRANSFER, 0, NULL);
    2614:	687b      	ldr	r3, [r7, #4]
    2616:	68dc      	ldr	r4, [r3, #12]
    2618:	6878      	ldr	r0, [r7, #4]
    261a:	2300      	movs	r3, #0
    261c:	2200      	movs	r2, #0
    261e:	2118      	movs	r1, #24
    2620:	47a0      	blx	r4
    2622:	0003      	movs	r3, r0
}
    2624:	0018      	movs	r0, r3
    2626:	46bd      	mov	sp, r7
    2628:	b003      	add	sp, #12
    262a:	bd90      	pop	{r4, r7, pc}

0000262c <u8x8_cad_EndTransfer>:

uint8_t u8x8_cad_EndTransfer(u8x8_t *u8x8)
{
    262c:	b590      	push	{r4, r7, lr}
    262e:	b083      	sub	sp, #12
    2630:	af00      	add	r7, sp, #0
    2632:	6078      	str	r0, [r7, #4]
  return u8x8->cad_cb(u8x8, U8X8_MSG_CAD_END_TRANSFER, 0, NULL);
    2634:	687b      	ldr	r3, [r7, #4]
    2636:	68dc      	ldr	r4, [r3, #12]
    2638:	6878      	ldr	r0, [r7, #4]
    263a:	2300      	movs	r3, #0
    263c:	2200      	movs	r2, #0
    263e:	2119      	movs	r1, #25
    2640:	47a0      	blx	r4
    2642:	0003      	movs	r3, r0
}
    2644:	0018      	movs	r0, r3
    2646:	46bd      	mov	sp, r7
    2648:	b003      	add	sp, #12
    264a:	bd90      	pop	{r4, r7, pc}

0000264c <u8x8_cad_SendSequence>:
  254 milli	delay by milliseconds
  255		end of sequence
*/

void u8x8_cad_SendSequence(u8x8_t *u8x8, uint8_t const *data)
{
    264c:	b590      	push	{r4, r7, lr}
    264e:	b085      	sub	sp, #20
    2650:	af00      	add	r7, sp, #0
    2652:	6078      	str	r0, [r7, #4]
    2654:	6039      	str	r1, [r7, #0]
  uint8_t cmd;
  uint8_t v;

  for(;;)
  {
    cmd = *data;
    2656:	230f      	movs	r3, #15
    2658:	18fb      	adds	r3, r7, r3
    265a:	683a      	ldr	r2, [r7, #0]
    265c:	7812      	ldrb	r2, [r2, #0]
    265e:	701a      	strb	r2, [r3, #0]
    data++;
    2660:	683b      	ldr	r3, [r7, #0]
    2662:	3301      	adds	r3, #1
    2664:	603b      	str	r3, [r7, #0]
    switch( cmd )
    2666:	230f      	movs	r3, #15
    2668:	18fb      	adds	r3, r7, r3
    266a:	781b      	ldrb	r3, [r3, #0]
    266c:	2b17      	cmp	r3, #23
    266e:	d01c      	beq.n	26aa <u8x8_cad_SendSequence+0x5e>
    2670:	dc02      	bgt.n	2678 <u8x8_cad_SendSequence+0x2c>
    2672:	2b15      	cmp	r3, #21
    2674:	db45      	blt.n	2702 <u8x8_cad_SendSequence+0xb6>
    2676:	e004      	b.n	2682 <u8x8_cad_SendSequence+0x36>
    2678:	2b19      	cmp	r3, #25
    267a:	dd26      	ble.n	26ca <u8x8_cad_SendSequence+0x7e>
    267c:	2bfe      	cmp	r3, #254	; 0xfe
    267e:	d02e      	beq.n	26de <u8x8_cad_SendSequence+0x92>
	  v = *data;
	  u8x8_gpio_Delay(u8x8, U8X8_MSG_DELAY_MILLI, v);	    
	  data++;
	  break;
      default:
	return;
    2680:	e03f      	b.n	2702 <u8x8_cad_SendSequence+0xb6>
	  v = *data;
    2682:	683b      	ldr	r3, [r7, #0]
    2684:	781a      	ldrb	r2, [r3, #0]
    2686:	230e      	movs	r3, #14
    2688:	18fb      	adds	r3, r7, r3
    268a:	701a      	strb	r2, [r3, #0]
	  u8x8->cad_cb(u8x8, cmd, v, NULL);
    268c:	687b      	ldr	r3, [r7, #4]
    268e:	68dc      	ldr	r4, [r3, #12]
    2690:	230e      	movs	r3, #14
    2692:	18fb      	adds	r3, r7, r3
    2694:	781a      	ldrb	r2, [r3, #0]
    2696:	230f      	movs	r3, #15
    2698:	18fb      	adds	r3, r7, r3
    269a:	7819      	ldrb	r1, [r3, #0]
    269c:	6878      	ldr	r0, [r7, #4]
    269e:	2300      	movs	r3, #0
    26a0:	47a0      	blx	r4
	  data++;
    26a2:	683b      	ldr	r3, [r7, #0]
    26a4:	3301      	adds	r3, #1
    26a6:	603b      	str	r3, [r7, #0]
	  break;
    26a8:	e02a      	b.n	2700 <u8x8_cad_SendSequence+0xb4>
	  v = *data;
    26aa:	683b      	ldr	r3, [r7, #0]
    26ac:	781a      	ldrb	r2, [r3, #0]
    26ae:	230e      	movs	r3, #14
    26b0:	18fb      	adds	r3, r7, r3
    26b2:	701a      	strb	r2, [r3, #0]
	  u8x8_cad_SendData(u8x8, 1, &v);
    26b4:	230e      	movs	r3, #14
    26b6:	18fa      	adds	r2, r7, r3
    26b8:	687b      	ldr	r3, [r7, #4]
    26ba:	2101      	movs	r1, #1
    26bc:	0018      	movs	r0, r3
    26be:	f7ff ff8d 	bl	25dc <u8x8_cad_SendData>
	  data++;
    26c2:	683b      	ldr	r3, [r7, #0]
    26c4:	3301      	adds	r3, #1
    26c6:	603b      	str	r3, [r7, #0]
	  break;
    26c8:	e01a      	b.n	2700 <u8x8_cad_SendSequence+0xb4>
	  u8x8->cad_cb(u8x8, cmd, 0, NULL);
    26ca:	687b      	ldr	r3, [r7, #4]
    26cc:	68dc      	ldr	r4, [r3, #12]
    26ce:	230f      	movs	r3, #15
    26d0:	18fb      	adds	r3, r7, r3
    26d2:	7819      	ldrb	r1, [r3, #0]
    26d4:	6878      	ldr	r0, [r7, #4]
    26d6:	2300      	movs	r3, #0
    26d8:	2200      	movs	r2, #0
    26da:	47a0      	blx	r4
	  break;
    26dc:	e010      	b.n	2700 <u8x8_cad_SendSequence+0xb4>
	  v = *data;
    26de:	683b      	ldr	r3, [r7, #0]
    26e0:	781a      	ldrb	r2, [r3, #0]
    26e2:	230e      	movs	r3, #14
    26e4:	18fb      	adds	r3, r7, r3
    26e6:	701a      	strb	r2, [r3, #0]
	  u8x8_gpio_Delay(u8x8, U8X8_MSG_DELAY_MILLI, v);	    
    26e8:	230e      	movs	r3, #14
    26ea:	18fb      	adds	r3, r7, r3
    26ec:	781a      	ldrb	r2, [r3, #0]
    26ee:	687b      	ldr	r3, [r7, #4]
    26f0:	2129      	movs	r1, #41	; 0x29
    26f2:	0018      	movs	r0, r3
    26f4:	f000 fb88 	bl	2e08 <u8x8_gpio_call>
	  data++;
    26f8:	683b      	ldr	r3, [r7, #0]
    26fa:	3301      	adds	r3, #1
    26fc:	603b      	str	r3, [r7, #0]
	  break;
    26fe:	46c0      	nop			; (mov r8, r8)
    cmd = *data;
    2700:	e7a9      	b.n	2656 <u8x8_cad_SendSequence+0xa>
	return;
    2702:	46c0      	nop			; (mov r8, r8)
    }
  }
}
    2704:	46bd      	mov	sp, r7
    2706:	b005      	add	sp, #20
    2708:	bd90      	pop	{r4, r7, pc}
	...

0000270c <u8x8_cad_empty>:


uint8_t u8x8_cad_empty(u8x8_t *u8x8, uint8_t msg, uint8_t arg_int, void *arg_ptr)
{
    270c:	b5b0      	push	{r4, r5, r7, lr}
    270e:	b084      	sub	sp, #16
    2710:	af00      	add	r7, sp, #0
    2712:	60f8      	str	r0, [r7, #12]
    2714:	0008      	movs	r0, r1
    2716:	0011      	movs	r1, r2
    2718:	607b      	str	r3, [r7, #4]
    271a:	230b      	movs	r3, #11
    271c:	18fb      	adds	r3, r7, r3
    271e:	1c02      	adds	r2, r0, #0
    2720:	701a      	strb	r2, [r3, #0]
    2722:	230a      	movs	r3, #10
    2724:	18fb      	adds	r3, r7, r3
    2726:	1c0a      	adds	r2, r1, #0
    2728:	701a      	strb	r2, [r3, #0]
  switch(msg)
    272a:	230b      	movs	r3, #11
    272c:	18fb      	adds	r3, r7, r3
    272e:	781b      	ldrb	r3, [r3, #0]
    2730:	3b14      	subs	r3, #20
    2732:	2b05      	cmp	r3, #5
    2734:	d824      	bhi.n	2780 <u8x8_cad_empty+0x74>
    2736:	009a      	lsls	r2, r3, #2
    2738:	4b15      	ldr	r3, [pc, #84]	; (2790 <u8x8_cad_empty+0x84>)
    273a:	18d3      	adds	r3, r2, r3
    273c:	681b      	ldr	r3, [r3, #0]
    273e:	469f      	mov	pc, r3
  {
    case U8X8_MSG_CAD_SEND_CMD:
      u8x8_byte_SendByte(u8x8, arg_int);
    2740:	230a      	movs	r3, #10
    2742:	18fb      	adds	r3, r7, r3
    2744:	781a      	ldrb	r2, [r3, #0]
    2746:	68fb      	ldr	r3, [r7, #12]
    2748:	0011      	movs	r1, r2
    274a:	0018      	movs	r0, r3
    274c:	f7ff ff0c 	bl	2568 <u8x8_byte_SendByte>
      break;
    2750:	e018      	b.n	2784 <u8x8_cad_empty+0x78>
    case U8X8_MSG_CAD_SEND_ARG:
      u8x8_byte_SendByte(u8x8, arg_int);
    2752:	230a      	movs	r3, #10
    2754:	18fb      	adds	r3, r7, r3
    2756:	781a      	ldrb	r2, [r3, #0]
    2758:	68fb      	ldr	r3, [r7, #12]
    275a:	0011      	movs	r1, r2
    275c:	0018      	movs	r0, r3
    275e:	f7ff ff03 	bl	2568 <u8x8_byte_SendByte>
      break;
    2762:	e00f      	b.n	2784 <u8x8_cad_empty+0x78>
    case U8X8_MSG_CAD_SEND_DATA:
    case U8X8_MSG_CAD_INIT:
    case U8X8_MSG_CAD_START_TRANSFER:
    case U8X8_MSG_CAD_END_TRANSFER:
      return u8x8->byte_cb(u8x8, msg, arg_int, arg_ptr);
    2764:	68fb      	ldr	r3, [r7, #12]
    2766:	691c      	ldr	r4, [r3, #16]
    2768:	687d      	ldr	r5, [r7, #4]
    276a:	230a      	movs	r3, #10
    276c:	18fb      	adds	r3, r7, r3
    276e:	781a      	ldrb	r2, [r3, #0]
    2770:	230b      	movs	r3, #11
    2772:	18fb      	adds	r3, r7, r3
    2774:	7819      	ldrb	r1, [r3, #0]
    2776:	68f8      	ldr	r0, [r7, #12]
    2778:	002b      	movs	r3, r5
    277a:	47a0      	blx	r4
    277c:	0003      	movs	r3, r0
    277e:	e002      	b.n	2786 <u8x8_cad_empty+0x7a>
    default:
      return 0;
    2780:	2300      	movs	r3, #0
    2782:	e000      	b.n	2786 <u8x8_cad_empty+0x7a>
  }
  return 1;
    2784:	2301      	movs	r3, #1
}
    2786:	0018      	movs	r0, r3
    2788:	46bd      	mov	sp, r7
    278a:	b004      	add	sp, #16
    278c:	bdb0      	pop	{r4, r5, r7, pc}
    278e:	46c0      	nop			; (mov r8, r8)
    2790:	00008e2c 	.word	0x00008e2c

00002794 <u8x8_d_helper_display_setup_memory>:
  this is a helper function for the U8X8_MSG_DISPLAY_SETUP_MEMORY function.
  It can be called within the display callback function to carry out the usual standard tasks.
  
*/
void u8x8_d_helper_display_setup_memory(u8x8_t *u8x8, const u8x8_display_info_t *display_info)
{
    2794:	b580      	push	{r7, lr}
    2796:	b082      	sub	sp, #8
    2798:	af00      	add	r7, sp, #0
    279a:	6078      	str	r0, [r7, #4]
    279c:	6039      	str	r1, [r7, #0]
      /* 1) set display info struct */
      u8x8->display_info = display_info;
    279e:	687b      	ldr	r3, [r7, #4]
    27a0:	683a      	ldr	r2, [r7, #0]
    27a2:	601a      	str	r2, [r3, #0]
      u8x8->x_offset = u8x8->display_info->default_x_offset;
    27a4:	687b      	ldr	r3, [r7, #4]
    27a6:	681b      	ldr	r3, [r3, #0]
    27a8:	7c99      	ldrb	r1, [r3, #18]
    27aa:	687b      	ldr	r3, [r7, #4]
    27ac:	2222      	movs	r2, #34	; 0x22
    27ae:	5499      	strb	r1, [r3, r2]
}
    27b0:	46c0      	nop			; (mov r8, r8)
    27b2:	46bd      	mov	sp, r7
    27b4:	b002      	add	sp, #8
    27b6:	bd80      	pop	{r7, pc}

000027b8 <u8x8_d_helper_display_init>:
  this is a helper function for the U8X8_MSG_DISPLAY_INIT function.
  It can be called within the display callback function to carry out the usual standard tasks.
  
*/
void u8x8_d_helper_display_init(u8x8_t *u8x8)
{
    27b8:	b590      	push	{r4, r7, lr}
    27ba:	b083      	sub	sp, #12
    27bc:	af00      	add	r7, sp, #0
    27be:	6078      	str	r0, [r7, #4]
      /* 2) apply port directions to the GPIO lines and apply default values for the IO lines*/
      u8x8_gpio_Init(u8x8);
    27c0:	687b      	ldr	r3, [r7, #4]
    27c2:	695c      	ldr	r4, [r3, #20]
    27c4:	6878      	ldr	r0, [r7, #4]
    27c6:	2300      	movs	r3, #0
    27c8:	2200      	movs	r2, #0
    27ca:	2128      	movs	r1, #40	; 0x28
    27cc:	47a0      	blx	r4
      u8x8_cad_Init(u8x8);              /* this will also call U8X8_MSG_BYTE_INIT, byte init will NOT call GPIO_INIT */
    27ce:	687b      	ldr	r3, [r7, #4]
    27d0:	68dc      	ldr	r4, [r3, #12]
    27d2:	6878      	ldr	r0, [r7, #4]
    27d4:	2300      	movs	r3, #0
    27d6:	2200      	movs	r2, #0
    27d8:	2114      	movs	r1, #20
    27da:	47a0      	blx	r4

      /* 3) do reset */
      u8x8_gpio_SetReset(u8x8, 1);
    27dc:	687b      	ldr	r3, [r7, #4]
    27de:	2201      	movs	r2, #1
    27e0:	214b      	movs	r1, #75	; 0x4b
    27e2:	0018      	movs	r0, r3
    27e4:	f000 fb10 	bl	2e08 <u8x8_gpio_call>
      u8x8_gpio_Delay(u8x8, U8X8_MSG_DELAY_MILLI, u8x8->display_info->reset_pulse_width_ms);
    27e8:	687b      	ldr	r3, [r7, #4]
    27ea:	681b      	ldr	r3, [r3, #0]
    27ec:	791a      	ldrb	r2, [r3, #4]
    27ee:	687b      	ldr	r3, [r7, #4]
    27f0:	2129      	movs	r1, #41	; 0x29
    27f2:	0018      	movs	r0, r3
    27f4:	f000 fb08 	bl	2e08 <u8x8_gpio_call>
      u8x8_gpio_SetReset(u8x8, 0);
    27f8:	687b      	ldr	r3, [r7, #4]
    27fa:	2200      	movs	r2, #0
    27fc:	214b      	movs	r1, #75	; 0x4b
    27fe:	0018      	movs	r0, r3
    2800:	f000 fb02 	bl	2e08 <u8x8_gpio_call>
      u8x8_gpio_Delay(u8x8, U8X8_MSG_DELAY_MILLI, u8x8->display_info->reset_pulse_width_ms);
    2804:	687b      	ldr	r3, [r7, #4]
    2806:	681b      	ldr	r3, [r3, #0]
    2808:	791a      	ldrb	r2, [r3, #4]
    280a:	687b      	ldr	r3, [r7, #4]
    280c:	2129      	movs	r1, #41	; 0x29
    280e:	0018      	movs	r0, r3
    2810:	f000 fafa 	bl	2e08 <u8x8_gpio_call>
      u8x8_gpio_SetReset(u8x8, 1);
    2814:	687b      	ldr	r3, [r7, #4]
    2816:	2201      	movs	r2, #1
    2818:	214b      	movs	r1, #75	; 0x4b
    281a:	0018      	movs	r0, r3
    281c:	f000 faf4 	bl	2e08 <u8x8_gpio_call>
      u8x8_gpio_Delay(u8x8, U8X8_MSG_DELAY_MILLI, u8x8->display_info->post_reset_wait_ms);
    2820:	687b      	ldr	r3, [r7, #4]
    2822:	681b      	ldr	r3, [r3, #0]
    2824:	795a      	ldrb	r2, [r3, #5]
    2826:	687b      	ldr	r3, [r7, #4]
    2828:	2129      	movs	r1, #41	; 0x29
    282a:	0018      	movs	r0, r3
    282c:	f000 faec 	bl	2e08 <u8x8_gpio_call>
}    
    2830:	46c0      	nop			; (mov r8, r8)
    2832:	46bd      	mov	sp, r7
    2834:	b003      	add	sp, #12
    2836:	bd90      	pop	{r4, r7, pc}

00002838 <u8x8_DrawTile>:

/*==========================================*/
/* official functions */

uint8_t u8x8_DrawTile(u8x8_t *u8x8, uint8_t x, uint8_t y, uint8_t cnt, uint8_t *tile_ptr)
{
    2838:	b590      	push	{r4, r7, lr}
    283a:	b085      	sub	sp, #20
    283c:	af00      	add	r7, sp, #0
    283e:	6078      	str	r0, [r7, #4]
    2840:	000c      	movs	r4, r1
    2842:	0010      	movs	r0, r2
    2844:	0019      	movs	r1, r3
    2846:	1cfb      	adds	r3, r7, #3
    2848:	1c22      	adds	r2, r4, #0
    284a:	701a      	strb	r2, [r3, #0]
    284c:	1cbb      	adds	r3, r7, #2
    284e:	1c02      	adds	r2, r0, #0
    2850:	701a      	strb	r2, [r3, #0]
    2852:	1c7b      	adds	r3, r7, #1
    2854:	1c0a      	adds	r2, r1, #0
    2856:	701a      	strb	r2, [r3, #0]
  u8x8_tile_t tile;
  tile.x_pos = x;
    2858:	2308      	movs	r3, #8
    285a:	18fb      	adds	r3, r7, r3
    285c:	1cfa      	adds	r2, r7, #3
    285e:	7812      	ldrb	r2, [r2, #0]
    2860:	715a      	strb	r2, [r3, #5]
  tile.y_pos = y;
    2862:	2308      	movs	r3, #8
    2864:	18fb      	adds	r3, r7, r3
    2866:	1cba      	adds	r2, r7, #2
    2868:	7812      	ldrb	r2, [r2, #0]
    286a:	719a      	strb	r2, [r3, #6]
  tile.cnt = cnt;
    286c:	2308      	movs	r3, #8
    286e:	18fb      	adds	r3, r7, r3
    2870:	1c7a      	adds	r2, r7, #1
    2872:	7812      	ldrb	r2, [r2, #0]
    2874:	711a      	strb	r2, [r3, #4]
  tile.tile_ptr = tile_ptr;
    2876:	2308      	movs	r3, #8
    2878:	18fb      	adds	r3, r7, r3
    287a:	6a3a      	ldr	r2, [r7, #32]
    287c:	601a      	str	r2, [r3, #0]
  return u8x8->display_cb(u8x8, U8X8_MSG_DISPLAY_DRAW_TILE, 1, (void *)&tile);
    287e:	687b      	ldr	r3, [r7, #4]
    2880:	689c      	ldr	r4, [r3, #8]
    2882:	2308      	movs	r3, #8
    2884:	18fb      	adds	r3, r7, r3
    2886:	6878      	ldr	r0, [r7, #4]
    2888:	2201      	movs	r2, #1
    288a:	210f      	movs	r1, #15
    288c:	47a0      	blx	r4
    288e:	0003      	movs	r3, r0
}
    2890:	0018      	movs	r0, r3
    2892:	46bd      	mov	sp, r7
    2894:	b005      	add	sp, #20
    2896:	bd90      	pop	{r4, r7, pc}

00002898 <u8x8_SetupMemory>:

/* should be implemented as macro */
void u8x8_SetupMemory(u8x8_t *u8x8)
{
    2898:	b590      	push	{r4, r7, lr}
    289a:	b083      	sub	sp, #12
    289c:	af00      	add	r7, sp, #0
    289e:	6078      	str	r0, [r7, #4]
  u8x8->display_cb(u8x8, U8X8_MSG_DISPLAY_SETUP_MEMORY, 0, NULL);  
    28a0:	687b      	ldr	r3, [r7, #4]
    28a2:	689c      	ldr	r4, [r3, #8]
    28a4:	6878      	ldr	r0, [r7, #4]
    28a6:	2300      	movs	r3, #0
    28a8:	2200      	movs	r2, #0
    28aa:	2109      	movs	r1, #9
    28ac:	47a0      	blx	r4
}
    28ae:	46c0      	nop			; (mov r8, r8)
    28b0:	46bd      	mov	sp, r7
    28b2:	b003      	add	sp, #12
    28b4:	bd90      	pop	{r4, r7, pc}

000028b6 <u8x8_InitDisplay>:
  In some cases it is not required to init the display (for example if the display is already running, but the controller comes out of deep sleep mode).
  Then InitDisplay can be skipped, but u8x8_InitInterface()  (== u8x8_gpio_Init() and u8x8_cad_Init()) need to be executed.

*/
void u8x8_InitDisplay(u8x8_t *u8x8)
{
    28b6:	b590      	push	{r4, r7, lr}
    28b8:	b083      	sub	sp, #12
    28ba:	af00      	add	r7, sp, #0
    28bc:	6078      	str	r0, [r7, #4]
  u8x8->display_cb(u8x8, U8X8_MSG_DISPLAY_INIT, 0, NULL);       /* this will call u8x8_d_helper_display_init() and send the init seqence to the display */
    28be:	687b      	ldr	r3, [r7, #4]
    28c0:	689c      	ldr	r4, [r3, #8]
    28c2:	6878      	ldr	r0, [r7, #4]
    28c4:	2300      	movs	r3, #0
    28c6:	2200      	movs	r2, #0
    28c8:	210a      	movs	r1, #10
    28ca:	47a0      	blx	r4
  /* u8x8->display_cb(u8x8, U8X8_MSG_DISPLAY_SET_FLIP_MODE, 0, NULL);  */ /* It would make sense to call flip mode 0 here after U8X8_MSG_DISPLAY_INIT */
}
    28cc:	46c0      	nop			; (mov r8, r8)
    28ce:	46bd      	mov	sp, r7
    28d0:	b003      	add	sp, #12
    28d2:	bd90      	pop	{r4, r7, pc}

000028d4 <u8x8_SetPowerSave>:

void u8x8_SetPowerSave(u8x8_t *u8x8, uint8_t is_enable)
{
    28d4:	b590      	push	{r4, r7, lr}
    28d6:	b083      	sub	sp, #12
    28d8:	af00      	add	r7, sp, #0
    28da:	6078      	str	r0, [r7, #4]
    28dc:	000a      	movs	r2, r1
    28de:	1cfb      	adds	r3, r7, #3
    28e0:	701a      	strb	r2, [r3, #0]
  u8x8->display_cb(u8x8, U8X8_MSG_DISPLAY_SET_POWER_SAVE, is_enable, NULL);  
    28e2:	687b      	ldr	r3, [r7, #4]
    28e4:	689c      	ldr	r4, [r3, #8]
    28e6:	1cfb      	adds	r3, r7, #3
    28e8:	781a      	ldrb	r2, [r3, #0]
    28ea:	6878      	ldr	r0, [r7, #4]
    28ec:	2300      	movs	r3, #0
    28ee:	210b      	movs	r1, #11
    28f0:	47a0      	blx	r4
}
    28f2:	46c0      	nop			; (mov r8, r8)
    28f4:	46bd      	mov	sp, r7
    28f6:	b003      	add	sp, #12
    28f8:	bd90      	pop	{r4, r7, pc}

000028fa <u8x8_SetContrast>:
{
  u8x8->display_cb(u8x8, U8X8_MSG_DISPLAY_SET_FLIP_MODE, mode, NULL);  
}

void u8x8_SetContrast(u8x8_t *u8x8, uint8_t value)
{
    28fa:	b590      	push	{r4, r7, lr}
    28fc:	b083      	sub	sp, #12
    28fe:	af00      	add	r7, sp, #0
    2900:	6078      	str	r0, [r7, #4]
    2902:	000a      	movs	r2, r1
    2904:	1cfb      	adds	r3, r7, #3
    2906:	701a      	strb	r2, [r3, #0]
  u8x8->display_cb(u8x8, U8X8_MSG_DISPLAY_SET_CONTRAST, value, NULL);  
    2908:	687b      	ldr	r3, [r7, #4]
    290a:	689c      	ldr	r4, [r3, #8]
    290c:	1cfb      	adds	r3, r7, #3
    290e:	781a      	ldrb	r2, [r3, #0]
    2910:	6878      	ldr	r0, [r7, #4]
    2912:	2300      	movs	r3, #0
    2914:	210e      	movs	r1, #14
    2916:	47a0      	blx	r4
}
    2918:	46c0      	nop			; (mov r8, r8)
    291a:	46bd      	mov	sp, r7
    291c:	b003      	add	sp, #12
    291e:	bd90      	pop	{r4, r7, pc}

00002920 <u8x8_RefreshDisplay>:

void u8x8_RefreshDisplay(u8x8_t *u8x8)
{
    2920:	b590      	push	{r4, r7, lr}
    2922:	b083      	sub	sp, #12
    2924:	af00      	add	r7, sp, #0
    2926:	6078      	str	r0, [r7, #4]
  u8x8->display_cb(u8x8, U8X8_MSG_DISPLAY_REFRESH, 0, NULL);  
    2928:	687b      	ldr	r3, [r7, #4]
    292a:	689c      	ldr	r4, [r3, #8]
    292c:	6878      	ldr	r0, [r7, #4]
    292e:	2300      	movs	r3, #0
    2930:	2200      	movs	r2, #0
    2932:	2110      	movs	r1, #16
    2934:	47a0      	blx	r4
}
    2936:	46c0      	nop			; (mov r8, r8)
    2938:	46bd      	mov	sp, r7
    293a:	b003      	add	sp, #12
    293c:	bd90      	pop	{r4, r7, pc}
	...

00002940 <u8x8_d_gp1287ai_common>:
    U8X8_END_TRANSFER(),

    U8X8_END() /* end of sequence */
};
uint8_t u8x8_d_gp1287ai_common(u8x8_t *u8x8, uint8_t msg, uint8_t arg_int, void *arg_ptr)
{
    2940:	b580      	push	{r7, lr}
    2942:	b088      	sub	sp, #32
    2944:	af00      	add	r7, sp, #0
    2946:	60f8      	str	r0, [r7, #12]
    2948:	0008      	movs	r0, r1
    294a:	0011      	movs	r1, r2
    294c:	607b      	str	r3, [r7, #4]
    294e:	230b      	movs	r3, #11
    2950:	18fb      	adds	r3, r7, r3
    2952:	1c02      	adds	r2, r0, #0
    2954:	701a      	strb	r2, [r3, #0]
    2956:	230a      	movs	r3, #10
    2958:	18fb      	adds	r3, r7, r3
    295a:	1c0a      	adds	r2, r1, #0
    295c:	701a      	strb	r2, [r3, #0]
    uint8_t *ptr;
    uint8_t x, y;
    uint16_t tx_cnt;
    uint8_t swapped_byte;
    switch (msg)
    295e:	230b      	movs	r3, #11
    2960:	18fb      	adds	r3, r7, r3
    2962:	781b      	ldrb	r3, [r3, #0]
    2964:	2b0e      	cmp	r3, #14
    2966:	d018      	beq.n	299a <u8x8_d_gp1287ai_common+0x5a>
    2968:	2b0f      	cmp	r3, #15
    296a:	d100      	bne.n	296e <u8x8_d_gp1287ai_common+0x2e>
    296c:	e0cf      	b.n	2b0e <u8x8_d_gp1287ai_common+0x1ce>
    296e:	2b0b      	cmp	r3, #11
    2970:	d000      	beq.n	2974 <u8x8_d_gp1287ai_common+0x34>
    2972:	e201      	b.n	2d78 <u8x8_d_gp1287ai_common+0x438>
    {
    case U8X8_MSG_DISPLAY_SET_POWER_SAVE:
        if (arg_int == 0)
    2974:	230a      	movs	r3, #10
    2976:	18fb      	adds	r3, r7, r3
    2978:	781b      	ldrb	r3, [r3, #0]
    297a:	2b00      	cmp	r3, #0
    297c:	d106      	bne.n	298c <u8x8_d_gp1287ai_common+0x4c>
            u8x8_cad_SendSequence(u8x8, u8x8_d_gp1287ai_wakeup_seq);
    297e:	4ac6      	ldr	r2, [pc, #792]	; (2c98 <u8x8_d_gp1287ai_common+0x358>)
    2980:	68fb      	ldr	r3, [r7, #12]
    2982:	0011      	movs	r1, r2
    2984:	0018      	movs	r0, r3
    2986:	f7ff fe61 	bl	264c <u8x8_cad_SendSequence>
        else
            u8x8_cad_SendSequence(u8x8, u8x8_d_gp1287ai_standby_seq);
        break;
    298a:	e1f7      	b.n	2d7c <u8x8_d_gp1287ai_common+0x43c>
            u8x8_cad_SendSequence(u8x8, u8x8_d_gp1287ai_standby_seq);
    298c:	4ac3      	ldr	r2, [pc, #780]	; (2c9c <u8x8_d_gp1287ai_common+0x35c>)
    298e:	68fb      	ldr	r3, [r7, #12]
    2990:	0011      	movs	r1, r2
    2992:	0018      	movs	r0, r3
    2994:	f7ff fe5a 	bl	264c <u8x8_cad_SendSequence>
        break;
    2998:	e1f0      	b.n	2d7c <u8x8_d_gp1287ai_common+0x43c>
#ifdef U8X8_WITH_SET_CONTRAST
    case U8X8_MSG_DISPLAY_SET_CONTRAST:
        u8x8_cad_StartTransfer(u8x8);
    299a:	68fb      	ldr	r3, [r7, #12]
    299c:	0018      	movs	r0, r3
    299e:	f7ff fe35 	bl	260c <u8x8_cad_StartTransfer>
        u8x8_cad_SendCmd(u8x8, SWAP8(0x0A0));
    29a2:	68fb      	ldr	r3, [r7, #12]
    29a4:	2105      	movs	r1, #5
    29a6:	0018      	movs	r0, r3
    29a8:	f7ff fdf0 	bl	258c <u8x8_cad_SendCmd>
        //u8x8_cad_SendArg(u8x8, SWAP8((arg_int * 4) >> 8));   /* Dimming level */
        //u8x8_cad_SendArg(u8x8, SWAP8((arg_int * 4) & 0xFF)); /* Dimming level */
		
		u8x8_cad_SendArg(u8x8, SWAP8((arg_int * 4) >> 8));   /* Dimming level */
    29ac:	230a      	movs	r3, #10
    29ae:	18fb      	adds	r3, r7, r3
    29b0:	781b      	ldrb	r3, [r3, #0]
    29b2:	009b      	lsls	r3, r3, #2
    29b4:	13db      	asrs	r3, r3, #15
    29b6:	b25b      	sxtb	r3, r3
    29b8:	2201      	movs	r2, #1
    29ba:	4013      	ands	r3, r2
    29bc:	b25a      	sxtb	r2, r3
    29be:	230a      	movs	r3, #10
    29c0:	18fb      	adds	r3, r7, r3
    29c2:	781b      	ldrb	r3, [r3, #0]
    29c4:	009b      	lsls	r3, r3, #2
    29c6:	135b      	asrs	r3, r3, #13
    29c8:	b25b      	sxtb	r3, r3
    29ca:	2102      	movs	r1, #2
    29cc:	400b      	ands	r3, r1
    29ce:	b25b      	sxtb	r3, r3
    29d0:	4313      	orrs	r3, r2
    29d2:	b25a      	sxtb	r2, r3
    29d4:	230a      	movs	r3, #10
    29d6:	18fb      	adds	r3, r7, r3
    29d8:	781b      	ldrb	r3, [r3, #0]
    29da:	009b      	lsls	r3, r3, #2
    29dc:	12db      	asrs	r3, r3, #11
    29de:	b25b      	sxtb	r3, r3
    29e0:	2104      	movs	r1, #4
    29e2:	400b      	ands	r3, r1
    29e4:	b25b      	sxtb	r3, r3
    29e6:	4313      	orrs	r3, r2
    29e8:	b25a      	sxtb	r2, r3
    29ea:	230a      	movs	r3, #10
    29ec:	18fb      	adds	r3, r7, r3
    29ee:	781b      	ldrb	r3, [r3, #0]
    29f0:	009b      	lsls	r3, r3, #2
    29f2:	125b      	asrs	r3, r3, #9
    29f4:	b25b      	sxtb	r3, r3
    29f6:	2108      	movs	r1, #8
    29f8:	400b      	ands	r3, r1
    29fa:	b25b      	sxtb	r3, r3
    29fc:	4313      	orrs	r3, r2
    29fe:	b25a      	sxtb	r2, r3
    2a00:	230a      	movs	r3, #10
    2a02:	18fb      	adds	r3, r7, r3
    2a04:	781b      	ldrb	r3, [r3, #0]
    2a06:	009b      	lsls	r3, r3, #2
    2a08:	121b      	asrs	r3, r3, #8
    2a0a:	005b      	lsls	r3, r3, #1
    2a0c:	b25b      	sxtb	r3, r3
    2a0e:	2110      	movs	r1, #16
    2a10:	400b      	ands	r3, r1
    2a12:	b25b      	sxtb	r3, r3
    2a14:	4313      	orrs	r3, r2
    2a16:	b25a      	sxtb	r2, r3
    2a18:	230a      	movs	r3, #10
    2a1a:	18fb      	adds	r3, r7, r3
    2a1c:	781b      	ldrb	r3, [r3, #0]
    2a1e:	009b      	lsls	r3, r3, #2
    2a20:	121b      	asrs	r3, r3, #8
    2a22:	00db      	lsls	r3, r3, #3
    2a24:	b25b      	sxtb	r3, r3
    2a26:	2120      	movs	r1, #32
    2a28:	400b      	ands	r3, r1
    2a2a:	b25b      	sxtb	r3, r3
    2a2c:	4313      	orrs	r3, r2
    2a2e:	b25a      	sxtb	r2, r3
    2a30:	230a      	movs	r3, #10
    2a32:	18fb      	adds	r3, r7, r3
    2a34:	781b      	ldrb	r3, [r3, #0]
    2a36:	009b      	lsls	r3, r3, #2
    2a38:	121b      	asrs	r3, r3, #8
    2a3a:	015b      	lsls	r3, r3, #5
    2a3c:	b25b      	sxtb	r3, r3
    2a3e:	2140      	movs	r1, #64	; 0x40
    2a40:	400b      	ands	r3, r1
    2a42:	b25b      	sxtb	r3, r3
    2a44:	4313      	orrs	r3, r2
    2a46:	b25a      	sxtb	r2, r3
    2a48:	230a      	movs	r3, #10
    2a4a:	18fb      	adds	r3, r7, r3
    2a4c:	781b      	ldrb	r3, [r3, #0]
    2a4e:	009b      	lsls	r3, r3, #2
    2a50:	121b      	asrs	r3, r3, #8
    2a52:	01db      	lsls	r3, r3, #7
    2a54:	b25b      	sxtb	r3, r3
    2a56:	4313      	orrs	r3, r2
    2a58:	b25b      	sxtb	r3, r3
    2a5a:	b2da      	uxtb	r2, r3
    2a5c:	68fb      	ldr	r3, [r7, #12]
    2a5e:	0011      	movs	r1, r2
    2a60:	0018      	movs	r0, r3
    2a62:	f7ff fda7 	bl	25b4 <u8x8_cad_SendArg>
		u8x8_cad_SendArg(u8x8, SWAP8(arg_int)); /* Dimming level */
    2a66:	230a      	movs	r3, #10
    2a68:	18fb      	adds	r3, r7, r3
    2a6a:	781b      	ldrb	r3, [r3, #0]
    2a6c:	09db      	lsrs	r3, r3, #7
    2a6e:	b2db      	uxtb	r3, r3
    2a70:	b25a      	sxtb	r2, r3
    2a72:	230a      	movs	r3, #10
    2a74:	18fb      	adds	r3, r7, r3
    2a76:	781b      	ldrb	r3, [r3, #0]
    2a78:	115b      	asrs	r3, r3, #5
    2a7a:	b25b      	sxtb	r3, r3
    2a7c:	2102      	movs	r1, #2
    2a7e:	400b      	ands	r3, r1
    2a80:	b25b      	sxtb	r3, r3
    2a82:	4313      	orrs	r3, r2
    2a84:	b25a      	sxtb	r2, r3
    2a86:	230a      	movs	r3, #10
    2a88:	18fb      	adds	r3, r7, r3
    2a8a:	781b      	ldrb	r3, [r3, #0]
    2a8c:	10db      	asrs	r3, r3, #3
    2a8e:	b25b      	sxtb	r3, r3
    2a90:	2104      	movs	r1, #4
    2a92:	400b      	ands	r3, r1
    2a94:	b25b      	sxtb	r3, r3
    2a96:	4313      	orrs	r3, r2
    2a98:	b25a      	sxtb	r2, r3
    2a9a:	230a      	movs	r3, #10
    2a9c:	18fb      	adds	r3, r7, r3
    2a9e:	781b      	ldrb	r3, [r3, #0]
    2aa0:	105b      	asrs	r3, r3, #1
    2aa2:	b25b      	sxtb	r3, r3
    2aa4:	2108      	movs	r1, #8
    2aa6:	400b      	ands	r3, r1
    2aa8:	b25b      	sxtb	r3, r3
    2aaa:	4313      	orrs	r3, r2
    2aac:	b25a      	sxtb	r2, r3
    2aae:	230a      	movs	r3, #10
    2ab0:	18fb      	adds	r3, r7, r3
    2ab2:	781b      	ldrb	r3, [r3, #0]
    2ab4:	005b      	lsls	r3, r3, #1
    2ab6:	b25b      	sxtb	r3, r3
    2ab8:	2110      	movs	r1, #16
    2aba:	400b      	ands	r3, r1
    2abc:	b25b      	sxtb	r3, r3
    2abe:	4313      	orrs	r3, r2
    2ac0:	b25a      	sxtb	r2, r3
    2ac2:	230a      	movs	r3, #10
    2ac4:	18fb      	adds	r3, r7, r3
    2ac6:	781b      	ldrb	r3, [r3, #0]
    2ac8:	00db      	lsls	r3, r3, #3
    2aca:	b25b      	sxtb	r3, r3
    2acc:	2120      	movs	r1, #32
    2ace:	400b      	ands	r3, r1
    2ad0:	b25b      	sxtb	r3, r3
    2ad2:	4313      	orrs	r3, r2
    2ad4:	b25a      	sxtb	r2, r3
    2ad6:	230a      	movs	r3, #10
    2ad8:	18fb      	adds	r3, r7, r3
    2ada:	781b      	ldrb	r3, [r3, #0]
    2adc:	015b      	lsls	r3, r3, #5
    2ade:	b25b      	sxtb	r3, r3
    2ae0:	2140      	movs	r1, #64	; 0x40
    2ae2:	400b      	ands	r3, r1
    2ae4:	b25b      	sxtb	r3, r3
    2ae6:	4313      	orrs	r3, r2
    2ae8:	b25a      	sxtb	r2, r3
    2aea:	230a      	movs	r3, #10
    2aec:	18fb      	adds	r3, r7, r3
    2aee:	781b      	ldrb	r3, [r3, #0]
    2af0:	01db      	lsls	r3, r3, #7
    2af2:	b25b      	sxtb	r3, r3
    2af4:	4313      	orrs	r3, r2
    2af6:	b25b      	sxtb	r3, r3
    2af8:	b2da      	uxtb	r2, r3
    2afa:	68fb      	ldr	r3, [r7, #12]
    2afc:	0011      	movs	r1, r2
    2afe:	0018      	movs	r0, r3
    2b00:	f7ff fd58 	bl	25b4 <u8x8_cad_SendArg>
		
        u8x8_cad_EndTransfer(u8x8);
    2b04:	68fb      	ldr	r3, [r7, #12]
    2b06:	0018      	movs	r0, r3
    2b08:	f7ff fd90 	bl	262c <u8x8_cad_EndTransfer>
        break;
    2b0c:	e136      	b.n	2d7c <u8x8_d_gp1287ai_common+0x43c>
#endif
    case U8X8_MSG_DISPLAY_DRAW_TILE:
        x = ((u8x8_tile_t *)arg_ptr)->x_pos * 8;
    2b0e:	687b      	ldr	r3, [r7, #4]
    2b10:	795a      	ldrb	r2, [r3, #5]
    2b12:	2319      	movs	r3, #25
    2b14:	18fb      	adds	r3, r7, r3
    2b16:	00d2      	lsls	r2, r2, #3
    2b18:	701a      	strb	r2, [r3, #0]
        y = ((u8x8_tile_t *)arg_ptr)->y_pos * 8 + 4;
    2b1a:	687b      	ldr	r3, [r7, #4]
    2b1c:	799b      	ldrb	r3, [r3, #6]
    2b1e:	00db      	lsls	r3, r3, #3
    2b20:	b2da      	uxtb	r2, r3
    2b22:	2318      	movs	r3, #24
    2b24:	18fb      	adds	r3, r7, r3
    2b26:	3204      	adds	r2, #4
    2b28:	701a      	strb	r2, [r3, #0]

        u8x8_cad_StartTransfer(u8x8);
    2b2a:	68fb      	ldr	r3, [r7, #12]
    2b2c:	0018      	movs	r0, r3
    2b2e:	f7ff fd6d 	bl	260c <u8x8_cad_StartTransfer>

        u8x8_cad_SendCmd(u8x8, SWAP8(0x0F0));
    2b32:	68fb      	ldr	r3, [r7, #12]
    2b34:	210f      	movs	r1, #15
    2b36:	0018      	movs	r0, r3
    2b38:	f7ff fd28 	bl	258c <u8x8_cad_SendCmd>
        u8x8_cad_SendArg(u8x8, SWAP8(x));
    2b3c:	2319      	movs	r3, #25
    2b3e:	18fb      	adds	r3, r7, r3
    2b40:	781b      	ldrb	r3, [r3, #0]
    2b42:	09db      	lsrs	r3, r3, #7
    2b44:	b2db      	uxtb	r3, r3
    2b46:	b25a      	sxtb	r2, r3
    2b48:	2319      	movs	r3, #25
    2b4a:	18fb      	adds	r3, r7, r3
    2b4c:	781b      	ldrb	r3, [r3, #0]
    2b4e:	115b      	asrs	r3, r3, #5
    2b50:	b25b      	sxtb	r3, r3
    2b52:	2102      	movs	r1, #2
    2b54:	400b      	ands	r3, r1
    2b56:	b25b      	sxtb	r3, r3
    2b58:	4313      	orrs	r3, r2
    2b5a:	b25a      	sxtb	r2, r3
    2b5c:	2319      	movs	r3, #25
    2b5e:	18fb      	adds	r3, r7, r3
    2b60:	781b      	ldrb	r3, [r3, #0]
    2b62:	10db      	asrs	r3, r3, #3
    2b64:	b25b      	sxtb	r3, r3
    2b66:	2104      	movs	r1, #4
    2b68:	400b      	ands	r3, r1
    2b6a:	b25b      	sxtb	r3, r3
    2b6c:	4313      	orrs	r3, r2
    2b6e:	b25a      	sxtb	r2, r3
    2b70:	2319      	movs	r3, #25
    2b72:	18fb      	adds	r3, r7, r3
    2b74:	781b      	ldrb	r3, [r3, #0]
    2b76:	105b      	asrs	r3, r3, #1
    2b78:	b25b      	sxtb	r3, r3
    2b7a:	2108      	movs	r1, #8
    2b7c:	400b      	ands	r3, r1
    2b7e:	b25b      	sxtb	r3, r3
    2b80:	4313      	orrs	r3, r2
    2b82:	b25a      	sxtb	r2, r3
    2b84:	2319      	movs	r3, #25
    2b86:	18fb      	adds	r3, r7, r3
    2b88:	781b      	ldrb	r3, [r3, #0]
    2b8a:	005b      	lsls	r3, r3, #1
    2b8c:	b25b      	sxtb	r3, r3
    2b8e:	2110      	movs	r1, #16
    2b90:	400b      	ands	r3, r1
    2b92:	b25b      	sxtb	r3, r3
    2b94:	4313      	orrs	r3, r2
    2b96:	b25a      	sxtb	r2, r3
    2b98:	2319      	movs	r3, #25
    2b9a:	18fb      	adds	r3, r7, r3
    2b9c:	781b      	ldrb	r3, [r3, #0]
    2b9e:	00db      	lsls	r3, r3, #3
    2ba0:	b25b      	sxtb	r3, r3
    2ba2:	2120      	movs	r1, #32
    2ba4:	400b      	ands	r3, r1
    2ba6:	b25b      	sxtb	r3, r3
    2ba8:	4313      	orrs	r3, r2
    2baa:	b25a      	sxtb	r2, r3
    2bac:	2319      	movs	r3, #25
    2bae:	18fb      	adds	r3, r7, r3
    2bb0:	781b      	ldrb	r3, [r3, #0]
    2bb2:	015b      	lsls	r3, r3, #5
    2bb4:	b25b      	sxtb	r3, r3
    2bb6:	2140      	movs	r1, #64	; 0x40
    2bb8:	400b      	ands	r3, r1
    2bba:	b25b      	sxtb	r3, r3
    2bbc:	4313      	orrs	r3, r2
    2bbe:	b25a      	sxtb	r2, r3
    2bc0:	2319      	movs	r3, #25
    2bc2:	18fb      	adds	r3, r7, r3
    2bc4:	781b      	ldrb	r3, [r3, #0]
    2bc6:	01db      	lsls	r3, r3, #7
    2bc8:	b25b      	sxtb	r3, r3
    2bca:	4313      	orrs	r3, r2
    2bcc:	b25b      	sxtb	r3, r3
    2bce:	b2da      	uxtb	r2, r3
    2bd0:	68fb      	ldr	r3, [r7, #12]
    2bd2:	0011      	movs	r1, r2
    2bd4:	0018      	movs	r0, r3
    2bd6:	f7ff fced 	bl	25b4 <u8x8_cad_SendArg>
        u8x8_cad_SendArg(u8x8, SWAP8(y));
    2bda:	2318      	movs	r3, #24
    2bdc:	18fb      	adds	r3, r7, r3
    2bde:	781b      	ldrb	r3, [r3, #0]
    2be0:	09db      	lsrs	r3, r3, #7
    2be2:	b2db      	uxtb	r3, r3
    2be4:	b25a      	sxtb	r2, r3
    2be6:	2318      	movs	r3, #24
    2be8:	18fb      	adds	r3, r7, r3
    2bea:	781b      	ldrb	r3, [r3, #0]
    2bec:	115b      	asrs	r3, r3, #5
    2bee:	b25b      	sxtb	r3, r3
    2bf0:	2102      	movs	r1, #2
    2bf2:	400b      	ands	r3, r1
    2bf4:	b25b      	sxtb	r3, r3
    2bf6:	4313      	orrs	r3, r2
    2bf8:	b25a      	sxtb	r2, r3
    2bfa:	2318      	movs	r3, #24
    2bfc:	18fb      	adds	r3, r7, r3
    2bfe:	781b      	ldrb	r3, [r3, #0]
    2c00:	10db      	asrs	r3, r3, #3
    2c02:	b25b      	sxtb	r3, r3
    2c04:	2104      	movs	r1, #4
    2c06:	400b      	ands	r3, r1
    2c08:	b25b      	sxtb	r3, r3
    2c0a:	4313      	orrs	r3, r2
    2c0c:	b25a      	sxtb	r2, r3
    2c0e:	2318      	movs	r3, #24
    2c10:	18fb      	adds	r3, r7, r3
    2c12:	781b      	ldrb	r3, [r3, #0]
    2c14:	105b      	asrs	r3, r3, #1
    2c16:	b25b      	sxtb	r3, r3
    2c18:	2108      	movs	r1, #8
    2c1a:	400b      	ands	r3, r1
    2c1c:	b25b      	sxtb	r3, r3
    2c1e:	4313      	orrs	r3, r2
    2c20:	b25a      	sxtb	r2, r3
    2c22:	2318      	movs	r3, #24
    2c24:	18fb      	adds	r3, r7, r3
    2c26:	781b      	ldrb	r3, [r3, #0]
    2c28:	005b      	lsls	r3, r3, #1
    2c2a:	b25b      	sxtb	r3, r3
    2c2c:	2110      	movs	r1, #16
    2c2e:	400b      	ands	r3, r1
    2c30:	b25b      	sxtb	r3, r3
    2c32:	4313      	orrs	r3, r2
    2c34:	b25a      	sxtb	r2, r3
    2c36:	2318      	movs	r3, #24
    2c38:	18fb      	adds	r3, r7, r3
    2c3a:	781b      	ldrb	r3, [r3, #0]
    2c3c:	00db      	lsls	r3, r3, #3
    2c3e:	b25b      	sxtb	r3, r3
    2c40:	2120      	movs	r1, #32
    2c42:	400b      	ands	r3, r1
    2c44:	b25b      	sxtb	r3, r3
    2c46:	4313      	orrs	r3, r2
    2c48:	b25a      	sxtb	r2, r3
    2c4a:	2318      	movs	r3, #24
    2c4c:	18fb      	adds	r3, r7, r3
    2c4e:	781b      	ldrb	r3, [r3, #0]
    2c50:	015b      	lsls	r3, r3, #5
    2c52:	b25b      	sxtb	r3, r3
    2c54:	2140      	movs	r1, #64	; 0x40
    2c56:	400b      	ands	r3, r1
    2c58:	b25b      	sxtb	r3, r3
    2c5a:	4313      	orrs	r3, r2
    2c5c:	b25a      	sxtb	r2, r3
    2c5e:	2318      	movs	r3, #24
    2c60:	18fb      	adds	r3, r7, r3
    2c62:	781b      	ldrb	r3, [r3, #0]
    2c64:	01db      	lsls	r3, r3, #7
    2c66:	b25b      	sxtb	r3, r3
    2c68:	4313      	orrs	r3, r2
    2c6a:	b25b      	sxtb	r3, r3
    2c6c:	b2da      	uxtb	r2, r3
    2c6e:	68fb      	ldr	r3, [r7, #12]
    2c70:	0011      	movs	r1, r2
    2c72:	0018      	movs	r0, r3
    2c74:	f7ff fc9e 	bl	25b4 <u8x8_cad_SendArg>
        u8x8_cad_SendArg(u8x8, SWAP8(0x007)); /* return every 8 pixels */
    2c78:	68fb      	ldr	r3, [r7, #12]
    2c7a:	21e0      	movs	r1, #224	; 0xe0
    2c7c:	0018      	movs	r0, r3
    2c7e:	f7ff fc99 	bl	25b4 <u8x8_cad_SendArg>
        do
        {
            ptr = ((u8x8_tile_t *)arg_ptr)->tile_ptr;
    2c82:	687b      	ldr	r3, [r7, #4]
    2c84:	681b      	ldr	r3, [r3, #0]
    2c86:	61fb      	str	r3, [r7, #28]
            tx_cnt = ((u8x8_tile_t *)arg_ptr)->cnt * 8;
    2c88:	687b      	ldr	r3, [r7, #4]
    2c8a:	791b      	ldrb	r3, [r3, #4]
    2c8c:	b29a      	uxth	r2, r3
    2c8e:	231a      	movs	r3, #26
    2c90:	18fb      	adds	r3, r7, r3
    2c92:	00d2      	lsls	r2, r2, #3
    2c94:	801a      	strh	r2, [r3, #0]
            while (tx_cnt > 0)
    2c96:	e059      	b.n	2d4c <u8x8_d_gp1287ai_common+0x40c>
    2c98:	00008ecc 	.word	0x00008ecc
    2c9c:	00008ec4 	.word	0x00008ec4
            {
                swapped_byte = SWAP8(*ptr);
    2ca0:	69fb      	ldr	r3, [r7, #28]
    2ca2:	781b      	ldrb	r3, [r3, #0]
    2ca4:	09db      	lsrs	r3, r3, #7
    2ca6:	b2db      	uxtb	r3, r3
    2ca8:	b25a      	sxtb	r2, r3
    2caa:	69fb      	ldr	r3, [r7, #28]
    2cac:	781b      	ldrb	r3, [r3, #0]
    2cae:	115b      	asrs	r3, r3, #5
    2cb0:	b25b      	sxtb	r3, r3
    2cb2:	2102      	movs	r1, #2
    2cb4:	400b      	ands	r3, r1
    2cb6:	b25b      	sxtb	r3, r3
    2cb8:	4313      	orrs	r3, r2
    2cba:	b25a      	sxtb	r2, r3
    2cbc:	69fb      	ldr	r3, [r7, #28]
    2cbe:	781b      	ldrb	r3, [r3, #0]
    2cc0:	10db      	asrs	r3, r3, #3
    2cc2:	b25b      	sxtb	r3, r3
    2cc4:	2104      	movs	r1, #4
    2cc6:	400b      	ands	r3, r1
    2cc8:	b25b      	sxtb	r3, r3
    2cca:	4313      	orrs	r3, r2
    2ccc:	b25a      	sxtb	r2, r3
    2cce:	69fb      	ldr	r3, [r7, #28]
    2cd0:	781b      	ldrb	r3, [r3, #0]
    2cd2:	105b      	asrs	r3, r3, #1
    2cd4:	b25b      	sxtb	r3, r3
    2cd6:	2108      	movs	r1, #8
    2cd8:	400b      	ands	r3, r1
    2cda:	b25b      	sxtb	r3, r3
    2cdc:	4313      	orrs	r3, r2
    2cde:	b25a      	sxtb	r2, r3
    2ce0:	69fb      	ldr	r3, [r7, #28]
    2ce2:	781b      	ldrb	r3, [r3, #0]
    2ce4:	005b      	lsls	r3, r3, #1
    2ce6:	b25b      	sxtb	r3, r3
    2ce8:	2110      	movs	r1, #16
    2cea:	400b      	ands	r3, r1
    2cec:	b25b      	sxtb	r3, r3
    2cee:	4313      	orrs	r3, r2
    2cf0:	b25a      	sxtb	r2, r3
    2cf2:	69fb      	ldr	r3, [r7, #28]
    2cf4:	781b      	ldrb	r3, [r3, #0]
    2cf6:	00db      	lsls	r3, r3, #3
    2cf8:	b25b      	sxtb	r3, r3
    2cfa:	2120      	movs	r1, #32
    2cfc:	400b      	ands	r3, r1
    2cfe:	b25b      	sxtb	r3, r3
    2d00:	4313      	orrs	r3, r2
    2d02:	b25a      	sxtb	r2, r3
    2d04:	69fb      	ldr	r3, [r7, #28]
    2d06:	781b      	ldrb	r3, [r3, #0]
    2d08:	015b      	lsls	r3, r3, #5
    2d0a:	b25b      	sxtb	r3, r3
    2d0c:	2140      	movs	r1, #64	; 0x40
    2d0e:	400b      	ands	r3, r1
    2d10:	b25b      	sxtb	r3, r3
    2d12:	4313      	orrs	r3, r2
    2d14:	b25a      	sxtb	r2, r3
    2d16:	69fb      	ldr	r3, [r7, #28]
    2d18:	781b      	ldrb	r3, [r3, #0]
    2d1a:	01db      	lsls	r3, r3, #7
    2d1c:	b25b      	sxtb	r3, r3
    2d1e:	4313      	orrs	r3, r2
    2d20:	b25b      	sxtb	r3, r3
    2d22:	b2da      	uxtb	r2, r3
    2d24:	2317      	movs	r3, #23
    2d26:	18fb      	adds	r3, r7, r3
    2d28:	701a      	strb	r2, [r3, #0]
                u8x8_cad_SendData(u8x8, 1, &swapped_byte);
    2d2a:	2317      	movs	r3, #23
    2d2c:	18fa      	adds	r2, r7, r3
    2d2e:	68fb      	ldr	r3, [r7, #12]
    2d30:	2101      	movs	r1, #1
    2d32:	0018      	movs	r0, r3
    2d34:	f7ff fc52 	bl	25dc <u8x8_cad_SendData>
                ptr += 1;
    2d38:	69fb      	ldr	r3, [r7, #28]
    2d3a:	3301      	adds	r3, #1
    2d3c:	61fb      	str	r3, [r7, #28]
                tx_cnt -= 1;
    2d3e:	231a      	movs	r3, #26
    2d40:	18fb      	adds	r3, r7, r3
    2d42:	221a      	movs	r2, #26
    2d44:	18ba      	adds	r2, r7, r2
    2d46:	8812      	ldrh	r2, [r2, #0]
    2d48:	3a01      	subs	r2, #1
    2d4a:	801a      	strh	r2, [r3, #0]
            while (tx_cnt > 0)
    2d4c:	231a      	movs	r3, #26
    2d4e:	18fb      	adds	r3, r7, r3
    2d50:	881b      	ldrh	r3, [r3, #0]
    2d52:	2b00      	cmp	r3, #0
    2d54:	d1a4      	bne.n	2ca0 <u8x8_d_gp1287ai_common+0x360>
            }
            arg_int--;
    2d56:	230a      	movs	r3, #10
    2d58:	18fb      	adds	r3, r7, r3
    2d5a:	781a      	ldrb	r2, [r3, #0]
    2d5c:	230a      	movs	r3, #10
    2d5e:	18fb      	adds	r3, r7, r3
    2d60:	3a01      	subs	r2, #1
    2d62:	701a      	strb	r2, [r3, #0]
        } while (arg_int > 0);
    2d64:	230a      	movs	r3, #10
    2d66:	18fb      	adds	r3, r7, r3
    2d68:	781b      	ldrb	r3, [r3, #0]
    2d6a:	2b00      	cmp	r3, #0
    2d6c:	d189      	bne.n	2c82 <u8x8_d_gp1287ai_common+0x342>

        u8x8_cad_EndTransfer(u8x8);
    2d6e:	68fb      	ldr	r3, [r7, #12]
    2d70:	0018      	movs	r0, r3
    2d72:	f7ff fc5b 	bl	262c <u8x8_cad_EndTransfer>
        break;
    2d76:	e001      	b.n	2d7c <u8x8_d_gp1287ai_common+0x43c>
    default:
        return 0;
    2d78:	2300      	movs	r3, #0
    2d7a:	e000      	b.n	2d7e <u8x8_d_gp1287ai_common+0x43e>
    }
    return 1;
    2d7c:	2301      	movs	r3, #1
}
    2d7e:	0018      	movs	r0, r3
    2d80:	46bd      	mov	sp, r7
    2d82:	b008      	add	sp, #32
    2d84:	bd80      	pop	{r7, pc}
    2d86:	46c0      	nop			; (mov r8, r8)

00002d88 <u8x8_d_gp1287ai_256x50>:
uint8_t u8x8_d_gp1287ai_256x50(u8x8_t *u8x8, uint8_t msg, uint8_t arg_int, void *arg_ptr)
{
    2d88:	b590      	push	{r4, r7, lr}
    2d8a:	b085      	sub	sp, #20
    2d8c:	af00      	add	r7, sp, #0
    2d8e:	60f8      	str	r0, [r7, #12]
    2d90:	0008      	movs	r0, r1
    2d92:	0011      	movs	r1, r2
    2d94:	607b      	str	r3, [r7, #4]
    2d96:	230b      	movs	r3, #11
    2d98:	18fb      	adds	r3, r7, r3
    2d9a:	1c02      	adds	r2, r0, #0
    2d9c:	701a      	strb	r2, [r3, #0]
    2d9e:	230a      	movs	r3, #10
    2da0:	18fb      	adds	r3, r7, r3
    2da2:	1c0a      	adds	r2, r1, #0
    2da4:	701a      	strb	r2, [r3, #0]
    switch (msg)
    2da6:	230b      	movs	r3, #11
    2da8:	18fb      	adds	r3, r7, r3
    2daa:	781b      	ldrb	r3, [r3, #0]
    2dac:	2b09      	cmp	r3, #9
    2dae:	d002      	beq.n	2db6 <u8x8_d_gp1287ai_256x50+0x2e>
    2db0:	2b0a      	cmp	r3, #10
    2db2:	d007      	beq.n	2dc4 <u8x8_d_gp1287ai_256x50+0x3c>
    2db4:	e011      	b.n	2dda <u8x8_d_gp1287ai_256x50+0x52>
    {
    case U8X8_MSG_DISPLAY_SETUP_MEMORY:
        u8x8_d_helper_display_setup_memory(u8x8, &u8x8_gp1287ai_display_info);
    2db6:	4a12      	ldr	r2, [pc, #72]	; (2e00 <u8x8_d_gp1287ai_256x50+0x78>)
    2db8:	68fb      	ldr	r3, [r7, #12]
    2dba:	0011      	movs	r1, r2
    2dbc:	0018      	movs	r0, r3
    2dbe:	f7ff fce9 	bl	2794 <u8x8_d_helper_display_setup_memory>
        break;
    2dc2:	e017      	b.n	2df4 <u8x8_d_gp1287ai_256x50+0x6c>
    case U8X8_MSG_DISPLAY_INIT:
        u8x8_d_helper_display_init(u8x8);
    2dc4:	68fb      	ldr	r3, [r7, #12]
    2dc6:	0018      	movs	r0, r3
    2dc8:	f7ff fcf6 	bl	27b8 <u8x8_d_helper_display_init>
        u8x8_cad_SendSequence(u8x8, u8x8_d_gp1287ai_init_seq);
    2dcc:	4a0d      	ldr	r2, [pc, #52]	; (2e04 <u8x8_d_gp1287ai_256x50+0x7c>)
    2dce:	68fb      	ldr	r3, [r7, #12]
    2dd0:	0011      	movs	r1, r2
    2dd2:	0018      	movs	r0, r3
    2dd4:	f7ff fc3a 	bl	264c <u8x8_cad_SendSequence>
        break;
    2dd8:	e00c      	b.n	2df4 <u8x8_d_gp1287ai_256x50+0x6c>
    default:
        return u8x8_d_gp1287ai_common(u8x8, msg, arg_int, arg_ptr);
    2dda:	687c      	ldr	r4, [r7, #4]
    2ddc:	230a      	movs	r3, #10
    2dde:	18fb      	adds	r3, r7, r3
    2de0:	781a      	ldrb	r2, [r3, #0]
    2de2:	230b      	movs	r3, #11
    2de4:	18fb      	adds	r3, r7, r3
    2de6:	7819      	ldrb	r1, [r3, #0]
    2de8:	68f8      	ldr	r0, [r7, #12]
    2dea:	0023      	movs	r3, r4
    2dec:	f7ff fda8 	bl	2940 <u8x8_d_gp1287ai_common>
    2df0:	0003      	movs	r3, r0
    2df2:	e000      	b.n	2df6 <u8x8_d_gp1287ai_256x50+0x6e>
    }
    return 1;
    2df4:	2301      	movs	r3, #1
}
    2df6:	0018      	movs	r0, r3
    2df8:	46bd      	mov	sp, r7
    2dfa:	b005      	add	sp, #20
    2dfc:	bd90      	pop	{r4, r7, pc}
    2dfe:	46c0      	nop			; (mov r8, r8)
    2e00:	00008e44 	.word	0x00008e44
    2e04:	00008e5c 	.word	0x00008e5c

00002e08 <u8x8_gpio_call>:

#include "u8x8.h"


void u8x8_gpio_call(u8x8_t *u8x8, uint8_t msg, uint8_t arg)
{
    2e08:	b590      	push	{r4, r7, lr}
    2e0a:	b083      	sub	sp, #12
    2e0c:	af00      	add	r7, sp, #0
    2e0e:	6078      	str	r0, [r7, #4]
    2e10:	0008      	movs	r0, r1
    2e12:	0011      	movs	r1, r2
    2e14:	1cfb      	adds	r3, r7, #3
    2e16:	1c02      	adds	r2, r0, #0
    2e18:	701a      	strb	r2, [r3, #0]
    2e1a:	1cbb      	adds	r3, r7, #2
    2e1c:	1c0a      	adds	r2, r1, #0
    2e1e:	701a      	strb	r2, [r3, #0]
  u8x8->gpio_and_delay_cb(u8x8, msg, arg, NULL);
    2e20:	687b      	ldr	r3, [r7, #4]
    2e22:	695c      	ldr	r4, [r3, #20]
    2e24:	1cbb      	adds	r3, r7, #2
    2e26:	781a      	ldrb	r2, [r3, #0]
    2e28:	1cfb      	adds	r3, r7, #3
    2e2a:	7819      	ldrb	r1, [r3, #0]
    2e2c:	6878      	ldr	r0, [r7, #4]
    2e2e:	2300      	movs	r3, #0
    2e30:	47a0      	blx	r4
}
    2e32:	46c0      	nop			; (mov r8, r8)
    2e34:	46bd      	mov	sp, r7
    2e36:	b003      	add	sp, #12
    2e38:	bd90      	pop	{r4, r7, pc}

00002e3a <u8x8_dummy_cb>:

#include "u8x8.h"

/* universal dummy callback, which will be default for all callbacks */
uint8_t u8x8_dummy_cb(U8X8_UNUSED u8x8_t *u8x8, U8X8_UNUSED uint8_t msg, U8X8_UNUSED uint8_t arg_int, U8X8_UNUSED void *arg_ptr)
{
    2e3a:	b580      	push	{r7, lr}
    2e3c:	b084      	sub	sp, #16
    2e3e:	af00      	add	r7, sp, #0
    2e40:	60f8      	str	r0, [r7, #12]
    2e42:	0008      	movs	r0, r1
    2e44:	0011      	movs	r1, r2
    2e46:	607b      	str	r3, [r7, #4]
    2e48:	230b      	movs	r3, #11
    2e4a:	18fb      	adds	r3, r7, r3
    2e4c:	1c02      	adds	r2, r0, #0
    2e4e:	701a      	strb	r2, [r3, #0]
    2e50:	230a      	movs	r3, #10
    2e52:	18fb      	adds	r3, r7, r3
    2e54:	1c0a      	adds	r2, r1, #0
    2e56:	701a      	strb	r2, [r3, #0]
  /* the dummy callback will not handle any message and will fail for all messages */
  return 0;
    2e58:	2300      	movs	r3, #0
}
    2e5a:	0018      	movs	r0, r3
    2e5c:	46bd      	mov	sp, r7
    2e5e:	b004      	add	sp, #16
    2e60:	bd80      	pop	{r7, pc}
	...

00002e64 <u8x8_SetupDefaults>:
    Setup u8x8
  Args:
    u8x8	An empty u8x8 structure
*/
void u8x8_SetupDefaults(u8x8_t *u8x8)
{
    2e64:	b580      	push	{r7, lr}
    2e66:	b082      	sub	sp, #8
    2e68:	af00      	add	r7, sp, #0
    2e6a:	6078      	str	r0, [r7, #4]
    u8x8->display_info = NULL;
    2e6c:	687b      	ldr	r3, [r7, #4]
    2e6e:	2200      	movs	r2, #0
    2e70:	601a      	str	r2, [r3, #0]
    u8x8->display_cb = u8x8_dummy_cb;
    2e72:	687b      	ldr	r3, [r7, #4]
    2e74:	4a10      	ldr	r2, [pc, #64]	; (2eb8 <u8x8_SetupDefaults+0x54>)
    2e76:	609a      	str	r2, [r3, #8]
    u8x8->cad_cb = u8x8_dummy_cb;
    2e78:	687b      	ldr	r3, [r7, #4]
    2e7a:	4a0f      	ldr	r2, [pc, #60]	; (2eb8 <u8x8_SetupDefaults+0x54>)
    2e7c:	60da      	str	r2, [r3, #12]
    u8x8->byte_cb = u8x8_dummy_cb;
    2e7e:	687b      	ldr	r3, [r7, #4]
    2e80:	4a0d      	ldr	r2, [pc, #52]	; (2eb8 <u8x8_SetupDefaults+0x54>)
    2e82:	611a      	str	r2, [r3, #16]
    u8x8->gpio_and_delay_cb = u8x8_dummy_cb;
    2e84:	687b      	ldr	r3, [r7, #4]
    2e86:	4a0c      	ldr	r2, [pc, #48]	; (2eb8 <u8x8_SetupDefaults+0x54>)
    2e88:	615a      	str	r2, [r3, #20]
    u8x8->is_font_inverse_mode = 0;
    2e8a:	687b      	ldr	r3, [r7, #4]
    2e8c:	2223      	movs	r2, #35	; 0x23
    2e8e:	2100      	movs	r1, #0
    2e90:	5499      	strb	r1, [r3, r2]
    //u8x8->device_address = 0;
    u8x8->utf8_state = 0;		/* also reset by u8x8_utf8_init */
    2e92:	687b      	ldr	r3, [r7, #4]
    2e94:	2226      	movs	r2, #38	; 0x26
    2e96:	2100      	movs	r1, #0
    2e98:	5499      	strb	r1, [r3, r2]
    u8x8->bus_clock = 0;		/* issue 769 */
    2e9a:	687b      	ldr	r3, [r7, #4]
    2e9c:	2200      	movs	r2, #0
    2e9e:	619a      	str	r2, [r3, #24]
    u8x8->i2c_address = 255;
    2ea0:	687b      	ldr	r3, [r7, #4]
    2ea2:	2224      	movs	r2, #36	; 0x24
    2ea4:	21ff      	movs	r1, #255	; 0xff
    2ea6:	5499      	strb	r1, [r3, r2]
    u8x8->debounce_default_pin_state = 255;	/* assume all low active buttons */
    2ea8:	687b      	ldr	r3, [r7, #4]
    2eaa:	2228      	movs	r2, #40	; 0x28
    2eac:	21ff      	movs	r1, #255	; 0xff
    2eae:	5499      	strb	r1, [r3, r2]
    uint8_t i;
    for( i = 0; i < U8X8_PIN_CNT; i++ )
      u8x8->pins[i] = U8X8_PIN_NONE;
  }
#endif
}
    2eb0:	46c0      	nop			; (mov r8, r8)
    2eb2:	46bd      	mov	sp, r7
    2eb4:	b002      	add	sp, #8
    2eb6:	bd80      	pop	{r7, pc}
    2eb8:	00002e3b 	.word	0x00002e3b

00002ebc <u8x8_Setup>:
    byte_cb			Display controller/communication specific callback funtion
    gpio_and_delay_cb	Environment specific callback function

*/
void u8x8_Setup(u8x8_t *u8x8, u8x8_msg_cb display_cb, u8x8_msg_cb cad_cb, u8x8_msg_cb byte_cb, u8x8_msg_cb gpio_and_delay_cb)
{
    2ebc:	b580      	push	{r7, lr}
    2ebe:	b084      	sub	sp, #16
    2ec0:	af00      	add	r7, sp, #0
    2ec2:	60f8      	str	r0, [r7, #12]
    2ec4:	60b9      	str	r1, [r7, #8]
    2ec6:	607a      	str	r2, [r7, #4]
    2ec8:	603b      	str	r3, [r7, #0]
  /* setup defaults and reset pins to U8X8_PIN_NONE */
  u8x8_SetupDefaults(u8x8);
    2eca:	68fb      	ldr	r3, [r7, #12]
    2ecc:	0018      	movs	r0, r3
    2ece:	f7ff ffc9 	bl	2e64 <u8x8_SetupDefaults>

  /* setup specific callbacks */
  u8x8->display_cb = display_cb;
    2ed2:	68fb      	ldr	r3, [r7, #12]
    2ed4:	68ba      	ldr	r2, [r7, #8]
    2ed6:	609a      	str	r2, [r3, #8]
  u8x8->cad_cb = cad_cb;
    2ed8:	68fb      	ldr	r3, [r7, #12]
    2eda:	687a      	ldr	r2, [r7, #4]
    2edc:	60da      	str	r2, [r3, #12]
  u8x8->byte_cb = byte_cb;
    2ede:	68fb      	ldr	r3, [r7, #12]
    2ee0:	683a      	ldr	r2, [r7, #0]
    2ee2:	611a      	str	r2, [r3, #16]
  u8x8->gpio_and_delay_cb = gpio_and_delay_cb;
    2ee4:	68fb      	ldr	r3, [r7, #12]
    2ee6:	69ba      	ldr	r2, [r7, #24]
    2ee8:	615a      	str	r2, [r3, #20]

  /* setup display info */
  u8x8_SetupMemory(u8x8);
    2eea:	68fb      	ldr	r3, [r7, #12]
    2eec:	0018      	movs	r0, r3
    2eee:	f7ff fcd3 	bl	2898 <u8x8_SetupMemory>
}
    2ef2:	46c0      	nop			; (mov r8, r8)
    2ef4:	46bd      	mov	sp, r7
    2ef6:	b004      	add	sp, #16
    2ef8:	bd80      	pop	{r7, pc}
	...

00002efc <Reset_Handler>:
/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
{
    2efc:	b580      	push	{r7, lr}
    2efe:	b082      	sub	sp, #8
    2f00:	af00      	add	r7, sp, #0
        uint32_t *pSrc, *pDest;

        /* Initialize the relocate segment */
        pSrc = &_etext;
    2f02:	4b19      	ldr	r3, [pc, #100]	; (2f68 <Reset_Handler+0x6c>)
    2f04:	607b      	str	r3, [r7, #4]
        pDest = &_srelocate;
    2f06:	4b19      	ldr	r3, [pc, #100]	; (2f6c <Reset_Handler+0x70>)
    2f08:	603b      	str	r3, [r7, #0]

        if (pSrc != pDest) {
    2f0a:	687a      	ldr	r2, [r7, #4]
    2f0c:	683b      	ldr	r3, [r7, #0]
    2f0e:	429a      	cmp	r2, r3
    2f10:	d00c      	beq.n	2f2c <Reset_Handler+0x30>
                for (; pDest < &_erelocate;) {
    2f12:	e007      	b.n	2f24 <Reset_Handler+0x28>
                        *pDest++ = *pSrc++;
    2f14:	683b      	ldr	r3, [r7, #0]
    2f16:	1d1a      	adds	r2, r3, #4
    2f18:	603a      	str	r2, [r7, #0]
    2f1a:	687a      	ldr	r2, [r7, #4]
    2f1c:	1d11      	adds	r1, r2, #4
    2f1e:	6079      	str	r1, [r7, #4]
    2f20:	6812      	ldr	r2, [r2, #0]
    2f22:	601a      	str	r2, [r3, #0]
                for (; pDest < &_erelocate;) {
    2f24:	683a      	ldr	r2, [r7, #0]
    2f26:	4b12      	ldr	r3, [pc, #72]	; (2f70 <Reset_Handler+0x74>)
    2f28:	429a      	cmp	r2, r3
    2f2a:	d3f3      	bcc.n	2f14 <Reset_Handler+0x18>
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
    2f2c:	4b11      	ldr	r3, [pc, #68]	; (2f74 <Reset_Handler+0x78>)
    2f2e:	603b      	str	r3, [r7, #0]
    2f30:	e004      	b.n	2f3c <Reset_Handler+0x40>
                *pDest++ = 0;
    2f32:	683b      	ldr	r3, [r7, #0]
    2f34:	1d1a      	adds	r2, r3, #4
    2f36:	603a      	str	r2, [r7, #0]
    2f38:	2200      	movs	r2, #0
    2f3a:	601a      	str	r2, [r3, #0]
        for (pDest = &_szero; pDest < &_ezero;) {
    2f3c:	683a      	ldr	r2, [r7, #0]
    2f3e:	4b0e      	ldr	r3, [pc, #56]	; (2f78 <Reset_Handler+0x7c>)
    2f40:	429a      	cmp	r2, r3
    2f42:	d3f6      	bcc.n	2f32 <Reset_Handler+0x36>
        }

        /* Set the vector table base address */
        pSrc = (uint32_t *) & _sfixed;
    2f44:	4b0d      	ldr	r3, [pc, #52]	; (2f7c <Reset_Handler+0x80>)
    2f46:	607b      	str	r3, [r7, #4]
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
    2f48:	4b0d      	ldr	r3, [pc, #52]	; (2f80 <Reset_Handler+0x84>)
    2f4a:	687a      	ldr	r2, [r7, #4]
    2f4c:	21ff      	movs	r1, #255	; 0xff
    2f4e:	438a      	bics	r2, r1
    2f50:	609a      	str	r2, [r3, #8]

        /* Overwriting the default value of the NVMCTRL.CTRLB.MANW bit (errata reference 13134) */
        NVMCTRL->CTRLB.bit.MANW = 1;
    2f52:	4a0c      	ldr	r2, [pc, #48]	; (2f84 <Reset_Handler+0x88>)
    2f54:	6853      	ldr	r3, [r2, #4]
    2f56:	2180      	movs	r1, #128	; 0x80
    2f58:	430b      	orrs	r3, r1
    2f5a:	6053      	str	r3, [r2, #4]

        /* Initialize the C library */
        __libc_init_array();
    2f5c:	f005 f8ca 	bl	80f4 <__libc_init_array>

        /* Branch to main function */
        main();
    2f60:	f004 fdb6 	bl	7ad0 <main>

        /* Infinite loop */
        while (1);
    2f64:	e7fe      	b.n	2f64 <Reset_Handler+0x68>
    2f66:	46c0      	nop			; (mov r8, r8)
    2f68:	00009210 	.word	0x00009210
    2f6c:	20000000 	.word	0x20000000
    2f70:	20000090 	.word	0x20000090
    2f74:	20000090 	.word	0x20000090
    2f78:	20000968 	.word	0x20000968
    2f7c:	00000000 	.word	0x00000000
    2f80:	e000ed00 	.word	0xe000ed00
    2f84:	41004000 	.word	0x41004000

00002f88 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
    2f88:	b580      	push	{r7, lr}
    2f8a:	af00      	add	r7, sp, #0
        while (1) {
    2f8c:	e7fe      	b.n	2f8c <Dummy_Handler+0x4>

00002f8e <hri_gclk_write_CLKCTRL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_gclk_write_CLKCTRL_reg(const void *const hw, hri_gclk_clkctrl_reg_t data)
{
    2f8e:	b580      	push	{r7, lr}
    2f90:	b082      	sub	sp, #8
    2f92:	af00      	add	r7, sp, #0
    2f94:	6078      	str	r0, [r7, #4]
    2f96:	000a      	movs	r2, r1
    2f98:	1cbb      	adds	r3, r7, #2
    2f9a:	801a      	strh	r2, [r3, #0]
	GCLK_CRITICAL_SECTION_ENTER();
	((Gclk *)hw)->CLKCTRL.reg = data;
    2f9c:	687b      	ldr	r3, [r7, #4]
    2f9e:	1cba      	adds	r2, r7, #2
    2fa0:	8812      	ldrh	r2, [r2, #0]
    2fa2:	805a      	strh	r2, [r3, #2]
	GCLK_CRITICAL_SECTION_LEAVE();
}
    2fa4:	46c0      	nop			; (mov r8, r8)
    2fa6:	46bd      	mov	sp, r7
    2fa8:	b002      	add	sp, #8
    2faa:	bd80      	pop	{r7, pc}

00002fac <hri_port_set_DIR_reg>:
{
	((Port *)hw)->Group[submodule_index].DIRTGL.reg = PORT_DIR_DIR(mask);
}

static inline void hri_port_set_DIR_reg(const void *const hw, uint8_t submodule_index, hri_port_dir_reg_t mask)
{
    2fac:	b580      	push	{r7, lr}
    2fae:	b084      	sub	sp, #16
    2fb0:	af00      	add	r7, sp, #0
    2fb2:	60f8      	str	r0, [r7, #12]
    2fb4:	607a      	str	r2, [r7, #4]
    2fb6:	230b      	movs	r3, #11
    2fb8:	18fb      	adds	r3, r7, r3
    2fba:	1c0a      	adds	r2, r1, #0
    2fbc:	701a      	strb	r2, [r3, #0]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    2fbe:	230b      	movs	r3, #11
    2fc0:	18fb      	adds	r3, r7, r3
    2fc2:	781b      	ldrb	r3, [r3, #0]
    2fc4:	68fa      	ldr	r2, [r7, #12]
    2fc6:	01db      	lsls	r3, r3, #7
    2fc8:	18d3      	adds	r3, r2, r3
    2fca:	3308      	adds	r3, #8
    2fcc:	687a      	ldr	r2, [r7, #4]
    2fce:	601a      	str	r2, [r3, #0]
}
    2fd0:	46c0      	nop			; (mov r8, r8)
    2fd2:	46bd      	mov	sp, r7
    2fd4:	b004      	add	sp, #16
    2fd6:	bd80      	pop	{r7, pc}

00002fd8 <hri_port_clear_DIR_reg>:
	((Port *)hw)->Group[submodule_index].DIRSET.reg = data;
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = ~data;
}

static inline void hri_port_clear_DIR_reg(const void *const hw, uint8_t submodule_index, hri_port_dir_reg_t mask)
{
    2fd8:	b580      	push	{r7, lr}
    2fda:	b084      	sub	sp, #16
    2fdc:	af00      	add	r7, sp, #0
    2fde:	60f8      	str	r0, [r7, #12]
    2fe0:	607a      	str	r2, [r7, #4]
    2fe2:	230b      	movs	r3, #11
    2fe4:	18fb      	adds	r3, r7, r3
    2fe6:	1c0a      	adds	r2, r1, #0
    2fe8:	701a      	strb	r2, [r3, #0]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    2fea:	230b      	movs	r3, #11
    2fec:	18fb      	adds	r3, r7, r3
    2fee:	781b      	ldrb	r3, [r3, #0]
    2ff0:	68fa      	ldr	r2, [r7, #12]
    2ff2:	01db      	lsls	r3, r3, #7
    2ff4:	18d3      	adds	r3, r2, r3
    2ff6:	3304      	adds	r3, #4
    2ff8:	687a      	ldr	r2, [r7, #4]
    2ffa:	601a      	str	r2, [r3, #0]
}
    2ffc:	46c0      	nop			; (mov r8, r8)
    2ffe:	46bd      	mov	sp, r7
    3000:	b004      	add	sp, #16
    3002:	bd80      	pop	{r7, pc}

00003004 <hri_port_set_OUT_reg>:
{
	((Port *)hw)->Group[submodule_index].OUTTGL.reg = PORT_OUT_OUT(mask);
}

static inline void hri_port_set_OUT_reg(const void *const hw, uint8_t submodule_index, hri_port_out_reg_t mask)
{
    3004:	b580      	push	{r7, lr}
    3006:	b084      	sub	sp, #16
    3008:	af00      	add	r7, sp, #0
    300a:	60f8      	str	r0, [r7, #12]
    300c:	607a      	str	r2, [r7, #4]
    300e:	230b      	movs	r3, #11
    3010:	18fb      	adds	r3, r7, r3
    3012:	1c0a      	adds	r2, r1, #0
    3014:	701a      	strb	r2, [r3, #0]
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    3016:	230b      	movs	r3, #11
    3018:	18fb      	adds	r3, r7, r3
    301a:	781b      	ldrb	r3, [r3, #0]
    301c:	68fa      	ldr	r2, [r7, #12]
    301e:	01db      	lsls	r3, r3, #7
    3020:	18d3      	adds	r3, r2, r3
    3022:	3318      	adds	r3, #24
    3024:	687a      	ldr	r2, [r7, #4]
    3026:	601a      	str	r2, [r3, #0]
}
    3028:	46c0      	nop			; (mov r8, r8)
    302a:	46bd      	mov	sp, r7
    302c:	b004      	add	sp, #16
    302e:	bd80      	pop	{r7, pc}

00003030 <hri_port_clear_OUT_reg>:
	((Port *)hw)->Group[submodule_index].OUTSET.reg = data;
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = ~data;
}

static inline void hri_port_clear_OUT_reg(const void *const hw, uint8_t submodule_index, hri_port_out_reg_t mask)
{
    3030:	b580      	push	{r7, lr}
    3032:	b084      	sub	sp, #16
    3034:	af00      	add	r7, sp, #0
    3036:	60f8      	str	r0, [r7, #12]
    3038:	607a      	str	r2, [r7, #4]
    303a:	230b      	movs	r3, #11
    303c:	18fb      	adds	r3, r7, r3
    303e:	1c0a      	adds	r2, r1, #0
    3040:	701a      	strb	r2, [r3, #0]
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    3042:	230b      	movs	r3, #11
    3044:	18fb      	adds	r3, r7, r3
    3046:	781b      	ldrb	r3, [r3, #0]
    3048:	68fa      	ldr	r2, [r7, #12]
    304a:	01db      	lsls	r3, r3, #7
    304c:	18d3      	adds	r3, r2, r3
    304e:	3314      	adds	r3, #20
    3050:	687a      	ldr	r2, [r7, #4]
    3052:	601a      	str	r2, [r3, #0]
}
    3054:	46c0      	nop			; (mov r8, r8)
    3056:	46bd      	mov	sp, r7
    3058:	b004      	add	sp, #16
    305a:	bd80      	pop	{r7, pc}

0000305c <hri_port_write_PMUX_PMUXE_bf>:
	return tmp;
}

static inline void hri_port_write_PMUX_PMUXE_bf(const void *const hw, uint8_t submodule_index, uint8_t index,
                                                hri_port_pmux_reg_t data)
{
    305c:	b590      	push	{r4, r7, lr}
    305e:	b085      	sub	sp, #20
    3060:	af00      	add	r7, sp, #0
    3062:	6078      	str	r0, [r7, #4]
    3064:	000c      	movs	r4, r1
    3066:	0010      	movs	r0, r2
    3068:	0019      	movs	r1, r3
    306a:	1cfb      	adds	r3, r7, #3
    306c:	1c22      	adds	r2, r4, #0
    306e:	701a      	strb	r2, [r3, #0]
    3070:	1cbb      	adds	r3, r7, #2
    3072:	1c02      	adds	r2, r0, #0
    3074:	701a      	strb	r2, [r3, #0]
    3076:	1c7b      	adds	r3, r7, #1
    3078:	1c0a      	adds	r2, r1, #0
    307a:	701a      	strb	r2, [r3, #0]
	uint8_t tmp;
	PORT_CRITICAL_SECTION_ENTER();
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
    307c:	1cfb      	adds	r3, r7, #3
    307e:	7819      	ldrb	r1, [r3, #0]
    3080:	1cbb      	adds	r3, r7, #2
    3082:	781a      	ldrb	r2, [r3, #0]
    3084:	230f      	movs	r3, #15
    3086:	18fb      	adds	r3, r7, r3
    3088:	6878      	ldr	r0, [r7, #4]
    308a:	2430      	movs	r4, #48	; 0x30
    308c:	01c9      	lsls	r1, r1, #7
    308e:	1841      	adds	r1, r0, r1
    3090:	188a      	adds	r2, r1, r2
    3092:	1912      	adds	r2, r2, r4
    3094:	7812      	ldrb	r2, [r2, #0]
    3096:	701a      	strb	r2, [r3, #0]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
    3098:	230f      	movs	r3, #15
    309a:	18fb      	adds	r3, r7, r3
    309c:	220f      	movs	r2, #15
    309e:	18ba      	adds	r2, r7, r2
    30a0:	7812      	ldrb	r2, [r2, #0]
    30a2:	210f      	movs	r1, #15
    30a4:	438a      	bics	r2, r1
    30a6:	701a      	strb	r2, [r3, #0]
	tmp |= PORT_PMUX_PMUXE(data);
    30a8:	1c7b      	adds	r3, r7, #1
    30aa:	781b      	ldrb	r3, [r3, #0]
    30ac:	220f      	movs	r2, #15
    30ae:	4013      	ands	r3, r2
    30b0:	b2d9      	uxtb	r1, r3
    30b2:	230f      	movs	r3, #15
    30b4:	18fb      	adds	r3, r7, r3
    30b6:	220f      	movs	r2, #15
    30b8:	18ba      	adds	r2, r7, r2
    30ba:	7812      	ldrb	r2, [r2, #0]
    30bc:	430a      	orrs	r2, r1
    30be:	701a      	strb	r2, [r3, #0]
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
    30c0:	1cfb      	adds	r3, r7, #3
    30c2:	781a      	ldrb	r2, [r3, #0]
    30c4:	1cbb      	adds	r3, r7, #2
    30c6:	781b      	ldrb	r3, [r3, #0]
    30c8:	6879      	ldr	r1, [r7, #4]
    30ca:	2030      	movs	r0, #48	; 0x30
    30cc:	01d2      	lsls	r2, r2, #7
    30ce:	188a      	adds	r2, r1, r2
    30d0:	18d3      	adds	r3, r2, r3
    30d2:	181b      	adds	r3, r3, r0
    30d4:	220f      	movs	r2, #15
    30d6:	18ba      	adds	r2, r7, r2
    30d8:	7812      	ldrb	r2, [r2, #0]
    30da:	701a      	strb	r2, [r3, #0]
	PORT_CRITICAL_SECTION_LEAVE();
}
    30dc:	46c0      	nop			; (mov r8, r8)
    30de:	46bd      	mov	sp, r7
    30e0:	b005      	add	sp, #20
    30e2:	bd90      	pop	{r4, r7, pc}

000030e4 <hri_port_write_PMUX_PMUXO_bf>:
	return tmp;
}

static inline void hri_port_write_PMUX_PMUXO_bf(const void *const hw, uint8_t submodule_index, uint8_t index,
                                                hri_port_pmux_reg_t data)
{
    30e4:	b590      	push	{r4, r7, lr}
    30e6:	b085      	sub	sp, #20
    30e8:	af00      	add	r7, sp, #0
    30ea:	6078      	str	r0, [r7, #4]
    30ec:	000c      	movs	r4, r1
    30ee:	0010      	movs	r0, r2
    30f0:	0019      	movs	r1, r3
    30f2:	1cfb      	adds	r3, r7, #3
    30f4:	1c22      	adds	r2, r4, #0
    30f6:	701a      	strb	r2, [r3, #0]
    30f8:	1cbb      	adds	r3, r7, #2
    30fa:	1c02      	adds	r2, r0, #0
    30fc:	701a      	strb	r2, [r3, #0]
    30fe:	1c7b      	adds	r3, r7, #1
    3100:	1c0a      	adds	r2, r1, #0
    3102:	701a      	strb	r2, [r3, #0]
	uint8_t tmp;
	PORT_CRITICAL_SECTION_ENTER();
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
    3104:	1cfb      	adds	r3, r7, #3
    3106:	7819      	ldrb	r1, [r3, #0]
    3108:	1cbb      	adds	r3, r7, #2
    310a:	781a      	ldrb	r2, [r3, #0]
    310c:	230f      	movs	r3, #15
    310e:	18fb      	adds	r3, r7, r3
    3110:	6878      	ldr	r0, [r7, #4]
    3112:	2430      	movs	r4, #48	; 0x30
    3114:	01c9      	lsls	r1, r1, #7
    3116:	1841      	adds	r1, r0, r1
    3118:	188a      	adds	r2, r1, r2
    311a:	1912      	adds	r2, r2, r4
    311c:	7812      	ldrb	r2, [r2, #0]
    311e:	701a      	strb	r2, [r3, #0]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
    3120:	230f      	movs	r3, #15
    3122:	18fb      	adds	r3, r7, r3
    3124:	220f      	movs	r2, #15
    3126:	18ba      	adds	r2, r7, r2
    3128:	7812      	ldrb	r2, [r2, #0]
    312a:	210f      	movs	r1, #15
    312c:	400a      	ands	r2, r1
    312e:	701a      	strb	r2, [r3, #0]
	tmp |= PORT_PMUX_PMUXO(data);
    3130:	1c7b      	adds	r3, r7, #1
    3132:	781b      	ldrb	r3, [r3, #0]
    3134:	011b      	lsls	r3, r3, #4
    3136:	b2d9      	uxtb	r1, r3
    3138:	230f      	movs	r3, #15
    313a:	18fb      	adds	r3, r7, r3
    313c:	220f      	movs	r2, #15
    313e:	18ba      	adds	r2, r7, r2
    3140:	7812      	ldrb	r2, [r2, #0]
    3142:	430a      	orrs	r2, r1
    3144:	701a      	strb	r2, [r3, #0]
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
    3146:	1cfb      	adds	r3, r7, #3
    3148:	781a      	ldrb	r2, [r3, #0]
    314a:	1cbb      	adds	r3, r7, #2
    314c:	781b      	ldrb	r3, [r3, #0]
    314e:	6879      	ldr	r1, [r7, #4]
    3150:	2030      	movs	r0, #48	; 0x30
    3152:	01d2      	lsls	r2, r2, #7
    3154:	188a      	adds	r2, r1, r2
    3156:	18d3      	adds	r3, r2, r3
    3158:	181b      	adds	r3, r3, r0
    315a:	220f      	movs	r2, #15
    315c:	18ba      	adds	r2, r7, r2
    315e:	7812      	ldrb	r2, [r2, #0]
    3160:	701a      	strb	r2, [r3, #0]
	PORT_CRITICAL_SECTION_LEAVE();
}
    3162:	46c0      	nop			; (mov r8, r8)
    3164:	46bd      	mov	sp, r7
    3166:	b005      	add	sp, #20
    3168:	bd90      	pop	{r4, r7, pc}

0000316a <hri_port_write_PINCFG_PMUXEN_bit>:
	return (bool)tmp;
}

static inline void hri_port_write_PINCFG_PMUXEN_bit(const void *const hw, uint8_t submodule_index, uint8_t index,
                                                    bool value)
{
    316a:	b590      	push	{r4, r7, lr}
    316c:	b085      	sub	sp, #20
    316e:	af00      	add	r7, sp, #0
    3170:	6078      	str	r0, [r7, #4]
    3172:	000c      	movs	r4, r1
    3174:	0010      	movs	r0, r2
    3176:	0019      	movs	r1, r3
    3178:	1cfb      	adds	r3, r7, #3
    317a:	1c22      	adds	r2, r4, #0
    317c:	701a      	strb	r2, [r3, #0]
    317e:	1cbb      	adds	r3, r7, #2
    3180:	1c02      	adds	r2, r0, #0
    3182:	701a      	strb	r2, [r3, #0]
    3184:	1c7b      	adds	r3, r7, #1
    3186:	1c0a      	adds	r2, r1, #0
    3188:	701a      	strb	r2, [r3, #0]
	uint8_t tmp;
	PORT_CRITICAL_SECTION_ENTER();
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    318a:	1cfb      	adds	r3, r7, #3
    318c:	7819      	ldrb	r1, [r3, #0]
    318e:	1cbb      	adds	r3, r7, #2
    3190:	781a      	ldrb	r2, [r3, #0]
    3192:	230f      	movs	r3, #15
    3194:	18fb      	adds	r3, r7, r3
    3196:	6878      	ldr	r0, [r7, #4]
    3198:	2440      	movs	r4, #64	; 0x40
    319a:	01c9      	lsls	r1, r1, #7
    319c:	1841      	adds	r1, r0, r1
    319e:	188a      	adds	r2, r1, r2
    31a0:	1912      	adds	r2, r2, r4
    31a2:	7812      	ldrb	r2, [r2, #0]
    31a4:	701a      	strb	r2, [r3, #0]
	tmp &= ~PORT_PINCFG_PMUXEN;
    31a6:	230f      	movs	r3, #15
    31a8:	18fb      	adds	r3, r7, r3
    31aa:	220f      	movs	r2, #15
    31ac:	18ba      	adds	r2, r7, r2
    31ae:	7812      	ldrb	r2, [r2, #0]
    31b0:	2101      	movs	r1, #1
    31b2:	438a      	bics	r2, r1
    31b4:	701a      	strb	r2, [r3, #0]
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
    31b6:	1c7b      	adds	r3, r7, #1
    31b8:	7819      	ldrb	r1, [r3, #0]
    31ba:	230f      	movs	r3, #15
    31bc:	18fb      	adds	r3, r7, r3
    31be:	220f      	movs	r2, #15
    31c0:	18ba      	adds	r2, r7, r2
    31c2:	7812      	ldrb	r2, [r2, #0]
    31c4:	430a      	orrs	r2, r1
    31c6:	701a      	strb	r2, [r3, #0]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    31c8:	1cfb      	adds	r3, r7, #3
    31ca:	781a      	ldrb	r2, [r3, #0]
    31cc:	1cbb      	adds	r3, r7, #2
    31ce:	781b      	ldrb	r3, [r3, #0]
    31d0:	6879      	ldr	r1, [r7, #4]
    31d2:	2040      	movs	r0, #64	; 0x40
    31d4:	01d2      	lsls	r2, r2, #7
    31d6:	188a      	adds	r2, r1, r2
    31d8:	18d3      	adds	r3, r2, r3
    31da:	181b      	adds	r3, r3, r0
    31dc:	220f      	movs	r2, #15
    31de:	18ba      	adds	r2, r7, r2
    31e0:	7812      	ldrb	r2, [r2, #0]
    31e2:	701a      	strb	r2, [r3, #0]
	PORT_CRITICAL_SECTION_LEAVE();
}
    31e4:	46c0      	nop			; (mov r8, r8)
    31e6:	46bd      	mov	sp, r7
    31e8:	b005      	add	sp, #20
    31ea:	bd90      	pop	{r4, r7, pc}

000031ec <hri_port_set_PINCFG_PULLEN_bit>:
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg ^= PORT_PINCFG_INEN;
	PORT_CRITICAL_SECTION_LEAVE();
}

static inline void hri_port_set_PINCFG_PULLEN_bit(const void *const hw, uint8_t submodule_index, uint8_t index)
{
    31ec:	b5b0      	push	{r4, r5, r7, lr}
    31ee:	b082      	sub	sp, #8
    31f0:	af00      	add	r7, sp, #0
    31f2:	6078      	str	r0, [r7, #4]
    31f4:	0008      	movs	r0, r1
    31f6:	0011      	movs	r1, r2
    31f8:	1cfb      	adds	r3, r7, #3
    31fa:	1c02      	adds	r2, r0, #0
    31fc:	701a      	strb	r2, [r3, #0]
    31fe:	1cbb      	adds	r3, r7, #2
    3200:	1c0a      	adds	r2, r1, #0
    3202:	701a      	strb	r2, [r3, #0]
	PORT_CRITICAL_SECTION_ENTER();
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg |= PORT_PINCFG_PULLEN;
    3204:	1cfb      	adds	r3, r7, #3
    3206:	781a      	ldrb	r2, [r3, #0]
    3208:	1cbb      	adds	r3, r7, #2
    320a:	781b      	ldrb	r3, [r3, #0]
    320c:	1cf9      	adds	r1, r7, #3
    320e:	7808      	ldrb	r0, [r1, #0]
    3210:	1cb9      	adds	r1, r7, #2
    3212:	7809      	ldrb	r1, [r1, #0]
    3214:	687c      	ldr	r4, [r7, #4]
    3216:	2540      	movs	r5, #64	; 0x40
    3218:	01c0      	lsls	r0, r0, #7
    321a:	1820      	adds	r0, r4, r0
    321c:	1841      	adds	r1, r0, r1
    321e:	1949      	adds	r1, r1, r5
    3220:	7809      	ldrb	r1, [r1, #0]
    3222:	b2c9      	uxtb	r1, r1
    3224:	2004      	movs	r0, #4
    3226:	4301      	orrs	r1, r0
    3228:	b2cc      	uxtb	r4, r1
    322a:	6879      	ldr	r1, [r7, #4]
    322c:	2040      	movs	r0, #64	; 0x40
    322e:	01d2      	lsls	r2, r2, #7
    3230:	188a      	adds	r2, r1, r2
    3232:	18d3      	adds	r3, r2, r3
    3234:	181b      	adds	r3, r3, r0
    3236:	1c22      	adds	r2, r4, #0
    3238:	701a      	strb	r2, [r3, #0]
	PORT_CRITICAL_SECTION_LEAVE();
}
    323a:	46c0      	nop			; (mov r8, r8)
    323c:	46bd      	mov	sp, r7
    323e:	b002      	add	sp, #8
    3240:	bdb0      	pop	{r4, r5, r7, pc}

00003242 <hri_port_clear_PINCFG_PULLEN_bit>:
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
	PORT_CRITICAL_SECTION_LEAVE();
}

static inline void hri_port_clear_PINCFG_PULLEN_bit(const void *const hw, uint8_t submodule_index, uint8_t index)
{
    3242:	b5b0      	push	{r4, r5, r7, lr}
    3244:	b082      	sub	sp, #8
    3246:	af00      	add	r7, sp, #0
    3248:	6078      	str	r0, [r7, #4]
    324a:	0008      	movs	r0, r1
    324c:	0011      	movs	r1, r2
    324e:	1cfb      	adds	r3, r7, #3
    3250:	1c02      	adds	r2, r0, #0
    3252:	701a      	strb	r2, [r3, #0]
    3254:	1cbb      	adds	r3, r7, #2
    3256:	1c0a      	adds	r2, r1, #0
    3258:	701a      	strb	r2, [r3, #0]
	PORT_CRITICAL_SECTION_ENTER();
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
    325a:	1cfb      	adds	r3, r7, #3
    325c:	781a      	ldrb	r2, [r3, #0]
    325e:	1cbb      	adds	r3, r7, #2
    3260:	781b      	ldrb	r3, [r3, #0]
    3262:	1cf9      	adds	r1, r7, #3
    3264:	7808      	ldrb	r0, [r1, #0]
    3266:	1cb9      	adds	r1, r7, #2
    3268:	7809      	ldrb	r1, [r1, #0]
    326a:	687c      	ldr	r4, [r7, #4]
    326c:	2540      	movs	r5, #64	; 0x40
    326e:	01c0      	lsls	r0, r0, #7
    3270:	1820      	adds	r0, r4, r0
    3272:	1841      	adds	r1, r0, r1
    3274:	1949      	adds	r1, r1, r5
    3276:	7809      	ldrb	r1, [r1, #0]
    3278:	b2c9      	uxtb	r1, r1
    327a:	2004      	movs	r0, #4
    327c:	4381      	bics	r1, r0
    327e:	b2cc      	uxtb	r4, r1
    3280:	6879      	ldr	r1, [r7, #4]
    3282:	2040      	movs	r0, #64	; 0x40
    3284:	01d2      	lsls	r2, r2, #7
    3286:	188a      	adds	r2, r1, r2
    3288:	18d3      	adds	r3, r2, r3
    328a:	181b      	adds	r3, r3, r0
    328c:	1c22      	adds	r2, r4, #0
    328e:	701a      	strb	r2, [r3, #0]
	PORT_CRITICAL_SECTION_LEAVE();
}
    3290:	46c0      	nop			; (mov r8, r8)
    3292:	46bd      	mov	sp, r7
    3294:	b002      	add	sp, #8
    3296:	bdb0      	pop	{r4, r5, r7, pc}

00003298 <hri_port_write_WRCONFIG_reg>:
	return ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
}

static inline void hri_port_write_WRCONFIG_reg(const void *const hw, uint8_t submodule_index,
                                               hri_port_wrconfig_reg_t data)
{
    3298:	b580      	push	{r7, lr}
    329a:	b084      	sub	sp, #16
    329c:	af00      	add	r7, sp, #0
    329e:	60f8      	str	r0, [r7, #12]
    32a0:	607a      	str	r2, [r7, #4]
    32a2:	230b      	movs	r3, #11
    32a4:	18fb      	adds	r3, r7, r3
    32a6:	1c0a      	adds	r2, r1, #0
    32a8:	701a      	strb	r2, [r3, #0]
	PORT_CRITICAL_SECTION_ENTER();
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    32aa:	230b      	movs	r3, #11
    32ac:	18fb      	adds	r3, r7, r3
    32ae:	781b      	ldrb	r3, [r3, #0]
    32b0:	68fa      	ldr	r2, [r7, #12]
    32b2:	01db      	lsls	r3, r3, #7
    32b4:	18d3      	adds	r3, r2, r3
    32b6:	3328      	adds	r3, #40	; 0x28
    32b8:	687a      	ldr	r2, [r7, #4]
    32ba:	601a      	str	r2, [r3, #0]
	PORT_CRITICAL_SECTION_LEAVE();
}
    32bc:	46c0      	nop			; (mov r8, r8)
    32be:	46bd      	mov	sp, r7
    32c0:	b004      	add	sp, #16
    32c2:	bd80      	pop	{r7, pc}

000032c4 <_gpio_set_direction>:
/**
 * \brief Set direction on port with mask
 */
static inline void _gpio_set_direction(const enum gpio_port port, const uint32_t mask,
                                       const enum gpio_direction direction)
{
    32c4:	b580      	push	{r7, lr}
    32c6:	b082      	sub	sp, #8
    32c8:	af00      	add	r7, sp, #0
    32ca:	6039      	str	r1, [r7, #0]
    32cc:	0011      	movs	r1, r2
    32ce:	1dfb      	adds	r3, r7, #7
    32d0:	1c02      	adds	r2, r0, #0
    32d2:	701a      	strb	r2, [r3, #0]
    32d4:	1dbb      	adds	r3, r7, #6
    32d6:	1c0a      	adds	r2, r1, #0
    32d8:	701a      	strb	r2, [r3, #0]
	switch (direction) {
    32da:	1dbb      	adds	r3, r7, #6
    32dc:	781b      	ldrb	r3, [r3, #0]
    32de:	2b01      	cmp	r3, #1
    32e0:	d023      	beq.n	332a <_gpio_set_direction+0x66>
    32e2:	2b02      	cmp	r3, #2
    32e4:	d03f      	beq.n	3366 <_gpio_set_direction+0xa2>
    32e6:	2b00      	cmp	r3, #0
    32e8:	d15d      	bne.n	33a6 <_gpio_set_direction+0xe2>
	case GPIO_DIRECTION_OFF:
		hri_port_clear_DIR_reg(PORT_IOBUS, port, mask);
    32ea:	683a      	ldr	r2, [r7, #0]
    32ec:	1dfb      	adds	r3, r7, #7
    32ee:	7819      	ldrb	r1, [r3, #0]
    32f0:	23c0      	movs	r3, #192	; 0xc0
    32f2:	05db      	lsls	r3, r3, #23
    32f4:	0018      	movs	r0, r3
    32f6:	f7ff fe6f 	bl	2fd8 <hri_port_clear_DIR_reg>
		hri_port_write_WRCONFIG_reg(PORT, port, PORT_WRCONFIG_WRPINCFG | (mask & 0xffff));
    32fa:	683b      	ldr	r3, [r7, #0]
    32fc:	041b      	lsls	r3, r3, #16
    32fe:	0c1b      	lsrs	r3, r3, #16
    3300:	2280      	movs	r2, #128	; 0x80
    3302:	05d2      	lsls	r2, r2, #23
    3304:	431a      	orrs	r2, r3
    3306:	1dfb      	adds	r3, r7, #7
    3308:	781b      	ldrb	r3, [r3, #0]
    330a:	482c      	ldr	r0, [pc, #176]	; (33bc <_gpio_set_direction+0xf8>)
    330c:	0019      	movs	r1, r3
    330e:	f7ff ffc3 	bl	3298 <hri_port_write_WRCONFIG_reg>
		hri_port_write_WRCONFIG_reg(
		    PORT, port, PORT_WRCONFIG_HWSEL | PORT_WRCONFIG_WRPINCFG | ((mask & 0xffff0000) >> 16));
    3312:	683b      	ldr	r3, [r7, #0]
    3314:	0c1b      	lsrs	r3, r3, #16
		hri_port_write_WRCONFIG_reg(
    3316:	22c0      	movs	r2, #192	; 0xc0
    3318:	0612      	lsls	r2, r2, #24
    331a:	431a      	orrs	r2, r3
    331c:	1dfb      	adds	r3, r7, #7
    331e:	781b      	ldrb	r3, [r3, #0]
    3320:	4826      	ldr	r0, [pc, #152]	; (33bc <_gpio_set_direction+0xf8>)
    3322:	0019      	movs	r1, r3
    3324:	f7ff ffb8 	bl	3298 <hri_port_write_WRCONFIG_reg>
		break;
    3328:	e043      	b.n	33b2 <_gpio_set_direction+0xee>

	case GPIO_DIRECTION_IN:
		hri_port_clear_DIR_reg(PORT_IOBUS, port, mask);
    332a:	683a      	ldr	r2, [r7, #0]
    332c:	1dfb      	adds	r3, r7, #7
    332e:	7819      	ldrb	r1, [r3, #0]
    3330:	23c0      	movs	r3, #192	; 0xc0
    3332:	05db      	lsls	r3, r3, #23
    3334:	0018      	movs	r0, r3
    3336:	f7ff fe4f 	bl	2fd8 <hri_port_clear_DIR_reg>
		hri_port_write_WRCONFIG_reg(PORT, port, PORT_WRCONFIG_WRPINCFG | PORT_WRCONFIG_INEN | (mask & 0xffff));
    333a:	683b      	ldr	r3, [r7, #0]
    333c:	041b      	lsls	r3, r3, #16
    333e:	0c1b      	lsrs	r3, r3, #16
    3340:	4a1f      	ldr	r2, [pc, #124]	; (33c0 <_gpio_set_direction+0xfc>)
    3342:	431a      	orrs	r2, r3
    3344:	1dfb      	adds	r3, r7, #7
    3346:	781b      	ldrb	r3, [r3, #0]
    3348:	481c      	ldr	r0, [pc, #112]	; (33bc <_gpio_set_direction+0xf8>)
    334a:	0019      	movs	r1, r3
    334c:	f7ff ffa4 	bl	3298 <hri_port_write_WRCONFIG_reg>
		hri_port_write_WRCONFIG_reg(PORT,
		                            port,
		                            PORT_WRCONFIG_HWSEL | PORT_WRCONFIG_WRPINCFG | PORT_WRCONFIG_INEN
		                                | ((mask & 0xffff0000) >> 16));
    3350:	683b      	ldr	r3, [r7, #0]
    3352:	0c1b      	lsrs	r3, r3, #16
		hri_port_write_WRCONFIG_reg(PORT,
    3354:	4a1b      	ldr	r2, [pc, #108]	; (33c4 <_gpio_set_direction+0x100>)
    3356:	431a      	orrs	r2, r3
    3358:	1dfb      	adds	r3, r7, #7
    335a:	781b      	ldrb	r3, [r3, #0]
    335c:	4817      	ldr	r0, [pc, #92]	; (33bc <_gpio_set_direction+0xf8>)
    335e:	0019      	movs	r1, r3
    3360:	f7ff ff9a 	bl	3298 <hri_port_write_WRCONFIG_reg>
		break;
    3364:	e025      	b.n	33b2 <_gpio_set_direction+0xee>

	case GPIO_DIRECTION_OUT:
		hri_port_set_DIR_reg(PORT_IOBUS, port, mask);
    3366:	683a      	ldr	r2, [r7, #0]
    3368:	1dfb      	adds	r3, r7, #7
    336a:	7819      	ldrb	r1, [r3, #0]
    336c:	23c0      	movs	r3, #192	; 0xc0
    336e:	05db      	lsls	r3, r3, #23
    3370:	0018      	movs	r0, r3
    3372:	f7ff fe1b 	bl	2fac <hri_port_set_DIR_reg>
		hri_port_write_WRCONFIG_reg(PORT, port, PORT_WRCONFIG_WRPINCFG | (mask & 0xffff));
    3376:	683b      	ldr	r3, [r7, #0]
    3378:	041b      	lsls	r3, r3, #16
    337a:	0c1b      	lsrs	r3, r3, #16
    337c:	2280      	movs	r2, #128	; 0x80
    337e:	05d2      	lsls	r2, r2, #23
    3380:	431a      	orrs	r2, r3
    3382:	1dfb      	adds	r3, r7, #7
    3384:	781b      	ldrb	r3, [r3, #0]
    3386:	480d      	ldr	r0, [pc, #52]	; (33bc <_gpio_set_direction+0xf8>)
    3388:	0019      	movs	r1, r3
    338a:	f7ff ff85 	bl	3298 <hri_port_write_WRCONFIG_reg>
		hri_port_write_WRCONFIG_reg(
		    PORT, port, PORT_WRCONFIG_HWSEL | PORT_WRCONFIG_WRPINCFG | ((mask & 0xffff0000) >> 16));
    338e:	683b      	ldr	r3, [r7, #0]
    3390:	0c1b      	lsrs	r3, r3, #16
		hri_port_write_WRCONFIG_reg(
    3392:	22c0      	movs	r2, #192	; 0xc0
    3394:	0612      	lsls	r2, r2, #24
    3396:	431a      	orrs	r2, r3
    3398:	1dfb      	adds	r3, r7, #7
    339a:	781b      	ldrb	r3, [r3, #0]
    339c:	4807      	ldr	r0, [pc, #28]	; (33bc <_gpio_set_direction+0xf8>)
    339e:	0019      	movs	r1, r3
    33a0:	f7ff ff7a 	bl	3298 <hri_port_write_WRCONFIG_reg>
		break;
    33a4:	e005      	b.n	33b2 <_gpio_set_direction+0xee>

	default:
		ASSERT(false);
    33a6:	4b08      	ldr	r3, [pc, #32]	; (33c8 <_gpio_set_direction+0x104>)
    33a8:	2245      	movs	r2, #69	; 0x45
    33aa:	0019      	movs	r1, r3
    33ac:	2000      	movs	r0, #0
    33ae:	f000 ffd7 	bl	4360 <assert>
	}
}
    33b2:	46c0      	nop			; (mov r8, r8)
    33b4:	46bd      	mov	sp, r7
    33b6:	b002      	add	sp, #8
    33b8:	bd80      	pop	{r7, pc}
    33ba:	46c0      	nop			; (mov r8, r8)
    33bc:	41004400 	.word	0x41004400
    33c0:	40020000 	.word	0x40020000
    33c4:	c0020000 	.word	0xc0020000
    33c8:	00008edc 	.word	0x00008edc

000033cc <_gpio_set_level>:

/**
 * \brief Set output level on port with mask
 */
static inline void _gpio_set_level(const enum gpio_port port, const uint32_t mask, const bool level)
{
    33cc:	b580      	push	{r7, lr}
    33ce:	b082      	sub	sp, #8
    33d0:	af00      	add	r7, sp, #0
    33d2:	6039      	str	r1, [r7, #0]
    33d4:	0011      	movs	r1, r2
    33d6:	1dfb      	adds	r3, r7, #7
    33d8:	1c02      	adds	r2, r0, #0
    33da:	701a      	strb	r2, [r3, #0]
    33dc:	1dbb      	adds	r3, r7, #6
    33de:	1c0a      	adds	r2, r1, #0
    33e0:	701a      	strb	r2, [r3, #0]
	if (level) {
    33e2:	1dbb      	adds	r3, r7, #6
    33e4:	781b      	ldrb	r3, [r3, #0]
    33e6:	2b00      	cmp	r3, #0
    33e8:	d008      	beq.n	33fc <_gpio_set_level+0x30>
		hri_port_set_OUT_reg(PORT_IOBUS, port, mask);
    33ea:	683a      	ldr	r2, [r7, #0]
    33ec:	1dfb      	adds	r3, r7, #7
    33ee:	7819      	ldrb	r1, [r3, #0]
    33f0:	23c0      	movs	r3, #192	; 0xc0
    33f2:	05db      	lsls	r3, r3, #23
    33f4:	0018      	movs	r0, r3
    33f6:	f7ff fe05 	bl	3004 <hri_port_set_OUT_reg>
	} else {
		hri_port_clear_OUT_reg(PORT_IOBUS, port, mask);
	}
}
    33fa:	e007      	b.n	340c <_gpio_set_level+0x40>
		hri_port_clear_OUT_reg(PORT_IOBUS, port, mask);
    33fc:	683a      	ldr	r2, [r7, #0]
    33fe:	1dfb      	adds	r3, r7, #7
    3400:	7819      	ldrb	r1, [r3, #0]
    3402:	23c0      	movs	r3, #192	; 0xc0
    3404:	05db      	lsls	r3, r3, #23
    3406:	0018      	movs	r0, r3
    3408:	f7ff fe12 	bl	3030 <hri_port_clear_OUT_reg>
}
    340c:	46c0      	nop			; (mov r8, r8)
    340e:	46bd      	mov	sp, r7
    3410:	b002      	add	sp, #8
    3412:	bd80      	pop	{r7, pc}

00003414 <_gpio_set_pin_pull_mode>:
/**
 * \brief Set pin pull mode
 */
static inline void _gpio_set_pin_pull_mode(const enum gpio_port port, const uint8_t pin,
                                           const enum gpio_pull_mode pull_mode)
{
    3414:	b590      	push	{r4, r7, lr}
    3416:	b083      	sub	sp, #12
    3418:	af00      	add	r7, sp, #0
    341a:	0004      	movs	r4, r0
    341c:	0008      	movs	r0, r1
    341e:	0011      	movs	r1, r2
    3420:	1dfb      	adds	r3, r7, #7
    3422:	1c22      	adds	r2, r4, #0
    3424:	701a      	strb	r2, [r3, #0]
    3426:	1dbb      	adds	r3, r7, #6
    3428:	1c02      	adds	r2, r0, #0
    342a:	701a      	strb	r2, [r3, #0]
    342c:	1d7b      	adds	r3, r7, #5
    342e:	1c0a      	adds	r2, r1, #0
    3430:	701a      	strb	r2, [r3, #0]
	switch (pull_mode) {
    3432:	1d7b      	adds	r3, r7, #5
    3434:	781b      	ldrb	r3, [r3, #0]
    3436:	2b01      	cmp	r3, #1
    3438:	d00c      	beq.n	3454 <_gpio_set_pin_pull_mode+0x40>
    343a:	2b02      	cmp	r3, #2
    343c:	d029      	beq.n	3492 <_gpio_set_pin_pull_mode+0x7e>
    343e:	2b00      	cmp	r3, #0
    3440:	d146      	bne.n	34d0 <_gpio_set_pin_pull_mode+0xbc>
	case GPIO_PULL_OFF:
		hri_port_clear_PINCFG_PULLEN_bit(PORT, port, pin);
    3442:	1dbb      	adds	r3, r7, #6
    3444:	781a      	ldrb	r2, [r3, #0]
    3446:	1dfb      	adds	r3, r7, #7
    3448:	781b      	ldrb	r3, [r3, #0]
    344a:	4827      	ldr	r0, [pc, #156]	; (34e8 <_gpio_set_pin_pull_mode+0xd4>)
    344c:	0019      	movs	r1, r3
    344e:	f7ff fef8 	bl	3242 <hri_port_clear_PINCFG_PULLEN_bit>
		break;
    3452:	e044      	b.n	34de <_gpio_set_pin_pull_mode+0xca>

	case GPIO_PULL_UP:
		hri_port_clear_DIR_reg(PORT_IOBUS, port, 1U << pin);
    3454:	1dbb      	adds	r3, r7, #6
    3456:	781b      	ldrb	r3, [r3, #0]
    3458:	2201      	movs	r2, #1
    345a:	409a      	lsls	r2, r3
    345c:	1dfb      	adds	r3, r7, #7
    345e:	7819      	ldrb	r1, [r3, #0]
    3460:	23c0      	movs	r3, #192	; 0xc0
    3462:	05db      	lsls	r3, r3, #23
    3464:	0018      	movs	r0, r3
    3466:	f7ff fdb7 	bl	2fd8 <hri_port_clear_DIR_reg>
		hri_port_set_PINCFG_PULLEN_bit(PORT, port, pin);
    346a:	1dbb      	adds	r3, r7, #6
    346c:	781a      	ldrb	r2, [r3, #0]
    346e:	1dfb      	adds	r3, r7, #7
    3470:	781b      	ldrb	r3, [r3, #0]
    3472:	481d      	ldr	r0, [pc, #116]	; (34e8 <_gpio_set_pin_pull_mode+0xd4>)
    3474:	0019      	movs	r1, r3
    3476:	f7ff feb9 	bl	31ec <hri_port_set_PINCFG_PULLEN_bit>
		hri_port_set_OUT_reg(PORT_IOBUS, port, 1U << pin);
    347a:	1dbb      	adds	r3, r7, #6
    347c:	781b      	ldrb	r3, [r3, #0]
    347e:	2201      	movs	r2, #1
    3480:	409a      	lsls	r2, r3
    3482:	1dfb      	adds	r3, r7, #7
    3484:	7819      	ldrb	r1, [r3, #0]
    3486:	23c0      	movs	r3, #192	; 0xc0
    3488:	05db      	lsls	r3, r3, #23
    348a:	0018      	movs	r0, r3
    348c:	f7ff fdba 	bl	3004 <hri_port_set_OUT_reg>
		break;
    3490:	e025      	b.n	34de <_gpio_set_pin_pull_mode+0xca>

	case GPIO_PULL_DOWN:
		hri_port_clear_DIR_reg(PORT_IOBUS, port, 1U << pin);
    3492:	1dbb      	adds	r3, r7, #6
    3494:	781b      	ldrb	r3, [r3, #0]
    3496:	2201      	movs	r2, #1
    3498:	409a      	lsls	r2, r3
    349a:	1dfb      	adds	r3, r7, #7
    349c:	7819      	ldrb	r1, [r3, #0]
    349e:	23c0      	movs	r3, #192	; 0xc0
    34a0:	05db      	lsls	r3, r3, #23
    34a2:	0018      	movs	r0, r3
    34a4:	f7ff fd98 	bl	2fd8 <hri_port_clear_DIR_reg>
		hri_port_set_PINCFG_PULLEN_bit(PORT, port, pin);
    34a8:	1dbb      	adds	r3, r7, #6
    34aa:	781a      	ldrb	r2, [r3, #0]
    34ac:	1dfb      	adds	r3, r7, #7
    34ae:	781b      	ldrb	r3, [r3, #0]
    34b0:	480d      	ldr	r0, [pc, #52]	; (34e8 <_gpio_set_pin_pull_mode+0xd4>)
    34b2:	0019      	movs	r1, r3
    34b4:	f7ff fe9a 	bl	31ec <hri_port_set_PINCFG_PULLEN_bit>
		hri_port_clear_OUT_reg(PORT_IOBUS, port, 1U << pin);
    34b8:	1dbb      	adds	r3, r7, #6
    34ba:	781b      	ldrb	r3, [r3, #0]
    34bc:	2201      	movs	r2, #1
    34be:	409a      	lsls	r2, r3
    34c0:	1dfb      	adds	r3, r7, #7
    34c2:	7819      	ldrb	r1, [r3, #0]
    34c4:	23c0      	movs	r3, #192	; 0xc0
    34c6:	05db      	lsls	r3, r3, #23
    34c8:	0018      	movs	r0, r3
    34ca:	f7ff fdb1 	bl	3030 <hri_port_clear_OUT_reg>
		break;
    34ce:	e006      	b.n	34de <_gpio_set_pin_pull_mode+0xca>

	default:
		ASSERT(false);
    34d0:	4b06      	ldr	r3, [pc, #24]	; (34ec <_gpio_set_pin_pull_mode+0xd8>)
    34d2:	2288      	movs	r2, #136	; 0x88
    34d4:	0019      	movs	r1, r3
    34d6:	2000      	movs	r0, #0
    34d8:	f000 ff42 	bl	4360 <assert>
		break;
    34dc:	46c0      	nop			; (mov r8, r8)
	}
}
    34de:	46c0      	nop			; (mov r8, r8)
    34e0:	46bd      	mov	sp, r7
    34e2:	b003      	add	sp, #12
    34e4:	bd90      	pop	{r4, r7, pc}
    34e6:	46c0      	nop			; (mov r8, r8)
    34e8:	41004400 	.word	0x41004400
    34ec:	00008edc 	.word	0x00008edc

000034f0 <_gpio_set_pin_function>:

/**
 * \brief Set gpio pin function
 */
static inline void _gpio_set_pin_function(const uint32_t gpio, const uint32_t function)
{
    34f0:	b590      	push	{r4, r7, lr}
    34f2:	b085      	sub	sp, #20
    34f4:	af00      	add	r7, sp, #0
    34f6:	6078      	str	r0, [r7, #4]
    34f8:	6039      	str	r1, [r7, #0]
	uint8_t port = GPIO_PORT(gpio);
    34fa:	687b      	ldr	r3, [r7, #4]
    34fc:	095a      	lsrs	r2, r3, #5
    34fe:	230f      	movs	r3, #15
    3500:	18fb      	adds	r3, r7, r3
    3502:	701a      	strb	r2, [r3, #0]
	uint8_t pin  = GPIO_PIN(gpio);
    3504:	687b      	ldr	r3, [r7, #4]
    3506:	b2da      	uxtb	r2, r3
    3508:	230e      	movs	r3, #14
    350a:	18fb      	adds	r3, r7, r3
    350c:	211f      	movs	r1, #31
    350e:	400a      	ands	r2, r1
    3510:	701a      	strb	r2, [r3, #0]

	if (function == GPIO_PIN_FUNCTION_OFF) {
    3512:	683b      	ldr	r3, [r7, #0]
    3514:	3301      	adds	r3, #1
    3516:	d10a      	bne.n	352e <_gpio_set_pin_function+0x3e>
		hri_port_write_PINCFG_PMUXEN_bit(PORT, port, pin, false);
    3518:	230e      	movs	r3, #14
    351a:	18fb      	adds	r3, r7, r3
    351c:	781a      	ldrb	r2, [r3, #0]
    351e:	230f      	movs	r3, #15
    3520:	18fb      	adds	r3, r7, r3
    3522:	7819      	ldrb	r1, [r3, #0]
    3524:	481b      	ldr	r0, [pc, #108]	; (3594 <_gpio_set_pin_function+0xa4>)
    3526:	2300      	movs	r3, #0
    3528:	f7ff fe1f 	bl	316a <hri_port_write_PINCFG_PMUXEN_bit>
		} else {
			// Even numbered pin
			hri_port_write_PMUX_PMUXE_bf(PORT, port, pin >> 1, function & 0xffff);
		}
	}
}
    352c:	e02e      	b.n	358c <_gpio_set_pin_function+0x9c>
		hri_port_write_PINCFG_PMUXEN_bit(PORT, port, pin, true);
    352e:	230e      	movs	r3, #14
    3530:	18fb      	adds	r3, r7, r3
    3532:	781a      	ldrb	r2, [r3, #0]
    3534:	230f      	movs	r3, #15
    3536:	18fb      	adds	r3, r7, r3
    3538:	7819      	ldrb	r1, [r3, #0]
    353a:	4816      	ldr	r0, [pc, #88]	; (3594 <_gpio_set_pin_function+0xa4>)
    353c:	2301      	movs	r3, #1
    353e:	f7ff fe14 	bl	316a <hri_port_write_PINCFG_PMUXEN_bit>
		if (pin & 1) {
    3542:	230e      	movs	r3, #14
    3544:	18fb      	adds	r3, r7, r3
    3546:	781b      	ldrb	r3, [r3, #0]
    3548:	2201      	movs	r2, #1
    354a:	4013      	ands	r3, r2
    354c:	d00f      	beq.n	356e <_gpio_set_pin_function+0x7e>
			hri_port_write_PMUX_PMUXO_bf(PORT, port, pin >> 1, function & 0xffff);
    354e:	230e      	movs	r3, #14
    3550:	18fb      	adds	r3, r7, r3
    3552:	781b      	ldrb	r3, [r3, #0]
    3554:	085b      	lsrs	r3, r3, #1
    3556:	b2da      	uxtb	r2, r3
    3558:	683b      	ldr	r3, [r7, #0]
    355a:	b2d8      	uxtb	r0, r3
    355c:	230f      	movs	r3, #15
    355e:	18fb      	adds	r3, r7, r3
    3560:	7819      	ldrb	r1, [r3, #0]
    3562:	4c0c      	ldr	r4, [pc, #48]	; (3594 <_gpio_set_pin_function+0xa4>)
    3564:	0003      	movs	r3, r0
    3566:	0020      	movs	r0, r4
    3568:	f7ff fdbc 	bl	30e4 <hri_port_write_PMUX_PMUXO_bf>
}
    356c:	e00e      	b.n	358c <_gpio_set_pin_function+0x9c>
			hri_port_write_PMUX_PMUXE_bf(PORT, port, pin >> 1, function & 0xffff);
    356e:	230e      	movs	r3, #14
    3570:	18fb      	adds	r3, r7, r3
    3572:	781b      	ldrb	r3, [r3, #0]
    3574:	085b      	lsrs	r3, r3, #1
    3576:	b2da      	uxtb	r2, r3
    3578:	683b      	ldr	r3, [r7, #0]
    357a:	b2d8      	uxtb	r0, r3
    357c:	230f      	movs	r3, #15
    357e:	18fb      	adds	r3, r7, r3
    3580:	7819      	ldrb	r1, [r3, #0]
    3582:	4c04      	ldr	r4, [pc, #16]	; (3594 <_gpio_set_pin_function+0xa4>)
    3584:	0003      	movs	r3, r0
    3586:	0020      	movs	r0, r4
    3588:	f7ff fd68 	bl	305c <hri_port_write_PMUX_PMUXE_bf>
}
    358c:	46c0      	nop			; (mov r8, r8)
    358e:	46bd      	mov	sp, r7
    3590:	b005      	add	sp, #20
    3592:	bd90      	pop	{r4, r7, pc}
    3594:	41004400 	.word	0x41004400

00003598 <gpio_set_pin_pull_mode>:
 * \param[in] pull_mode GPIO_PULL_DOWN = Pull pin low with internal resistor
 *                      GPIO_PULL_UP   = Pull pin high with internal resistor
 *                      GPIO_PULL_OFF  = Disable pin pull mode
 */
static inline void gpio_set_pin_pull_mode(const uint8_t pin, const enum gpio_pull_mode pull_mode)
{
    3598:	b580      	push	{r7, lr}
    359a:	b082      	sub	sp, #8
    359c:	af00      	add	r7, sp, #0
    359e:	0002      	movs	r2, r0
    35a0:	1dfb      	adds	r3, r7, #7
    35a2:	701a      	strb	r2, [r3, #0]
    35a4:	1dbb      	adds	r3, r7, #6
    35a6:	1c0a      	adds	r2, r1, #0
    35a8:	701a      	strb	r2, [r3, #0]
	_gpio_set_pin_pull_mode((enum gpio_port)GPIO_PORT(pin), pin & 0x1F, pull_mode);
    35aa:	1dfb      	adds	r3, r7, #7
    35ac:	781b      	ldrb	r3, [r3, #0]
    35ae:	095b      	lsrs	r3, r3, #5
    35b0:	b2d8      	uxtb	r0, r3
    35b2:	1dfb      	adds	r3, r7, #7
    35b4:	781b      	ldrb	r3, [r3, #0]
    35b6:	221f      	movs	r2, #31
    35b8:	4013      	ands	r3, r2
    35ba:	b2d9      	uxtb	r1, r3
    35bc:	1dbb      	adds	r3, r7, #6
    35be:	781b      	ldrb	r3, [r3, #0]
    35c0:	001a      	movs	r2, r3
    35c2:	f7ff ff27 	bl	3414 <_gpio_set_pin_pull_mode>
}
    35c6:	46c0      	nop			; (mov r8, r8)
    35c8:	46bd      	mov	sp, r7
    35ca:	b002      	add	sp, #8
    35cc:	bd80      	pop	{r7, pc}

000035ce <gpio_set_pin_function>:
 * \param[in] function  The pin function is given by a 32-bit wide bitfield
 *                      found in the header files for the device
 *
 */
static inline void gpio_set_pin_function(const uint32_t pin, uint32_t function)
{
    35ce:	b580      	push	{r7, lr}
    35d0:	b082      	sub	sp, #8
    35d2:	af00      	add	r7, sp, #0
    35d4:	6078      	str	r0, [r7, #4]
    35d6:	6039      	str	r1, [r7, #0]
	_gpio_set_pin_function(pin, function);
    35d8:	683a      	ldr	r2, [r7, #0]
    35da:	687b      	ldr	r3, [r7, #4]
    35dc:	0011      	movs	r1, r2
    35de:	0018      	movs	r0, r3
    35e0:	f7ff ff86 	bl	34f0 <_gpio_set_pin_function>
}
    35e4:	46c0      	nop			; (mov r8, r8)
    35e6:	46bd      	mov	sp, r7
    35e8:	b002      	add	sp, #8
    35ea:	bd80      	pop	{r7, pc}

000035ec <gpio_set_pin_direction>:
 *                      GPIO_DIRECTION_OUT = Data direction out
 *                      GPIO_DIRECTION_OFF = Disables the pin
 *                      (low power state)
 */
static inline void gpio_set_pin_direction(const uint8_t pin, const enum gpio_direction direction)
{
    35ec:	b580      	push	{r7, lr}
    35ee:	b082      	sub	sp, #8
    35f0:	af00      	add	r7, sp, #0
    35f2:	0002      	movs	r2, r0
    35f4:	1dfb      	adds	r3, r7, #7
    35f6:	701a      	strb	r2, [r3, #0]
    35f8:	1dbb      	adds	r3, r7, #6
    35fa:	1c0a      	adds	r2, r1, #0
    35fc:	701a      	strb	r2, [r3, #0]
	_gpio_set_direction((enum gpio_port)GPIO_PORT(pin), 1U << GPIO_PIN(pin), direction);
    35fe:	1dfb      	adds	r3, r7, #7
    3600:	781b      	ldrb	r3, [r3, #0]
    3602:	095b      	lsrs	r3, r3, #5
    3604:	b2d8      	uxtb	r0, r3
    3606:	1dfb      	adds	r3, r7, #7
    3608:	781b      	ldrb	r3, [r3, #0]
    360a:	221f      	movs	r2, #31
    360c:	4013      	ands	r3, r2
    360e:	2201      	movs	r2, #1
    3610:	409a      	lsls	r2, r3
    3612:	0011      	movs	r1, r2
    3614:	1dbb      	adds	r3, r7, #6
    3616:	781b      	ldrb	r3, [r3, #0]
    3618:	001a      	movs	r2, r3
    361a:	f7ff fe53 	bl	32c4 <_gpio_set_direction>
}
    361e:	46c0      	nop			; (mov r8, r8)
    3620:	46bd      	mov	sp, r7
    3622:	b002      	add	sp, #8
    3624:	bd80      	pop	{r7, pc}

00003626 <gpio_set_pin_level>:
 * \param[in] pin       The pin number for device
 * \param[in] level true  = Pin level set to "high" state
 *                  false = Pin level set to "low" state
 */
static inline void gpio_set_pin_level(const uint8_t pin, const bool level)
{
    3626:	b580      	push	{r7, lr}
    3628:	b082      	sub	sp, #8
    362a:	af00      	add	r7, sp, #0
    362c:	0002      	movs	r2, r0
    362e:	1dfb      	adds	r3, r7, #7
    3630:	701a      	strb	r2, [r3, #0]
    3632:	1dbb      	adds	r3, r7, #6
    3634:	1c0a      	adds	r2, r1, #0
    3636:	701a      	strb	r2, [r3, #0]
	_gpio_set_level((enum gpio_port)GPIO_PORT(pin), 1U << GPIO_PIN(pin), level);
    3638:	1dfb      	adds	r3, r7, #7
    363a:	781b      	ldrb	r3, [r3, #0]
    363c:	095b      	lsrs	r3, r3, #5
    363e:	b2d8      	uxtb	r0, r3
    3640:	1dfb      	adds	r3, r7, #7
    3642:	781b      	ldrb	r3, [r3, #0]
    3644:	221f      	movs	r2, #31
    3646:	4013      	ands	r3, r2
    3648:	2201      	movs	r2, #1
    364a:	409a      	lsls	r2, r3
    364c:	0011      	movs	r1, r2
    364e:	1dbb      	adds	r3, r7, #6
    3650:	781b      	ldrb	r3, [r3, #0]
    3652:	001a      	movs	r2, r3
    3654:	f7ff feba 	bl	33cc <_gpio_set_level>
}
    3658:	46c0      	nop			; (mov r8, r8)
    365a:	46bd      	mov	sp, r7
    365c:	b002      	add	sp, #8
    365e:	bd80      	pop	{r7, pc}

00003660 <init_mcu>:
 * This function calls the various initialization functions.
 * Currently the following initialization functions are supported:
 *  - System clock initialization
 */
static inline void init_mcu(void)
{
    3660:	b580      	push	{r7, lr}
    3662:	af00      	add	r7, sp, #0
	_init_chip();
    3664:	f000 ff4a 	bl	44fc <_init_chip>
}
    3668:	46c0      	nop			; (mov r8, r8)
    366a:	46bd      	mov	sp, r7
    366c:	bd80      	pop	{r7, pc}
	...

00003670 <_gclk_enable_channel>:
 *
 * \param[in] channel The channel to enable clock for
 * \param[in] source The clock source for the given channel
 */
static inline void _gclk_enable_channel(const uint8_t channel, const uint8_t source)
{
    3670:	b580      	push	{r7, lr}
    3672:	b082      	sub	sp, #8
    3674:	af00      	add	r7, sp, #0
    3676:	0002      	movs	r2, r0
    3678:	1dfb      	adds	r3, r7, #7
    367a:	701a      	strb	r2, [r3, #0]
    367c:	1dbb      	adds	r3, r7, #6
    367e:	1c0a      	adds	r2, r1, #0
    3680:	701a      	strb	r2, [r3, #0]

	hri_gclk_write_CLKCTRL_reg(GCLK,
	                           GCLK_CLKCTRL_ID(channel) | GCLK_CLKCTRL_GEN(source) | (1 << GCLK_CLKCTRL_CLKEN_Pos));
    3682:	1dfb      	adds	r3, r7, #7
    3684:	781b      	ldrb	r3, [r3, #0]
    3686:	b29b      	uxth	r3, r3
    3688:	223f      	movs	r2, #63	; 0x3f
    368a:	4013      	ands	r3, r2
    368c:	b29a      	uxth	r2, r3
    368e:	1dbb      	adds	r3, r7, #6
    3690:	781b      	ldrb	r3, [r3, #0]
    3692:	b29b      	uxth	r3, r3
    3694:	021b      	lsls	r3, r3, #8
    3696:	b299      	uxth	r1, r3
    3698:	23f0      	movs	r3, #240	; 0xf0
    369a:	011b      	lsls	r3, r3, #4
    369c:	400b      	ands	r3, r1
    369e:	b29b      	uxth	r3, r3
    36a0:	4313      	orrs	r3, r2
    36a2:	b29b      	uxth	r3, r3
	hri_gclk_write_CLKCTRL_reg(GCLK,
    36a4:	2280      	movs	r2, #128	; 0x80
    36a6:	01d2      	lsls	r2, r2, #7
    36a8:	4313      	orrs	r3, r2
    36aa:	b29b      	uxth	r3, r3
    36ac:	4a04      	ldr	r2, [pc, #16]	; (36c0 <_gclk_enable_channel+0x50>)
    36ae:	0019      	movs	r1, r3
    36b0:	0010      	movs	r0, r2
    36b2:	f7ff fc6c 	bl	2f8e <hri_gclk_write_CLKCTRL_reg>
}
    36b6:	46c0      	nop			; (mov r8, r8)
    36b8:	46bd      	mov	sp, r7
    36ba:	b002      	add	sp, #8
    36bc:	bd80      	pop	{r7, pc}
    36be:	46c0      	nop			; (mov r8, r8)
    36c0:	40000c00 	.word	0x40000c00

000036c4 <_pm_get_ahb_index>:
 * \param[in] module Module to get index for
 *
 * \return index of the given module if succeeds, ERR_INVALID_ARG otherwise
 */
static inline int32_t _pm_get_ahb_index(const void *const module)
{
    36c4:	b580      	push	{r7, lr}
    36c6:	b082      	sub	sp, #8
    36c8:	af00      	add	r7, sp, #0
    36ca:	6078      	str	r0, [r7, #4]
	if ((uint32_t)module == (uint32_t)PM_BUS_APBA) {
    36cc:	687b      	ldr	r3, [r7, #4]
    36ce:	2b01      	cmp	r3, #1
    36d0:	d101      	bne.n	36d6 <_pm_get_ahb_index+0x12>
		return 0;
    36d2:	2300      	movs	r3, #0
    36d4:	e017      	b.n	3706 <_pm_get_ahb_index+0x42>
	} else if ((uint32_t)module == (uint32_t)PM_BUS_APBB) {
    36d6:	687b      	ldr	r3, [r7, #4]
    36d8:	2b02      	cmp	r3, #2
    36da:	d101      	bne.n	36e0 <_pm_get_ahb_index+0x1c>
		return 1;
    36dc:	2301      	movs	r3, #1
    36de:	e012      	b.n	3706 <_pm_get_ahb_index+0x42>
	} else if ((uint32_t)module == (uint32_t)PM_BUS_APBC) {
    36e0:	687b      	ldr	r3, [r7, #4]
    36e2:	2b03      	cmp	r3, #3
    36e4:	d101      	bne.n	36ea <_pm_get_ahb_index+0x26>
		return 2;
    36e6:	2302      	movs	r3, #2
    36e8:	e00d      	b.n	3706 <_pm_get_ahb_index+0x42>
	}
	if ((uint32_t)module == (uint32_t)DSU) {
    36ea:	687b      	ldr	r3, [r7, #4]
    36ec:	4a08      	ldr	r2, [pc, #32]	; (3710 <_pm_get_ahb_index+0x4c>)
    36ee:	4293      	cmp	r3, r2
    36f0:	d101      	bne.n	36f6 <_pm_get_ahb_index+0x32>
		return 3;
    36f2:	2303      	movs	r3, #3
    36f4:	e007      	b.n	3706 <_pm_get_ahb_index+0x42>
	} else if ((uint32_t)module == (uint32_t)NVMCTRL) {
    36f6:	687b      	ldr	r3, [r7, #4]
    36f8:	4a06      	ldr	r2, [pc, #24]	; (3714 <_pm_get_ahb_index+0x50>)
    36fa:	4293      	cmp	r3, r2
    36fc:	d101      	bne.n	3702 <_pm_get_ahb_index+0x3e>
		return 4;
    36fe:	2304      	movs	r3, #4
    3700:	e001      	b.n	3706 <_pm_get_ahb_index+0x42>
	}

	return ERR_INVALID_ARG;
    3702:	230d      	movs	r3, #13
    3704:	425b      	negs	r3, r3
}
    3706:	0018      	movs	r0, r3
    3708:	46bd      	mov	sp, r7
    370a:	b002      	add	sp, #8
    370c:	bd80      	pop	{r7, pc}
    370e:	46c0      	nop			; (mov r8, r8)
    3710:	41002000 	.word	0x41002000
    3714:	41004000 	.word	0x41004000

00003718 <_pm_get_apbb_index>:
 * \param[in] module Module to get index for
 *
 * \return index of the given module if succeeds, ERR_INVALID_ARG otherwise
 */
static inline int32_t _pm_get_apbb_index(const void *const module)
{
    3718:	b580      	push	{r7, lr}
    371a:	b082      	sub	sp, #8
    371c:	af00      	add	r7, sp, #0
    371e:	6078      	str	r0, [r7, #4]
	if ((uint32_t)module == (uint32_t)PAC1) {
    3720:	687a      	ldr	r2, [r7, #4]
    3722:	2382      	movs	r3, #130	; 0x82
    3724:	05db      	lsls	r3, r3, #23
    3726:	429a      	cmp	r2, r3
    3728:	d101      	bne.n	372e <_pm_get_apbb_index+0x16>
		return 0;
    372a:	2300      	movs	r3, #0
    372c:	e013      	b.n	3756 <_pm_get_apbb_index+0x3e>
	} else if ((uint32_t)module == (uint32_t)DSU) {
    372e:	687b      	ldr	r3, [r7, #4]
    3730:	4a0b      	ldr	r2, [pc, #44]	; (3760 <_pm_get_apbb_index+0x48>)
    3732:	4293      	cmp	r3, r2
    3734:	d101      	bne.n	373a <_pm_get_apbb_index+0x22>
		return 1;
    3736:	2301      	movs	r3, #1
    3738:	e00d      	b.n	3756 <_pm_get_apbb_index+0x3e>
	} else if ((uint32_t)module == (uint32_t)NVMCTRL) {
    373a:	687b      	ldr	r3, [r7, #4]
    373c:	4a09      	ldr	r2, [pc, #36]	; (3764 <_pm_get_apbb_index+0x4c>)
    373e:	4293      	cmp	r3, r2
    3740:	d101      	bne.n	3746 <_pm_get_apbb_index+0x2e>
		return 2;
    3742:	2302      	movs	r3, #2
    3744:	e007      	b.n	3756 <_pm_get_apbb_index+0x3e>
	}
	if ((uint32_t)module == (uint32_t)PORT) {
    3746:	687b      	ldr	r3, [r7, #4]
    3748:	4a07      	ldr	r2, [pc, #28]	; (3768 <_pm_get_apbb_index+0x50>)
    374a:	4293      	cmp	r3, r2
    374c:	d101      	bne.n	3752 <_pm_get_apbb_index+0x3a>
		return 3;
    374e:	2303      	movs	r3, #3
    3750:	e001      	b.n	3756 <_pm_get_apbb_index+0x3e>
	}

	return ERR_INVALID_ARG;
    3752:	230d      	movs	r3, #13
    3754:	425b      	negs	r3, r3
}
    3756:	0018      	movs	r0, r3
    3758:	46bd      	mov	sp, r7
    375a:	b002      	add	sp, #8
    375c:	bd80      	pop	{r7, pc}
    375e:	46c0      	nop			; (mov r8, r8)
    3760:	41002000 	.word	0x41002000
    3764:	41004000 	.word	0x41004000
    3768:	41004400 	.word	0x41004400

0000376c <_pm_enable_bus_clock>:
 *
 * \param[in] bus A bus to enable clock on
 * \param[in] module A hardware module to enable clock for
 */
static inline void _pm_enable_bus_clock(const enum _pm_bus bus, const void *const module)
{
    376c:	b580      	push	{r7, lr}
    376e:	b084      	sub	sp, #16
    3770:	af00      	add	r7, sp, #0
    3772:	0002      	movs	r2, r0
    3774:	6039      	str	r1, [r7, #0]
    3776:	1dfb      	adds	r3, r7, #7
    3778:	701a      	strb	r2, [r3, #0]
	uint32_t peripheral = ((uint32_t)module & 0x0000ff00) >> 10;
    377a:	683b      	ldr	r3, [r7, #0]
    377c:	0a9b      	lsrs	r3, r3, #10
    377e:	223f      	movs	r2, #63	; 0x3f
    3780:	4013      	ands	r3, r2
    3782:	60fb      	str	r3, [r7, #12]

	switch (bus) {
    3784:	1dfb      	adds	r3, r7, #7
    3786:	781b      	ldrb	r3, [r3, #0]
    3788:	2b01      	cmp	r3, #1
    378a:	d01e      	beq.n	37ca <_pm_enable_bus_clock+0x5e>
    378c:	dc02      	bgt.n	3794 <_pm_enable_bus_clock+0x28>
    378e:	2b00      	cmp	r3, #0
    3790:	d005      	beq.n	379e <_pm_enable_bus_clock+0x32>
    3792:	e044      	b.n	381e <_pm_enable_bus_clock+0xb2>
    3794:	2b02      	cmp	r3, #2
    3796:	d022      	beq.n	37de <_pm_enable_bus_clock+0x72>
    3798:	2b03      	cmp	r3, #3
    379a:	d036      	beq.n	380a <_pm_enable_bus_clock+0x9e>
    379c:	e03f      	b.n	381e <_pm_enable_bus_clock+0xb2>
	case PM_BUS_AHB:
		if (_pm_get_ahb_index(module) >= 0) {
    379e:	683b      	ldr	r3, [r7, #0]
    37a0:	0018      	movs	r0, r3
    37a2:	f7ff ff8f 	bl	36c4 <_pm_get_ahb_index>
    37a6:	1e03      	subs	r3, r0, #0
    37a8:	db40      	blt.n	382c <_pm_enable_bus_clock+0xc0>
			peripheral = (uint32_t)_pm_get_ahb_index(module);
    37aa:	683b      	ldr	r3, [r7, #0]
    37ac:	0018      	movs	r0, r3
    37ae:	f7ff ff89 	bl	36c4 <_pm_get_ahb_index>
    37b2:	0003      	movs	r3, r0
    37b4:	60fb      	str	r3, [r7, #12]
			PM->AHBMASK.reg |= 1 << peripheral;
    37b6:	4b21      	ldr	r3, [pc, #132]	; (383c <_pm_enable_bus_clock+0xd0>)
    37b8:	4a20      	ldr	r2, [pc, #128]	; (383c <_pm_enable_bus_clock+0xd0>)
    37ba:	6952      	ldr	r2, [r2, #20]
    37bc:	2001      	movs	r0, #1
    37be:	68f9      	ldr	r1, [r7, #12]
    37c0:	4088      	lsls	r0, r1
    37c2:	0001      	movs	r1, r0
    37c4:	430a      	orrs	r2, r1
    37c6:	615a      	str	r2, [r3, #20]
		}
		break;
    37c8:	e030      	b.n	382c <_pm_enable_bus_clock+0xc0>
	case PM_BUS_APBA:
		PM->APBAMASK.reg |= 1 << peripheral;
    37ca:	4b1c      	ldr	r3, [pc, #112]	; (383c <_pm_enable_bus_clock+0xd0>)
    37cc:	4a1b      	ldr	r2, [pc, #108]	; (383c <_pm_enable_bus_clock+0xd0>)
    37ce:	6992      	ldr	r2, [r2, #24]
    37d0:	2001      	movs	r0, #1
    37d2:	68f9      	ldr	r1, [r7, #12]
    37d4:	4088      	lsls	r0, r1
    37d6:	0001      	movs	r1, r0
    37d8:	430a      	orrs	r2, r1
    37da:	619a      	str	r2, [r3, #24]
		break;
    37dc:	e029      	b.n	3832 <_pm_enable_bus_clock+0xc6>
	case PM_BUS_APBB:
		if (_pm_get_apbb_index(module) >= 0) {
    37de:	683b      	ldr	r3, [r7, #0]
    37e0:	0018      	movs	r0, r3
    37e2:	f7ff ff99 	bl	3718 <_pm_get_apbb_index>
    37e6:	1e03      	subs	r3, r0, #0
    37e8:	db22      	blt.n	3830 <_pm_enable_bus_clock+0xc4>
			peripheral = (uint32_t)_pm_get_apbb_index(module);
    37ea:	683b      	ldr	r3, [r7, #0]
    37ec:	0018      	movs	r0, r3
    37ee:	f7ff ff93 	bl	3718 <_pm_get_apbb_index>
    37f2:	0003      	movs	r3, r0
    37f4:	60fb      	str	r3, [r7, #12]
			PM->APBBMASK.reg |= 1 << peripheral;
    37f6:	4b11      	ldr	r3, [pc, #68]	; (383c <_pm_enable_bus_clock+0xd0>)
    37f8:	4a10      	ldr	r2, [pc, #64]	; (383c <_pm_enable_bus_clock+0xd0>)
    37fa:	69d2      	ldr	r2, [r2, #28]
    37fc:	2001      	movs	r0, #1
    37fe:	68f9      	ldr	r1, [r7, #12]
    3800:	4088      	lsls	r0, r1
    3802:	0001      	movs	r1, r0
    3804:	430a      	orrs	r2, r1
    3806:	61da      	str	r2, [r3, #28]
		}
		break;
    3808:	e012      	b.n	3830 <_pm_enable_bus_clock+0xc4>
	case PM_BUS_APBC:
		PM->APBCMASK.reg |= 1 << peripheral;
    380a:	4b0c      	ldr	r3, [pc, #48]	; (383c <_pm_enable_bus_clock+0xd0>)
    380c:	4a0b      	ldr	r2, [pc, #44]	; (383c <_pm_enable_bus_clock+0xd0>)
    380e:	6a12      	ldr	r2, [r2, #32]
    3810:	2001      	movs	r0, #1
    3812:	68f9      	ldr	r1, [r7, #12]
    3814:	4088      	lsls	r0, r1
    3816:	0001      	movs	r1, r0
    3818:	430a      	orrs	r2, r1
    381a:	621a      	str	r2, [r3, #32]
		break;
    381c:	e009      	b.n	3832 <_pm_enable_bus_clock+0xc6>
	default:
		ASSERT(false);
    381e:	4b08      	ldr	r3, [pc, #32]	; (3840 <_pm_enable_bus_clock+0xd4>)
    3820:	228d      	movs	r2, #141	; 0x8d
    3822:	0019      	movs	r1, r3
    3824:	2000      	movs	r0, #0
    3826:	f000 fd9b 	bl	4360 <assert>
		break;
    382a:	e002      	b.n	3832 <_pm_enable_bus_clock+0xc6>
		break;
    382c:	46c0      	nop			; (mov r8, r8)
    382e:	e000      	b.n	3832 <_pm_enable_bus_clock+0xc6>
		break;
    3830:	46c0      	nop			; (mov r8, r8)
	}
}
    3832:	46c0      	nop			; (mov r8, r8)
    3834:	46bd      	mov	sp, r7
    3836:	b004      	add	sp, #16
    3838:	bd80      	pop	{r7, pc}
    383a:	46c0      	nop			; (mov r8, r8)
    383c:	40000400 	.word	0x40000400
    3840:	00008ef8 	.word	0x00008ef8

00003844 <EXTERNAL_IRQ_0_init>:
struct usart_sync_descriptor DEBUG_SERIAL;

//struct i2c_m_sync_desc EXT_I2C;

void EXTERNAL_IRQ_0_init(void)
{
    3844:	b580      	push	{r7, lr}
    3846:	af00      	add	r7, sp, #0
	_gclk_enable_channel(EIC_GCLK_ID, CONF_GCLK_EIC_SRC);
    3848:	2100      	movs	r1, #0
    384a:	2003      	movs	r0, #3
    384c:	f7ff ff10 	bl	3670 <_gclk_enable_channel>

	// Set pin direction to input
	gpio_set_pin_direction(BTN, GPIO_DIRECTION_IN);
    3850:	2101      	movs	r1, #1
    3852:	2021      	movs	r0, #33	; 0x21
    3854:	f7ff feca 	bl	35ec <gpio_set_pin_direction>

	gpio_set_pin_pull_mode(BTN,
    3858:	2100      	movs	r1, #0
    385a:	2021      	movs	r0, #33	; 0x21
    385c:	f7ff fe9c 	bl	3598 <gpio_set_pin_pull_mode>
	                       // <GPIO_PULL_OFF"> Off
	                       // <GPIO_PULL_UP"> Pull-up
	                       // <GPIO_PULL_DOWN"> Pull-down
	                       GPIO_PULL_OFF);

	gpio_set_pin_function(BTN, PINMUX_PB01A_EIC_EXTINT1);
    3860:	2384      	movs	r3, #132	; 0x84
    3862:	039b      	lsls	r3, r3, #14
    3864:	0019      	movs	r1, r3
    3866:	2021      	movs	r0, #33	; 0x21
    3868:	f7ff feb1 	bl	35ce <gpio_set_pin_function>

	// Set pin direction to input
	gpio_set_pin_direction(RTC_IRQ, GPIO_DIRECTION_IN);
    386c:	2101      	movs	r1, #1
    386e:	200a      	movs	r0, #10
    3870:	f7ff febc 	bl	35ec <gpio_set_pin_direction>

	gpio_set_pin_pull_mode(RTC_IRQ,
    3874:	2100      	movs	r1, #0
    3876:	200a      	movs	r0, #10
    3878:	f7ff fe8e 	bl	3598 <gpio_set_pin_pull_mode>
	                       // <GPIO_PULL_OFF"> Off
	                       // <GPIO_PULL_UP"> Pull-up
	                       // <GPIO_PULL_DOWN"> Pull-down
	                       GPIO_PULL_OFF);

	gpio_set_pin_function(RTC_IRQ, PINMUX_PA10A_EIC_EXTINT10);
    387c:	23a0      	movs	r3, #160	; 0xa0
    387e:	031b      	lsls	r3, r3, #12
    3880:	0019      	movs	r1, r3
    3882:	200a      	movs	r0, #10
    3884:	f7ff fea3 	bl	35ce <gpio_set_pin_function>

	// Set pin direction to input
	

	ext_irq_init();
    3888:	f000 f8d8 	bl	3a3c <ext_irq_init>
}
    388c:	46c0      	nop			; (mov r8, r8)
    388e:	46bd      	mov	sp, r7
    3890:	bd80      	pop	{r7, pc}
	...

00003894 <DEBUG_SERIAL_PORT_init>:
	//spi_m_sync_init(&RF_SPI, SERCOM1);
	//RF_SPI_PORT_init();
//}

void DEBUG_SERIAL_PORT_init(void)
{
    3894:	b580      	push	{r7, lr}
    3896:	af00      	add	r7, sp, #0
	gpio_set_pin_function(PA16, PINMUX_PA16D_SERCOM3_PAD0);
    3898:	4b06      	ldr	r3, [pc, #24]	; (38b4 <DEBUG_SERIAL_PORT_init+0x20>)
    389a:	0019      	movs	r1, r3
    389c:	2010      	movs	r0, #16
    389e:	f7ff fe96 	bl	35ce <gpio_set_pin_function>
	gpio_set_pin_function(PA17, PINMUX_PA17D_SERCOM3_PAD1);
    38a2:	4b05      	ldr	r3, [pc, #20]	; (38b8 <DEBUG_SERIAL_PORT_init+0x24>)
    38a4:	0019      	movs	r1, r3
    38a6:	2011      	movs	r0, #17
    38a8:	f7ff fe91 	bl	35ce <gpio_set_pin_function>
}
    38ac:	46c0      	nop			; (mov r8, r8)
    38ae:	46bd      	mov	sp, r7
    38b0:	bd80      	pop	{r7, pc}
    38b2:	46c0      	nop			; (mov r8, r8)
    38b4:	00100003 	.word	0x00100003
    38b8:	00110003 	.word	0x00110003

000038bc <DEBUG_SERIAL_CLOCK_init>:

void DEBUG_SERIAL_CLOCK_init(void)
{
    38bc:	b580      	push	{r7, lr}
    38be:	af00      	add	r7, sp, #0
	_pm_enable_bus_clock(PM_BUS_APBC, SERCOM3);
    38c0:	4b05      	ldr	r3, [pc, #20]	; (38d8 <DEBUG_SERIAL_CLOCK_init+0x1c>)
    38c2:	0019      	movs	r1, r3
    38c4:	2003      	movs	r0, #3
    38c6:	f7ff ff51 	bl	376c <_pm_enable_bus_clock>
	_gclk_enable_channel(SERCOM3_GCLK_ID_CORE, CONF_GCLK_SERCOM3_CORE_SRC);
    38ca:	2100      	movs	r1, #0
    38cc:	2010      	movs	r0, #16
    38ce:	f7ff fecf 	bl	3670 <_gclk_enable_channel>
}
    38d2:	46c0      	nop			; (mov r8, r8)
    38d4:	46bd      	mov	sp, r7
    38d6:	bd80      	pop	{r7, pc}
    38d8:	42001400 	.word	0x42001400

000038dc <DEBUG_SERIAL_init>:

void DEBUG_SERIAL_init(void)
{
    38dc:	b580      	push	{r7, lr}
    38de:	af00      	add	r7, sp, #0
	DEBUG_SERIAL_CLOCK_init();
    38e0:	f7ff ffec 	bl	38bc <DEBUG_SERIAL_CLOCK_init>
	usart_sync_init(&DEBUG_SERIAL, SERCOM3, (void *)NULL);
    38e4:	4905      	ldr	r1, [pc, #20]	; (38fc <DEBUG_SERIAL_init+0x20>)
    38e6:	4b06      	ldr	r3, [pc, #24]	; (3900 <DEBUG_SERIAL_init+0x24>)
    38e8:	2200      	movs	r2, #0
    38ea:	0018      	movs	r0, r3
    38ec:	f000 fc56 	bl	419c <usart_sync_init>
	DEBUG_SERIAL_PORT_init();
    38f0:	f7ff ffd0 	bl	3894 <DEBUG_SERIAL_PORT_init>
}
    38f4:	46c0      	nop			; (mov r8, r8)
    38f6:	46bd      	mov	sp, r7
    38f8:	bd80      	pop	{r7, pc}
    38fa:	46c0      	nop			; (mov r8, r8)
    38fc:	42001400 	.word	0x42001400
    3900:	20000800 	.word	0x20000800

00003904 <delay_driver_init>:




void delay_driver_init(void)
{
    3904:	b580      	push	{r7, lr}
    3906:	af00      	add	r7, sp, #0
	delay_init(SysTick);
    3908:	4b03      	ldr	r3, [pc, #12]	; (3918 <delay_driver_init+0x14>)
    390a:	0018      	movs	r0, r3
    390c:	f000 f86c 	bl	39e8 <delay_init>
}
    3910:	46c0      	nop			; (mov r8, r8)
    3912:	46bd      	mov	sp, r7
    3914:	bd80      	pop	{r7, pc}
    3916:	46c0      	nop			; (mov r8, r8)
    3918:	e000e010 	.word	0xe000e010

0000391c <system_init>:

void system_init(void)
{
    391c:	b580      	push	{r7, lr}
    391e:	af00      	add	r7, sp, #0
	init_mcu();
    3920:	f7ff fe9e 	bl	3660 <init_mcu>


	gpio_set_pin_level(LED_G, false);
    3924:	2100      	movs	r1, #0
    3926:	2020      	movs	r0, #32
    3928:	f7ff fe7d 	bl	3626 <gpio_set_pin_level>
	gpio_set_pin_direction(LED_G, GPIO_DIRECTION_OUT);
    392c:	2102      	movs	r1, #2
    392e:	2020      	movs	r0, #32
    3930:	f7ff fe5c 	bl	35ec <gpio_set_pin_direction>
	gpio_set_pin_function(LED_G, GPIO_PIN_FUNCTION_OFF);
    3934:	2301      	movs	r3, #1
    3936:	425b      	negs	r3, r3
    3938:	0019      	movs	r1, r3
    393a:	2020      	movs	r0, #32
    393c:	f7ff fe47 	bl	35ce <gpio_set_pin_function>

	gpio_set_pin_level(IO4,
    3940:	2100      	movs	r1, #0
    3942:	2027      	movs	r0, #39	; 0x27
    3944:	f7ff fe6f 	bl	3626 <gpio_set_pin_level>
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(IO4, GPIO_DIRECTION_OUT);
    3948:	2102      	movs	r1, #2
    394a:	2027      	movs	r0, #39	; 0x27
    394c:	f7ff fe4e 	bl	35ec <gpio_set_pin_direction>
	gpio_set_pin_function(IO4, GPIO_PIN_FUNCTION_OFF);
    3950:	2301      	movs	r3, #1
    3952:	425b      	negs	r3, r3
    3954:	0019      	movs	r1, r3
    3956:	2027      	movs	r0, #39	; 0x27
    3958:	f7ff fe39 	bl	35ce <gpio_set_pin_function>


	gpio_set_pin_level(IO3,
    395c:	2100      	movs	r1, #0
    395e:	2028      	movs	r0, #40	; 0x28
    3960:	f7ff fe61 	bl	3626 <gpio_set_pin_level>
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(IO3, GPIO_DIRECTION_OUT);
    3964:	2102      	movs	r1, #2
    3966:	2028      	movs	r0, #40	; 0x28
    3968:	f7ff fe40 	bl	35ec <gpio_set_pin_direction>
	gpio_set_pin_function(IO3, GPIO_PIN_FUNCTION_OFF);
    396c:	2301      	movs	r3, #1
    396e:	425b      	negs	r3, r3
    3970:	0019      	movs	r1, r3
    3972:	2028      	movs	r0, #40	; 0x28
    3974:	f7ff fe2b 	bl	35ce <gpio_set_pin_function>
	// GPIO on PB31

	gpio_set_pin_level(LED_R,
    3978:	2101      	movs	r1, #1
    397a:	203f      	movs	r0, #63	; 0x3f
    397c:	f7ff fe53 	bl	3626 <gpio_set_pin_level>
	                   // <false"> Low
	                   // <true"> High
	                   true);

	// Set pin direction to output
	gpio_set_pin_direction(LED_R, GPIO_DIRECTION_OUT);
    3980:	2102      	movs	r1, #2
    3982:	203f      	movs	r0, #63	; 0x3f
    3984:	f7ff fe32 	bl	35ec <gpio_set_pin_direction>

	gpio_set_pin_function(LED_R, GPIO_PIN_FUNCTION_OFF);
    3988:	2301      	movs	r3, #1
    398a:	425b      	negs	r3, r3
    398c:	0019      	movs	r1, r3
    398e:	203f      	movs	r0, #63	; 0x3f
    3990:	f7ff fe1d 	bl	35ce <gpio_set_pin_function>

	EXTERNAL_IRQ_0_init();
    3994:	f7ff ff56 	bl	3844 <EXTERNAL_IRQ_0_init>

	//EXT_SPI_init();

	//RF_SPI_init();

	DEBUG_SERIAL_init();
    3998:	f7ff ffa0 	bl	38dc <DEBUG_SERIAL_init>

	delay_driver_init();
    399c:	f7ff ffb2 	bl	3904 <delay_driver_init>
}
    39a0:	46c0      	nop			; (mov r8, r8)
    39a2:	46bd      	mov	sp, r7
    39a4:	bd80      	pop	{r7, pc}

000039a6 <atomic_enter_critical>:

/**
 * \brief Disable interrupts, enter critical section
 */
void atomic_enter_critical(hal_atomic_t volatile *atomic)
{
    39a6:	b580      	push	{r7, lr}
    39a8:	b084      	sub	sp, #16
    39aa:	af00      	add	r7, sp, #0
    39ac:	6078      	str	r0, [r7, #4]
 */
__STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
    39ae:	f3ef 8310 	mrs	r3, PRIMASK
    39b2:	60fb      	str	r3, [r7, #12]
  return(result);
    39b4:	68fa      	ldr	r2, [r7, #12]
	*atomic = __get_PRIMASK();
    39b6:	687b      	ldr	r3, [r7, #4]
    39b8:	601a      	str	r2, [r3, #0]
  __ASM volatile ("cpsid i" : : : "memory");
    39ba:	b672      	cpsid	i
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
    39bc:	f3bf 8f5f 	dmb	sy
	__disable_irq();
	__DMB();
}
    39c0:	46c0      	nop			; (mov r8, r8)
    39c2:	46bd      	mov	sp, r7
    39c4:	b004      	add	sp, #16
    39c6:	bd80      	pop	{r7, pc}

000039c8 <atomic_leave_critical>:

/**
 * \brief Exit atomic section
 */
void atomic_leave_critical(hal_atomic_t volatile *atomic)
{
    39c8:	b580      	push	{r7, lr}
    39ca:	b084      	sub	sp, #16
    39cc:	af00      	add	r7, sp, #0
    39ce:	6078      	str	r0, [r7, #4]
    39d0:	f3bf 8f5f 	dmb	sy
	__DMB();
	__set_PRIMASK(*atomic);
    39d4:	687b      	ldr	r3, [r7, #4]
    39d6:	681b      	ldr	r3, [r3, #0]
    39d8:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
    39da:	68fb      	ldr	r3, [r7, #12]
    39dc:	f383 8810 	msr	PRIMASK, r3
}
    39e0:	46c0      	nop			; (mov r8, r8)
    39e2:	46bd      	mov	sp, r7
    39e4:	b004      	add	sp, #16
    39e6:	bd80      	pop	{r7, pc}

000039e8 <delay_init>:

/**
 * \brief Initialize Delay driver
 */
void delay_init(void *const hw)
{
    39e8:	b580      	push	{r7, lr}
    39ea:	b082      	sub	sp, #8
    39ec:	af00      	add	r7, sp, #0
    39ee:	6078      	str	r0, [r7, #4]
	_delay_init(hardware = hw);
    39f0:	4b05      	ldr	r3, [pc, #20]	; (3a08 <delay_init+0x20>)
    39f2:	687a      	ldr	r2, [r7, #4]
    39f4:	601a      	str	r2, [r3, #0]
    39f6:	4b04      	ldr	r3, [pc, #16]	; (3a08 <delay_init+0x20>)
    39f8:	681b      	ldr	r3, [r3, #0]
    39fa:	0018      	movs	r0, r3
    39fc:	f002 fcfe 	bl	63fc <_delay_init>
}
    3a00:	46c0      	nop			; (mov r8, r8)
    3a02:	46bd      	mov	sp, r7
    3a04:	b002      	add	sp, #8
    3a06:	bd80      	pop	{r7, pc}
    3a08:	200007ac 	.word	0x200007ac

00003a0c <delay_ms>:

/**
 * \brief Perform delay in ms
 */
void delay_ms(const uint16_t ms)
{
    3a0c:	b590      	push	{r4, r7, lr}
    3a0e:	b083      	sub	sp, #12
    3a10:	af00      	add	r7, sp, #0
    3a12:	0002      	movs	r2, r0
    3a14:	1dbb      	adds	r3, r7, #6
    3a16:	801a      	strh	r2, [r3, #0]
	_delay_cycles(hardware, _get_cycles_for_ms(ms));
    3a18:	4b07      	ldr	r3, [pc, #28]	; (3a38 <delay_ms+0x2c>)
    3a1a:	681c      	ldr	r4, [r3, #0]
    3a1c:	1dbb      	adds	r3, r7, #6
    3a1e:	881b      	ldrh	r3, [r3, #0]
    3a20:	0018      	movs	r0, r3
    3a22:	f000 fd45 	bl	44b0 <_get_cycles_for_ms>
    3a26:	0003      	movs	r3, r0
    3a28:	0019      	movs	r1, r3
    3a2a:	0020      	movs	r0, r4
    3a2c:	f002 fcf2 	bl	6414 <_delay_cycles>
}
    3a30:	46c0      	nop			; (mov r8, r8)
    3a32:	46bd      	mov	sp, r7
    3a34:	b003      	add	sp, #12
    3a36:	bd90      	pop	{r4, r7, pc}
    3a38:	200007ac 	.word	0x200007ac

00003a3c <ext_irq_init>:

/**
 * \brief Initialize external irq component if any
 */
int32_t ext_irq_init(void)
{
    3a3c:	b580      	push	{r7, lr}
    3a3e:	b082      	sub	sp, #8
    3a40:	af00      	add	r7, sp, #0
	uint16_t i;

	for (i = 0; i < EXT_IRQ_AMOUNT; i++) {
    3a42:	1dbb      	adds	r3, r7, #6
    3a44:	2200      	movs	r2, #0
    3a46:	801a      	strh	r2, [r3, #0]
    3a48:	e013      	b.n	3a72 <ext_irq_init+0x36>
		ext_irqs[i].pin = 0xFFFFFFFF;
    3a4a:	1dbb      	adds	r3, r7, #6
    3a4c:	881b      	ldrh	r3, [r3, #0]
    3a4e:	4a0f      	ldr	r2, [pc, #60]	; (3a8c <ext_irq_init+0x50>)
    3a50:	00db      	lsls	r3, r3, #3
    3a52:	18d3      	adds	r3, r2, r3
    3a54:	3304      	adds	r3, #4
    3a56:	2201      	movs	r2, #1
    3a58:	4252      	negs	r2, r2
    3a5a:	601a      	str	r2, [r3, #0]
		ext_irqs[i].cb  = NULL;
    3a5c:	1dbb      	adds	r3, r7, #6
    3a5e:	881a      	ldrh	r2, [r3, #0]
    3a60:	4b0a      	ldr	r3, [pc, #40]	; (3a8c <ext_irq_init+0x50>)
    3a62:	00d2      	lsls	r2, r2, #3
    3a64:	2100      	movs	r1, #0
    3a66:	50d1      	str	r1, [r2, r3]
	for (i = 0; i < EXT_IRQ_AMOUNT; i++) {
    3a68:	1dbb      	adds	r3, r7, #6
    3a6a:	881a      	ldrh	r2, [r3, #0]
    3a6c:	1dbb      	adds	r3, r7, #6
    3a6e:	3201      	adds	r2, #1
    3a70:	801a      	strh	r2, [r3, #0]
    3a72:	1dbb      	adds	r3, r7, #6
    3a74:	881b      	ldrh	r3, [r3, #0]
    3a76:	2b02      	cmp	r3, #2
    3a78:	d9e7      	bls.n	3a4a <ext_irq_init+0xe>
	}

	return _ext_irq_init(process_ext_irq);
    3a7a:	4b05      	ldr	r3, [pc, #20]	; (3a90 <ext_irq_init+0x54>)
    3a7c:	0018      	movs	r0, r3
    3a7e:	f000 fe77 	bl	4770 <_ext_irq_init>
    3a82:	0003      	movs	r3, r0
}
    3a84:	0018      	movs	r0, r3
    3a86:	46bd      	mov	sp, r7
    3a88:	b002      	add	sp, #8
    3a8a:	bd80      	pop	{r7, pc}
    3a8c:	200007b0 	.word	0x200007b0
    3a90:	00003c69 	.word	0x00003c69

00003a94 <ext_irq_register>:

/**
 * \brief Register callback for the given external interrupt
 */
int32_t ext_irq_register(const uint32_t pin, ext_irq_cb_t cb)
{
    3a94:	b580      	push	{r7, lr}
    3a96:	b086      	sub	sp, #24
    3a98:	af00      	add	r7, sp, #0
    3a9a:	6078      	str	r0, [r7, #4]
    3a9c:	6039      	str	r1, [r7, #0]
	uint8_t i = 0, j = 0;
    3a9e:	2317      	movs	r3, #23
    3aa0:	18fb      	adds	r3, r7, r3
    3aa2:	2200      	movs	r2, #0
    3aa4:	701a      	strb	r2, [r3, #0]
    3aa6:	2316      	movs	r3, #22
    3aa8:	18fb      	adds	r3, r7, r3
    3aaa:	2200      	movs	r2, #0
    3aac:	701a      	strb	r2, [r3, #0]
	bool    found = false;
    3aae:	2315      	movs	r3, #21
    3ab0:	18fb      	adds	r3, r7, r3
    3ab2:	2200      	movs	r2, #0
    3ab4:	701a      	strb	r2, [r3, #0]

	for (; i < EXT_IRQ_AMOUNT; i++) {
    3ab6:	e01d      	b.n	3af4 <ext_irq_register+0x60>
		if (ext_irqs[i].pin == pin) {
    3ab8:	2317      	movs	r3, #23
    3aba:	18fb      	adds	r3, r7, r3
    3abc:	781b      	ldrb	r3, [r3, #0]
    3abe:	4a69      	ldr	r2, [pc, #420]	; (3c64 <ext_irq_register+0x1d0>)
    3ac0:	00db      	lsls	r3, r3, #3
    3ac2:	18d3      	adds	r3, r2, r3
    3ac4:	3304      	adds	r3, #4
    3ac6:	681a      	ldr	r2, [r3, #0]
    3ac8:	687b      	ldr	r3, [r7, #4]
    3aca:	429a      	cmp	r2, r3
    3acc:	d10b      	bne.n	3ae6 <ext_irq_register+0x52>
			ext_irqs[i].cb = cb;
    3ace:	2317      	movs	r3, #23
    3ad0:	18fb      	adds	r3, r7, r3
    3ad2:	781a      	ldrb	r2, [r3, #0]
    3ad4:	4b63      	ldr	r3, [pc, #396]	; (3c64 <ext_irq_register+0x1d0>)
    3ad6:	00d2      	lsls	r2, r2, #3
    3ad8:	6839      	ldr	r1, [r7, #0]
    3ada:	50d1      	str	r1, [r2, r3]
			found          = true;
    3adc:	2315      	movs	r3, #21
    3ade:	18fb      	adds	r3, r7, r3
    3ae0:	2201      	movs	r2, #1
    3ae2:	701a      	strb	r2, [r3, #0]
			break;
    3ae4:	e00b      	b.n	3afe <ext_irq_register+0x6a>
	for (; i < EXT_IRQ_AMOUNT; i++) {
    3ae6:	2317      	movs	r3, #23
    3ae8:	18fb      	adds	r3, r7, r3
    3aea:	781a      	ldrb	r2, [r3, #0]
    3aec:	2317      	movs	r3, #23
    3aee:	18fb      	adds	r3, r7, r3
    3af0:	3201      	adds	r2, #1
    3af2:	701a      	strb	r2, [r3, #0]
    3af4:	2317      	movs	r3, #23
    3af6:	18fb      	adds	r3, r7, r3
    3af8:	781b      	ldrb	r3, [r3, #0]
    3afa:	2b02      	cmp	r3, #2
    3afc:	d9dc      	bls.n	3ab8 <ext_irq_register+0x24>
		}
	}

	if (NULL == cb) {
    3afe:	683b      	ldr	r3, [r7, #0]
    3b00:	2b00      	cmp	r3, #0
    3b02:	d111      	bne.n	3b28 <ext_irq_register+0x94>
		if (!found) {
    3b04:	2315      	movs	r3, #21
    3b06:	18fb      	adds	r3, r7, r3
    3b08:	781b      	ldrb	r3, [r3, #0]
    3b0a:	2201      	movs	r2, #1
    3b0c:	4053      	eors	r3, r2
    3b0e:	b2db      	uxtb	r3, r3
    3b10:	2b00      	cmp	r3, #0
    3b12:	d002      	beq.n	3b1a <ext_irq_register+0x86>
			return ERR_INVALID_ARG;
    3b14:	230d      	movs	r3, #13
    3b16:	425b      	negs	r3, r3
    3b18:	e09f      	b.n	3c5a <ext_irq_register+0x1c6>
		}
		return _ext_irq_enable(pin, false);
    3b1a:	687b      	ldr	r3, [r7, #4]
    3b1c:	2100      	movs	r1, #0
    3b1e:	0018      	movs	r0, r3
    3b20:	f000 fe82 	bl	4828 <_ext_irq_enable>
    3b24:	0003      	movs	r3, r0
    3b26:	e098      	b.n	3c5a <ext_irq_register+0x1c6>
	}

	if (!found) {
    3b28:	2315      	movs	r3, #21
    3b2a:	18fb      	adds	r3, r7, r3
    3b2c:	781b      	ldrb	r3, [r3, #0]
    3b2e:	2201      	movs	r2, #1
    3b30:	4053      	eors	r3, r2
    3b32:	b2db      	uxtb	r3, r3
    3b34:	2b00      	cmp	r3, #0
    3b36:	d100      	bne.n	3b3a <ext_irq_register+0xa6>
    3b38:	e07e      	b.n	3c38 <ext_irq_register+0x1a4>
		for (i = 0; i < EXT_IRQ_AMOUNT; i++) {
    3b3a:	2317      	movs	r3, #23
    3b3c:	18fb      	adds	r3, r7, r3
    3b3e:	2200      	movs	r2, #0
    3b40:	701a      	strb	r2, [r3, #0]
    3b42:	e023      	b.n	3b8c <ext_irq_register+0xf8>
			if (NULL == ext_irqs[i].cb) {
    3b44:	2317      	movs	r3, #23
    3b46:	18fb      	adds	r3, r7, r3
    3b48:	781a      	ldrb	r2, [r3, #0]
    3b4a:	4b46      	ldr	r3, [pc, #280]	; (3c64 <ext_irq_register+0x1d0>)
    3b4c:	00d2      	lsls	r2, r2, #3
    3b4e:	58d3      	ldr	r3, [r2, r3]
    3b50:	2b00      	cmp	r3, #0
    3b52:	d114      	bne.n	3b7e <ext_irq_register+0xea>
				ext_irqs[i].cb  = cb;
    3b54:	2317      	movs	r3, #23
    3b56:	18fb      	adds	r3, r7, r3
    3b58:	781a      	ldrb	r2, [r3, #0]
    3b5a:	4b42      	ldr	r3, [pc, #264]	; (3c64 <ext_irq_register+0x1d0>)
    3b5c:	00d2      	lsls	r2, r2, #3
    3b5e:	6839      	ldr	r1, [r7, #0]
    3b60:	50d1      	str	r1, [r2, r3]
				ext_irqs[i].pin = pin;
    3b62:	2317      	movs	r3, #23
    3b64:	18fb      	adds	r3, r7, r3
    3b66:	781b      	ldrb	r3, [r3, #0]
    3b68:	4a3e      	ldr	r2, [pc, #248]	; (3c64 <ext_irq_register+0x1d0>)
    3b6a:	00db      	lsls	r3, r3, #3
    3b6c:	18d3      	adds	r3, r2, r3
    3b6e:	3304      	adds	r3, #4
    3b70:	687a      	ldr	r2, [r7, #4]
    3b72:	601a      	str	r2, [r3, #0]
				found           = true;
    3b74:	2315      	movs	r3, #21
    3b76:	18fb      	adds	r3, r7, r3
    3b78:	2201      	movs	r2, #1
    3b7a:	701a      	strb	r2, [r3, #0]
				break;
    3b7c:	e00b      	b.n	3b96 <ext_irq_register+0x102>
		for (i = 0; i < EXT_IRQ_AMOUNT; i++) {
    3b7e:	2317      	movs	r3, #23
    3b80:	18fb      	adds	r3, r7, r3
    3b82:	781a      	ldrb	r2, [r3, #0]
    3b84:	2317      	movs	r3, #23
    3b86:	18fb      	adds	r3, r7, r3
    3b88:	3201      	adds	r2, #1
    3b8a:	701a      	strb	r2, [r3, #0]
    3b8c:	2317      	movs	r3, #23
    3b8e:	18fb      	adds	r3, r7, r3
    3b90:	781b      	ldrb	r3, [r3, #0]
    3b92:	2b02      	cmp	r3, #2
    3b94:	d9d6      	bls.n	3b44 <ext_irq_register+0xb0>
			}
		}
		for (; (j < EXT_IRQ_AMOUNT) && (i < EXT_IRQ_AMOUNT); j++) {
    3b96:	e045      	b.n	3c24 <ext_irq_register+0x190>
			if ((ext_irqs[i].pin < ext_irqs[j].pin) && (ext_irqs[j].pin != 0xFFFFFFFF)) {
    3b98:	2317      	movs	r3, #23
    3b9a:	18fb      	adds	r3, r7, r3
    3b9c:	781b      	ldrb	r3, [r3, #0]
    3b9e:	4a31      	ldr	r2, [pc, #196]	; (3c64 <ext_irq_register+0x1d0>)
    3ba0:	00db      	lsls	r3, r3, #3
    3ba2:	18d3      	adds	r3, r2, r3
    3ba4:	3304      	adds	r3, #4
    3ba6:	681a      	ldr	r2, [r3, #0]
    3ba8:	2316      	movs	r3, #22
    3baa:	18fb      	adds	r3, r7, r3
    3bac:	781b      	ldrb	r3, [r3, #0]
    3bae:	492d      	ldr	r1, [pc, #180]	; (3c64 <ext_irq_register+0x1d0>)
    3bb0:	00db      	lsls	r3, r3, #3
    3bb2:	18cb      	adds	r3, r1, r3
    3bb4:	3304      	adds	r3, #4
    3bb6:	681b      	ldr	r3, [r3, #0]
    3bb8:	429a      	cmp	r2, r3
    3bba:	d22c      	bcs.n	3c16 <ext_irq_register+0x182>
    3bbc:	2316      	movs	r3, #22
    3bbe:	18fb      	adds	r3, r7, r3
    3bc0:	781b      	ldrb	r3, [r3, #0]
    3bc2:	4a28      	ldr	r2, [pc, #160]	; (3c64 <ext_irq_register+0x1d0>)
    3bc4:	00db      	lsls	r3, r3, #3
    3bc6:	18d3      	adds	r3, r2, r3
    3bc8:	3304      	adds	r3, #4
    3bca:	681b      	ldr	r3, [r3, #0]
    3bcc:	3301      	adds	r3, #1
    3bce:	d022      	beq.n	3c16 <ext_irq_register+0x182>
				struct ext_irq tmp = ext_irqs[j];
    3bd0:	2316      	movs	r3, #22
    3bd2:	18fb      	adds	r3, r7, r3
    3bd4:	781b      	ldrb	r3, [r3, #0]
    3bd6:	220c      	movs	r2, #12
    3bd8:	18ba      	adds	r2, r7, r2
    3bda:	4922      	ldr	r1, [pc, #136]	; (3c64 <ext_irq_register+0x1d0>)
    3bdc:	00db      	lsls	r3, r3, #3
    3bde:	18cb      	adds	r3, r1, r3
    3be0:	cb03      	ldmia	r3!, {r0, r1}
    3be2:	c203      	stmia	r2!, {r0, r1}

				ext_irqs[j] = ext_irqs[i];
    3be4:	2316      	movs	r3, #22
    3be6:	18fb      	adds	r3, r7, r3
    3be8:	781b      	ldrb	r3, [r3, #0]
    3bea:	2217      	movs	r2, #23
    3bec:	18ba      	adds	r2, r7, r2
    3bee:	7812      	ldrb	r2, [r2, #0]
    3bf0:	481c      	ldr	r0, [pc, #112]	; (3c64 <ext_irq_register+0x1d0>)
    3bf2:	00db      	lsls	r3, r3, #3
    3bf4:	491b      	ldr	r1, [pc, #108]	; (3c64 <ext_irq_register+0x1d0>)
    3bf6:	00d2      	lsls	r2, r2, #3
    3bf8:	18c3      	adds	r3, r0, r3
    3bfa:	188a      	adds	r2, r1, r2
    3bfc:	ca03      	ldmia	r2!, {r0, r1}
    3bfe:	c303      	stmia	r3!, {r0, r1}
				ext_irqs[i] = tmp;
    3c00:	2317      	movs	r3, #23
    3c02:	18fb      	adds	r3, r7, r3
    3c04:	781b      	ldrb	r3, [r3, #0]
    3c06:	4a17      	ldr	r2, [pc, #92]	; (3c64 <ext_irq_register+0x1d0>)
    3c08:	00db      	lsls	r3, r3, #3
    3c0a:	210c      	movs	r1, #12
    3c0c:	1879      	adds	r1, r7, r1
    3c0e:	18d3      	adds	r3, r2, r3
    3c10:	000a      	movs	r2, r1
    3c12:	ca03      	ldmia	r2!, {r0, r1}
    3c14:	c303      	stmia	r3!, {r0, r1}
		for (; (j < EXT_IRQ_AMOUNT) && (i < EXT_IRQ_AMOUNT); j++) {
    3c16:	2316      	movs	r3, #22
    3c18:	18fb      	adds	r3, r7, r3
    3c1a:	781a      	ldrb	r2, [r3, #0]
    3c1c:	2316      	movs	r3, #22
    3c1e:	18fb      	adds	r3, r7, r3
    3c20:	3201      	adds	r2, #1
    3c22:	701a      	strb	r2, [r3, #0]
    3c24:	2316      	movs	r3, #22
    3c26:	18fb      	adds	r3, r7, r3
    3c28:	781b      	ldrb	r3, [r3, #0]
    3c2a:	2b02      	cmp	r3, #2
    3c2c:	d804      	bhi.n	3c38 <ext_irq_register+0x1a4>
    3c2e:	2317      	movs	r3, #23
    3c30:	18fb      	adds	r3, r7, r3
    3c32:	781b      	ldrb	r3, [r3, #0]
    3c34:	2b02      	cmp	r3, #2
    3c36:	d9af      	bls.n	3b98 <ext_irq_register+0x104>
			}
		}
	}

	if (!found) {
    3c38:	2315      	movs	r3, #21
    3c3a:	18fb      	adds	r3, r7, r3
    3c3c:	781b      	ldrb	r3, [r3, #0]
    3c3e:	2201      	movs	r2, #1
    3c40:	4053      	eors	r3, r2
    3c42:	b2db      	uxtb	r3, r3
    3c44:	2b00      	cmp	r3, #0
    3c46:	d002      	beq.n	3c4e <ext_irq_register+0x1ba>
		return ERR_INVALID_ARG;
    3c48:	230d      	movs	r3, #13
    3c4a:	425b      	negs	r3, r3
    3c4c:	e005      	b.n	3c5a <ext_irq_register+0x1c6>
	}

	return _ext_irq_enable(pin, true);
    3c4e:	687b      	ldr	r3, [r7, #4]
    3c50:	2101      	movs	r1, #1
    3c52:	0018      	movs	r0, r3
    3c54:	f000 fde8 	bl	4828 <_ext_irq_enable>
    3c58:	0003      	movs	r3, r0
}
    3c5a:	0018      	movs	r0, r3
    3c5c:	46bd      	mov	sp, r7
    3c5e:	b006      	add	sp, #24
    3c60:	bd80      	pop	{r7, pc}
    3c62:	46c0      	nop			; (mov r8, r8)
    3c64:	200007b0 	.word	0x200007b0

00003c68 <process_ext_irq>:
 * \brief Interrupt processing routine
 *
 * \param[in] pin The pin which triggered the interrupt
 */
static void process_ext_irq(const uint32_t pin)
{
    3c68:	b580      	push	{r7, lr}
    3c6a:	b084      	sub	sp, #16
    3c6c:	af00      	add	r7, sp, #0
    3c6e:	6078      	str	r0, [r7, #4]
	uint8_t lower = 0, middle, upper = EXT_IRQ_AMOUNT;
    3c70:	230f      	movs	r3, #15
    3c72:	18fb      	adds	r3, r7, r3
    3c74:	2200      	movs	r2, #0
    3c76:	701a      	strb	r2, [r3, #0]
    3c78:	230e      	movs	r3, #14
    3c7a:	18fb      	adds	r3, r7, r3
    3c7c:	2203      	movs	r2, #3
    3c7e:	701a      	strb	r2, [r3, #0]

	while (upper >= lower) {
    3c80:	e050      	b.n	3d24 <process_ext_irq+0xbc>
		middle = (upper + lower) >> 1;
    3c82:	230e      	movs	r3, #14
    3c84:	18fb      	adds	r3, r7, r3
    3c86:	781a      	ldrb	r2, [r3, #0]
    3c88:	230f      	movs	r3, #15
    3c8a:	18fb      	adds	r3, r7, r3
    3c8c:	781b      	ldrb	r3, [r3, #0]
    3c8e:	18d3      	adds	r3, r2, r3
    3c90:	105a      	asrs	r2, r3, #1
    3c92:	230d      	movs	r3, #13
    3c94:	18fb      	adds	r3, r7, r3
    3c96:	701a      	strb	r2, [r3, #0]
		if (middle >= EXT_IRQ_AMOUNT) {
    3c98:	230d      	movs	r3, #13
    3c9a:	18fb      	adds	r3, r7, r3
    3c9c:	781b      	ldrb	r3, [r3, #0]
    3c9e:	2b02      	cmp	r3, #2
    3ca0:	d849      	bhi.n	3d36 <process_ext_irq+0xce>
			return;
		}

		if (ext_irqs[middle].pin == pin) {
    3ca2:	230d      	movs	r3, #13
    3ca4:	18fb      	adds	r3, r7, r3
    3ca6:	781b      	ldrb	r3, [r3, #0]
    3ca8:	4a26      	ldr	r2, [pc, #152]	; (3d44 <process_ext_irq+0xdc>)
    3caa:	00db      	lsls	r3, r3, #3
    3cac:	18d3      	adds	r3, r2, r3
    3cae:	3304      	adds	r3, #4
    3cb0:	681a      	ldr	r2, [r3, #0]
    3cb2:	687b      	ldr	r3, [r7, #4]
    3cb4:	429a      	cmp	r2, r3
    3cb6:	d10f      	bne.n	3cd8 <process_ext_irq+0x70>
			if (ext_irqs[middle].cb) {
    3cb8:	230d      	movs	r3, #13
    3cba:	18fb      	adds	r3, r7, r3
    3cbc:	781a      	ldrb	r2, [r3, #0]
    3cbe:	4b21      	ldr	r3, [pc, #132]	; (3d44 <process_ext_irq+0xdc>)
    3cc0:	00d2      	lsls	r2, r2, #3
    3cc2:	58d3      	ldr	r3, [r2, r3]
    3cc4:	2b00      	cmp	r3, #0
    3cc6:	d038      	beq.n	3d3a <process_ext_irq+0xd2>
				ext_irqs[middle].cb();
    3cc8:	230d      	movs	r3, #13
    3cca:	18fb      	adds	r3, r7, r3
    3ccc:	781a      	ldrb	r2, [r3, #0]
    3cce:	4b1d      	ldr	r3, [pc, #116]	; (3d44 <process_ext_irq+0xdc>)
    3cd0:	00d2      	lsls	r2, r2, #3
    3cd2:	58d3      	ldr	r3, [r2, r3]
    3cd4:	4798      	blx	r3
			}
			return;
    3cd6:	e030      	b.n	3d3a <process_ext_irq+0xd2>
		}

		if (ext_irqs[middle].pin < pin) {
    3cd8:	230d      	movs	r3, #13
    3cda:	18fb      	adds	r3, r7, r3
    3cdc:	781b      	ldrb	r3, [r3, #0]
    3cde:	4a19      	ldr	r2, [pc, #100]	; (3d44 <process_ext_irq+0xdc>)
    3ce0:	00db      	lsls	r3, r3, #3
    3ce2:	18d3      	adds	r3, r2, r3
    3ce4:	3304      	adds	r3, #4
    3ce6:	681a      	ldr	r2, [r3, #0]
    3ce8:	687b      	ldr	r3, [r7, #4]
    3cea:	429a      	cmp	r2, r3
    3cec:	d20d      	bcs.n	3d0a <process_ext_irq+0xa2>
			lower = middle + 1;
    3cee:	230f      	movs	r3, #15
    3cf0:	18fb      	adds	r3, r7, r3
    3cf2:	220d      	movs	r2, #13
    3cf4:	18ba      	adds	r2, r7, r2
    3cf6:	7812      	ldrb	r2, [r2, #0]
    3cf8:	3201      	adds	r2, #1
    3cfa:	701a      	strb	r2, [r3, #0]
    3cfc:	230e      	movs	r3, #14
    3cfe:	18fb      	adds	r3, r7, r3
    3d00:	220e      	movs	r2, #14
    3d02:	18ba      	adds	r2, r7, r2
    3d04:	7812      	ldrb	r2, [r2, #0]
    3d06:	701a      	strb	r2, [r3, #0]
    3d08:	e00c      	b.n	3d24 <process_ext_irq+0xbc>
		} else {
			upper = middle - 1;
    3d0a:	230e      	movs	r3, #14
    3d0c:	18fb      	adds	r3, r7, r3
    3d0e:	220d      	movs	r2, #13
    3d10:	18ba      	adds	r2, r7, r2
    3d12:	7812      	ldrb	r2, [r2, #0]
    3d14:	3a01      	subs	r2, #1
    3d16:	701a      	strb	r2, [r3, #0]
    3d18:	230f      	movs	r3, #15
    3d1a:	18fb      	adds	r3, r7, r3
    3d1c:	220f      	movs	r2, #15
    3d1e:	18ba      	adds	r2, r7, r2
    3d20:	7812      	ldrb	r2, [r2, #0]
    3d22:	701a      	strb	r2, [r3, #0]
	while (upper >= lower) {
    3d24:	230e      	movs	r3, #14
    3d26:	18fa      	adds	r2, r7, r3
    3d28:	230f      	movs	r3, #15
    3d2a:	18fb      	adds	r3, r7, r3
    3d2c:	7812      	ldrb	r2, [r2, #0]
    3d2e:	781b      	ldrb	r3, [r3, #0]
    3d30:	429a      	cmp	r2, r3
    3d32:	d2a6      	bcs.n	3c82 <process_ext_irq+0x1a>
    3d34:	e002      	b.n	3d3c <process_ext_irq+0xd4>
			return;
    3d36:	46c0      	nop			; (mov r8, r8)
    3d38:	e000      	b.n	3d3c <process_ext_irq+0xd4>
			return;
    3d3a:	46c0      	nop			; (mov r8, r8)
		}
	}
}
    3d3c:	46bd      	mov	sp, r7
    3d3e:	b004      	add	sp, #16
    3d40:	bd80      	pop	{r7, pc}
    3d42:	46c0      	nop			; (mov r8, r8)
    3d44:	200007b0 	.word	0x200007b0

00003d48 <i2c_m_sync_read>:

/**
 * \brief Sync version of I2C I/O read
 */
static int32_t i2c_m_sync_read(struct io_descriptor *io, uint8_t *buf, const uint16_t n)
{
    3d48:	b580      	push	{r7, lr}
    3d4a:	b08a      	sub	sp, #40	; 0x28
    3d4c:	af00      	add	r7, sp, #0
    3d4e:	60f8      	str	r0, [r7, #12]
    3d50:	60b9      	str	r1, [r7, #8]
    3d52:	1dbb      	adds	r3, r7, #6
    3d54:	801a      	strh	r2, [r3, #0]
	struct i2c_m_sync_desc *i2c = CONTAINER_OF(io, struct i2c_m_sync_desc, io);
    3d56:	68fb      	ldr	r3, [r7, #12]
    3d58:	3b14      	subs	r3, #20
    3d5a:	627b      	str	r3, [r7, #36]	; 0x24
	struct _i2c_m_msg       msg;
	int32_t                 ret;

	msg.addr   = i2c->slave_addr;
    3d5c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    3d5e:	8b9a      	ldrh	r2, [r3, #28]
    3d60:	2314      	movs	r3, #20
    3d62:	18fb      	adds	r3, r7, r3
    3d64:	801a      	strh	r2, [r3, #0]
	msg.len    = n;
    3d66:	1dbb      	adds	r3, r7, #6
    3d68:	881a      	ldrh	r2, [r3, #0]
    3d6a:	2314      	movs	r3, #20
    3d6c:	18fb      	adds	r3, r7, r3
    3d6e:	605a      	str	r2, [r3, #4]
	msg.flags  = I2C_M_STOP | I2C_M_RD;
    3d70:	2314      	movs	r3, #20
    3d72:	18fb      	adds	r3, r7, r3
    3d74:	4a0c      	ldr	r2, [pc, #48]	; (3da8 <i2c_m_sync_read+0x60>)
    3d76:	805a      	strh	r2, [r3, #2]
	msg.buffer = buf;
    3d78:	2314      	movs	r3, #20
    3d7a:	18fb      	adds	r3, r7, r3
    3d7c:	68ba      	ldr	r2, [r7, #8]
    3d7e:	609a      	str	r2, [r3, #8]

	ret = _i2c_m_sync_transfer(&i2c->device, &msg);
    3d80:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    3d82:	2214      	movs	r2, #20
    3d84:	18ba      	adds	r2, r7, r2
    3d86:	0011      	movs	r1, r2
    3d88:	0018      	movs	r0, r3
    3d8a:	f001 fdb1 	bl	58f0 <_i2c_m_sync_transfer>
    3d8e:	0003      	movs	r3, r0
    3d90:	623b      	str	r3, [r7, #32]

	if (ret) {
    3d92:	6a3b      	ldr	r3, [r7, #32]
    3d94:	2b00      	cmp	r3, #0
    3d96:	d001      	beq.n	3d9c <i2c_m_sync_read+0x54>
		return ret;
    3d98:	6a3b      	ldr	r3, [r7, #32]
    3d9a:	e001      	b.n	3da0 <i2c_m_sync_read+0x58>
	}

	return n;
    3d9c:	1dbb      	adds	r3, r7, #6
    3d9e:	881b      	ldrh	r3, [r3, #0]
}
    3da0:	0018      	movs	r0, r3
    3da2:	46bd      	mov	sp, r7
    3da4:	b00a      	add	sp, #40	; 0x28
    3da6:	bd80      	pop	{r7, pc}
    3da8:	ffff8001 	.word	0xffff8001

00003dac <i2c_m_sync_write>:

/**
 * \brief Sync version of I2C I/O write
 */
static int32_t i2c_m_sync_write(struct io_descriptor *io, const uint8_t *buf, const uint16_t n)
{
    3dac:	b580      	push	{r7, lr}
    3dae:	b08a      	sub	sp, #40	; 0x28
    3db0:	af00      	add	r7, sp, #0
    3db2:	60f8      	str	r0, [r7, #12]
    3db4:	60b9      	str	r1, [r7, #8]
    3db6:	1dbb      	adds	r3, r7, #6
    3db8:	801a      	strh	r2, [r3, #0]
	struct i2c_m_sync_desc *i2c = CONTAINER_OF(io, struct i2c_m_sync_desc, io);
    3dba:	68fb      	ldr	r3, [r7, #12]
    3dbc:	3b14      	subs	r3, #20
    3dbe:	627b      	str	r3, [r7, #36]	; 0x24
	struct _i2c_m_msg       msg;
	int32_t                 ret;

	msg.addr   = i2c->slave_addr;
    3dc0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    3dc2:	8b9a      	ldrh	r2, [r3, #28]
    3dc4:	2314      	movs	r3, #20
    3dc6:	18fb      	adds	r3, r7, r3
    3dc8:	801a      	strh	r2, [r3, #0]
	msg.len    = n;
    3dca:	1dbb      	adds	r3, r7, #6
    3dcc:	881a      	ldrh	r2, [r3, #0]
    3dce:	2314      	movs	r3, #20
    3dd0:	18fb      	adds	r3, r7, r3
    3dd2:	605a      	str	r2, [r3, #4]
	msg.flags  = I2C_M_STOP;
    3dd4:	2314      	movs	r3, #20
    3dd6:	18fb      	adds	r3, r7, r3
    3dd8:	4a0c      	ldr	r2, [pc, #48]	; (3e0c <i2c_m_sync_write+0x60>)
    3dda:	805a      	strh	r2, [r3, #2]
	msg.buffer = (uint8_t *)buf;
    3ddc:	2314      	movs	r3, #20
    3dde:	18fb      	adds	r3, r7, r3
    3de0:	68ba      	ldr	r2, [r7, #8]
    3de2:	609a      	str	r2, [r3, #8]

	ret = _i2c_m_sync_transfer(&i2c->device, &msg);
    3de4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    3de6:	2214      	movs	r2, #20
    3de8:	18ba      	adds	r2, r7, r2
    3dea:	0011      	movs	r1, r2
    3dec:	0018      	movs	r0, r3
    3dee:	f001 fd7f 	bl	58f0 <_i2c_m_sync_transfer>
    3df2:	0003      	movs	r3, r0
    3df4:	623b      	str	r3, [r7, #32]

	if (ret) {
    3df6:	6a3b      	ldr	r3, [r7, #32]
    3df8:	2b00      	cmp	r3, #0
    3dfa:	d001      	beq.n	3e00 <i2c_m_sync_write+0x54>
		return ret;
    3dfc:	6a3b      	ldr	r3, [r7, #32]
    3dfe:	e001      	b.n	3e04 <i2c_m_sync_write+0x58>
	}

	return n;
    3e00:	1dbb      	adds	r3, r7, #6
    3e02:	881b      	ldrh	r3, [r3, #0]
}
    3e04:	0018      	movs	r0, r3
    3e06:	46bd      	mov	sp, r7
    3e08:	b00a      	add	sp, #40	; 0x28
    3e0a:	bd80      	pop	{r7, pc}
    3e0c:	ffff8000 	.word	0xffff8000

00003e10 <i2c_m_sync_init>:

/**
 * \brief Sync version of i2c initialize
 */
int32_t i2c_m_sync_init(struct i2c_m_sync_desc *i2c, void *hw)
{
    3e10:	b580      	push	{r7, lr}
    3e12:	b084      	sub	sp, #16
    3e14:	af00      	add	r7, sp, #0
    3e16:	6078      	str	r0, [r7, #4]
    3e18:	6039      	str	r1, [r7, #0]
	int32_t init_status;
	ASSERT(i2c);
    3e1a:	687b      	ldr	r3, [r7, #4]
    3e1c:	1e5a      	subs	r2, r3, #1
    3e1e:	4193      	sbcs	r3, r2
    3e20:	b2db      	uxtb	r3, r3
    3e22:	490e      	ldr	r1, [pc, #56]	; (3e5c <i2c_m_sync_init+0x4c>)
    3e24:	225e      	movs	r2, #94	; 0x5e
    3e26:	0018      	movs	r0, r3
    3e28:	f000 fa9a 	bl	4360 <assert>

	init_status = _i2c_m_sync_init(&i2c->device, hw);
    3e2c:	687b      	ldr	r3, [r7, #4]
    3e2e:	683a      	ldr	r2, [r7, #0]
    3e30:	0011      	movs	r1, r2
    3e32:	0018      	movs	r0, r3
    3e34:	f001 fc20 	bl	5678 <_i2c_m_sync_init>
    3e38:	0003      	movs	r3, r0
    3e3a:	60fb      	str	r3, [r7, #12]
	if (init_status) {
    3e3c:	68fb      	ldr	r3, [r7, #12]
    3e3e:	2b00      	cmp	r3, #0
    3e40:	d001      	beq.n	3e46 <i2c_m_sync_init+0x36>
		return init_status;
    3e42:	68fb      	ldr	r3, [r7, #12]
    3e44:	e006      	b.n	3e54 <i2c_m_sync_init+0x44>
	}

	/* Init I/O */
	i2c->io.read  = i2c_m_sync_read;
    3e46:	687b      	ldr	r3, [r7, #4]
    3e48:	4a05      	ldr	r2, [pc, #20]	; (3e60 <i2c_m_sync_init+0x50>)
    3e4a:	619a      	str	r2, [r3, #24]
	i2c->io.write = i2c_m_sync_write;
    3e4c:	687b      	ldr	r3, [r7, #4]
    3e4e:	4a05      	ldr	r2, [pc, #20]	; (3e64 <i2c_m_sync_init+0x54>)
    3e50:	615a      	str	r2, [r3, #20]

	return ERR_NONE;
    3e52:	2300      	movs	r3, #0
}
    3e54:	0018      	movs	r0, r3
    3e56:	46bd      	mov	sp, r7
    3e58:	b004      	add	sp, #16
    3e5a:	bd80      	pop	{r7, pc}
    3e5c:	00008f10 	.word	0x00008f10
    3e60:	00003d49 	.word	0x00003d49
    3e64:	00003dad 	.word	0x00003dad

00003e68 <i2c_m_sync_enable>:

/**
 * \brief Sync version of i2c enable
 */
int32_t i2c_m_sync_enable(struct i2c_m_sync_desc *i2c)
{
    3e68:	b580      	push	{r7, lr}
    3e6a:	b082      	sub	sp, #8
    3e6c:	af00      	add	r7, sp, #0
    3e6e:	6078      	str	r0, [r7, #4]
	return _i2c_m_sync_enable(&i2c->device);
    3e70:	687b      	ldr	r3, [r7, #4]
    3e72:	0018      	movs	r0, r3
    3e74:	f001 fc82 	bl	577c <_i2c_m_sync_enable>
    3e78:	0003      	movs	r3, r0
}
    3e7a:	0018      	movs	r0, r3
    3e7c:	46bd      	mov	sp, r7
    3e7e:	b002      	add	sp, #8
    3e80:	bd80      	pop	{r7, pc}

00003e82 <i2c_m_sync_set_slaveaddr>:

/**
 * \brief Sync version of i2c set slave address
 */
int32_t i2c_m_sync_set_slaveaddr(struct i2c_m_sync_desc *i2c, int16_t addr, int32_t addr_len)
{
    3e82:	b580      	push	{r7, lr}
    3e84:	b084      	sub	sp, #16
    3e86:	af00      	add	r7, sp, #0
    3e88:	60f8      	str	r0, [r7, #12]
    3e8a:	607a      	str	r2, [r7, #4]
    3e8c:	230a      	movs	r3, #10
    3e8e:	18fb      	adds	r3, r7, r3
    3e90:	1c0a      	adds	r2, r1, #0
    3e92:	801a      	strh	r2, [r3, #0]
	return i2c->slave_addr = (addr & 0x3ff) | (addr_len & I2C_M_TEN);
    3e94:	230a      	movs	r3, #10
    3e96:	18fb      	adds	r3, r7, r3
    3e98:	881b      	ldrh	r3, [r3, #0]
    3e9a:	059b      	lsls	r3, r3, #22
    3e9c:	0d9b      	lsrs	r3, r3, #22
    3e9e:	b21a      	sxth	r2, r3
    3ea0:	687b      	ldr	r3, [r7, #4]
    3ea2:	b219      	sxth	r1, r3
    3ea4:	2380      	movs	r3, #128	; 0x80
    3ea6:	00db      	lsls	r3, r3, #3
    3ea8:	400b      	ands	r3, r1
    3eaa:	b21b      	sxth	r3, r3
    3eac:	4313      	orrs	r3, r2
    3eae:	b21b      	sxth	r3, r3
    3eb0:	b29a      	uxth	r2, r3
    3eb2:	68fb      	ldr	r3, [r7, #12]
    3eb4:	839a      	strh	r2, [r3, #28]
    3eb6:	68fb      	ldr	r3, [r7, #12]
    3eb8:	8b9b      	ldrh	r3, [r3, #28]
}
    3eba:	0018      	movs	r0, r3
    3ebc:	46bd      	mov	sp, r7
    3ebe:	b004      	add	sp, #16
    3ec0:	bd80      	pop	{r7, pc}

00003ec2 <i2c_m_sync_get_io_descriptor>:

/**
 * \brief Retrieve I/O descriptor
 */
int32_t i2c_m_sync_get_io_descriptor(struct i2c_m_sync_desc *const i2c, struct io_descriptor **io)
{
    3ec2:	b580      	push	{r7, lr}
    3ec4:	b082      	sub	sp, #8
    3ec6:	af00      	add	r7, sp, #0
    3ec8:	6078      	str	r0, [r7, #4]
    3eca:	6039      	str	r1, [r7, #0]
	*io = &i2c->io;
    3ecc:	687b      	ldr	r3, [r7, #4]
    3ece:	3314      	adds	r3, #20
    3ed0:	001a      	movs	r2, r3
    3ed2:	683b      	ldr	r3, [r7, #0]
    3ed4:	601a      	str	r2, [r3, #0]
	return ERR_NONE;
    3ed6:	2300      	movs	r3, #0
}
    3ed8:	0018      	movs	r0, r3
    3eda:	46bd      	mov	sp, r7
    3edc:	b002      	add	sp, #8
    3ede:	bd80      	pop	{r7, pc}

00003ee0 <io_write>:

/**
 * \brief I/O write interface
 */
int32_t io_write(struct io_descriptor *const io_descr, const uint8_t *const buf, const uint16_t length)
{
    3ee0:	b580      	push	{r7, lr}
    3ee2:	b084      	sub	sp, #16
    3ee4:	af00      	add	r7, sp, #0
    3ee6:	60f8      	str	r0, [r7, #12]
    3ee8:	60b9      	str	r1, [r7, #8]
    3eea:	1dbb      	adds	r3, r7, #6
    3eec:	801a      	strh	r2, [r3, #0]
	ASSERT(io_descr && buf);
    3eee:	68fb      	ldr	r3, [r7, #12]
    3ef0:	2b00      	cmp	r3, #0
    3ef2:	d004      	beq.n	3efe <io_write+0x1e>
    3ef4:	68bb      	ldr	r3, [r7, #8]
    3ef6:	2b00      	cmp	r3, #0
    3ef8:	d001      	beq.n	3efe <io_write+0x1e>
    3efa:	2301      	movs	r3, #1
    3efc:	e000      	b.n	3f00 <io_write+0x20>
    3efe:	2300      	movs	r3, #0
    3f00:	1c1a      	adds	r2, r3, #0
    3f02:	2301      	movs	r3, #1
    3f04:	4013      	ands	r3, r2
    3f06:	b2db      	uxtb	r3, r3
    3f08:	4908      	ldr	r1, [pc, #32]	; (3f2c <io_write+0x4c>)
    3f0a:	2234      	movs	r2, #52	; 0x34
    3f0c:	0018      	movs	r0, r3
    3f0e:	f000 fa27 	bl	4360 <assert>
	return io_descr->write(io_descr, buf, length);
    3f12:	68fb      	ldr	r3, [r7, #12]
    3f14:	681b      	ldr	r3, [r3, #0]
    3f16:	1dba      	adds	r2, r7, #6
    3f18:	8812      	ldrh	r2, [r2, #0]
    3f1a:	68b9      	ldr	r1, [r7, #8]
    3f1c:	68f8      	ldr	r0, [r7, #12]
    3f1e:	4798      	blx	r3
    3f20:	0003      	movs	r3, r0
}
    3f22:	0018      	movs	r0, r3
    3f24:	46bd      	mov	sp, r7
    3f26:	b004      	add	sp, #16
    3f28:	bd80      	pop	{r7, pc}
    3f2a:	46c0      	nop			; (mov r8, r8)
    3f2c:	00008f2c 	.word	0x00008f2c

00003f30 <io_read>:

/**
 * \brief I/O read interface
 */
int32_t io_read(struct io_descriptor *const io_descr, uint8_t *const buf, const uint16_t length)
{
    3f30:	b580      	push	{r7, lr}
    3f32:	b084      	sub	sp, #16
    3f34:	af00      	add	r7, sp, #0
    3f36:	60f8      	str	r0, [r7, #12]
    3f38:	60b9      	str	r1, [r7, #8]
    3f3a:	1dbb      	adds	r3, r7, #6
    3f3c:	801a      	strh	r2, [r3, #0]
	ASSERT(io_descr && buf);
    3f3e:	68fb      	ldr	r3, [r7, #12]
    3f40:	2b00      	cmp	r3, #0
    3f42:	d004      	beq.n	3f4e <io_read+0x1e>
    3f44:	68bb      	ldr	r3, [r7, #8]
    3f46:	2b00      	cmp	r3, #0
    3f48:	d001      	beq.n	3f4e <io_read+0x1e>
    3f4a:	2301      	movs	r3, #1
    3f4c:	e000      	b.n	3f50 <io_read+0x20>
    3f4e:	2300      	movs	r3, #0
    3f50:	1c1a      	adds	r2, r3, #0
    3f52:	2301      	movs	r3, #1
    3f54:	4013      	ands	r3, r2
    3f56:	b2db      	uxtb	r3, r3
    3f58:	4908      	ldr	r1, [pc, #32]	; (3f7c <io_read+0x4c>)
    3f5a:	223d      	movs	r2, #61	; 0x3d
    3f5c:	0018      	movs	r0, r3
    3f5e:	f000 f9ff 	bl	4360 <assert>
	return io_descr->read(io_descr, buf, length);
    3f62:	68fb      	ldr	r3, [r7, #12]
    3f64:	685b      	ldr	r3, [r3, #4]
    3f66:	1dba      	adds	r2, r7, #6
    3f68:	8812      	ldrh	r2, [r2, #0]
    3f6a:	68b9      	ldr	r1, [r7, #8]
    3f6c:	68f8      	ldr	r0, [r7, #12]
    3f6e:	4798      	blx	r3
    3f70:	0003      	movs	r3, r0
}
    3f72:	0018      	movs	r0, r3
    3f74:	46bd      	mov	sp, r7
    3f76:	b004      	add	sp, #16
    3f78:	bd80      	pop	{r7, pc}
    3f7a:	46c0      	nop			; (mov r8, r8)
    3f7c:	00008f2c 	.word	0x00008f2c

00003f80 <spi_m_sync_init>:
	ASSERT(spi);
	spi->func = (struct _spi_m_sync_hpl_interface *)func;
}

int32_t spi_m_sync_init(struct spi_m_sync_descriptor *spi, void *const hw)
{
    3f80:	b580      	push	{r7, lr}
    3f82:	b084      	sub	sp, #16
    3f84:	af00      	add	r7, sp, #0
    3f86:	6078      	str	r0, [r7, #4]
    3f88:	6039      	str	r1, [r7, #0]
	int32_t rc = 0;
    3f8a:	2300      	movs	r3, #0
    3f8c:	60fb      	str	r3, [r7, #12]
	ASSERT(spi && hw);
    3f8e:	687b      	ldr	r3, [r7, #4]
    3f90:	2b00      	cmp	r3, #0
    3f92:	d004      	beq.n	3f9e <spi_m_sync_init+0x1e>
    3f94:	683b      	ldr	r3, [r7, #0]
    3f96:	2b00      	cmp	r3, #0
    3f98:	d001      	beq.n	3f9e <spi_m_sync_init+0x1e>
    3f9a:	2301      	movs	r3, #1
    3f9c:	e000      	b.n	3fa0 <spi_m_sync_init+0x20>
    3f9e:	2300      	movs	r3, #0
    3fa0:	1c1a      	adds	r2, r3, #0
    3fa2:	2301      	movs	r3, #1
    3fa4:	4013      	ands	r3, r2
    3fa6:	b2db      	uxtb	r3, r3
    3fa8:	4911      	ldr	r1, [pc, #68]	; (3ff0 <spi_m_sync_init+0x70>)
    3faa:	2240      	movs	r2, #64	; 0x40
    3fac:	0018      	movs	r0, r3
    3fae:	f000 f9d7 	bl	4360 <assert>
	spi->dev.prvt = (void *)hw;
    3fb2:	687b      	ldr	r3, [r7, #4]
    3fb4:	683a      	ldr	r2, [r7, #0]
    3fb6:	605a      	str	r2, [r3, #4]
	rc            = _spi_m_sync_init(&spi->dev, hw);
    3fb8:	687b      	ldr	r3, [r7, #4]
    3fba:	3304      	adds	r3, #4
    3fbc:	683a      	ldr	r2, [r7, #0]
    3fbe:	0011      	movs	r1, r2
    3fc0:	0018      	movs	r0, r3
    3fc2:	f001 fe37 	bl	5c34 <_spi_m_sync_init>
    3fc6:	0003      	movs	r3, r0
    3fc8:	60fb      	str	r3, [r7, #12]

	if (rc < 0) {
    3fca:	68fb      	ldr	r3, [r7, #12]
    3fcc:	2b00      	cmp	r3, #0
    3fce:	da01      	bge.n	3fd4 <spi_m_sync_init+0x54>
		return rc;
    3fd0:	68fb      	ldr	r3, [r7, #12]
    3fd2:	e009      	b.n	3fe8 <spi_m_sync_init+0x68>
	}

	spi->flags    = SPI_DEACTIVATE_NEXT;
    3fd4:	687b      	ldr	r3, [r7, #4]
    3fd6:	4a07      	ldr	r2, [pc, #28]	; (3ff4 <spi_m_sync_init+0x74>)
    3fd8:	829a      	strh	r2, [r3, #20]
	spi->io.read  = _spi_m_sync_io_read;
    3fda:	687b      	ldr	r3, [r7, #4]
    3fdc:	4a06      	ldr	r2, [pc, #24]	; (3ff8 <spi_m_sync_init+0x78>)
    3fde:	611a      	str	r2, [r3, #16]
	spi->io.write = _spi_m_sync_io_write;
    3fe0:	687b      	ldr	r3, [r7, #4]
    3fe2:	4a06      	ldr	r2, [pc, #24]	; (3ffc <spi_m_sync_init+0x7c>)
    3fe4:	60da      	str	r2, [r3, #12]

	return ERR_NONE;
    3fe6:	2300      	movs	r3, #0
}
    3fe8:	0018      	movs	r0, r3
    3fea:	46bd      	mov	sp, r7
    3fec:	b004      	add	sp, #16
    3fee:	bd80      	pop	{r7, pc}
    3ff0:	00008f40 	.word	0x00008f40
    3ff4:	ffff8000 	.word	0xffff8000
    3ff8:	00004031 	.word	0x00004031
    3ffc:	0000408d 	.word	0x0000408d

00004000 <spi_m_sync_enable>:
	ASSERT(spi);
	_spi_m_sync_deinit(&spi->dev);
}

void spi_m_sync_enable(struct spi_m_sync_descriptor *spi)
{
    4000:	b580      	push	{r7, lr}
    4002:	b082      	sub	sp, #8
    4004:	af00      	add	r7, sp, #0
    4006:	6078      	str	r0, [r7, #4]
	ASSERT(spi);
    4008:	687b      	ldr	r3, [r7, #4]
    400a:	1e5a      	subs	r2, r3, #1
    400c:	4193      	sbcs	r3, r2
    400e:	b2db      	uxtb	r3, r3
    4010:	4906      	ldr	r1, [pc, #24]	; (402c <spi_m_sync_enable+0x2c>)
    4012:	2257      	movs	r2, #87	; 0x57
    4014:	0018      	movs	r0, r3
    4016:	f000 f9a3 	bl	4360 <assert>
	_spi_m_sync_enable(&spi->dev);
    401a:	687b      	ldr	r3, [r7, #4]
    401c:	3304      	adds	r3, #4
    401e:	0018      	movs	r0, r3
    4020:	f001 fe86 	bl	5d30 <_spi_m_sync_enable>
}
    4024:	46c0      	nop			; (mov r8, r8)
    4026:	46bd      	mov	sp, r7
    4028:	b002      	add	sp, #8
    402a:	bd80      	pop	{r7, pc}
    402c:	00008f40 	.word	0x00008f40

00004030 <_spi_m_sync_io_read>:
 *  \return Operation status.
 *  \retval size Success.
 *  \retval >=0 Time out, with number of characters read.
 */
static int32_t _spi_m_sync_io_read(struct io_descriptor *io, uint8_t *buf, const uint16_t length)
{
    4030:	b580      	push	{r7, lr}
    4032:	b088      	sub	sp, #32
    4034:	af00      	add	r7, sp, #0
    4036:	60f8      	str	r0, [r7, #12]
    4038:	60b9      	str	r1, [r7, #8]
    403a:	1dbb      	adds	r3, r7, #6
    403c:	801a      	strh	r2, [r3, #0]
	ASSERT(io);
    403e:	68fb      	ldr	r3, [r7, #12]
    4040:	1e5a      	subs	r2, r3, #1
    4042:	4193      	sbcs	r3, r2
    4044:	b2db      	uxtb	r3, r3
    4046:	4910      	ldr	r1, [pc, #64]	; (4088 <_spi_m_sync_io_read+0x58>)
    4048:	2287      	movs	r2, #135	; 0x87
    404a:	0018      	movs	r0, r3
    404c:	f000 f988 	bl	4360 <assert>

	struct spi_m_sync_descriptor *spi = CONTAINER_OF(io, struct spi_m_sync_descriptor, io);
    4050:	68fb      	ldr	r3, [r7, #12]
    4052:	3b0c      	subs	r3, #12
    4054:	61fb      	str	r3, [r7, #28]
	struct spi_xfer               xfer;

	xfer.rxbuf = buf;
    4056:	2310      	movs	r3, #16
    4058:	18fb      	adds	r3, r7, r3
    405a:	68ba      	ldr	r2, [r7, #8]
    405c:	605a      	str	r2, [r3, #4]
	xfer.txbuf = 0;
    405e:	2310      	movs	r3, #16
    4060:	18fb      	adds	r3, r7, r3
    4062:	2200      	movs	r2, #0
    4064:	601a      	str	r2, [r3, #0]
	xfer.size  = length;
    4066:	1dbb      	adds	r3, r7, #6
    4068:	881a      	ldrh	r2, [r3, #0]
    406a:	2310      	movs	r3, #16
    406c:	18fb      	adds	r3, r7, r3
    406e:	609a      	str	r2, [r3, #8]

	return spi_m_sync_transfer(spi, &xfer);
    4070:	2310      	movs	r3, #16
    4072:	18fa      	adds	r2, r7, r3
    4074:	69fb      	ldr	r3, [r7, #28]
    4076:	0011      	movs	r1, r2
    4078:	0018      	movs	r0, r3
    407a:	f000 f835 	bl	40e8 <spi_m_sync_transfer>
    407e:	0003      	movs	r3, r0
}
    4080:	0018      	movs	r0, r3
    4082:	46bd      	mov	sp, r7
    4084:	b008      	add	sp, #32
    4086:	bd80      	pop	{r7, pc}
    4088:	00008f40 	.word	0x00008f40

0000408c <_spi_m_sync_io_write>:
 *  \return Operation status.
 *  \retval size Success.
 *  \retval >=0 Timeout, with number of characters transferred.
 */
static int32_t _spi_m_sync_io_write(struct io_descriptor *const io, const uint8_t *const buf, const uint16_t length)
{
    408c:	b580      	push	{r7, lr}
    408e:	b088      	sub	sp, #32
    4090:	af00      	add	r7, sp, #0
    4092:	60f8      	str	r0, [r7, #12]
    4094:	60b9      	str	r1, [r7, #8]
    4096:	1dbb      	adds	r3, r7, #6
    4098:	801a      	strh	r2, [r3, #0]
	ASSERT(io);
    409a:	68fb      	ldr	r3, [r7, #12]
    409c:	1e5a      	subs	r2, r3, #1
    409e:	4193      	sbcs	r3, r2
    40a0:	b2db      	uxtb	r3, r3
    40a2:	4910      	ldr	r1, [pc, #64]	; (40e4 <_spi_m_sync_io_write+0x58>)
    40a4:	22a3      	movs	r2, #163	; 0xa3
    40a6:	0018      	movs	r0, r3
    40a8:	f000 f95a 	bl	4360 <assert>

	struct spi_m_sync_descriptor *spi = CONTAINER_OF(io, struct spi_m_sync_descriptor, io);
    40ac:	68fb      	ldr	r3, [r7, #12]
    40ae:	3b0c      	subs	r3, #12
    40b0:	61fb      	str	r3, [r7, #28]
	struct spi_xfer               xfer;

	xfer.rxbuf = 0;
    40b2:	2310      	movs	r3, #16
    40b4:	18fb      	adds	r3, r7, r3
    40b6:	2200      	movs	r2, #0
    40b8:	605a      	str	r2, [r3, #4]
	xfer.txbuf = (uint8_t *)buf;
    40ba:	2310      	movs	r3, #16
    40bc:	18fb      	adds	r3, r7, r3
    40be:	68ba      	ldr	r2, [r7, #8]
    40c0:	601a      	str	r2, [r3, #0]
	xfer.size  = length;
    40c2:	1dbb      	adds	r3, r7, #6
    40c4:	881a      	ldrh	r2, [r3, #0]
    40c6:	2310      	movs	r3, #16
    40c8:	18fb      	adds	r3, r7, r3
    40ca:	609a      	str	r2, [r3, #8]

	return spi_m_sync_transfer(spi, &xfer);
    40cc:	2310      	movs	r3, #16
    40ce:	18fa      	adds	r2, r7, r3
    40d0:	69fb      	ldr	r3, [r7, #28]
    40d2:	0011      	movs	r1, r2
    40d4:	0018      	movs	r0, r3
    40d6:	f000 f807 	bl	40e8 <spi_m_sync_transfer>
    40da:	0003      	movs	r3, r0
}
    40dc:	0018      	movs	r0, r3
    40de:	46bd      	mov	sp, r7
    40e0:	b008      	add	sp, #32
    40e2:	bd80      	pop	{r7, pc}
    40e4:	00008f40 	.word	0x00008f40

000040e8 <spi_m_sync_transfer>:

int32_t spi_m_sync_transfer(struct spi_m_sync_descriptor *spi, const struct spi_xfer *p_xfer)
{
    40e8:	b580      	push	{r7, lr}
    40ea:	b086      	sub	sp, #24
    40ec:	af00      	add	r7, sp, #0
    40ee:	6078      	str	r0, [r7, #4]
    40f0:	6039      	str	r1, [r7, #0]
	struct spi_msg msg;

	ASSERT(spi && p_xfer);
    40f2:	687b      	ldr	r3, [r7, #4]
    40f4:	2b00      	cmp	r3, #0
    40f6:	d004      	beq.n	4102 <spi_m_sync_transfer+0x1a>
    40f8:	683b      	ldr	r3, [r7, #0]
    40fa:	2b00      	cmp	r3, #0
    40fc:	d001      	beq.n	4102 <spi_m_sync_transfer+0x1a>
    40fe:	2301      	movs	r3, #1
    4100:	e000      	b.n	4104 <spi_m_sync_transfer+0x1c>
    4102:	2300      	movs	r3, #0
    4104:	1c1a      	adds	r2, r3, #0
    4106:	2301      	movs	r3, #1
    4108:	4013      	ands	r3, r2
    410a:	b2db      	uxtb	r3, r3
    410c:	4910      	ldr	r1, [pc, #64]	; (4150 <spi_m_sync_transfer+0x68>)
    410e:	22b3      	movs	r2, #179	; 0xb3
    4110:	0018      	movs	r0, r3
    4112:	f000 f925 	bl	4360 <assert>

	msg.txbuf = p_xfer->txbuf;
    4116:	683b      	ldr	r3, [r7, #0]
    4118:	681a      	ldr	r2, [r3, #0]
    411a:	230c      	movs	r3, #12
    411c:	18fb      	adds	r3, r7, r3
    411e:	601a      	str	r2, [r3, #0]
	msg.rxbuf = p_xfer->rxbuf;
    4120:	683b      	ldr	r3, [r7, #0]
    4122:	685a      	ldr	r2, [r3, #4]
    4124:	230c      	movs	r3, #12
    4126:	18fb      	adds	r3, r7, r3
    4128:	605a      	str	r2, [r3, #4]
	msg.size  = p_xfer->size;
    412a:	683b      	ldr	r3, [r7, #0]
    412c:	689a      	ldr	r2, [r3, #8]
    412e:	230c      	movs	r3, #12
    4130:	18fb      	adds	r3, r7, r3
    4132:	609a      	str	r2, [r3, #8]
	return _spi_m_sync_trans(&spi->dev, &msg);
    4134:	687b      	ldr	r3, [r7, #4]
    4136:	3304      	adds	r3, #4
    4138:	220c      	movs	r2, #12
    413a:	18ba      	adds	r2, r7, r2
    413c:	0011      	movs	r1, r2
    413e:	0018      	movs	r0, r3
    4140:	f001 fea2 	bl	5e88 <_spi_m_sync_trans>
    4144:	0003      	movs	r3, r0
}
    4146:	0018      	movs	r0, r3
    4148:	46bd      	mov	sp, r7
    414a:	b006      	add	sp, #24
    414c:	bd80      	pop	{r7, pc}
    414e:	46c0      	nop			; (mov r8, r8)
    4150:	00008f40 	.word	0x00008f40

00004154 <spi_m_sync_get_io_descriptor>:

int32_t spi_m_sync_get_io_descriptor(struct spi_m_sync_descriptor *const spi, struct io_descriptor **io)
{
    4154:	b580      	push	{r7, lr}
    4156:	b082      	sub	sp, #8
    4158:	af00      	add	r7, sp, #0
    415a:	6078      	str	r0, [r7, #4]
    415c:	6039      	str	r1, [r7, #0]
	ASSERT(spi && io);
    415e:	687b      	ldr	r3, [r7, #4]
    4160:	2b00      	cmp	r3, #0
    4162:	d004      	beq.n	416e <spi_m_sync_get_io_descriptor+0x1a>
    4164:	683b      	ldr	r3, [r7, #0]
    4166:	2b00      	cmp	r3, #0
    4168:	d001      	beq.n	416e <spi_m_sync_get_io_descriptor+0x1a>
    416a:	2301      	movs	r3, #1
    416c:	e000      	b.n	4170 <spi_m_sync_get_io_descriptor+0x1c>
    416e:	2300      	movs	r3, #0
    4170:	1c1a      	adds	r2, r3, #0
    4172:	2301      	movs	r3, #1
    4174:	4013      	ands	r3, r2
    4176:	b2db      	uxtb	r3, r3
    4178:	4907      	ldr	r1, [pc, #28]	; (4198 <spi_m_sync_get_io_descriptor+0x44>)
    417a:	22bd      	movs	r2, #189	; 0xbd
    417c:	0018      	movs	r0, r3
    417e:	f000 f8ef 	bl	4360 <assert>
	*io = &spi->io;
    4182:	687b      	ldr	r3, [r7, #4]
    4184:	330c      	adds	r3, #12
    4186:	001a      	movs	r2, r3
    4188:	683b      	ldr	r3, [r7, #0]
    418a:	601a      	str	r2, [r3, #0]
	return 0;
    418c:	2300      	movs	r3, #0
}
    418e:	0018      	movs	r0, r3
    4190:	46bd      	mov	sp, r7
    4192:	b002      	add	sp, #8
    4194:	bd80      	pop	{r7, pc}
    4196:	46c0      	nop			; (mov r8, r8)
    4198:	00008f40 	.word	0x00008f40

0000419c <usart_sync_init>:

/**
 * \brief Initialize usart interface
 */
int32_t usart_sync_init(struct usart_sync_descriptor *const descr, void *const hw, void *const func)
{
    419c:	b580      	push	{r7, lr}
    419e:	b086      	sub	sp, #24
    41a0:	af00      	add	r7, sp, #0
    41a2:	60f8      	str	r0, [r7, #12]
    41a4:	60b9      	str	r1, [r7, #8]
    41a6:	607a      	str	r2, [r7, #4]
	int32_t init_status;
	ASSERT(descr && hw);
    41a8:	68fb      	ldr	r3, [r7, #12]
    41aa:	2b00      	cmp	r3, #0
    41ac:	d004      	beq.n	41b8 <usart_sync_init+0x1c>
    41ae:	68bb      	ldr	r3, [r7, #8]
    41b0:	2b00      	cmp	r3, #0
    41b2:	d001      	beq.n	41b8 <usart_sync_init+0x1c>
    41b4:	2301      	movs	r3, #1
    41b6:	e000      	b.n	41ba <usart_sync_init+0x1e>
    41b8:	2300      	movs	r3, #0
    41ba:	1c1a      	adds	r2, r3, #0
    41bc:	2301      	movs	r3, #1
    41be:	4013      	ands	r3, r2
    41c0:	b2db      	uxtb	r3, r3
    41c2:	490f      	ldr	r1, [pc, #60]	; (4200 <usart_sync_init+0x64>)
    41c4:	2234      	movs	r2, #52	; 0x34
    41c6:	0018      	movs	r0, r3
    41c8:	f000 f8ca 	bl	4360 <assert>
	init_status = _usart_sync_init(&descr->device, hw);
    41cc:	68fb      	ldr	r3, [r7, #12]
    41ce:	3308      	adds	r3, #8
    41d0:	68ba      	ldr	r2, [r7, #8]
    41d2:	0011      	movs	r1, r2
    41d4:	0018      	movs	r0, r3
    41d6:	f001 f805 	bl	51e4 <_usart_sync_init>
    41da:	0003      	movs	r3, r0
    41dc:	617b      	str	r3, [r7, #20]
	if (init_status) {
    41de:	697b      	ldr	r3, [r7, #20]
    41e0:	2b00      	cmp	r3, #0
    41e2:	d001      	beq.n	41e8 <usart_sync_init+0x4c>
		return init_status;
    41e4:	697b      	ldr	r3, [r7, #20]
    41e6:	e006      	b.n	41f6 <usart_sync_init+0x5a>
	}

	descr->io.read  = usart_sync_read;
    41e8:	68fb      	ldr	r3, [r7, #12]
    41ea:	4a06      	ldr	r2, [pc, #24]	; (4204 <usart_sync_init+0x68>)
    41ec:	605a      	str	r2, [r3, #4]
	descr->io.write = usart_sync_write;
    41ee:	68fb      	ldr	r3, [r7, #12]
    41f0:	4a05      	ldr	r2, [pc, #20]	; (4208 <usart_sync_init+0x6c>)
    41f2:	601a      	str	r2, [r3, #0]

	return ERR_NONE;
    41f4:	2300      	movs	r3, #0
}
    41f6:	0018      	movs	r0, r3
    41f8:	46bd      	mov	sp, r7
    41fa:	b006      	add	sp, #24
    41fc:	bd80      	pop	{r7, pc}
    41fe:	46c0      	nop			; (mov r8, r8)
    4200:	00008f5c 	.word	0x00008f5c
    4204:	000042d1 	.word	0x000042d1
    4208:	0000420d 	.word	0x0000420d

0000420c <usart_sync_write>:
 * \param[in] length The number of bytes to write
 *
 * \return The number of bytes written.
 */
static int32_t usart_sync_write(struct io_descriptor *const io_descr, const uint8_t *const buf, const uint16_t length)
{
    420c:	b580      	push	{r7, lr}
    420e:	b086      	sub	sp, #24
    4210:	af00      	add	r7, sp, #0
    4212:	60f8      	str	r0, [r7, #12]
    4214:	60b9      	str	r1, [r7, #8]
    4216:	1dbb      	adds	r3, r7, #6
    4218:	801a      	strh	r2, [r3, #0]
	uint32_t                      offset = 0;
    421a:	2300      	movs	r3, #0
    421c:	617b      	str	r3, [r7, #20]
	struct usart_sync_descriptor *descr  = CONTAINER_OF(io_descr, struct usart_sync_descriptor, io);
    421e:	68fb      	ldr	r3, [r7, #12]
    4220:	613b      	str	r3, [r7, #16]

	ASSERT(io_descr && buf && length);
    4222:	68fb      	ldr	r3, [r7, #12]
    4224:	2b00      	cmp	r3, #0
    4226:	d008      	beq.n	423a <usart_sync_write+0x2e>
    4228:	68bb      	ldr	r3, [r7, #8]
    422a:	2b00      	cmp	r3, #0
    422c:	d005      	beq.n	423a <usart_sync_write+0x2e>
    422e:	1dbb      	adds	r3, r7, #6
    4230:	881b      	ldrh	r3, [r3, #0]
    4232:	2b00      	cmp	r3, #0
    4234:	d001      	beq.n	423a <usart_sync_write+0x2e>
    4236:	2301      	movs	r3, #1
    4238:	e000      	b.n	423c <usart_sync_write+0x30>
    423a:	2300      	movs	r3, #0
    423c:	1c1a      	adds	r2, r3, #0
    423e:	2301      	movs	r3, #1
    4240:	4013      	ands	r3, r2
    4242:	b2db      	uxtb	r3, r3
    4244:	4921      	ldr	r1, [pc, #132]	; (42cc <usart_sync_write+0xc0>)
    4246:	22f1      	movs	r2, #241	; 0xf1
    4248:	0018      	movs	r0, r3
    424a:	f000 f889 	bl	4360 <assert>
	while (!_usart_sync_is_ready_to_send(&descr->device))
    424e:	46c0      	nop			; (mov r8, r8)
    4250:	693b      	ldr	r3, [r7, #16]
    4252:	3308      	adds	r3, #8
    4254:	0018      	movs	r0, r3
    4256:	f001 f804 	bl	5262 <_usart_sync_is_ready_to_send>
    425a:	0003      	movs	r3, r0
    425c:	001a      	movs	r2, r3
    425e:	2301      	movs	r3, #1
    4260:	4053      	eors	r3, r2
    4262:	b2db      	uxtb	r3, r3
    4264:	2b00      	cmp	r3, #0
    4266:	d1f3      	bne.n	4250 <usart_sync_write+0x44>
		;
	do {
		_usart_sync_write_byte(&descr->device, buf[offset]);
    4268:	693b      	ldr	r3, [r7, #16]
    426a:	3308      	adds	r3, #8
    426c:	0018      	movs	r0, r3
    426e:	68ba      	ldr	r2, [r7, #8]
    4270:	697b      	ldr	r3, [r7, #20]
    4272:	18d3      	adds	r3, r2, r3
    4274:	781b      	ldrb	r3, [r3, #0]
    4276:	0019      	movs	r1, r3
    4278:	f000 ffd0 	bl	521c <_usart_sync_write_byte>
		while (!_usart_sync_is_ready_to_send(&descr->device))
    427c:	46c0      	nop			; (mov r8, r8)
    427e:	693b      	ldr	r3, [r7, #16]
    4280:	3308      	adds	r3, #8
    4282:	0018      	movs	r0, r3
    4284:	f000 ffed 	bl	5262 <_usart_sync_is_ready_to_send>
    4288:	0003      	movs	r3, r0
    428a:	001a      	movs	r2, r3
    428c:	2301      	movs	r3, #1
    428e:	4053      	eors	r3, r2
    4290:	b2db      	uxtb	r3, r3
    4292:	2b00      	cmp	r3, #0
    4294:	d1f3      	bne.n	427e <usart_sync_write+0x72>
			;
	} while (++offset < length);
    4296:	697b      	ldr	r3, [r7, #20]
    4298:	3301      	adds	r3, #1
    429a:	617b      	str	r3, [r7, #20]
    429c:	1dbb      	adds	r3, r7, #6
    429e:	881b      	ldrh	r3, [r3, #0]
    42a0:	697a      	ldr	r2, [r7, #20]
    42a2:	429a      	cmp	r2, r3
    42a4:	d3e0      	bcc.n	4268 <usart_sync_write+0x5c>
	while (!_usart_sync_is_transmit_done(&descr->device))
    42a6:	46c0      	nop			; (mov r8, r8)
    42a8:	693b      	ldr	r3, [r7, #16]
    42aa:	3308      	adds	r3, #8
    42ac:	0018      	movs	r0, r3
    42ae:	f000 ffe6 	bl	527e <_usart_sync_is_transmit_done>
    42b2:	0003      	movs	r3, r0
    42b4:	001a      	movs	r2, r3
    42b6:	2301      	movs	r3, #1
    42b8:	4053      	eors	r3, r2
    42ba:	b2db      	uxtb	r3, r3
    42bc:	2b00      	cmp	r3, #0
    42be:	d1f3      	bne.n	42a8 <usart_sync_write+0x9c>
		;
	return (int32_t)offset;
    42c0:	697b      	ldr	r3, [r7, #20]
}
    42c2:	0018      	movs	r0, r3
    42c4:	46bd      	mov	sp, r7
    42c6:	b006      	add	sp, #24
    42c8:	bd80      	pop	{r7, pc}
    42ca:	46c0      	nop			; (mov r8, r8)
    42cc:	00008f5c 	.word	0x00008f5c

000042d0 <usart_sync_read>:
 * \param[in] length The size of a buffer
 *
 * \return The number of bytes read.
 */
static int32_t usart_sync_read(struct io_descriptor *const io_descr, uint8_t *const buf, const uint16_t length)
{
    42d0:	b590      	push	{r4, r7, lr}
    42d2:	b087      	sub	sp, #28
    42d4:	af00      	add	r7, sp, #0
    42d6:	60f8      	str	r0, [r7, #12]
    42d8:	60b9      	str	r1, [r7, #8]
    42da:	1dbb      	adds	r3, r7, #6
    42dc:	801a      	strh	r2, [r3, #0]
	uint32_t                      offset = 0;
    42de:	2300      	movs	r3, #0
    42e0:	617b      	str	r3, [r7, #20]
	struct usart_sync_descriptor *descr  = CONTAINER_OF(io_descr, struct usart_sync_descriptor, io);
    42e2:	68fb      	ldr	r3, [r7, #12]
    42e4:	613b      	str	r3, [r7, #16]

	ASSERT(io_descr && buf && length);
    42e6:	68fb      	ldr	r3, [r7, #12]
    42e8:	2b00      	cmp	r3, #0
    42ea:	d008      	beq.n	42fe <usart_sync_read+0x2e>
    42ec:	68bb      	ldr	r3, [r7, #8]
    42ee:	2b00      	cmp	r3, #0
    42f0:	d005      	beq.n	42fe <usart_sync_read+0x2e>
    42f2:	1dbb      	adds	r3, r7, #6
    42f4:	881b      	ldrh	r3, [r3, #0]
    42f6:	2b00      	cmp	r3, #0
    42f8:	d001      	beq.n	42fe <usart_sync_read+0x2e>
    42fa:	2301      	movs	r3, #1
    42fc:	e000      	b.n	4300 <usart_sync_read+0x30>
    42fe:	2300      	movs	r3, #0
    4300:	1c1a      	adds	r2, r3, #0
    4302:	2301      	movs	r3, #1
    4304:	4013      	ands	r3, r2
    4306:	b2d8      	uxtb	r0, r3
    4308:	2386      	movs	r3, #134	; 0x86
    430a:	005a      	lsls	r2, r3, #1
    430c:	4b13      	ldr	r3, [pc, #76]	; (435c <usart_sync_read+0x8c>)
    430e:	0019      	movs	r1, r3
    4310:	f000 f826 	bl	4360 <assert>
	do {
		while (!_usart_sync_is_byte_received(&descr->device))
    4314:	46c0      	nop			; (mov r8, r8)
    4316:	693b      	ldr	r3, [r7, #16]
    4318:	3308      	adds	r3, #8
    431a:	0018      	movs	r0, r3
    431c:	f000 ffbd 	bl	529a <_usart_sync_is_byte_received>
    4320:	0003      	movs	r3, r0
    4322:	001a      	movs	r2, r3
    4324:	2301      	movs	r3, #1
    4326:	4053      	eors	r3, r2
    4328:	b2db      	uxtb	r3, r3
    432a:	2b00      	cmp	r3, #0
    432c:	d1f3      	bne.n	4316 <usart_sync_read+0x46>
			;
		buf[offset] = _usart_sync_read_byte(&descr->device);
    432e:	68ba      	ldr	r2, [r7, #8]
    4330:	697b      	ldr	r3, [r7, #20]
    4332:	18d4      	adds	r4, r2, r3
    4334:	693b      	ldr	r3, [r7, #16]
    4336:	3308      	adds	r3, #8
    4338:	0018      	movs	r0, r3
    433a:	f000 ff83 	bl	5244 <_usart_sync_read_byte>
    433e:	0003      	movs	r3, r0
    4340:	7023      	strb	r3, [r4, #0]
	} while (++offset < length);
    4342:	697b      	ldr	r3, [r7, #20]
    4344:	3301      	adds	r3, #1
    4346:	617b      	str	r3, [r7, #20]
    4348:	1dbb      	adds	r3, r7, #6
    434a:	881b      	ldrh	r3, [r3, #0]
    434c:	697a      	ldr	r2, [r7, #20]
    434e:	429a      	cmp	r2, r3
    4350:	d3e0      	bcc.n	4314 <usart_sync_read+0x44>

	return (int32_t)offset;
    4352:	697b      	ldr	r3, [r7, #20]
}
    4354:	0018      	movs	r0, r3
    4356:	46bd      	mov	sp, r7
    4358:	b007      	add	sp, #28
    435a:	bd90      	pop	{r4, r7, pc}
    435c:	00008f5c 	.word	0x00008f5c

00004360 <assert>:

/**
 * \brief Assert function
 */
void assert(const bool condition, const char *const file, const int line)
{
    4360:	b580      	push	{r7, lr}
    4362:	b084      	sub	sp, #16
    4364:	af00      	add	r7, sp, #0
    4366:	60b9      	str	r1, [r7, #8]
    4368:	607a      	str	r2, [r7, #4]
    436a:	230f      	movs	r3, #15
    436c:	18fb      	adds	r3, r7, r3
    436e:	1c02      	adds	r2, r0, #0
    4370:	701a      	strb	r2, [r3, #0]
	if (!(condition)) {
    4372:	230f      	movs	r3, #15
    4374:	18fb      	adds	r3, r7, r3
    4376:	781b      	ldrb	r3, [r3, #0]
    4378:	2201      	movs	r2, #1
    437a:	4053      	eors	r3, r2
    437c:	b2db      	uxtb	r3, r3
    437e:	2b00      	cmp	r3, #0
    4380:	d000      	beq.n	4384 <assert+0x24>
		__asm("BKPT #0");
    4382:	be00      	bkpt	0x0000
	}
	(void)file;
	(void)line;
}
    4384:	46c0      	nop			; (mov r8, r8)
    4386:	46bd      	mov	sp, r7
    4388:	b004      	add	sp, #16
    438a:	bd80      	pop	{r7, pc}

0000438c <_sbrk>:

/**
 * \brief Replacement of C library of _sbrk
 */
extern caddr_t _sbrk(int incr)
{
    438c:	b580      	push	{r7, lr}
    438e:	b084      	sub	sp, #16
    4390:	af00      	add	r7, sp, #0
    4392:	6078      	str	r0, [r7, #4]
	static unsigned char *heap = NULL;
	unsigned char *       prev_heap;

	if (heap == NULL) {
    4394:	4b0a      	ldr	r3, [pc, #40]	; (43c0 <_sbrk+0x34>)
    4396:	681b      	ldr	r3, [r3, #0]
    4398:	2b00      	cmp	r3, #0
    439a:	d102      	bne.n	43a2 <_sbrk+0x16>
		heap = (unsigned char *)&_end;
    439c:	4b08      	ldr	r3, [pc, #32]	; (43c0 <_sbrk+0x34>)
    439e:	4a09      	ldr	r2, [pc, #36]	; (43c4 <_sbrk+0x38>)
    43a0:	601a      	str	r2, [r3, #0]
	}
	prev_heap = heap;
    43a2:	4b07      	ldr	r3, [pc, #28]	; (43c0 <_sbrk+0x34>)
    43a4:	681b      	ldr	r3, [r3, #0]
    43a6:	60fb      	str	r3, [r7, #12]

	heap += incr;
    43a8:	4b05      	ldr	r3, [pc, #20]	; (43c0 <_sbrk+0x34>)
    43aa:	681a      	ldr	r2, [r3, #0]
    43ac:	687b      	ldr	r3, [r7, #4]
    43ae:	18d2      	adds	r2, r2, r3
    43b0:	4b03      	ldr	r3, [pc, #12]	; (43c0 <_sbrk+0x34>)
    43b2:	601a      	str	r2, [r3, #0]

	return (caddr_t)prev_heap;
    43b4:	68fb      	ldr	r3, [r7, #12]
}
    43b6:	0018      	movs	r0, r3
    43b8:	46bd      	mov	sp, r7
    43ba:	b004      	add	sp, #16
    43bc:	bd80      	pop	{r7, pc}
    43be:	46c0      	nop			; (mov r8, r8)
    43c0:	200007c8 	.word	0x200007c8
    43c4:	20002968 	.word	0x20002968

000043c8 <_get_cycles_for_ms_internal>:

/**
 * \brief Retrieve the amount of cycles to delay for the given amount of ms
 */
static inline uint32_t _get_cycles_for_ms_internal(const uint16_t ms, const uint32_t freq, const uint8_t power)
{
    43c8:	b590      	push	{r4, r7, lr}
    43ca:	b083      	sub	sp, #12
    43cc:	af00      	add	r7, sp, #0
    43ce:	6039      	str	r1, [r7, #0]
    43d0:	0011      	movs	r1, r2
    43d2:	1dbb      	adds	r3, r7, #6
    43d4:	1c02      	adds	r2, r0, #0
    43d6:	801a      	strh	r2, [r3, #0]
    43d8:	1d7b      	adds	r3, r7, #5
    43da:	1c0a      	adds	r2, r1, #0
    43dc:	701a      	strb	r2, [r3, #0]
	switch (power) {
    43de:	1d7b      	adds	r3, r7, #5
    43e0:	781b      	ldrb	r3, [r3, #0]
    43e2:	3b04      	subs	r3, #4
    43e4:	2b04      	cmp	r3, #4
    43e6:	d84c      	bhi.n	4482 <_get_cycles_for_ms_internal+0xba>
    43e8:	009a      	lsls	r2, r3, #2
    43ea:	4b2e      	ldr	r3, [pc, #184]	; (44a4 <_get_cycles_for_ms_internal+0xdc>)
    43ec:	18d3      	adds	r3, r2, r3
    43ee:	681b      	ldr	r3, [r3, #0]
    43f0:	469f      	mov	pc, r3
	case 8:
		return (ms * (freq / 100000)) * 100;
    43f2:	1dbb      	adds	r3, r7, #6
    43f4:	881c      	ldrh	r4, [r3, #0]
    43f6:	683b      	ldr	r3, [r7, #0]
    43f8:	492b      	ldr	r1, [pc, #172]	; (44a8 <_get_cycles_for_ms_internal+0xe0>)
    43fa:	0018      	movs	r0, r3
    43fc:	f003 fde0 	bl	7fc0 <__udivsi3>
    4400:	0003      	movs	r3, r0
    4402:	4363      	muls	r3, r4
    4404:	2264      	movs	r2, #100	; 0x64
    4406:	4353      	muls	r3, r2
    4408:	e047      	b.n	449a <_get_cycles_for_ms_internal+0xd2>
	case 7:
		return (ms * (freq / 10000)) * 10;
    440a:	1dbb      	adds	r3, r7, #6
    440c:	881c      	ldrh	r4, [r3, #0]
    440e:	683b      	ldr	r3, [r7, #0]
    4410:	4926      	ldr	r1, [pc, #152]	; (44ac <_get_cycles_for_ms_internal+0xe4>)
    4412:	0018      	movs	r0, r3
    4414:	f003 fdd4 	bl	7fc0 <__udivsi3>
    4418:	0003      	movs	r3, r0
    441a:	4363      	muls	r3, r4
    441c:	001a      	movs	r2, r3
    441e:	0013      	movs	r3, r2
    4420:	009b      	lsls	r3, r3, #2
    4422:	189b      	adds	r3, r3, r2
    4424:	005b      	lsls	r3, r3, #1
    4426:	e038      	b.n	449a <_get_cycles_for_ms_internal+0xd2>
	case 6:
		return (ms * (freq / 1000));
    4428:	1dbb      	adds	r3, r7, #6
    442a:	881c      	ldrh	r4, [r3, #0]
    442c:	683a      	ldr	r2, [r7, #0]
    442e:	23fa      	movs	r3, #250	; 0xfa
    4430:	0099      	lsls	r1, r3, #2
    4432:	0010      	movs	r0, r2
    4434:	f003 fdc4 	bl	7fc0 <__udivsi3>
    4438:	0003      	movs	r3, r0
    443a:	4363      	muls	r3, r4
    443c:	e02d      	b.n	449a <_get_cycles_for_ms_internal+0xd2>
	case 5:
		return (ms * (freq / 100) - 1) / 10 + 1;
    443e:	1dbb      	adds	r3, r7, #6
    4440:	881c      	ldrh	r4, [r3, #0]
    4442:	683b      	ldr	r3, [r7, #0]
    4444:	2164      	movs	r1, #100	; 0x64
    4446:	0018      	movs	r0, r3
    4448:	f003 fdba 	bl	7fc0 <__udivsi3>
    444c:	0003      	movs	r3, r0
    444e:	4363      	muls	r3, r4
    4450:	3b01      	subs	r3, #1
    4452:	210a      	movs	r1, #10
    4454:	0018      	movs	r0, r3
    4456:	f003 fdb3 	bl	7fc0 <__udivsi3>
    445a:	0003      	movs	r3, r0
    445c:	3301      	adds	r3, #1
    445e:	e01c      	b.n	449a <_get_cycles_for_ms_internal+0xd2>
	case 4:
		return (ms * (freq / 10) - 1) / 100 + 1;
    4460:	1dbb      	adds	r3, r7, #6
    4462:	881c      	ldrh	r4, [r3, #0]
    4464:	683b      	ldr	r3, [r7, #0]
    4466:	210a      	movs	r1, #10
    4468:	0018      	movs	r0, r3
    446a:	f003 fda9 	bl	7fc0 <__udivsi3>
    446e:	0003      	movs	r3, r0
    4470:	4363      	muls	r3, r4
    4472:	3b01      	subs	r3, #1
    4474:	2164      	movs	r1, #100	; 0x64
    4476:	0018      	movs	r0, r3
    4478:	f003 fda2 	bl	7fc0 <__udivsi3>
    447c:	0003      	movs	r3, r0
    447e:	3301      	adds	r3, #1
    4480:	e00b      	b.n	449a <_get_cycles_for_ms_internal+0xd2>
	default:
		return (ms * freq - 1) / 1000 + 1;
    4482:	1dbb      	adds	r3, r7, #6
    4484:	881b      	ldrh	r3, [r3, #0]
    4486:	683a      	ldr	r2, [r7, #0]
    4488:	4353      	muls	r3, r2
    448a:	1e5a      	subs	r2, r3, #1
    448c:	23fa      	movs	r3, #250	; 0xfa
    448e:	0099      	lsls	r1, r3, #2
    4490:	0010      	movs	r0, r2
    4492:	f003 fd95 	bl	7fc0 <__udivsi3>
    4496:	0003      	movs	r3, r0
    4498:	3301      	adds	r3, #1
	}
}
    449a:	0018      	movs	r0, r3
    449c:	46bd      	mov	sp, r7
    449e:	b003      	add	sp, #12
    44a0:	bd90      	pop	{r4, r7, pc}
    44a2:	46c0      	nop			; (mov r8, r8)
    44a4:	00008f78 	.word	0x00008f78
    44a8:	000186a0 	.word	0x000186a0
    44ac:	00002710 	.word	0x00002710

000044b0 <_get_cycles_for_ms>:

/**
 * \brief Retrieve the amount of cycles to delay for the given amount of ms
 */
uint32_t _get_cycles_for_ms(const uint16_t ms)
{
    44b0:	b580      	push	{r7, lr}
    44b2:	b082      	sub	sp, #8
    44b4:	af00      	add	r7, sp, #0
    44b6:	0002      	movs	r2, r0
    44b8:	1dbb      	adds	r3, r7, #6
    44ba:	801a      	strh	r2, [r3, #0]
	return _get_cycles_for_ms_internal(ms, CONF_CPU_FREQUENCY, CPU_FREQ_POWER);
    44bc:	4905      	ldr	r1, [pc, #20]	; (44d4 <_get_cycles_for_ms+0x24>)
    44be:	1dbb      	adds	r3, r7, #6
    44c0:	881b      	ldrh	r3, [r3, #0]
    44c2:	2208      	movs	r2, #8
    44c4:	0018      	movs	r0, r3
    44c6:	f7ff ff7f 	bl	43c8 <_get_cycles_for_ms_internal>
    44ca:	0003      	movs	r3, r0
}
    44cc:	0018      	movs	r0, r3
    44ce:	46bd      	mov	sp, r7
    44d0:	b002      	add	sp, #8
    44d2:	bd80      	pop	{r7, pc}
    44d4:	02dc6c00 	.word	0x02dc6c00

000044d8 <hri_nvmctrl_set_CTRLB_RWS_bf>:
	((Nvmctrl *)hw)->CTRLB.reg ^= NVMCTRL_CTRLB_CACHEDIS;
	NVMCTRL_CRITICAL_SECTION_LEAVE();
}

static inline void hri_nvmctrl_set_CTRLB_RWS_bf(const void *const hw, hri_nvmctrl_ctrlb_reg_t mask)
{
    44d8:	b580      	push	{r7, lr}
    44da:	b082      	sub	sp, #8
    44dc:	af00      	add	r7, sp, #0
    44de:	6078      	str	r0, [r7, #4]
    44e0:	6039      	str	r1, [r7, #0]
	NVMCTRL_CRITICAL_SECTION_ENTER();
	((Nvmctrl *)hw)->CTRLB.reg |= NVMCTRL_CTRLB_RWS(mask);
    44e2:	687b      	ldr	r3, [r7, #4]
    44e4:	685a      	ldr	r2, [r3, #4]
    44e6:	683b      	ldr	r3, [r7, #0]
    44e8:	005b      	lsls	r3, r3, #1
    44ea:	211e      	movs	r1, #30
    44ec:	400b      	ands	r3, r1
    44ee:	431a      	orrs	r2, r3
    44f0:	687b      	ldr	r3, [r7, #4]
    44f2:	605a      	str	r2, [r3, #4]
	NVMCTRL_CRITICAL_SECTION_LEAVE();
}
    44f4:	46c0      	nop			; (mov r8, r8)
    44f6:	46bd      	mov	sp, r7
    44f8:	b002      	add	sp, #8
    44fa:	bd80      	pop	{r7, pc}

000044fc <_init_chip>:

/**
 * \brief Initialize the hardware abstraction layer
 */
void _init_chip(void)
{
    44fc:	b580      	push	{r7, lr}
    44fe:	af00      	add	r7, sp, #0
	hri_nvmctrl_set_CTRLB_RWS_bf(NVMCTRL, CONF_NVM_WAIT_STATE);
    4500:	4b09      	ldr	r3, [pc, #36]	; (4528 <_init_chip+0x2c>)
    4502:	2103      	movs	r1, #3
    4504:	0018      	movs	r0, r3
    4506:	f7ff ffe7 	bl	44d8 <hri_nvmctrl_set_CTRLB_RWS_bf>

	_pm_init();
    450a:	f000 fb6d 	bl	4be8 <_pm_init>
	_sysctrl_init_sources();
    450e:	f001 fe7b 	bl	6208 <_sysctrl_init_sources>
#if _GCLK_INIT_1ST
	_gclk_init_generators_by_fref(_GCLK_INIT_1ST);
    4512:	2008      	movs	r0, #8
    4514:	f000 fada 	bl	4acc <_gclk_init_generators_by_fref>
#endif
	_sysctrl_init_referenced_generators();
    4518:	f001 fee8 	bl	62ec <_sysctrl_init_referenced_generators>
	_gclk_init_generators_by_fref(_GCLK_INIT_LAST);
    451c:	20f7      	movs	r0, #247	; 0xf7
    451e:	f000 fad5 	bl	4acc <_gclk_init_generators_by_fref>
}
    4522:	46c0      	nop			; (mov r8, r8)
    4524:	46bd      	mov	sp, r7
    4526:	bd80      	pop	{r7, pc}
    4528:	41004000 	.word	0x41004000

0000452c <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
    452c:	b580      	push	{r7, lr}
    452e:	b082      	sub	sp, #8
    4530:	af00      	add	r7, sp, #0
    4532:	0002      	movs	r2, r0
    4534:	1dfb      	adds	r3, r7, #7
    4536:	701a      	strb	r2, [r3, #0]
  if ((int32_t)(IRQn) >= 0)
    4538:	1dfb      	adds	r3, r7, #7
    453a:	781b      	ldrb	r3, [r3, #0]
    453c:	2b7f      	cmp	r3, #127	; 0x7f
    453e:	d809      	bhi.n	4554 <__NVIC_EnableIRQ+0x28>
  {
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    4540:	4b06      	ldr	r3, [pc, #24]	; (455c <__NVIC_EnableIRQ+0x30>)
    4542:	1dfa      	adds	r2, r7, #7
    4544:	7812      	ldrb	r2, [r2, #0]
    4546:	0011      	movs	r1, r2
    4548:	221f      	movs	r2, #31
    454a:	400a      	ands	r2, r1
    454c:	2101      	movs	r1, #1
    454e:	4091      	lsls	r1, r2
    4550:	000a      	movs	r2, r1
    4552:	601a      	str	r2, [r3, #0]
  }
}
    4554:	46c0      	nop			; (mov r8, r8)
    4556:	46bd      	mov	sp, r7
    4558:	b002      	add	sp, #8
    455a:	bd80      	pop	{r7, pc}
    455c:	e000e100 	.word	0xe000e100

00004560 <__NVIC_DisableIRQ>:
  \details Disables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
    4560:	b580      	push	{r7, lr}
    4562:	b082      	sub	sp, #8
    4564:	af00      	add	r7, sp, #0
    4566:	0002      	movs	r2, r0
    4568:	1dfb      	adds	r3, r7, #7
    456a:	701a      	strb	r2, [r3, #0]
  if ((int32_t)(IRQn) >= 0)
    456c:	1dfb      	adds	r3, r7, #7
    456e:	781b      	ldrb	r3, [r3, #0]
    4570:	2b7f      	cmp	r3, #127	; 0x7f
    4572:	d80e      	bhi.n	4592 <__NVIC_DisableIRQ+0x32>
  {
    NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    4574:	4909      	ldr	r1, [pc, #36]	; (459c <__NVIC_DisableIRQ+0x3c>)
    4576:	1dfb      	adds	r3, r7, #7
    4578:	781b      	ldrb	r3, [r3, #0]
    457a:	001a      	movs	r2, r3
    457c:	231f      	movs	r3, #31
    457e:	4013      	ands	r3, r2
    4580:	2201      	movs	r2, #1
    4582:	409a      	lsls	r2, r3
    4584:	0013      	movs	r3, r2
    4586:	2280      	movs	r2, #128	; 0x80
    4588:	508b      	str	r3, [r1, r2]
  __ASM volatile ("dsb 0xF":::"memory");
    458a:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    458e:	f3bf 8f6f 	isb	sy
    __DSB();
    __ISB();
  }
}
    4592:	46c0      	nop			; (mov r8, r8)
    4594:	46bd      	mov	sp, r7
    4596:	b002      	add	sp, #8
    4598:	bd80      	pop	{r7, pc}
    459a:	46c0      	nop			; (mov r8, r8)
    459c:	e000e100 	.word	0xe000e100

000045a0 <__NVIC_ClearPendingIRQ>:
  \details Clears the pending bit of a device specific interrupt in the NVIC pending register.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
    45a0:	b580      	push	{r7, lr}
    45a2:	b082      	sub	sp, #8
    45a4:	af00      	add	r7, sp, #0
    45a6:	0002      	movs	r2, r0
    45a8:	1dfb      	adds	r3, r7, #7
    45aa:	701a      	strb	r2, [r3, #0]
  if ((int32_t)(IRQn) >= 0)
    45ac:	1dfb      	adds	r3, r7, #7
    45ae:	781b      	ldrb	r3, [r3, #0]
    45b0:	2b7f      	cmp	r3, #127	; 0x7f
    45b2:	d80a      	bhi.n	45ca <__NVIC_ClearPendingIRQ+0x2a>
  {
    NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    45b4:	4907      	ldr	r1, [pc, #28]	; (45d4 <__NVIC_ClearPendingIRQ+0x34>)
    45b6:	1dfb      	adds	r3, r7, #7
    45b8:	781b      	ldrb	r3, [r3, #0]
    45ba:	001a      	movs	r2, r3
    45bc:	231f      	movs	r3, #31
    45be:	4013      	ands	r3, r2
    45c0:	2201      	movs	r2, #1
    45c2:	409a      	lsls	r2, r3
    45c4:	23c0      	movs	r3, #192	; 0xc0
    45c6:	005b      	lsls	r3, r3, #1
    45c8:	50ca      	str	r2, [r1, r3]
  }
}
    45ca:	46c0      	nop			; (mov r8, r8)
    45cc:	46bd      	mov	sp, r7
    45ce:	b002      	add	sp, #8
    45d0:	bd80      	pop	{r7, pc}
    45d2:	46c0      	nop			; (mov r8, r8)
    45d4:	e000e100 	.word	0xe000e100

000045d8 <hri_eic_wait_for_sync>:
typedef uint8_t  hri_eic_nmictrl_reg_t;
typedef uint8_t  hri_eic_nmiflag_reg_t;
typedef uint8_t  hri_eic_status_reg_t;

static inline void hri_eic_wait_for_sync(const void *const hw)
{
    45d8:	b580      	push	{r7, lr}
    45da:	b082      	sub	sp, #8
    45dc:	af00      	add	r7, sp, #0
    45de:	6078      	str	r0, [r7, #4]
	while (((const Eic *)hw)->STATUS.bit.SYNCBUSY)
    45e0:	46c0      	nop			; (mov r8, r8)
    45e2:	687b      	ldr	r3, [r7, #4]
    45e4:	785b      	ldrb	r3, [r3, #1]
    45e6:	061b      	lsls	r3, r3, #24
    45e8:	0fdb      	lsrs	r3, r3, #31
    45ea:	b2db      	uxtb	r3, r3
    45ec:	2b00      	cmp	r3, #0
    45ee:	d1f8      	bne.n	45e2 <hri_eic_wait_for_sync+0xa>
		;
}
    45f0:	46c0      	nop			; (mov r8, r8)
    45f2:	46bd      	mov	sp, r7
    45f4:	b002      	add	sp, #8
    45f6:	bd80      	pop	{r7, pc}

000045f8 <hri_eic_read_INTFLAG_reg>:
	tmp &= mask;
	return tmp;
}

static inline hri_eic_intflag_reg_t hri_eic_read_INTFLAG_reg(const void *const hw)
{
    45f8:	b580      	push	{r7, lr}
    45fa:	b082      	sub	sp, #8
    45fc:	af00      	add	r7, sp, #0
    45fe:	6078      	str	r0, [r7, #4]
	return ((Eic *)hw)->INTFLAG.reg;
    4600:	687b      	ldr	r3, [r7, #4]
    4602:	691b      	ldr	r3, [r3, #16]
}
    4604:	0018      	movs	r0, r3
    4606:	46bd      	mov	sp, r7
    4608:	b002      	add	sp, #8
    460a:	bd80      	pop	{r7, pc}

0000460c <hri_eic_clear_INTFLAG_reg>:

static inline void hri_eic_clear_INTFLAG_reg(const void *const hw, hri_eic_intflag_reg_t mask)
{
    460c:	b580      	push	{r7, lr}
    460e:	b082      	sub	sp, #8
    4610:	af00      	add	r7, sp, #0
    4612:	6078      	str	r0, [r7, #4]
    4614:	6039      	str	r1, [r7, #0]
	((Eic *)hw)->INTFLAG.reg = mask;
    4616:	687b      	ldr	r3, [r7, #4]
    4618:	683a      	ldr	r2, [r7, #0]
    461a:	611a      	str	r2, [r3, #16]
}
    461c:	46c0      	nop			; (mov r8, r8)
    461e:	46bd      	mov	sp, r7
    4620:	b002      	add	sp, #8
    4622:	bd80      	pop	{r7, pc}

00004624 <hri_eic_set_INTEN_reg>:
{
	((Eic *)hw)->INTENCLR.reg = EIC_INTENSET_EXTINT15;
}

static inline void hri_eic_set_INTEN_reg(const void *const hw, hri_eic_intenset_reg_t mask)
{
    4624:	b580      	push	{r7, lr}
    4626:	b082      	sub	sp, #8
    4628:	af00      	add	r7, sp, #0
    462a:	6078      	str	r0, [r7, #4]
    462c:	6039      	str	r1, [r7, #0]
	((Eic *)hw)->INTENSET.reg = mask;
    462e:	687b      	ldr	r3, [r7, #4]
    4630:	683a      	ldr	r2, [r7, #0]
    4632:	60da      	str	r2, [r3, #12]
}
    4634:	46c0      	nop			; (mov r8, r8)
    4636:	46bd      	mov	sp, r7
    4638:	b002      	add	sp, #8
    463a:	bd80      	pop	{r7, pc}

0000463c <hri_eic_read_INTEN_reg>:
	tmp &= mask;
	return tmp;
}

static inline hri_eic_intenset_reg_t hri_eic_read_INTEN_reg(const void *const hw)
{
    463c:	b580      	push	{r7, lr}
    463e:	b082      	sub	sp, #8
    4640:	af00      	add	r7, sp, #0
    4642:	6078      	str	r0, [r7, #4]
	return ((Eic *)hw)->INTENSET.reg;
    4644:	687b      	ldr	r3, [r7, #4]
    4646:	68db      	ldr	r3, [r3, #12]
}
    4648:	0018      	movs	r0, r3
    464a:	46bd      	mov	sp, r7
    464c:	b002      	add	sp, #8
    464e:	bd80      	pop	{r7, pc}

00004650 <hri_eic_clear_INTEN_reg>:
	((Eic *)hw)->INTENSET.reg = data;
	((Eic *)hw)->INTENCLR.reg = ~data;
}

static inline void hri_eic_clear_INTEN_reg(const void *const hw, hri_eic_intenset_reg_t mask)
{
    4650:	b580      	push	{r7, lr}
    4652:	b082      	sub	sp, #8
    4654:	af00      	add	r7, sp, #0
    4656:	6078      	str	r0, [r7, #4]
    4658:	6039      	str	r1, [r7, #0]
	((Eic *)hw)->INTENCLR.reg = mask;
    465a:	687b      	ldr	r3, [r7, #4]
    465c:	683a      	ldr	r2, [r7, #0]
    465e:	609a      	str	r2, [r3, #8]
}
    4660:	46c0      	nop			; (mov r8, r8)
    4662:	46bd      	mov	sp, r7
    4664:	b002      	add	sp, #8
    4666:	bd80      	pop	{r7, pc}

00004668 <hri_eic_set_CTRL_ENABLE_bit>:
	tmp = (tmp & EIC_CTRL_SWRST) >> EIC_CTRL_SWRST_Pos;
	return (bool)tmp;
}

static inline void hri_eic_set_CTRL_ENABLE_bit(const void *const hw)
{
    4668:	b580      	push	{r7, lr}
    466a:	b082      	sub	sp, #8
    466c:	af00      	add	r7, sp, #0
    466e:	6078      	str	r0, [r7, #4]
	EIC_CRITICAL_SECTION_ENTER();
	((Eic *)hw)->CTRL.reg |= EIC_CTRL_ENABLE;
    4670:	687b      	ldr	r3, [r7, #4]
    4672:	781b      	ldrb	r3, [r3, #0]
    4674:	b2db      	uxtb	r3, r3
    4676:	2202      	movs	r2, #2
    4678:	4313      	orrs	r3, r2
    467a:	b2da      	uxtb	r2, r3
    467c:	687b      	ldr	r3, [r7, #4]
    467e:	701a      	strb	r2, [r3, #0]
	hri_eic_wait_for_sync(hw);
    4680:	687b      	ldr	r3, [r7, #4]
    4682:	0018      	movs	r0, r3
    4684:	f7ff ffa8 	bl	45d8 <hri_eic_wait_for_sync>
	EIC_CRITICAL_SECTION_LEAVE();
}
    4688:	46c0      	nop			; (mov r8, r8)
    468a:	46bd      	mov	sp, r7
    468c:	b002      	add	sp, #8
    468e:	bd80      	pop	{r7, pc}

00004690 <hri_eic_get_CTRL_reg>:
	hri_eic_wait_for_sync(hw);
	EIC_CRITICAL_SECTION_LEAVE();
}

static inline hri_eic_ctrl_reg_t hri_eic_get_CTRL_reg(const void *const hw, hri_eic_ctrl_reg_t mask)
{
    4690:	b580      	push	{r7, lr}
    4692:	b084      	sub	sp, #16
    4694:	af00      	add	r7, sp, #0
    4696:	6078      	str	r0, [r7, #4]
    4698:	000a      	movs	r2, r1
    469a:	1cfb      	adds	r3, r7, #3
    469c:	701a      	strb	r2, [r3, #0]
	uint8_t tmp;
	hri_eic_wait_for_sync(hw);
    469e:	687b      	ldr	r3, [r7, #4]
    46a0:	0018      	movs	r0, r3
    46a2:	f7ff ff99 	bl	45d8 <hri_eic_wait_for_sync>
	tmp = ((Eic *)hw)->CTRL.reg;
    46a6:	230f      	movs	r3, #15
    46a8:	18fb      	adds	r3, r7, r3
    46aa:	687a      	ldr	r2, [r7, #4]
    46ac:	7812      	ldrb	r2, [r2, #0]
    46ae:	701a      	strb	r2, [r3, #0]
	tmp &= mask;
    46b0:	230f      	movs	r3, #15
    46b2:	18fb      	adds	r3, r7, r3
    46b4:	220f      	movs	r2, #15
    46b6:	18ba      	adds	r2, r7, r2
    46b8:	1cf9      	adds	r1, r7, #3
    46ba:	7812      	ldrb	r2, [r2, #0]
    46bc:	7809      	ldrb	r1, [r1, #0]
    46be:	400a      	ands	r2, r1
    46c0:	701a      	strb	r2, [r3, #0]
	return tmp;
    46c2:	230f      	movs	r3, #15
    46c4:	18fb      	adds	r3, r7, r3
    46c6:	781b      	ldrb	r3, [r3, #0]
}
    46c8:	0018      	movs	r0, r3
    46ca:	46bd      	mov	sp, r7
    46cc:	b004      	add	sp, #16
    46ce:	bd80      	pop	{r7, pc}

000046d0 <hri_eic_write_CTRL_reg>:

static inline void hri_eic_write_CTRL_reg(const void *const hw, hri_eic_ctrl_reg_t data)
{
    46d0:	b580      	push	{r7, lr}
    46d2:	b082      	sub	sp, #8
    46d4:	af00      	add	r7, sp, #0
    46d6:	6078      	str	r0, [r7, #4]
    46d8:	000a      	movs	r2, r1
    46da:	1cfb      	adds	r3, r7, #3
    46dc:	701a      	strb	r2, [r3, #0]
	EIC_CRITICAL_SECTION_ENTER();
	((Eic *)hw)->CTRL.reg = data;
    46de:	687b      	ldr	r3, [r7, #4]
    46e0:	1cfa      	adds	r2, r7, #3
    46e2:	7812      	ldrb	r2, [r2, #0]
    46e4:	701a      	strb	r2, [r3, #0]
	hri_eic_wait_for_sync(hw);
    46e6:	687b      	ldr	r3, [r7, #4]
    46e8:	0018      	movs	r0, r3
    46ea:	f7ff ff75 	bl	45d8 <hri_eic_wait_for_sync>
	EIC_CRITICAL_SECTION_LEAVE();
}
    46ee:	46c0      	nop			; (mov r8, r8)
    46f0:	46bd      	mov	sp, r7
    46f2:	b002      	add	sp, #8
    46f4:	bd80      	pop	{r7, pc}

000046f6 <hri_eic_write_NMICTRL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_eic_write_NMICTRL_reg(const void *const hw, hri_eic_nmictrl_reg_t data)
{
    46f6:	b580      	push	{r7, lr}
    46f8:	b082      	sub	sp, #8
    46fa:	af00      	add	r7, sp, #0
    46fc:	6078      	str	r0, [r7, #4]
    46fe:	000a      	movs	r2, r1
    4700:	1cfb      	adds	r3, r7, #3
    4702:	701a      	strb	r2, [r3, #0]
	EIC_CRITICAL_SECTION_ENTER();
	((Eic *)hw)->NMICTRL.reg = data;
    4704:	687b      	ldr	r3, [r7, #4]
    4706:	1cfa      	adds	r2, r7, #3
    4708:	7812      	ldrb	r2, [r2, #0]
    470a:	709a      	strb	r2, [r3, #2]
	EIC_CRITICAL_SECTION_LEAVE();
}
    470c:	46c0      	nop			; (mov r8, r8)
    470e:	46bd      	mov	sp, r7
    4710:	b002      	add	sp, #8
    4712:	bd80      	pop	{r7, pc}

00004714 <hri_eic_write_EVCTRL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_eic_write_EVCTRL_reg(const void *const hw, hri_eic_evctrl_reg_t data)
{
    4714:	b580      	push	{r7, lr}
    4716:	b082      	sub	sp, #8
    4718:	af00      	add	r7, sp, #0
    471a:	6078      	str	r0, [r7, #4]
    471c:	6039      	str	r1, [r7, #0]
	EIC_CRITICAL_SECTION_ENTER();
	((Eic *)hw)->EVCTRL.reg = data;
    471e:	687b      	ldr	r3, [r7, #4]
    4720:	683a      	ldr	r2, [r7, #0]
    4722:	605a      	str	r2, [r3, #4]
	EIC_CRITICAL_SECTION_LEAVE();
}
    4724:	46c0      	nop			; (mov r8, r8)
    4726:	46bd      	mov	sp, r7
    4728:	b002      	add	sp, #8
    472a:	bd80      	pop	{r7, pc}

0000472c <hri_eic_write_WAKEUP_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_eic_write_WAKEUP_reg(const void *const hw, hri_eic_wakeup_reg_t data)
{
    472c:	b580      	push	{r7, lr}
    472e:	b082      	sub	sp, #8
    4730:	af00      	add	r7, sp, #0
    4732:	6078      	str	r0, [r7, #4]
    4734:	6039      	str	r1, [r7, #0]
	EIC_CRITICAL_SECTION_ENTER();
	((Eic *)hw)->WAKEUP.reg = data;
    4736:	687b      	ldr	r3, [r7, #4]
    4738:	683a      	ldr	r2, [r7, #0]
    473a:	615a      	str	r2, [r3, #20]
	EIC_CRITICAL_SECTION_LEAVE();
}
    473c:	46c0      	nop			; (mov r8, r8)
    473e:	46bd      	mov	sp, r7
    4740:	b002      	add	sp, #8
    4742:	bd80      	pop	{r7, pc}

00004744 <hri_eic_write_CONFIG_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_eic_write_CONFIG_reg(const void *const hw, uint8_t index, hri_eic_config_reg_t data)
{
    4744:	b580      	push	{r7, lr}
    4746:	b084      	sub	sp, #16
    4748:	af00      	add	r7, sp, #0
    474a:	60f8      	str	r0, [r7, #12]
    474c:	607a      	str	r2, [r7, #4]
    474e:	230b      	movs	r3, #11
    4750:	18fb      	adds	r3, r7, r3
    4752:	1c0a      	adds	r2, r1, #0
    4754:	701a      	strb	r2, [r3, #0]
	EIC_CRITICAL_SECTION_ENTER();
	((Eic *)hw)->CONFIG[index].reg = data;
    4756:	230b      	movs	r3, #11
    4758:	18fb      	adds	r3, r7, r3
    475a:	781a      	ldrb	r2, [r3, #0]
    475c:	68fb      	ldr	r3, [r7, #12]
    475e:	3206      	adds	r2, #6
    4760:	0092      	lsls	r2, r2, #2
    4762:	6879      	ldr	r1, [r7, #4]
    4764:	50d1      	str	r1, [r2, r3]
	EIC_CRITICAL_SECTION_LEAVE();
}
    4766:	46c0      	nop			; (mov r8, r8)
    4768:	46bd      	mov	sp, r7
    476a:	b004      	add	sp, #16
    476c:	bd80      	pop	{r7, pc}
	...

00004770 <_ext_irq_init>:

/**
 * \brief Initialize external interrupt module
 */
int32_t _ext_irq_init(void (*cb)(const uint32_t pin))
{
    4770:	b580      	push	{r7, lr}
    4772:	b082      	sub	sp, #8
    4774:	af00      	add	r7, sp, #0
    4776:	6078      	str	r0, [r7, #4]
	hri_eic_wait_for_sync(EIC);
    4778:	4b28      	ldr	r3, [pc, #160]	; (481c <_ext_irq_init+0xac>)
    477a:	0018      	movs	r0, r3
    477c:	f7ff ff2c 	bl	45d8 <hri_eic_wait_for_sync>
	if (hri_eic_get_CTRL_reg(EIC, EIC_CTRL_ENABLE)) {
    4780:	4b26      	ldr	r3, [pc, #152]	; (481c <_ext_irq_init+0xac>)
    4782:	2102      	movs	r1, #2
    4784:	0018      	movs	r0, r3
    4786:	f7ff ff83 	bl	4690 <hri_eic_get_CTRL_reg>
    478a:	1e03      	subs	r3, r0, #0
    478c:	d008      	beq.n	47a0 <_ext_irq_init+0x30>
		hri_eic_write_CTRL_reg(EIC, 0);
    478e:	4b23      	ldr	r3, [pc, #140]	; (481c <_ext_irq_init+0xac>)
    4790:	2100      	movs	r1, #0
    4792:	0018      	movs	r0, r3
    4794:	f7ff ff9c 	bl	46d0 <hri_eic_write_CTRL_reg>
		hri_eic_wait_for_sync(EIC);
    4798:	4b20      	ldr	r3, [pc, #128]	; (481c <_ext_irq_init+0xac>)
    479a:	0018      	movs	r0, r3
    479c:	f7ff ff1c 	bl	45d8 <hri_eic_wait_for_sync>
	}
	hri_eic_write_CTRL_reg(EIC, EIC_CTRL_SWRST);
    47a0:	4b1e      	ldr	r3, [pc, #120]	; (481c <_ext_irq_init+0xac>)
    47a2:	2101      	movs	r1, #1
    47a4:	0018      	movs	r0, r3
    47a6:	f7ff ff93 	bl	46d0 <hri_eic_write_CTRL_reg>
	hri_eic_wait_for_sync(EIC);
    47aa:	4b1c      	ldr	r3, [pc, #112]	; (481c <_ext_irq_init+0xac>)
    47ac:	0018      	movs	r0, r3
    47ae:	f7ff ff13 	bl	45d8 <hri_eic_wait_for_sync>

	hri_eic_write_NMICTRL_reg(
    47b2:	4b1a      	ldr	r3, [pc, #104]	; (481c <_ext_irq_init+0xac>)
    47b4:	2100      	movs	r1, #0
    47b6:	0018      	movs	r0, r3
    47b8:	f7ff ff9d 	bl	46f6 <hri_eic_write_NMICTRL_reg>
	    EIC, (CONF_EIC_NMIFILTEN << EIC_NMICTRL_NMIFILTEN_Pos) | EIC_NMICTRL_NMISENSE(CONF_EIC_NMISENSE));
	hri_eic_write_EVCTRL_reg(EIC,
    47bc:	2380      	movs	r3, #128	; 0x80
    47be:	00db      	lsls	r3, r3, #3
    47c0:	4a16      	ldr	r2, [pc, #88]	; (481c <_ext_irq_init+0xac>)
    47c2:	0019      	movs	r1, r3
    47c4:	0010      	movs	r0, r2
    47c6:	f7ff ffa5 	bl	4714 <hri_eic_write_EVCTRL_reg>
	                             | (CONF_EIC_EXTINTEO6 << 6) | (CONF_EIC_EXTINTEO7 << 7) | (CONF_EIC_EXTINTEO8 << 8)
	                             | (CONF_EIC_EXTINTEO9 << 9) | (CONF_EIC_EXTINTEO10 << 10) | (CONF_EIC_EXTINTEO11 << 11)
	                             | (CONF_EIC_EXTINTEO12 << 12) | (CONF_EIC_EXTINTEO13 << 13)
	                             | (CONF_EIC_EXTINTEO14 << 14) | (CONF_EIC_EXTINTEO15 << 15) | 0);

	hri_eic_write_WAKEUP_reg(EIC,
    47ca:	2380      	movs	r3, #128	; 0x80
    47cc:	01db      	lsls	r3, r3, #7
    47ce:	4a13      	ldr	r2, [pc, #76]	; (481c <_ext_irq_init+0xac>)
    47d0:	0019      	movs	r1, r3
    47d2:	0010      	movs	r0, r2
    47d4:	f7ff ffaa 	bl	472c <hri_eic_write_WAKEUP_reg>
	                             | (CONF_EIC_WAKEUPEN3 << 3) | (CONF_EIC_WAKEUPEN4 << 4) | (CONF_EIC_WAKEUPEN5 << 5)
	                             | (CONF_EIC_WAKEUPEN6 << 6) | (CONF_EIC_WAKEUPEN7 << 7) | (CONF_EIC_WAKEUPEN8 << 8)
	                             | (CONF_EIC_WAKEUPEN9 << 9) | (CONF_EIC_WAKEUPEN10 << 10) | (CONF_EIC_WAKEUPEN11 << 11)
	                             | (CONF_EIC_WAKEUPEN12 << 12) | (CONF_EIC_WAKEUPEN13 << 13)
	                             | (CONF_EIC_WAKEUPEN14 << 14) | (CONF_EIC_WAKEUPEN15 << 15) | 0);
	hri_eic_write_CONFIG_reg(EIC,
    47d8:	4b10      	ldr	r3, [pc, #64]	; (481c <_ext_irq_init+0xac>)
    47da:	2290      	movs	r2, #144	; 0x90
    47dc:	2100      	movs	r1, #0
    47de:	0018      	movs	r0, r3
    47e0:	f7ff ffb0 	bl	4744 <hri_eic_write_CONFIG_reg>
	                             | (CONF_EIC_FILTEN5 << EIC_CONFIG_FILTEN5_Pos) | EIC_CONFIG_SENSE5(CONF_EIC_SENSE5)
	                             | (CONF_EIC_FILTEN6 << EIC_CONFIG_FILTEN6_Pos) | EIC_CONFIG_SENSE6(CONF_EIC_SENSE6)
	                             | (CONF_EIC_FILTEN7 << EIC_CONFIG_FILTEN7_Pos) | EIC_CONFIG_SENSE7(CONF_EIC_SENSE7)
	                             | 0);

	hri_eic_write_CONFIG_reg(EIC,
    47e4:	4a0e      	ldr	r2, [pc, #56]	; (4820 <_ext_irq_init+0xb0>)
    47e6:	4b0d      	ldr	r3, [pc, #52]	; (481c <_ext_irq_init+0xac>)
    47e8:	2101      	movs	r1, #1
    47ea:	0018      	movs	r0, r3
    47ec:	f7ff ffaa 	bl	4744 <hri_eic_write_CONFIG_reg>
	                             | (CONF_EIC_FILTEN13 << EIC_CONFIG_FILTEN5_Pos) | EIC_CONFIG_SENSE5(CONF_EIC_SENSE13)
	                             | (CONF_EIC_FILTEN14 << EIC_CONFIG_FILTEN6_Pos) | EIC_CONFIG_SENSE6(CONF_EIC_SENSE14)
	                             | (CONF_EIC_FILTEN15 << EIC_CONFIG_FILTEN7_Pos) | EIC_CONFIG_SENSE7(CONF_EIC_SENSE15)
	                             | 0);

	hri_eic_set_CTRL_ENABLE_bit(EIC);
    47f0:	4b0a      	ldr	r3, [pc, #40]	; (481c <_ext_irq_init+0xac>)
    47f2:	0018      	movs	r0, r3
    47f4:	f7ff ff38 	bl	4668 <hri_eic_set_CTRL_ENABLE_bit>

	NVIC_DisableIRQ(EIC_IRQn);
    47f8:	2004      	movs	r0, #4
    47fa:	f7ff feb1 	bl	4560 <__NVIC_DisableIRQ>
	NVIC_ClearPendingIRQ(EIC_IRQn);
    47fe:	2004      	movs	r0, #4
    4800:	f7ff fece 	bl	45a0 <__NVIC_ClearPendingIRQ>
	NVIC_EnableIRQ(EIC_IRQn);
    4804:	2004      	movs	r0, #4
    4806:	f7ff fe91 	bl	452c <__NVIC_EnableIRQ>

	callback = cb;
    480a:	4b06      	ldr	r3, [pc, #24]	; (4824 <_ext_irq_init+0xb4>)
    480c:	687a      	ldr	r2, [r7, #4]
    480e:	601a      	str	r2, [r3, #0]

	return ERR_NONE;
    4810:	2300      	movs	r3, #0
}
    4812:	0018      	movs	r0, r3
    4814:	46bd      	mov	sp, r7
    4816:	b002      	add	sp, #8
    4818:	bd80      	pop	{r7, pc}
    481a:	46c0      	nop			; (mov r8, r8)
    481c:	40001800 	.word	0x40001800
    4820:	01000200 	.word	0x01000200
    4824:	200007cc 	.word	0x200007cc

00004828 <_ext_irq_enable>:

/**
 * \brief Enable / disable external irq
 */
int32_t _ext_irq_enable(const uint32_t pin, const bool enable)
{
    4828:	b580      	push	{r7, lr}
    482a:	b084      	sub	sp, #16
    482c:	af00      	add	r7, sp, #0
    482e:	6078      	str	r0, [r7, #4]
    4830:	000a      	movs	r2, r1
    4832:	1cfb      	adds	r3, r7, #3
    4834:	701a      	strb	r2, [r3, #0]
	uint8_t extint = INVALID_EXTINT_NUMBER;
    4836:	230f      	movs	r3, #15
    4838:	18fb      	adds	r3, r7, r3
    483a:	22ff      	movs	r2, #255	; 0xff
    483c:	701a      	strb	r2, [r3, #0]
	uint8_t i      = 0;
    483e:	230e      	movs	r3, #14
    4840:	18fb      	adds	r3, r7, r3
    4842:	2200      	movs	r2, #0
    4844:	701a      	strb	r2, [r3, #0]

	for (; i < ARRAY_SIZE(_map); i++) {
    4846:	e01b      	b.n	4880 <_ext_irq_enable+0x58>
		if (_map[i].pin == pin) {
    4848:	230e      	movs	r3, #14
    484a:	18fb      	adds	r3, r7, r3
    484c:	781b      	ldrb	r3, [r3, #0]
    484e:	4a28      	ldr	r2, [pc, #160]	; (48f0 <_ext_irq_enable+0xc8>)
    4850:	00db      	lsls	r3, r3, #3
    4852:	18d3      	adds	r3, r2, r3
    4854:	3304      	adds	r3, #4
    4856:	681a      	ldr	r2, [r3, #0]
    4858:	687b      	ldr	r3, [r7, #4]
    485a:	429a      	cmp	r2, r3
    485c:	d109      	bne.n	4872 <_ext_irq_enable+0x4a>
			extint = _map[i].extint;
    485e:	230e      	movs	r3, #14
    4860:	18fb      	adds	r3, r7, r3
    4862:	7819      	ldrb	r1, [r3, #0]
    4864:	230f      	movs	r3, #15
    4866:	18fb      	adds	r3, r7, r3
    4868:	4a21      	ldr	r2, [pc, #132]	; (48f0 <_ext_irq_enable+0xc8>)
    486a:	00c9      	lsls	r1, r1, #3
    486c:	5c8a      	ldrb	r2, [r1, r2]
    486e:	701a      	strb	r2, [r3, #0]
			break;
    4870:	e00b      	b.n	488a <_ext_irq_enable+0x62>
	for (; i < ARRAY_SIZE(_map); i++) {
    4872:	230e      	movs	r3, #14
    4874:	18fb      	adds	r3, r7, r3
    4876:	781a      	ldrb	r2, [r3, #0]
    4878:	230e      	movs	r3, #14
    487a:	18fb      	adds	r3, r7, r3
    487c:	3201      	adds	r2, #1
    487e:	701a      	strb	r2, [r3, #0]
    4880:	230e      	movs	r3, #14
    4882:	18fb      	adds	r3, r7, r3
    4884:	781b      	ldrb	r3, [r3, #0]
    4886:	2b02      	cmp	r3, #2
    4888:	d9de      	bls.n	4848 <_ext_irq_enable+0x20>
		}
	}
	if (INVALID_EXTINT_NUMBER == extint) {
    488a:	230f      	movs	r3, #15
    488c:	18fb      	adds	r3, r7, r3
    488e:	781b      	ldrb	r3, [r3, #0]
    4890:	2bff      	cmp	r3, #255	; 0xff
    4892:	d102      	bne.n	489a <_ext_irq_enable+0x72>
		return ERR_INVALID_ARG;
    4894:	230d      	movs	r3, #13
    4896:	425b      	negs	r3, r3
    4898:	e026      	b.n	48e8 <_ext_irq_enable+0xc0>
	}

	if (enable) {
    489a:	1cfb      	adds	r3, r7, #3
    489c:	781b      	ldrb	r3, [r3, #0]
    489e:	2b00      	cmp	r3, #0
    48a0:	d00b      	beq.n	48ba <_ext_irq_enable+0x92>
		hri_eic_set_INTEN_reg(EIC, 1ul << extint);
    48a2:	230f      	movs	r3, #15
    48a4:	18fb      	adds	r3, r7, r3
    48a6:	781b      	ldrb	r3, [r3, #0]
    48a8:	2201      	movs	r2, #1
    48aa:	409a      	lsls	r2, r3
    48ac:	0013      	movs	r3, r2
    48ae:	4a11      	ldr	r2, [pc, #68]	; (48f4 <_ext_irq_enable+0xcc>)
    48b0:	0019      	movs	r1, r3
    48b2:	0010      	movs	r0, r2
    48b4:	f7ff feb6 	bl	4624 <hri_eic_set_INTEN_reg>
    48b8:	e015      	b.n	48e6 <_ext_irq_enable+0xbe>
	} else {
		hri_eic_clear_INTEN_reg(EIC, 1ul << extint);
    48ba:	230f      	movs	r3, #15
    48bc:	18fb      	adds	r3, r7, r3
    48be:	781b      	ldrb	r3, [r3, #0]
    48c0:	2201      	movs	r2, #1
    48c2:	409a      	lsls	r2, r3
    48c4:	0013      	movs	r3, r2
    48c6:	4a0b      	ldr	r2, [pc, #44]	; (48f4 <_ext_irq_enable+0xcc>)
    48c8:	0019      	movs	r1, r3
    48ca:	0010      	movs	r0, r2
    48cc:	f7ff fec0 	bl	4650 <hri_eic_clear_INTEN_reg>
		hri_eic_clear_INTFLAG_reg(EIC, 1ul << extint);
    48d0:	230f      	movs	r3, #15
    48d2:	18fb      	adds	r3, r7, r3
    48d4:	781b      	ldrb	r3, [r3, #0]
    48d6:	2201      	movs	r2, #1
    48d8:	409a      	lsls	r2, r3
    48da:	0013      	movs	r3, r2
    48dc:	4a05      	ldr	r2, [pc, #20]	; (48f4 <_ext_irq_enable+0xcc>)
    48de:	0019      	movs	r1, r3
    48e0:	0010      	movs	r0, r2
    48e2:	f7ff fe93 	bl	460c <hri_eic_clear_INTFLAG_reg>
	}

	return ERR_NONE;
    48e6:	2300      	movs	r3, #0
}
    48e8:	0018      	movs	r0, r3
    48ea:	46bd      	mov	sp, r7
    48ec:	b004      	add	sp, #16
    48ee:	bd80      	pop	{r7, pc}
    48f0:	00008f8c 	.word	0x00008f8c
    48f4:	40001800 	.word	0x40001800

000048f8 <EIC_Handler>:

/**
 * \brief EIC interrupt handler
 */
void EIC_Handler(void)
{
    48f8:	b590      	push	{r4, r7, lr}
    48fa:	b085      	sub	sp, #20
    48fc:	af00      	add	r7, sp, #0
	volatile uint32_t flags = hri_eic_read_INTFLAG_reg(EIC) & hri_eic_read_INTEN_reg(EIC);
    48fe:	4b59      	ldr	r3, [pc, #356]	; (4a64 <EIC_Handler+0x16c>)
    4900:	0018      	movs	r0, r3
    4902:	f7ff fe79 	bl	45f8 <hri_eic_read_INTFLAG_reg>
    4906:	0004      	movs	r4, r0
    4908:	4b56      	ldr	r3, [pc, #344]	; (4a64 <EIC_Handler+0x16c>)
    490a:	0018      	movs	r0, r3
    490c:	f7ff fe96 	bl	463c <hri_eic_read_INTEN_reg>
    4910:	0003      	movs	r3, r0
    4912:	4023      	ands	r3, r4
    4914:	603b      	str	r3, [r7, #0]
	int8_t            pos;
	uint32_t          pin = INVALID_PIN_NUMBER;
    4916:	2301      	movs	r3, #1
    4918:	425b      	negs	r3, r3
    491a:	60bb      	str	r3, [r7, #8]

	hri_eic_clear_INTFLAG_reg(EIC, flags);
    491c:	683b      	ldr	r3, [r7, #0]
    491e:	4a51      	ldr	r2, [pc, #324]	; (4a64 <EIC_Handler+0x16c>)
    4920:	0019      	movs	r1, r3
    4922:	0010      	movs	r0, r2
    4924:	f7ff fe72 	bl	460c <hri_eic_clear_INTFLAG_reg>

	ASSERT(callback);
    4928:	4b4f      	ldr	r3, [pc, #316]	; (4a68 <EIC_Handler+0x170>)
    492a:	681b      	ldr	r3, [r3, #0]
    492c:	1e5a      	subs	r2, r3, #1
    492e:	4193      	sbcs	r3, r2
    4930:	b2db      	uxtb	r3, r3
    4932:	494e      	ldr	r1, [pc, #312]	; (4a6c <EIC_Handler+0x174>)
    4934:	22d2      	movs	r2, #210	; 0xd2
    4936:	0018      	movs	r0, r3
    4938:	f7ff fd12 	bl	4360 <assert>

	while (flags) {
    493c:	e08a      	b.n	4a54 <EIC_Handler+0x15c>
		pos = ffs(flags) - 1;
    493e:	683b      	ldr	r3, [r7, #0]
    4940:	0018      	movs	r0, r3
    4942:	f003 fbc9 	bl	80d8 <ffs>
    4946:	0003      	movs	r3, r0
    4948:	b2db      	uxtb	r3, r3
    494a:	3b01      	subs	r3, #1
    494c:	b2da      	uxtb	r2, r3
    494e:	230f      	movs	r3, #15
    4950:	18fb      	adds	r3, r7, r3
    4952:	701a      	strb	r2, [r3, #0]
		while (-1 != pos) {
    4954:	e066      	b.n	4a24 <EIC_Handler+0x12c>
			uint8_t lower = 0, middle, upper = EXT_IRQ_AMOUNT;
    4956:	1dfb      	adds	r3, r7, #7
    4958:	2200      	movs	r2, #0
    495a:	701a      	strb	r2, [r3, #0]
    495c:	1dbb      	adds	r3, r7, #6
    495e:	2203      	movs	r2, #3
    4960:	701a      	strb	r2, [r3, #0]

			while (upper >= lower) {
    4962:	e03b      	b.n	49dc <EIC_Handler+0xe4>
				middle = (upper + lower) >> 1;
    4964:	1dbb      	adds	r3, r7, #6
    4966:	781a      	ldrb	r2, [r3, #0]
    4968:	1dfb      	adds	r3, r7, #7
    496a:	781b      	ldrb	r3, [r3, #0]
    496c:	18d3      	adds	r3, r2, r3
    496e:	105a      	asrs	r2, r3, #1
    4970:	1d7b      	adds	r3, r7, #5
    4972:	701a      	strb	r2, [r3, #0]
				if (_map[middle].extint == pos) {
    4974:	1d7b      	adds	r3, r7, #5
    4976:	781a      	ldrb	r2, [r3, #0]
    4978:	4b3d      	ldr	r3, [pc, #244]	; (4a70 <EIC_Handler+0x178>)
    497a:	00d2      	lsls	r2, r2, #3
    497c:	5cd3      	ldrb	r3, [r2, r3]
    497e:	001a      	movs	r2, r3
    4980:	230f      	movs	r3, #15
    4982:	18fb      	adds	r3, r7, r3
    4984:	781b      	ldrb	r3, [r3, #0]
    4986:	b25b      	sxtb	r3, r3
    4988:	429a      	cmp	r2, r3
    498a:	d108      	bne.n	499e <EIC_Handler+0xa6>
					pin = _map[middle].pin;
    498c:	1d7b      	adds	r3, r7, #5
    498e:	781b      	ldrb	r3, [r3, #0]
    4990:	4a37      	ldr	r2, [pc, #220]	; (4a70 <EIC_Handler+0x178>)
    4992:	00db      	lsls	r3, r3, #3
    4994:	18d3      	adds	r3, r2, r3
    4996:	3304      	adds	r3, #4
    4998:	681b      	ldr	r3, [r3, #0]
    499a:	60bb      	str	r3, [r7, #8]
					break;
    499c:	e024      	b.n	49e8 <EIC_Handler+0xf0>
				}
				if (_map[middle].extint < pos) {
    499e:	1d7b      	adds	r3, r7, #5
    49a0:	781a      	ldrb	r2, [r3, #0]
    49a2:	4b33      	ldr	r3, [pc, #204]	; (4a70 <EIC_Handler+0x178>)
    49a4:	00d2      	lsls	r2, r2, #3
    49a6:	5cd3      	ldrb	r3, [r2, r3]
    49a8:	001a      	movs	r2, r3
    49aa:	230f      	movs	r3, #15
    49ac:	18fb      	adds	r3, r7, r3
    49ae:	781b      	ldrb	r3, [r3, #0]
    49b0:	b25b      	sxtb	r3, r3
    49b2:	429a      	cmp	r2, r3
    49b4:	da09      	bge.n	49ca <EIC_Handler+0xd2>
					lower = middle + 1;
    49b6:	1dfb      	adds	r3, r7, #7
    49b8:	1d7a      	adds	r2, r7, #5
    49ba:	7812      	ldrb	r2, [r2, #0]
    49bc:	3201      	adds	r2, #1
    49be:	701a      	strb	r2, [r3, #0]
    49c0:	1dbb      	adds	r3, r7, #6
    49c2:	1dba      	adds	r2, r7, #6
    49c4:	7812      	ldrb	r2, [r2, #0]
    49c6:	701a      	strb	r2, [r3, #0]
    49c8:	e008      	b.n	49dc <EIC_Handler+0xe4>
				} else {
					upper = middle - 1;
    49ca:	1dbb      	adds	r3, r7, #6
    49cc:	1d7a      	adds	r2, r7, #5
    49ce:	7812      	ldrb	r2, [r2, #0]
    49d0:	3a01      	subs	r2, #1
    49d2:	701a      	strb	r2, [r3, #0]
    49d4:	1dfb      	adds	r3, r7, #7
    49d6:	1dfa      	adds	r2, r7, #7
    49d8:	7812      	ldrb	r2, [r2, #0]
    49da:	701a      	strb	r2, [r3, #0]
			while (upper >= lower) {
    49dc:	1dba      	adds	r2, r7, #6
    49de:	1dfb      	adds	r3, r7, #7
    49e0:	7812      	ldrb	r2, [r2, #0]
    49e2:	781b      	ldrb	r3, [r3, #0]
    49e4:	429a      	cmp	r2, r3
    49e6:	d2bd      	bcs.n	4964 <EIC_Handler+0x6c>
				}
			}

			if (INVALID_PIN_NUMBER != pin) {
    49e8:	68bb      	ldr	r3, [r7, #8]
    49ea:	3301      	adds	r3, #1
    49ec:	d004      	beq.n	49f8 <EIC_Handler+0x100>
				callback(pin);
    49ee:	4b1e      	ldr	r3, [pc, #120]	; (4a68 <EIC_Handler+0x170>)
    49f0:	681b      	ldr	r3, [r3, #0]
    49f2:	68ba      	ldr	r2, [r7, #8]
    49f4:	0010      	movs	r0, r2
    49f6:	4798      	blx	r3
			}
			flags &= ~(1ul << pos);
    49f8:	230f      	movs	r3, #15
    49fa:	18fb      	adds	r3, r7, r3
    49fc:	781b      	ldrb	r3, [r3, #0]
    49fe:	b25b      	sxtb	r3, r3
    4a00:	2201      	movs	r2, #1
    4a02:	409a      	lsls	r2, r3
    4a04:	0013      	movs	r3, r2
    4a06:	43db      	mvns	r3, r3
    4a08:	683a      	ldr	r2, [r7, #0]
    4a0a:	4013      	ands	r3, r2
    4a0c:	603b      	str	r3, [r7, #0]
			pos = ffs(flags) - 1;
    4a0e:	683b      	ldr	r3, [r7, #0]
    4a10:	0018      	movs	r0, r3
    4a12:	f003 fb61 	bl	80d8 <ffs>
    4a16:	0003      	movs	r3, r0
    4a18:	b2db      	uxtb	r3, r3
    4a1a:	3b01      	subs	r3, #1
    4a1c:	b2da      	uxtb	r2, r3
    4a1e:	230f      	movs	r3, #15
    4a20:	18fb      	adds	r3, r7, r3
    4a22:	701a      	strb	r2, [r3, #0]
		while (-1 != pos) {
    4a24:	230f      	movs	r3, #15
    4a26:	18fb      	adds	r3, r7, r3
    4a28:	781b      	ldrb	r3, [r3, #0]
    4a2a:	b25b      	sxtb	r3, r3
    4a2c:	3301      	adds	r3, #1
    4a2e:	d192      	bne.n	4956 <EIC_Handler+0x5e>
		}
		flags = hri_eic_read_INTFLAG_reg(EIC) & hri_eic_read_INTEN_reg(EIC);
    4a30:	4b0c      	ldr	r3, [pc, #48]	; (4a64 <EIC_Handler+0x16c>)
    4a32:	0018      	movs	r0, r3
    4a34:	f7ff fde0 	bl	45f8 <hri_eic_read_INTFLAG_reg>
    4a38:	0004      	movs	r4, r0
    4a3a:	4b0a      	ldr	r3, [pc, #40]	; (4a64 <EIC_Handler+0x16c>)
    4a3c:	0018      	movs	r0, r3
    4a3e:	f7ff fdfd 	bl	463c <hri_eic_read_INTEN_reg>
    4a42:	0003      	movs	r3, r0
    4a44:	4023      	ands	r3, r4
    4a46:	603b      	str	r3, [r7, #0]
		hri_eic_clear_INTFLAG_reg(EIC, flags);
    4a48:	683b      	ldr	r3, [r7, #0]
    4a4a:	4a06      	ldr	r2, [pc, #24]	; (4a64 <EIC_Handler+0x16c>)
    4a4c:	0019      	movs	r1, r3
    4a4e:	0010      	movs	r0, r2
    4a50:	f7ff fddc 	bl	460c <hri_eic_clear_INTFLAG_reg>
	while (flags) {
    4a54:	683b      	ldr	r3, [r7, #0]
    4a56:	2b00      	cmp	r3, #0
    4a58:	d000      	beq.n	4a5c <EIC_Handler+0x164>
    4a5a:	e770      	b.n	493e <EIC_Handler+0x46>
	}
}
    4a5c:	46c0      	nop			; (mov r8, r8)
    4a5e:	46bd      	mov	sp, r7
    4a60:	b005      	add	sp, #20
    4a62:	bd90      	pop	{r4, r7, pc}
    4a64:	40001800 	.word	0x40001800
    4a68:	200007cc 	.word	0x200007cc
    4a6c:	00008fa4 	.word	0x00008fa4
    4a70:	00008f8c 	.word	0x00008f8c

00004a74 <hri_gclk_wait_for_sync>:
{
    4a74:	b580      	push	{r7, lr}
    4a76:	b082      	sub	sp, #8
    4a78:	af00      	add	r7, sp, #0
    4a7a:	6078      	str	r0, [r7, #4]
	while (((const Gclk *)hw)->STATUS.bit.SYNCBUSY)
    4a7c:	46c0      	nop			; (mov r8, r8)
    4a7e:	687b      	ldr	r3, [r7, #4]
    4a80:	785b      	ldrb	r3, [r3, #1]
    4a82:	061b      	lsls	r3, r3, #24
    4a84:	0fdb      	lsrs	r3, r3, #31
    4a86:	b2db      	uxtb	r3, r3
    4a88:	2b00      	cmp	r3, #0
    4a8a:	d1f8      	bne.n	4a7e <hri_gclk_wait_for_sync+0xa>
}
    4a8c:	46c0      	nop			; (mov r8, r8)
    4a8e:	46bd      	mov	sp, r7
    4a90:	b002      	add	sp, #8
    4a92:	bd80      	pop	{r7, pc}

00004a94 <hri_gclk_write_GENCTRL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_gclk_write_GENCTRL_reg(const void *const hw, hri_gclk_genctrl_reg_t data)
{
    4a94:	b580      	push	{r7, lr}
    4a96:	b082      	sub	sp, #8
    4a98:	af00      	add	r7, sp, #0
    4a9a:	6078      	str	r0, [r7, #4]
    4a9c:	6039      	str	r1, [r7, #0]
	GCLK_CRITICAL_SECTION_ENTER();
	((Gclk *)hw)->GENCTRL.reg = data;
    4a9e:	687b      	ldr	r3, [r7, #4]
    4aa0:	683a      	ldr	r2, [r7, #0]
    4aa2:	605a      	str	r2, [r3, #4]
	hri_gclk_wait_for_sync(hw);
    4aa4:	687b      	ldr	r3, [r7, #4]
    4aa6:	0018      	movs	r0, r3
    4aa8:	f7ff ffe4 	bl	4a74 <hri_gclk_wait_for_sync>
	GCLK_CRITICAL_SECTION_LEAVE();
}
    4aac:	46c0      	nop			; (mov r8, r8)
    4aae:	46bd      	mov	sp, r7
    4ab0:	b002      	add	sp, #8
    4ab2:	bd80      	pop	{r7, pc}

00004ab4 <hri_gclk_write_GENDIV_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_gclk_write_GENDIV_reg(const void *const hw, hri_gclk_gendiv_reg_t data)
{
    4ab4:	b580      	push	{r7, lr}
    4ab6:	b082      	sub	sp, #8
    4ab8:	af00      	add	r7, sp, #0
    4aba:	6078      	str	r0, [r7, #4]
    4abc:	6039      	str	r1, [r7, #0]
	GCLK_CRITICAL_SECTION_ENTER();
	((Gclk *)hw)->GENDIV.reg = data;
    4abe:	687b      	ldr	r3, [r7, #4]
    4ac0:	683a      	ldr	r2, [r7, #0]
    4ac2:	609a      	str	r2, [r3, #8]
	GCLK_CRITICAL_SECTION_LEAVE();
}
    4ac4:	46c0      	nop			; (mov r8, r8)
    4ac6:	46bd      	mov	sp, r7
    4ac8:	b002      	add	sp, #8
    4aca:	bd80      	pop	{r7, pc}

00004acc <_gclk_init_generators_by_fref>:
	        | CONF_GCLK_GEN_7_SRC | GCLK_GENCTRL_ID(7));
#endif
}

void _gclk_init_generators_by_fref(uint32_t bm)
{
    4acc:	b580      	push	{r7, lr}
    4ace:	b082      	sub	sp, #8
    4ad0:	af00      	add	r7, sp, #0
    4ad2:	6078      	str	r0, [r7, #4]

#if CONF_GCLK_GENERATOR_0_CONFIG == 1
	if (bm & (1ul << 0)) {
    4ad4:	687b      	ldr	r3, [r7, #4]
    4ad6:	2201      	movs	r2, #1
    4ad8:	4013      	ands	r3, r2
    4ada:	d00c      	beq.n	4af6 <_gclk_init_generators_by_fref+0x2a>
		hri_gclk_write_GENDIV_reg(GCLK, GCLK_GENDIV_DIV(CONF_GCLK_GEN_0_DIV) | GCLK_GENDIV_ID(0));
    4adc:	2380      	movs	r3, #128	; 0x80
    4ade:	005b      	lsls	r3, r3, #1
    4ae0:	4a0f      	ldr	r2, [pc, #60]	; (4b20 <_gclk_init_generators_by_fref+0x54>)
    4ae2:	0019      	movs	r1, r3
    4ae4:	0010      	movs	r0, r2
    4ae6:	f7ff ffe5 	bl	4ab4 <hri_gclk_write_GENDIV_reg>
		hri_gclk_write_GENCTRL_reg(
    4aea:	4a0e      	ldr	r2, [pc, #56]	; (4b24 <_gclk_init_generators_by_fref+0x58>)
    4aec:	4b0c      	ldr	r3, [pc, #48]	; (4b20 <_gclk_init_generators_by_fref+0x54>)
    4aee:	0011      	movs	r1, r2
    4af0:	0018      	movs	r0, r3
    4af2:	f7ff ffcf 	bl	4a94 <hri_gclk_write_GENCTRL_reg>
		        | (CONF_GCLK_GENERATOR_2_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_2_SRC | GCLK_GENCTRL_ID(2));
	}
#endif

#if CONF_GCLK_GENERATOR_3_CONFIG == 1
	if (bm & (1ul << 3)) {
    4af6:	687b      	ldr	r3, [r7, #4]
    4af8:	2208      	movs	r2, #8
    4afa:	4013      	ands	r3, r2
    4afc:	d00b      	beq.n	4b16 <_gclk_init_generators_by_fref+0x4a>
		hri_gclk_write_GENDIV_reg(GCLK, GCLK_GENDIV_DIV(CONF_GCLK_GEN_3_DIV) | GCLK_GENDIV_ID(3));
    4afe:	4a0a      	ldr	r2, [pc, #40]	; (4b28 <_gclk_init_generators_by_fref+0x5c>)
    4b00:	4b07      	ldr	r3, [pc, #28]	; (4b20 <_gclk_init_generators_by_fref+0x54>)
    4b02:	0011      	movs	r1, r2
    4b04:	0018      	movs	r0, r3
    4b06:	f7ff ffd5 	bl	4ab4 <hri_gclk_write_GENDIV_reg>
		hri_gclk_write_GENCTRL_reg(
    4b0a:	4a08      	ldr	r2, [pc, #32]	; (4b2c <_gclk_init_generators_by_fref+0x60>)
    4b0c:	4b04      	ldr	r3, [pc, #16]	; (4b20 <_gclk_init_generators_by_fref+0x54>)
    4b0e:	0011      	movs	r1, r2
    4b10:	0018      	movs	r0, r3
    4b12:	f7ff ffbf 	bl	4a94 <hri_gclk_write_GENCTRL_reg>
		        | (CONF_GCLK_GEN_7_DIVSEL << GCLK_GENCTRL_DIVSEL_Pos) | (CONF_GCLK_GEN_7_OE << GCLK_GENCTRL_OE_Pos)
		        | (CONF_GCLK_GEN_7_OOV << GCLK_GENCTRL_OOV_Pos) | (CONF_GCLK_GEN_7_IDC << GCLK_GENCTRL_IDC_Pos)
		        | (CONF_GCLK_GENERATOR_7_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_7_SRC | GCLK_GENCTRL_ID(7));
	}
#endif
}
    4b16:	46c0      	nop			; (mov r8, r8)
    4b18:	46bd      	mov	sp, r7
    4b1a:	b002      	add	sp, #8
    4b1c:	bd80      	pop	{r7, pc}
    4b1e:	46c0      	nop			; (mov r8, r8)
    4b20:	40000c00 	.word	0x40000c00
    4b24:	00010700 	.word	0x00010700
    4b28:	00000403 	.word	0x00000403
    4b2c:	00010403 	.word	0x00010403

00004b30 <hri_pm_set_CPUSEL_CPUDIV_bf>:
{
	return ((Pm *)hw)->SLEEP.reg;
}

static inline void hri_pm_set_CPUSEL_CPUDIV_bf(const void *const hw, hri_pm_cpusel_reg_t mask)
{
    4b30:	b580      	push	{r7, lr}
    4b32:	b082      	sub	sp, #8
    4b34:	af00      	add	r7, sp, #0
    4b36:	6078      	str	r0, [r7, #4]
    4b38:	000a      	movs	r2, r1
    4b3a:	1cfb      	adds	r3, r7, #3
    4b3c:	701a      	strb	r2, [r3, #0]
	PM_CRITICAL_SECTION_ENTER();
	((Pm *)hw)->CPUSEL.reg |= PM_CPUSEL_CPUDIV(mask);
    4b3e:	687b      	ldr	r3, [r7, #4]
    4b40:	7a1b      	ldrb	r3, [r3, #8]
    4b42:	b2da      	uxtb	r2, r3
    4b44:	1cfb      	adds	r3, r7, #3
    4b46:	781b      	ldrb	r3, [r3, #0]
    4b48:	2107      	movs	r1, #7
    4b4a:	400b      	ands	r3, r1
    4b4c:	b2db      	uxtb	r3, r3
    4b4e:	4313      	orrs	r3, r2
    4b50:	b2da      	uxtb	r2, r3
    4b52:	687b      	ldr	r3, [r7, #4]
    4b54:	721a      	strb	r2, [r3, #8]
	PM_CRITICAL_SECTION_LEAVE();
}
    4b56:	46c0      	nop			; (mov r8, r8)
    4b58:	46bd      	mov	sp, r7
    4b5a:	b002      	add	sp, #8
    4b5c:	bd80      	pop	{r7, pc}

00004b5e <hri_pm_set_APBASEL_APBADIV_bf>:
{
	return ((Pm *)hw)->CPUSEL.reg;
}

static inline void hri_pm_set_APBASEL_APBADIV_bf(const void *const hw, hri_pm_apbasel_reg_t mask)
{
    4b5e:	b580      	push	{r7, lr}
    4b60:	b082      	sub	sp, #8
    4b62:	af00      	add	r7, sp, #0
    4b64:	6078      	str	r0, [r7, #4]
    4b66:	000a      	movs	r2, r1
    4b68:	1cfb      	adds	r3, r7, #3
    4b6a:	701a      	strb	r2, [r3, #0]
	PM_CRITICAL_SECTION_ENTER();
	((Pm *)hw)->APBASEL.reg |= PM_APBASEL_APBADIV(mask);
    4b6c:	687b      	ldr	r3, [r7, #4]
    4b6e:	7a5b      	ldrb	r3, [r3, #9]
    4b70:	b2da      	uxtb	r2, r3
    4b72:	1cfb      	adds	r3, r7, #3
    4b74:	781b      	ldrb	r3, [r3, #0]
    4b76:	2107      	movs	r1, #7
    4b78:	400b      	ands	r3, r1
    4b7a:	b2db      	uxtb	r3, r3
    4b7c:	4313      	orrs	r3, r2
    4b7e:	b2da      	uxtb	r2, r3
    4b80:	687b      	ldr	r3, [r7, #4]
    4b82:	725a      	strb	r2, [r3, #9]
	PM_CRITICAL_SECTION_LEAVE();
}
    4b84:	46c0      	nop			; (mov r8, r8)
    4b86:	46bd      	mov	sp, r7
    4b88:	b002      	add	sp, #8
    4b8a:	bd80      	pop	{r7, pc}

00004b8c <hri_pm_set_APBBSEL_APBBDIV_bf>:
{
	return ((Pm *)hw)->APBASEL.reg;
}

static inline void hri_pm_set_APBBSEL_APBBDIV_bf(const void *const hw, hri_pm_apbbsel_reg_t mask)
{
    4b8c:	b580      	push	{r7, lr}
    4b8e:	b082      	sub	sp, #8
    4b90:	af00      	add	r7, sp, #0
    4b92:	6078      	str	r0, [r7, #4]
    4b94:	000a      	movs	r2, r1
    4b96:	1cfb      	adds	r3, r7, #3
    4b98:	701a      	strb	r2, [r3, #0]
	PM_CRITICAL_SECTION_ENTER();
	((Pm *)hw)->APBBSEL.reg |= PM_APBBSEL_APBBDIV(mask);
    4b9a:	687b      	ldr	r3, [r7, #4]
    4b9c:	7a9b      	ldrb	r3, [r3, #10]
    4b9e:	b2da      	uxtb	r2, r3
    4ba0:	1cfb      	adds	r3, r7, #3
    4ba2:	781b      	ldrb	r3, [r3, #0]
    4ba4:	2107      	movs	r1, #7
    4ba6:	400b      	ands	r3, r1
    4ba8:	b2db      	uxtb	r3, r3
    4baa:	4313      	orrs	r3, r2
    4bac:	b2da      	uxtb	r2, r3
    4bae:	687b      	ldr	r3, [r7, #4]
    4bb0:	729a      	strb	r2, [r3, #10]
	PM_CRITICAL_SECTION_LEAVE();
}
    4bb2:	46c0      	nop			; (mov r8, r8)
    4bb4:	46bd      	mov	sp, r7
    4bb6:	b002      	add	sp, #8
    4bb8:	bd80      	pop	{r7, pc}

00004bba <hri_pm_set_APBCSEL_APBCDIV_bf>:
{
	return ((Pm *)hw)->APBBSEL.reg;
}

static inline void hri_pm_set_APBCSEL_APBCDIV_bf(const void *const hw, hri_pm_apbcsel_reg_t mask)
{
    4bba:	b580      	push	{r7, lr}
    4bbc:	b082      	sub	sp, #8
    4bbe:	af00      	add	r7, sp, #0
    4bc0:	6078      	str	r0, [r7, #4]
    4bc2:	000a      	movs	r2, r1
    4bc4:	1cfb      	adds	r3, r7, #3
    4bc6:	701a      	strb	r2, [r3, #0]
	PM_CRITICAL_SECTION_ENTER();
	((Pm *)hw)->APBCSEL.reg |= PM_APBCSEL_APBCDIV(mask);
    4bc8:	687b      	ldr	r3, [r7, #4]
    4bca:	7adb      	ldrb	r3, [r3, #11]
    4bcc:	b2da      	uxtb	r2, r3
    4bce:	1cfb      	adds	r3, r7, #3
    4bd0:	781b      	ldrb	r3, [r3, #0]
    4bd2:	2107      	movs	r1, #7
    4bd4:	400b      	ands	r3, r1
    4bd6:	b2db      	uxtb	r3, r3
    4bd8:	4313      	orrs	r3, r2
    4bda:	b2da      	uxtb	r2, r3
    4bdc:	687b      	ldr	r3, [r7, #4]
    4bde:	72da      	strb	r2, [r3, #11]
	PM_CRITICAL_SECTION_LEAVE();
}
    4be0:	46c0      	nop			; (mov r8, r8)
    4be2:	46bd      	mov	sp, r7
    4be4:	b002      	add	sp, #8
    4be6:	bd80      	pop	{r7, pc}

00004be8 <_pm_init>:

/**
 * \brief Power Manager Init
 */
void _pm_init(void)
{
    4be8:	b580      	push	{r7, lr}
    4bea:	af00      	add	r7, sp, #0
	hri_pm_set_CPUSEL_CPUDIV_bf(PM, CONF_CPU_DIV);
    4bec:	4b0b      	ldr	r3, [pc, #44]	; (4c1c <_pm_init+0x34>)
    4bee:	2100      	movs	r1, #0
    4bf0:	0018      	movs	r0, r3
    4bf2:	f7ff ff9d 	bl	4b30 <hri_pm_set_CPUSEL_CPUDIV_bf>
	hri_pm_set_APBASEL_APBADIV_bf(PM, CONF_APBA_DIV);
    4bf6:	4b09      	ldr	r3, [pc, #36]	; (4c1c <_pm_init+0x34>)
    4bf8:	2100      	movs	r1, #0
    4bfa:	0018      	movs	r0, r3
    4bfc:	f7ff ffaf 	bl	4b5e <hri_pm_set_APBASEL_APBADIV_bf>
	hri_pm_set_APBBSEL_APBBDIV_bf(PM, CONF_APBB_DIV);
    4c00:	4b06      	ldr	r3, [pc, #24]	; (4c1c <_pm_init+0x34>)
    4c02:	2100      	movs	r1, #0
    4c04:	0018      	movs	r0, r3
    4c06:	f7ff ffc1 	bl	4b8c <hri_pm_set_APBBSEL_APBBDIV_bf>
	hri_pm_set_APBCSEL_APBCDIV_bf(PM, CONF_APBC_DIV);
    4c0a:	4b04      	ldr	r3, [pc, #16]	; (4c1c <_pm_init+0x34>)
    4c0c:	2100      	movs	r1, #0
    4c0e:	0018      	movs	r0, r3
    4c10:	f7ff ffd3 	bl	4bba <hri_pm_set_APBCSEL_APBCDIV_bf>
}
    4c14:	46c0      	nop			; (mov r8, r8)
    4c16:	46bd      	mov	sp, r7
    4c18:	bd80      	pop	{r7, pc}
    4c1a:	46c0      	nop			; (mov r8, r8)
    4c1c:	40000400 	.word	0x40000400

00004c20 <hri_sercomi2cm_wait_for_sync>:
typedef uint8_t  hri_sercomusart_dbgctrl_reg_t;
typedef uint8_t  hri_sercomusart_intenset_reg_t;
typedef uint8_t  hri_sercomusart_intflag_reg_t;

static inline void hri_sercomi2cm_wait_for_sync(const void *const hw)
{
    4c20:	b580      	push	{r7, lr}
    4c22:	b082      	sub	sp, #8
    4c24:	af00      	add	r7, sp, #0
    4c26:	6078      	str	r0, [r7, #4]
	while (((const Sercom *)hw)->I2CM.STATUS.bit.SYNCBUSY)
    4c28:	46c0      	nop			; (mov r8, r8)
    4c2a:	687b      	ldr	r3, [r7, #4]
    4c2c:	8a1b      	ldrh	r3, [r3, #16]
    4c2e:	041b      	lsls	r3, r3, #16
    4c30:	0fdb      	lsrs	r3, r3, #31
    4c32:	b2db      	uxtb	r3, r3
    4c34:	2b00      	cmp	r3, #0
    4c36:	d1f8      	bne.n	4c2a <hri_sercomi2cm_wait_for_sync+0xa>
		;
}
    4c38:	46c0      	nop			; (mov r8, r8)
    4c3a:	46bd      	mov	sp, r7
    4c3c:	b002      	add	sp, #8
    4c3e:	bd80      	pop	{r7, pc}

00004c40 <hri_sercomspi_wait_for_sync>:
{
	return ((const Sercom *)hw)->I2CS.STATUS.bit.SYNCBUSY;
}

static inline void hri_sercomspi_wait_for_sync(const void *const hw)
{
    4c40:	b580      	push	{r7, lr}
    4c42:	b082      	sub	sp, #8
    4c44:	af00      	add	r7, sp, #0
    4c46:	6078      	str	r0, [r7, #4]
	while (((const Sercom *)hw)->SPI.STATUS.bit.SYNCBUSY)
    4c48:	46c0      	nop			; (mov r8, r8)
    4c4a:	687b      	ldr	r3, [r7, #4]
    4c4c:	8a1b      	ldrh	r3, [r3, #16]
    4c4e:	041b      	lsls	r3, r3, #16
    4c50:	0fdb      	lsrs	r3, r3, #31
    4c52:	b2db      	uxtb	r3, r3
    4c54:	2b00      	cmp	r3, #0
    4c56:	d1f8      	bne.n	4c4a <hri_sercomspi_wait_for_sync+0xa>
		;
}
    4c58:	46c0      	nop			; (mov r8, r8)
    4c5a:	46bd      	mov	sp, r7
    4c5c:	b002      	add	sp, #8
    4c5e:	bd80      	pop	{r7, pc}

00004c60 <hri_sercomspi_is_syncing>:

static inline bool hri_sercomspi_is_syncing(const void *const hw)
{
    4c60:	b580      	push	{r7, lr}
    4c62:	b082      	sub	sp, #8
    4c64:	af00      	add	r7, sp, #0
    4c66:	6078      	str	r0, [r7, #4]
	return ((const Sercom *)hw)->SPI.STATUS.bit.SYNCBUSY;
    4c68:	687b      	ldr	r3, [r7, #4]
    4c6a:	8a1b      	ldrh	r3, [r3, #16]
    4c6c:	041b      	lsls	r3, r3, #16
    4c6e:	0fdb      	lsrs	r3, r3, #31
    4c70:	b2db      	uxtb	r3, r3
    4c72:	1e5a      	subs	r2, r3, #1
    4c74:	4193      	sbcs	r3, r2
    4c76:	b2db      	uxtb	r3, r3
}
    4c78:	0018      	movs	r0, r3
    4c7a:	46bd      	mov	sp, r7
    4c7c:	b002      	add	sp, #8
    4c7e:	bd80      	pop	{r7, pc}

00004c80 <hri_sercomusart_wait_for_sync>:

static inline void hri_sercomusart_wait_for_sync(const void *const hw)
{
    4c80:	b580      	push	{r7, lr}
    4c82:	b082      	sub	sp, #8
    4c84:	af00      	add	r7, sp, #0
    4c86:	6078      	str	r0, [r7, #4]
	while (((const Sercom *)hw)->USART.STATUS.bit.SYNCBUSY)
    4c88:	46c0      	nop			; (mov r8, r8)
    4c8a:	687b      	ldr	r3, [r7, #4]
    4c8c:	8a1b      	ldrh	r3, [r3, #16]
    4c8e:	041b      	lsls	r3, r3, #16
    4c90:	0fdb      	lsrs	r3, r3, #31
    4c92:	b2db      	uxtb	r3, r3
    4c94:	2b00      	cmp	r3, #0
    4c96:	d1f8      	bne.n	4c8a <hri_sercomusart_wait_for_sync+0xa>
		;
}
    4c98:	46c0      	nop			; (mov r8, r8)
    4c9a:	46bd      	mov	sp, r7
    4c9c:	b002      	add	sp, #8
    4c9e:	bd80      	pop	{r7, pc}

00004ca0 <hri_sercomi2cm_clear_interrupt_MB_bit>:
{
	return (((Sercom *)hw)->I2CM.INTFLAG.reg & SERCOM_I2CM_INTFLAG_MB) >> SERCOM_I2CM_INTFLAG_MB_Pos;
}

static inline void hri_sercomi2cm_clear_interrupt_MB_bit(const void *const hw)
{
    4ca0:	b580      	push	{r7, lr}
    4ca2:	b082      	sub	sp, #8
    4ca4:	af00      	add	r7, sp, #0
    4ca6:	6078      	str	r0, [r7, #4]
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_MB;
    4ca8:	687b      	ldr	r3, [r7, #4]
    4caa:	2201      	movs	r2, #1
    4cac:	739a      	strb	r2, [r3, #14]
}
    4cae:	46c0      	nop			; (mov r8, r8)
    4cb0:	46bd      	mov	sp, r7
    4cb2:	b002      	add	sp, #8
    4cb4:	bd80      	pop	{r7, pc}

00004cb6 <hri_sercomi2cm_clear_interrupt_SB_bit>:
{
	return (((Sercom *)hw)->I2CM.INTFLAG.reg & SERCOM_I2CM_INTFLAG_SB) >> SERCOM_I2CM_INTFLAG_SB_Pos;
}

static inline void hri_sercomi2cm_clear_interrupt_SB_bit(const void *const hw)
{
    4cb6:	b580      	push	{r7, lr}
    4cb8:	b082      	sub	sp, #8
    4cba:	af00      	add	r7, sp, #0
    4cbc:	6078      	str	r0, [r7, #4]
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_SB;
    4cbe:	687b      	ldr	r3, [r7, #4]
    4cc0:	2202      	movs	r2, #2
    4cc2:	739a      	strb	r2, [r3, #14]
}
    4cc4:	46c0      	nop			; (mov r8, r8)
    4cc6:	46bd      	mov	sp, r7
    4cc8:	b002      	add	sp, #8
    4cca:	bd80      	pop	{r7, pc}

00004ccc <hri_sercomi2cm_read_INTFLAG_reg>:
	tmp &= mask;
	return tmp;
}

static inline hri_sercomi2cm_intflag_reg_t hri_sercomi2cm_read_INTFLAG_reg(const void *const hw)
{
    4ccc:	b580      	push	{r7, lr}
    4cce:	b082      	sub	sp, #8
    4cd0:	af00      	add	r7, sp, #0
    4cd2:	6078      	str	r0, [r7, #4]
	return ((Sercom *)hw)->I2CM.INTFLAG.reg;
    4cd4:	687b      	ldr	r3, [r7, #4]
    4cd6:	7b9b      	ldrb	r3, [r3, #14]
    4cd8:	b2db      	uxtb	r3, r3
}
    4cda:	0018      	movs	r0, r3
    4cdc:	46bd      	mov	sp, r7
    4cde:	b002      	add	sp, #8
    4ce0:	bd80      	pop	{r7, pc}

00004ce2 <hri_sercomspi_get_INTFLAG_reg>:
	((Sercom *)hw)->SPI.INTFLAG.reg = SERCOM_SPI_INTFLAG_RXC;
}

static inline hri_sercomspi_intflag_reg_t hri_sercomspi_get_INTFLAG_reg(const void *const           hw,
                                                                        hri_sercomspi_intflag_reg_t mask)
{
    4ce2:	b580      	push	{r7, lr}
    4ce4:	b084      	sub	sp, #16
    4ce6:	af00      	add	r7, sp, #0
    4ce8:	6078      	str	r0, [r7, #4]
    4cea:	000a      	movs	r2, r1
    4cec:	1cfb      	adds	r3, r7, #3
    4cee:	701a      	strb	r2, [r3, #0]
	uint8_t tmp;
	tmp = ((Sercom *)hw)->SPI.INTFLAG.reg;
    4cf0:	230f      	movs	r3, #15
    4cf2:	18fb      	adds	r3, r7, r3
    4cf4:	687a      	ldr	r2, [r7, #4]
    4cf6:	7b92      	ldrb	r2, [r2, #14]
    4cf8:	701a      	strb	r2, [r3, #0]
	tmp &= mask;
    4cfa:	230f      	movs	r3, #15
    4cfc:	18fb      	adds	r3, r7, r3
    4cfe:	220f      	movs	r2, #15
    4d00:	18ba      	adds	r2, r7, r2
    4d02:	1cf9      	adds	r1, r7, #3
    4d04:	7812      	ldrb	r2, [r2, #0]
    4d06:	7809      	ldrb	r1, [r1, #0]
    4d08:	400a      	ands	r2, r1
    4d0a:	701a      	strb	r2, [r3, #0]
	return tmp;
    4d0c:	230f      	movs	r3, #15
    4d0e:	18fb      	adds	r3, r7, r3
    4d10:	781b      	ldrb	r3, [r3, #0]
}
    4d12:	0018      	movs	r0, r3
    4d14:	46bd      	mov	sp, r7
    4d16:	b004      	add	sp, #16
    4d18:	bd80      	pop	{r7, pc}

00004d1a <hri_sercomspi_read_INTFLAG_reg>:

static inline hri_sercomspi_intflag_reg_t hri_sercomspi_read_INTFLAG_reg(const void *const hw)
{
    4d1a:	b580      	push	{r7, lr}
    4d1c:	b082      	sub	sp, #8
    4d1e:	af00      	add	r7, sp, #0
    4d20:	6078      	str	r0, [r7, #4]
	return ((Sercom *)hw)->SPI.INTFLAG.reg;
    4d22:	687b      	ldr	r3, [r7, #4]
    4d24:	7b9b      	ldrb	r3, [r3, #14]
    4d26:	b2db      	uxtb	r3, r3
}
    4d28:	0018      	movs	r0, r3
    4d2a:	46bd      	mov	sp, r7
    4d2c:	b002      	add	sp, #8
    4d2e:	bd80      	pop	{r7, pc}

00004d30 <hri_sercomspi_clear_INTFLAG_reg>:

static inline void hri_sercomspi_clear_INTFLAG_reg(const void *const hw, hri_sercomspi_intflag_reg_t mask)
{
    4d30:	b580      	push	{r7, lr}
    4d32:	b082      	sub	sp, #8
    4d34:	af00      	add	r7, sp, #0
    4d36:	6078      	str	r0, [r7, #4]
    4d38:	000a      	movs	r2, r1
    4d3a:	1cfb      	adds	r3, r7, #3
    4d3c:	701a      	strb	r2, [r3, #0]
	((Sercom *)hw)->SPI.INTFLAG.reg = mask;
    4d3e:	687b      	ldr	r3, [r7, #4]
    4d40:	1cfa      	adds	r2, r7, #3
    4d42:	7812      	ldrb	r2, [r2, #0]
    4d44:	739a      	strb	r2, [r3, #14]
}
    4d46:	46c0      	nop			; (mov r8, r8)
    4d48:	46bd      	mov	sp, r7
    4d4a:	b002      	add	sp, #8
    4d4c:	bd80      	pop	{r7, pc}

00004d4e <hri_sercomusart_get_interrupt_DRE_bit>:
{
	((Sercom *)hw)->USART.INTFLAG.reg = SERCOM_USART_INTFLAG_RXS;
}

static inline bool hri_sercomusart_get_interrupt_DRE_bit(const void *const hw)
{
    4d4e:	b580      	push	{r7, lr}
    4d50:	b082      	sub	sp, #8
    4d52:	af00      	add	r7, sp, #0
    4d54:	6078      	str	r0, [r7, #4]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_DRE) >> SERCOM_USART_INTFLAG_DRE_Pos;
    4d56:	687b      	ldr	r3, [r7, #4]
    4d58:	7b9b      	ldrb	r3, [r3, #14]
    4d5a:	b2db      	uxtb	r3, r3
    4d5c:	001a      	movs	r2, r3
    4d5e:	2301      	movs	r3, #1
    4d60:	4013      	ands	r3, r2
    4d62:	1e5a      	subs	r2, r3, #1
    4d64:	4193      	sbcs	r3, r2
    4d66:	b2db      	uxtb	r3, r3
}
    4d68:	0018      	movs	r0, r3
    4d6a:	46bd      	mov	sp, r7
    4d6c:	b002      	add	sp, #8
    4d6e:	bd80      	pop	{r7, pc}

00004d70 <hri_sercomusart_get_interrupt_TXC_bit>:
{
	((Sercom *)hw)->USART.INTFLAG.reg = SERCOM_USART_INTFLAG_DRE;
}

static inline bool hri_sercomusart_get_interrupt_TXC_bit(const void *const hw)
{
    4d70:	b580      	push	{r7, lr}
    4d72:	b082      	sub	sp, #8
    4d74:	af00      	add	r7, sp, #0
    4d76:	6078      	str	r0, [r7, #4]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_TXC) >> SERCOM_USART_INTFLAG_TXC_Pos;
    4d78:	687b      	ldr	r3, [r7, #4]
    4d7a:	7b9b      	ldrb	r3, [r3, #14]
    4d7c:	b2db      	uxtb	r3, r3
    4d7e:	085b      	lsrs	r3, r3, #1
    4d80:	2201      	movs	r2, #1
    4d82:	4013      	ands	r3, r2
    4d84:	1e5a      	subs	r2, r3, #1
    4d86:	4193      	sbcs	r3, r2
    4d88:	b2db      	uxtb	r3, r3
}
    4d8a:	0018      	movs	r0, r3
    4d8c:	46bd      	mov	sp, r7
    4d8e:	b002      	add	sp, #8
    4d90:	bd80      	pop	{r7, pc}

00004d92 <hri_sercomusart_get_interrupt_RXC_bit>:
{
	((Sercom *)hw)->USART.INTFLAG.reg = SERCOM_USART_INTFLAG_TXC;
}

static inline bool hri_sercomusart_get_interrupt_RXC_bit(const void *const hw)
{
    4d92:	b580      	push	{r7, lr}
    4d94:	b082      	sub	sp, #8
    4d96:	af00      	add	r7, sp, #0
    4d98:	6078      	str	r0, [r7, #4]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_RXC) >> SERCOM_USART_INTFLAG_RXC_Pos;
    4d9a:	687b      	ldr	r3, [r7, #4]
    4d9c:	7b9b      	ldrb	r3, [r3, #14]
    4d9e:	b2db      	uxtb	r3, r3
    4da0:	089b      	lsrs	r3, r3, #2
    4da2:	2201      	movs	r2, #1
    4da4:	4013      	ands	r3, r2
    4da6:	1e5a      	subs	r2, r3, #1
    4da8:	4193      	sbcs	r3, r2
    4daa:	b2db      	uxtb	r3, r3
}
    4dac:	0018      	movs	r0, r3
    4dae:	46bd      	mov	sp, r7
    4db0:	b002      	add	sp, #8
    4db2:	bd80      	pop	{r7, pc}

00004db4 <hri_sercomi2cm_set_CTRLA_ENABLE_bit>:
	tmp = (tmp & SERCOM_I2CM_CTRLA_SWRST) >> SERCOM_I2CM_CTRLA_SWRST_Pos;
	return (bool)tmp;
}

static inline void hri_sercomi2cm_set_CTRLA_ENABLE_bit(const void *const hw)
{
    4db4:	b580      	push	{r7, lr}
    4db6:	b082      	sub	sp, #8
    4db8:	af00      	add	r7, sp, #0
    4dba:	6078      	str	r0, [r7, #4]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->I2CM.CTRLA.reg |= SERCOM_I2CM_CTRLA_ENABLE;
    4dbc:	687b      	ldr	r3, [r7, #4]
    4dbe:	681b      	ldr	r3, [r3, #0]
    4dc0:	2202      	movs	r2, #2
    4dc2:	431a      	orrs	r2, r3
    4dc4:	687b      	ldr	r3, [r7, #4]
    4dc6:	601a      	str	r2, [r3, #0]
	hri_sercomi2cm_wait_for_sync(hw);
    4dc8:	687b      	ldr	r3, [r7, #4]
    4dca:	0018      	movs	r0, r3
    4dcc:	f7ff ff28 	bl	4c20 <hri_sercomi2cm_wait_for_sync>
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    4dd0:	46c0      	nop			; (mov r8, r8)
    4dd2:	46bd      	mov	sp, r7
    4dd4:	b002      	add	sp, #8
    4dd6:	bd80      	pop	{r7, pc}

00004dd8 <hri_sercomi2cm_get_CTRLA_reg>:
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline hri_sercomi2cm_ctrla_reg_t hri_sercomi2cm_get_CTRLA_reg(const void *const          hw,
                                                                      hri_sercomi2cm_ctrla_reg_t mask)
{
    4dd8:	b580      	push	{r7, lr}
    4dda:	b084      	sub	sp, #16
    4ddc:	af00      	add	r7, sp, #0
    4dde:	6078      	str	r0, [r7, #4]
    4de0:	6039      	str	r1, [r7, #0]
	uint32_t tmp;
	hri_sercomi2cm_wait_for_sync(hw);
    4de2:	687b      	ldr	r3, [r7, #4]
    4de4:	0018      	movs	r0, r3
    4de6:	f7ff ff1b 	bl	4c20 <hri_sercomi2cm_wait_for_sync>
	tmp = ((Sercom *)hw)->I2CM.CTRLA.reg;
    4dea:	687b      	ldr	r3, [r7, #4]
    4dec:	681b      	ldr	r3, [r3, #0]
    4dee:	60fb      	str	r3, [r7, #12]
	tmp &= mask;
    4df0:	68fb      	ldr	r3, [r7, #12]
    4df2:	683a      	ldr	r2, [r7, #0]
    4df4:	4013      	ands	r3, r2
    4df6:	60fb      	str	r3, [r7, #12]
	return tmp;
    4df8:	68fb      	ldr	r3, [r7, #12]
}
    4dfa:	0018      	movs	r0, r3
    4dfc:	46bd      	mov	sp, r7
    4dfe:	b004      	add	sp, #16
    4e00:	bd80      	pop	{r7, pc}

00004e02 <hri_sercomi2cm_write_CTRLA_reg>:

static inline void hri_sercomi2cm_write_CTRLA_reg(const void *const hw, hri_sercomi2cm_ctrla_reg_t data)
{
    4e02:	b580      	push	{r7, lr}
    4e04:	b082      	sub	sp, #8
    4e06:	af00      	add	r7, sp, #0
    4e08:	6078      	str	r0, [r7, #4]
    4e0a:	6039      	str	r1, [r7, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->I2CM.CTRLA.reg = data;
    4e0c:	687b      	ldr	r3, [r7, #4]
    4e0e:	683a      	ldr	r2, [r7, #0]
    4e10:	601a      	str	r2, [r3, #0]
	hri_sercomi2cm_wait_for_sync(hw);
    4e12:	687b      	ldr	r3, [r7, #4]
    4e14:	0018      	movs	r0, r3
    4e16:	f7ff ff03 	bl	4c20 <hri_sercomi2cm_wait_for_sync>
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    4e1a:	46c0      	nop			; (mov r8, r8)
    4e1c:	46bd      	mov	sp, r7
    4e1e:	b002      	add	sp, #8
    4e20:	bd80      	pop	{r7, pc}

00004e22 <hri_sercomspi_set_CTRLA_ENABLE_bit>:
	tmp = (tmp & SERCOM_SPI_CTRLA_SWRST) >> SERCOM_SPI_CTRLA_SWRST_Pos;
	return (bool)tmp;
}

static inline void hri_sercomspi_set_CTRLA_ENABLE_bit(const void *const hw)
{
    4e22:	b580      	push	{r7, lr}
    4e24:	b082      	sub	sp, #8
    4e26:	af00      	add	r7, sp, #0
    4e28:	6078      	str	r0, [r7, #4]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->SPI.CTRLA.reg |= SERCOM_SPI_CTRLA_ENABLE;
    4e2a:	687b      	ldr	r3, [r7, #4]
    4e2c:	681b      	ldr	r3, [r3, #0]
    4e2e:	2202      	movs	r2, #2
    4e30:	431a      	orrs	r2, r3
    4e32:	687b      	ldr	r3, [r7, #4]
    4e34:	601a      	str	r2, [r3, #0]
	hri_sercomspi_wait_for_sync(hw);
    4e36:	687b      	ldr	r3, [r7, #4]
    4e38:	0018      	movs	r0, r3
    4e3a:	f7ff ff01 	bl	4c40 <hri_sercomspi_wait_for_sync>
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    4e3e:	46c0      	nop			; (mov r8, r8)
    4e40:	46bd      	mov	sp, r7
    4e42:	b002      	add	sp, #8
    4e44:	bd80      	pop	{r7, pc}

00004e46 <hri_sercomspi_get_CTRLA_ENABLE_bit>:

static inline bool hri_sercomspi_get_CTRLA_ENABLE_bit(const void *const hw)
{
    4e46:	b580      	push	{r7, lr}
    4e48:	b084      	sub	sp, #16
    4e4a:	af00      	add	r7, sp, #0
    4e4c:	6078      	str	r0, [r7, #4]
	uint32_t tmp;
	hri_sercomspi_wait_for_sync(hw);
    4e4e:	687b      	ldr	r3, [r7, #4]
    4e50:	0018      	movs	r0, r3
    4e52:	f7ff fef5 	bl	4c40 <hri_sercomspi_wait_for_sync>
	tmp = ((Sercom *)hw)->SPI.CTRLA.reg;
    4e56:	687b      	ldr	r3, [r7, #4]
    4e58:	681b      	ldr	r3, [r3, #0]
    4e5a:	60fb      	str	r3, [r7, #12]
	tmp = (tmp & SERCOM_SPI_CTRLA_ENABLE) >> SERCOM_SPI_CTRLA_ENABLE_Pos;
    4e5c:	68fb      	ldr	r3, [r7, #12]
    4e5e:	085b      	lsrs	r3, r3, #1
    4e60:	2201      	movs	r2, #1
    4e62:	4013      	ands	r3, r2
    4e64:	60fb      	str	r3, [r7, #12]
	return (bool)tmp;
    4e66:	68fb      	ldr	r3, [r7, #12]
    4e68:	1e5a      	subs	r2, r3, #1
    4e6a:	4193      	sbcs	r3, r2
    4e6c:	b2db      	uxtb	r3, r3
}
    4e6e:	0018      	movs	r0, r3
    4e70:	46bd      	mov	sp, r7
    4e72:	b004      	add	sp, #16
    4e74:	bd80      	pop	{r7, pc}

00004e76 <hri_sercomspi_get_CTRLA_reg>:
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline hri_sercomspi_ctrla_reg_t hri_sercomspi_get_CTRLA_reg(const void *const         hw,
                                                                    hri_sercomspi_ctrla_reg_t mask)
{
    4e76:	b580      	push	{r7, lr}
    4e78:	b084      	sub	sp, #16
    4e7a:	af00      	add	r7, sp, #0
    4e7c:	6078      	str	r0, [r7, #4]
    4e7e:	6039      	str	r1, [r7, #0]
	uint32_t tmp;
	hri_sercomspi_wait_for_sync(hw);
    4e80:	687b      	ldr	r3, [r7, #4]
    4e82:	0018      	movs	r0, r3
    4e84:	f7ff fedc 	bl	4c40 <hri_sercomspi_wait_for_sync>
	tmp = ((Sercom *)hw)->SPI.CTRLA.reg;
    4e88:	687b      	ldr	r3, [r7, #4]
    4e8a:	681b      	ldr	r3, [r3, #0]
    4e8c:	60fb      	str	r3, [r7, #12]
	tmp &= mask;
    4e8e:	68fb      	ldr	r3, [r7, #12]
    4e90:	683a      	ldr	r2, [r7, #0]
    4e92:	4013      	ands	r3, r2
    4e94:	60fb      	str	r3, [r7, #12]
	return tmp;
    4e96:	68fb      	ldr	r3, [r7, #12]
}
    4e98:	0018      	movs	r0, r3
    4e9a:	46bd      	mov	sp, r7
    4e9c:	b004      	add	sp, #16
    4e9e:	bd80      	pop	{r7, pc}

00004ea0 <hri_sercomspi_write_CTRLA_reg>:

static inline void hri_sercomspi_write_CTRLA_reg(const void *const hw, hri_sercomspi_ctrla_reg_t data)
{
    4ea0:	b580      	push	{r7, lr}
    4ea2:	b082      	sub	sp, #8
    4ea4:	af00      	add	r7, sp, #0
    4ea6:	6078      	str	r0, [r7, #4]
    4ea8:	6039      	str	r1, [r7, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->SPI.CTRLA.reg = data;
    4eaa:	687b      	ldr	r3, [r7, #4]
    4eac:	683a      	ldr	r2, [r7, #0]
    4eae:	601a      	str	r2, [r3, #0]
	hri_sercomspi_wait_for_sync(hw);
    4eb0:	687b      	ldr	r3, [r7, #4]
    4eb2:	0018      	movs	r0, r3
    4eb4:	f7ff fec4 	bl	4c40 <hri_sercomspi_wait_for_sync>
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    4eb8:	46c0      	nop			; (mov r8, r8)
    4eba:	46bd      	mov	sp, r7
    4ebc:	b002      	add	sp, #8
    4ebe:	bd80      	pop	{r7, pc}

00004ec0 <hri_sercomusart_get_CTRLA_reg>:
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline hri_sercomusart_ctrla_reg_t hri_sercomusart_get_CTRLA_reg(const void *const           hw,
                                                                        hri_sercomusart_ctrla_reg_t mask)
{
    4ec0:	b580      	push	{r7, lr}
    4ec2:	b084      	sub	sp, #16
    4ec4:	af00      	add	r7, sp, #0
    4ec6:	6078      	str	r0, [r7, #4]
    4ec8:	6039      	str	r1, [r7, #0]
	uint32_t tmp;
	hri_sercomusart_wait_for_sync(hw);
    4eca:	687b      	ldr	r3, [r7, #4]
    4ecc:	0018      	movs	r0, r3
    4ece:	f7ff fed7 	bl	4c80 <hri_sercomusart_wait_for_sync>
	tmp = ((Sercom *)hw)->USART.CTRLA.reg;
    4ed2:	687b      	ldr	r3, [r7, #4]
    4ed4:	681b      	ldr	r3, [r3, #0]
    4ed6:	60fb      	str	r3, [r7, #12]
	tmp &= mask;
    4ed8:	68fb      	ldr	r3, [r7, #12]
    4eda:	683a      	ldr	r2, [r7, #0]
    4edc:	4013      	ands	r3, r2
    4ede:	60fb      	str	r3, [r7, #12]
	return tmp;
    4ee0:	68fb      	ldr	r3, [r7, #12]
}
    4ee2:	0018      	movs	r0, r3
    4ee4:	46bd      	mov	sp, r7
    4ee6:	b004      	add	sp, #16
    4ee8:	bd80      	pop	{r7, pc}

00004eea <hri_sercomusart_write_CTRLA_reg>:

static inline void hri_sercomusart_write_CTRLA_reg(const void *const hw, hri_sercomusart_ctrla_reg_t data)
{
    4eea:	b580      	push	{r7, lr}
    4eec:	b082      	sub	sp, #8
    4eee:	af00      	add	r7, sp, #0
    4ef0:	6078      	str	r0, [r7, #4]
    4ef2:	6039      	str	r1, [r7, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.CTRLA.reg = data;
    4ef4:	687b      	ldr	r3, [r7, #4]
    4ef6:	683a      	ldr	r2, [r7, #0]
    4ef8:	601a      	str	r2, [r3, #0]
	hri_sercomusart_wait_for_sync(hw);
    4efa:	687b      	ldr	r3, [r7, #4]
    4efc:	0018      	movs	r0, r3
    4efe:	f7ff febf 	bl	4c80 <hri_sercomusart_wait_for_sync>
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    4f02:	46c0      	nop			; (mov r8, r8)
    4f04:	46bd      	mov	sp, r7
    4f06:	b002      	add	sp, #8
    4f08:	bd80      	pop	{r7, pc}

00004f0a <hri_sercomi2cm_set_CTRLB_SMEN_bit>:
	hri_sercomusart_wait_for_sync(hw);
	return ((Sercom *)hw)->USART.CTRLA.reg;
}

static inline void hri_sercomi2cm_set_CTRLB_SMEN_bit(const void *const hw)
{
    4f0a:	b580      	push	{r7, lr}
    4f0c:	b082      	sub	sp, #8
    4f0e:	af00      	add	r7, sp, #0
    4f10:	6078      	str	r0, [r7, #4]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_SMEN;
    4f12:	687b      	ldr	r3, [r7, #4]
    4f14:	685b      	ldr	r3, [r3, #4]
    4f16:	2280      	movs	r2, #128	; 0x80
    4f18:	0052      	lsls	r2, r2, #1
    4f1a:	431a      	orrs	r2, r3
    4f1c:	687b      	ldr	r3, [r7, #4]
    4f1e:	605a      	str	r2, [r3, #4]
	hri_sercomi2cm_wait_for_sync(hw);
    4f20:	687b      	ldr	r3, [r7, #4]
    4f22:	0018      	movs	r0, r3
    4f24:	f7ff fe7c 	bl	4c20 <hri_sercomi2cm_wait_for_sync>
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    4f28:	46c0      	nop			; (mov r8, r8)
    4f2a:	46bd      	mov	sp, r7
    4f2c:	b002      	add	sp, #8
    4f2e:	bd80      	pop	{r7, pc}

00004f30 <hri_sercomi2cm_clear_CTRLB_SMEN_bit>:
	hri_sercomi2cm_wait_for_sync(hw);
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline void hri_sercomi2cm_clear_CTRLB_SMEN_bit(const void *const hw)
{
    4f30:	b580      	push	{r7, lr}
    4f32:	b082      	sub	sp, #8
    4f34:	af00      	add	r7, sp, #0
    4f36:	6078      	str	r0, [r7, #4]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->I2CM.CTRLB.reg &= ~SERCOM_I2CM_CTRLB_SMEN;
    4f38:	687b      	ldr	r3, [r7, #4]
    4f3a:	685b      	ldr	r3, [r3, #4]
    4f3c:	4a05      	ldr	r2, [pc, #20]	; (4f54 <hri_sercomi2cm_clear_CTRLB_SMEN_bit+0x24>)
    4f3e:	401a      	ands	r2, r3
    4f40:	687b      	ldr	r3, [r7, #4]
    4f42:	605a      	str	r2, [r3, #4]
	hri_sercomi2cm_wait_for_sync(hw);
    4f44:	687b      	ldr	r3, [r7, #4]
    4f46:	0018      	movs	r0, r3
    4f48:	f7ff fe6a 	bl	4c20 <hri_sercomi2cm_wait_for_sync>
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    4f4c:	46c0      	nop			; (mov r8, r8)
    4f4e:	46bd      	mov	sp, r7
    4f50:	b002      	add	sp, #8
    4f52:	bd80      	pop	{r7, pc}
    4f54:	fffffeff 	.word	0xfffffeff

00004f58 <hri_sercomi2cm_set_CTRLB_ACKACT_bit>:
	hri_sercomi2cm_wait_for_sync(hw);
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline void hri_sercomi2cm_set_CTRLB_ACKACT_bit(const void *const hw)
{
    4f58:	b580      	push	{r7, lr}
    4f5a:	b082      	sub	sp, #8
    4f5c:	af00      	add	r7, sp, #0
    4f5e:	6078      	str	r0, [r7, #4]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_ACKACT;
    4f60:	687b      	ldr	r3, [r7, #4]
    4f62:	685b      	ldr	r3, [r3, #4]
    4f64:	2280      	movs	r2, #128	; 0x80
    4f66:	02d2      	lsls	r2, r2, #11
    4f68:	431a      	orrs	r2, r3
    4f6a:	687b      	ldr	r3, [r7, #4]
    4f6c:	605a      	str	r2, [r3, #4]
	hri_sercomi2cm_wait_for_sync(hw);
    4f6e:	687b      	ldr	r3, [r7, #4]
    4f70:	0018      	movs	r0, r3
    4f72:	f7ff fe55 	bl	4c20 <hri_sercomi2cm_wait_for_sync>
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    4f76:	46c0      	nop			; (mov r8, r8)
    4f78:	46bd      	mov	sp, r7
    4f7a:	b002      	add	sp, #8
    4f7c:	bd80      	pop	{r7, pc}
	...

00004f80 <hri_sercomi2cm_clear_CTRLB_ACKACT_bit>:
	hri_sercomi2cm_wait_for_sync(hw);
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline void hri_sercomi2cm_clear_CTRLB_ACKACT_bit(const void *const hw)
{
    4f80:	b580      	push	{r7, lr}
    4f82:	b082      	sub	sp, #8
    4f84:	af00      	add	r7, sp, #0
    4f86:	6078      	str	r0, [r7, #4]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->I2CM.CTRLB.reg &= ~SERCOM_I2CM_CTRLB_ACKACT;
    4f88:	687b      	ldr	r3, [r7, #4]
    4f8a:	685b      	ldr	r3, [r3, #4]
    4f8c:	4a05      	ldr	r2, [pc, #20]	; (4fa4 <hri_sercomi2cm_clear_CTRLB_ACKACT_bit+0x24>)
    4f8e:	401a      	ands	r2, r3
    4f90:	687b      	ldr	r3, [r7, #4]
    4f92:	605a      	str	r2, [r3, #4]
	hri_sercomi2cm_wait_for_sync(hw);
    4f94:	687b      	ldr	r3, [r7, #4]
    4f96:	0018      	movs	r0, r3
    4f98:	f7ff fe42 	bl	4c20 <hri_sercomi2cm_wait_for_sync>
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    4f9c:	46c0      	nop			; (mov r8, r8)
    4f9e:	46bd      	mov	sp, r7
    4fa0:	b002      	add	sp, #8
    4fa2:	bd80      	pop	{r7, pc}
    4fa4:	fffbffff 	.word	0xfffbffff

00004fa8 <hri_sercomi2cm_set_CTRLB_CMD_bf>:
	hri_sercomi2cm_wait_for_sync(hw);
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline void hri_sercomi2cm_set_CTRLB_CMD_bf(const void *const hw, hri_sercomi2cm_ctrlb_reg_t mask)
{
    4fa8:	b580      	push	{r7, lr}
    4faa:	b082      	sub	sp, #8
    4fac:	af00      	add	r7, sp, #0
    4fae:	6078      	str	r0, [r7, #4]
    4fb0:	6039      	str	r1, [r7, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
    4fb2:	687b      	ldr	r3, [r7, #4]
    4fb4:	685a      	ldr	r2, [r3, #4]
    4fb6:	683b      	ldr	r3, [r7, #0]
    4fb8:	0419      	lsls	r1, r3, #16
    4fba:	23c0      	movs	r3, #192	; 0xc0
    4fbc:	029b      	lsls	r3, r3, #10
    4fbe:	400b      	ands	r3, r1
    4fc0:	431a      	orrs	r2, r3
    4fc2:	687b      	ldr	r3, [r7, #4]
    4fc4:	605a      	str	r2, [r3, #4]
	hri_sercomi2cm_wait_for_sync(hw);
    4fc6:	687b      	ldr	r3, [r7, #4]
    4fc8:	0018      	movs	r0, r3
    4fca:	f7ff fe29 	bl	4c20 <hri_sercomi2cm_wait_for_sync>
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    4fce:	46c0      	nop			; (mov r8, r8)
    4fd0:	46bd      	mov	sp, r7
    4fd2:	b002      	add	sp, #8
    4fd4:	bd80      	pop	{r7, pc}

00004fd6 <hri_sercomi2cm_write_CTRLB_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomi2cm_write_CTRLB_reg(const void *const hw, hri_sercomi2cm_ctrlb_reg_t data)
{
    4fd6:	b580      	push	{r7, lr}
    4fd8:	b082      	sub	sp, #8
    4fda:	af00      	add	r7, sp, #0
    4fdc:	6078      	str	r0, [r7, #4]
    4fde:	6039      	str	r1, [r7, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->I2CM.CTRLB.reg = data;
    4fe0:	687b      	ldr	r3, [r7, #4]
    4fe2:	683a      	ldr	r2, [r7, #0]
    4fe4:	605a      	str	r2, [r3, #4]
	hri_sercomi2cm_wait_for_sync(hw);
    4fe6:	687b      	ldr	r3, [r7, #4]
    4fe8:	0018      	movs	r0, r3
    4fea:	f7ff fe19 	bl	4c20 <hri_sercomi2cm_wait_for_sync>
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    4fee:	46c0      	nop			; (mov r8, r8)
    4ff0:	46bd      	mov	sp, r7
    4ff2:	b002      	add	sp, #8
    4ff4:	bd80      	pop	{r7, pc}

00004ff6 <hri_sercomspi_write_CTRLB_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomspi_write_CTRLB_reg(const void *const hw, hri_sercomspi_ctrlb_reg_t data)
{
    4ff6:	b580      	push	{r7, lr}
    4ff8:	b082      	sub	sp, #8
    4ffa:	af00      	add	r7, sp, #0
    4ffc:	6078      	str	r0, [r7, #4]
    4ffe:	6039      	str	r1, [r7, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->SPI.CTRLB.reg = data;
    5000:	687b      	ldr	r3, [r7, #4]
    5002:	683a      	ldr	r2, [r7, #0]
    5004:	605a      	str	r2, [r3, #4]
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    5006:	46c0      	nop			; (mov r8, r8)
    5008:	46bd      	mov	sp, r7
    500a:	b002      	add	sp, #8
    500c:	bd80      	pop	{r7, pc}

0000500e <hri_sercomusart_write_CTRLB_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomusart_write_CTRLB_reg(const void *const hw, hri_sercomusart_ctrlb_reg_t data)
{
    500e:	b580      	push	{r7, lr}
    5010:	b082      	sub	sp, #8
    5012:	af00      	add	r7, sp, #0
    5014:	6078      	str	r0, [r7, #4]
    5016:	6039      	str	r1, [r7, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.CTRLB.reg = data;
    5018:	687b      	ldr	r3, [r7, #4]
    501a:	683a      	ldr	r2, [r7, #0]
    501c:	605a      	str	r2, [r3, #4]
	hri_sercomusart_wait_for_sync(hw);
    501e:	687b      	ldr	r3, [r7, #4]
    5020:	0018      	movs	r0, r3
    5022:	f7ff fe2d 	bl	4c80 <hri_sercomusart_wait_for_sync>
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    5026:	46c0      	nop			; (mov r8, r8)
    5028:	46bd      	mov	sp, r7
    502a:	b002      	add	sp, #8
    502c:	bd80      	pop	{r7, pc}

0000502e <hri_sercomspi_write_DBGCTRL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomspi_write_DBGCTRL_reg(const void *const hw, hri_sercomspi_dbgctrl_reg_t data)
{
    502e:	b580      	push	{r7, lr}
    5030:	b082      	sub	sp, #8
    5032:	af00      	add	r7, sp, #0
    5034:	6078      	str	r0, [r7, #4]
    5036:	000a      	movs	r2, r1
    5038:	1cfb      	adds	r3, r7, #3
    503a:	701a      	strb	r2, [r3, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->SPI.DBGCTRL.reg = data;
    503c:	687b      	ldr	r3, [r7, #4]
    503e:	1cfa      	adds	r2, r7, #3
    5040:	7812      	ldrb	r2, [r2, #0]
    5042:	721a      	strb	r2, [r3, #8]
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    5044:	46c0      	nop			; (mov r8, r8)
    5046:	46bd      	mov	sp, r7
    5048:	b002      	add	sp, #8
    504a:	bd80      	pop	{r7, pc}

0000504c <hri_sercomusart_write_DBGCTRL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomusart_write_DBGCTRL_reg(const void *const hw, hri_sercomusart_dbgctrl_reg_t data)
{
    504c:	b580      	push	{r7, lr}
    504e:	b082      	sub	sp, #8
    5050:	af00      	add	r7, sp, #0
    5052:	6078      	str	r0, [r7, #4]
    5054:	000a      	movs	r2, r1
    5056:	1cfb      	adds	r3, r7, #3
    5058:	701a      	strb	r2, [r3, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.DBGCTRL.reg = data;
    505a:	687b      	ldr	r3, [r7, #4]
    505c:	1cfa      	adds	r2, r7, #3
    505e:	7812      	ldrb	r2, [r2, #0]
    5060:	721a      	strb	r2, [r3, #8]
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    5062:	46c0      	nop			; (mov r8, r8)
    5064:	46bd      	mov	sp, r7
    5066:	b002      	add	sp, #8
    5068:	bd80      	pop	{r7, pc}

0000506a <hri_sercomi2cm_write_BAUD_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomi2cm_write_BAUD_reg(const void *const hw, hri_sercomi2cm_baud_reg_t data)
{
    506a:	b580      	push	{r7, lr}
    506c:	b082      	sub	sp, #8
    506e:	af00      	add	r7, sp, #0
    5070:	6078      	str	r0, [r7, #4]
    5072:	000a      	movs	r2, r1
    5074:	1cbb      	adds	r3, r7, #2
    5076:	801a      	strh	r2, [r3, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->I2CM.BAUD.reg = data;
    5078:	687b      	ldr	r3, [r7, #4]
    507a:	1cba      	adds	r2, r7, #2
    507c:	8812      	ldrh	r2, [r2, #0]
    507e:	815a      	strh	r2, [r3, #10]
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    5080:	46c0      	nop			; (mov r8, r8)
    5082:	46bd      	mov	sp, r7
    5084:	b002      	add	sp, #8
    5086:	bd80      	pop	{r7, pc}

00005088 <hri_sercomspi_write_BAUD_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomspi_write_BAUD_reg(const void *const hw, hri_sercomspi_baud_reg_t data)
{
    5088:	b580      	push	{r7, lr}
    508a:	b082      	sub	sp, #8
    508c:	af00      	add	r7, sp, #0
    508e:	6078      	str	r0, [r7, #4]
    5090:	000a      	movs	r2, r1
    5092:	1cfb      	adds	r3, r7, #3
    5094:	701a      	strb	r2, [r3, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->SPI.BAUD.reg = data;
    5096:	687b      	ldr	r3, [r7, #4]
    5098:	1cfa      	adds	r2, r7, #3
    509a:	7812      	ldrb	r2, [r2, #0]
    509c:	729a      	strb	r2, [r3, #10]
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    509e:	46c0      	nop			; (mov r8, r8)
    50a0:	46bd      	mov	sp, r7
    50a2:	b002      	add	sp, #8
    50a4:	bd80      	pop	{r7, pc}

000050a6 <hri_sercomusart_write_BAUD_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomusart_write_BAUD_reg(const void *const hw, hri_sercomusart_baud_reg_t data)
{
    50a6:	b580      	push	{r7, lr}
    50a8:	b082      	sub	sp, #8
    50aa:	af00      	add	r7, sp, #0
    50ac:	6078      	str	r0, [r7, #4]
    50ae:	000a      	movs	r2, r1
    50b0:	1cbb      	adds	r3, r7, #2
    50b2:	801a      	strh	r2, [r3, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.BAUD.reg = data;
    50b4:	687b      	ldr	r3, [r7, #4]
    50b6:	1cba      	adds	r2, r7, #2
    50b8:	8812      	ldrh	r2, [r2, #0]
    50ba:	815a      	strh	r2, [r3, #10]
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    50bc:	46c0      	nop			; (mov r8, r8)
    50be:	46bd      	mov	sp, r7
    50c0:	b002      	add	sp, #8
    50c2:	bd80      	pop	{r7, pc}

000050c4 <hri_sercomi2cm_write_ADDR_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomi2cm_write_ADDR_reg(const void *const hw, hri_sercomi2cm_addr_reg_t data)
{
    50c4:	b580      	push	{r7, lr}
    50c6:	b082      	sub	sp, #8
    50c8:	af00      	add	r7, sp, #0
    50ca:	6078      	str	r0, [r7, #4]
    50cc:	000a      	movs	r2, r1
    50ce:	1cfb      	adds	r3, r7, #3
    50d0:	701a      	strb	r2, [r3, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->I2CM.ADDR.reg = data;
    50d2:	687b      	ldr	r3, [r7, #4]
    50d4:	1cfa      	adds	r2, r7, #3
    50d6:	7812      	ldrb	r2, [r2, #0]
    50d8:	751a      	strb	r2, [r3, #20]
	hri_sercomi2cm_wait_for_sync(hw);
    50da:	687b      	ldr	r3, [r7, #4]
    50dc:	0018      	movs	r0, r3
    50de:	f7ff fd9f 	bl	4c20 <hri_sercomi2cm_wait_for_sync>
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    50e2:	46c0      	nop			; (mov r8, r8)
    50e4:	46bd      	mov	sp, r7
    50e6:	b002      	add	sp, #8
    50e8:	bd80      	pop	{r7, pc}

000050ea <hri_sercomspi_write_ADDR_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomspi_write_ADDR_reg(const void *const hw, hri_sercomspi_addr_reg_t data)
{
    50ea:	b580      	push	{r7, lr}
    50ec:	b082      	sub	sp, #8
    50ee:	af00      	add	r7, sp, #0
    50f0:	6078      	str	r0, [r7, #4]
    50f2:	6039      	str	r1, [r7, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->SPI.ADDR.reg = data;
    50f4:	687b      	ldr	r3, [r7, #4]
    50f6:	683a      	ldr	r2, [r7, #0]
    50f8:	615a      	str	r2, [r3, #20]
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    50fa:	46c0      	nop			; (mov r8, r8)
    50fc:	46bd      	mov	sp, r7
    50fe:	b002      	add	sp, #8
    5100:	bd80      	pop	{r7, pc}

00005102 <hri_sercomi2cm_write_DATA_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomi2cm_write_DATA_reg(const void *const hw, hri_sercomi2cm_data_reg_t data)
{
    5102:	b580      	push	{r7, lr}
    5104:	b082      	sub	sp, #8
    5106:	af00      	add	r7, sp, #0
    5108:	6078      	str	r0, [r7, #4]
    510a:	000a      	movs	r2, r1
    510c:	1cfb      	adds	r3, r7, #3
    510e:	701a      	strb	r2, [r3, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->I2CM.DATA.reg = data;
    5110:	687b      	ldr	r3, [r7, #4]
    5112:	1cfa      	adds	r2, r7, #3
    5114:	7812      	ldrb	r2, [r2, #0]
    5116:	761a      	strb	r2, [r3, #24]
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    5118:	46c0      	nop			; (mov r8, r8)
    511a:	46bd      	mov	sp, r7
    511c:	b002      	add	sp, #8
    511e:	bd80      	pop	{r7, pc}

00005120 <hri_sercomi2cm_read_DATA_reg>:
	((Sercom *)hw)->I2CM.DATA.reg ^= mask;
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline hri_sercomi2cm_data_reg_t hri_sercomi2cm_read_DATA_reg(const void *const hw)
{
    5120:	b580      	push	{r7, lr}
    5122:	b082      	sub	sp, #8
    5124:	af00      	add	r7, sp, #0
    5126:	6078      	str	r0, [r7, #4]
	return ((Sercom *)hw)->I2CM.DATA.reg;
    5128:	687b      	ldr	r3, [r7, #4]
    512a:	7e1b      	ldrb	r3, [r3, #24]
    512c:	b2db      	uxtb	r3, r3
}
    512e:	0018      	movs	r0, r3
    5130:	46bd      	mov	sp, r7
    5132:	b002      	add	sp, #8
    5134:	bd80      	pop	{r7, pc}

00005136 <hri_sercomspi_write_DATA_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomspi_write_DATA_reg(const void *const hw, hri_sercomspi_data_reg_t data)
{
    5136:	b580      	push	{r7, lr}
    5138:	b082      	sub	sp, #8
    513a:	af00      	add	r7, sp, #0
    513c:	6078      	str	r0, [r7, #4]
    513e:	000a      	movs	r2, r1
    5140:	1cbb      	adds	r3, r7, #2
    5142:	801a      	strh	r2, [r3, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->SPI.DATA.reg = data;
    5144:	687b      	ldr	r3, [r7, #4]
    5146:	1cba      	adds	r2, r7, #2
    5148:	8812      	ldrh	r2, [r2, #0]
    514a:	831a      	strh	r2, [r3, #24]
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    514c:	46c0      	nop			; (mov r8, r8)
    514e:	46bd      	mov	sp, r7
    5150:	b002      	add	sp, #8
    5152:	bd80      	pop	{r7, pc}

00005154 <hri_sercomspi_read_DATA_reg>:
	((Sercom *)hw)->SPI.DATA.reg ^= mask;
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline hri_sercomspi_data_reg_t hri_sercomspi_read_DATA_reg(const void *const hw)
{
    5154:	b580      	push	{r7, lr}
    5156:	b082      	sub	sp, #8
    5158:	af00      	add	r7, sp, #0
    515a:	6078      	str	r0, [r7, #4]
	return ((Sercom *)hw)->SPI.DATA.reg;
    515c:	687b      	ldr	r3, [r7, #4]
    515e:	8b1b      	ldrh	r3, [r3, #24]
    5160:	b29b      	uxth	r3, r3
}
    5162:	0018      	movs	r0, r3
    5164:	46bd      	mov	sp, r7
    5166:	b002      	add	sp, #8
    5168:	bd80      	pop	{r7, pc}

0000516a <hri_sercomusart_write_DATA_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomusart_write_DATA_reg(const void *const hw, hri_sercomusart_data_reg_t data)
{
    516a:	b580      	push	{r7, lr}
    516c:	b082      	sub	sp, #8
    516e:	af00      	add	r7, sp, #0
    5170:	6078      	str	r0, [r7, #4]
    5172:	000a      	movs	r2, r1
    5174:	1cbb      	adds	r3, r7, #2
    5176:	801a      	strh	r2, [r3, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.DATA.reg = data;
    5178:	687b      	ldr	r3, [r7, #4]
    517a:	1cba      	adds	r2, r7, #2
    517c:	8812      	ldrh	r2, [r2, #0]
    517e:	831a      	strh	r2, [r3, #24]
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    5180:	46c0      	nop			; (mov r8, r8)
    5182:	46bd      	mov	sp, r7
    5184:	b002      	add	sp, #8
    5186:	bd80      	pop	{r7, pc}

00005188 <hri_sercomusart_read_DATA_reg>:
	((Sercom *)hw)->USART.DATA.reg ^= mask;
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline hri_sercomusart_data_reg_t hri_sercomusart_read_DATA_reg(const void *const hw)
{
    5188:	b580      	push	{r7, lr}
    518a:	b082      	sub	sp, #8
    518c:	af00      	add	r7, sp, #0
    518e:	6078      	str	r0, [r7, #4]
	return ((Sercom *)hw)->USART.DATA.reg;
    5190:	687b      	ldr	r3, [r7, #4]
    5192:	8b1b      	ldrh	r3, [r3, #24]
    5194:	b29b      	uxth	r3, r3
}
    5196:	0018      	movs	r0, r3
    5198:	46bd      	mov	sp, r7
    519a:	b002      	add	sp, #8
    519c:	bd80      	pop	{r7, pc}

0000519e <hri_sercomi2cm_read_STATUS_BUSSTATE_bf>:
	hri_sercomi2cm_wait_for_sync(hw);
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline hri_sercomi2cm_status_reg_t hri_sercomi2cm_read_STATUS_BUSSTATE_bf(const void *const hw)
{
    519e:	b580      	push	{r7, lr}
    51a0:	b082      	sub	sp, #8
    51a2:	af00      	add	r7, sp, #0
    51a4:	6078      	str	r0, [r7, #4]
	hri_sercomi2cm_wait_for_sync(hw);
    51a6:	687b      	ldr	r3, [r7, #4]
    51a8:	0018      	movs	r0, r3
    51aa:	f7ff fd39 	bl	4c20 <hri_sercomi2cm_wait_for_sync>
	return (((Sercom *)hw)->I2CM.STATUS.reg & SERCOM_I2CM_STATUS_BUSSTATE_Msk) >> SERCOM_I2CM_STATUS_BUSSTATE_Pos;
    51ae:	687b      	ldr	r3, [r7, #4]
    51b0:	8a1b      	ldrh	r3, [r3, #16]
    51b2:	b29b      	uxth	r3, r3
    51b4:	091b      	lsrs	r3, r3, #4
    51b6:	b29b      	uxth	r3, r3
    51b8:	2203      	movs	r2, #3
    51ba:	4013      	ands	r3, r2
    51bc:	b29b      	uxth	r3, r3
}
    51be:	0018      	movs	r0, r3
    51c0:	46bd      	mov	sp, r7
    51c2:	b002      	add	sp, #8
    51c4:	bd80      	pop	{r7, pc}

000051c6 <hri_sercomi2cm_read_STATUS_reg>:
	hri_sercomi2cm_wait_for_sync(hw);
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline hri_sercomi2cm_status_reg_t hri_sercomi2cm_read_STATUS_reg(const void *const hw)
{
    51c6:	b580      	push	{r7, lr}
    51c8:	b082      	sub	sp, #8
    51ca:	af00      	add	r7, sp, #0
    51cc:	6078      	str	r0, [r7, #4]
	hri_sercomi2cm_wait_for_sync(hw);
    51ce:	687b      	ldr	r3, [r7, #4]
    51d0:	0018      	movs	r0, r3
    51d2:	f7ff fd25 	bl	4c20 <hri_sercomi2cm_wait_for_sync>
	return ((Sercom *)hw)->I2CM.STATUS.reg;
    51d6:	687b      	ldr	r3, [r7, #4]
    51d8:	8a1b      	ldrh	r3, [r3, #16]
    51da:	b29b      	uxth	r3, r3
}
    51dc:	0018      	movs	r0, r3
    51de:	46bd      	mov	sp, r7
    51e0:	b002      	add	sp, #8
    51e2:	bd80      	pop	{r7, pc}

000051e4 <_usart_sync_init>:

/**
 * \brief Initialize synchronous SERCOM USART
 */
int32_t _usart_sync_init(struct _usart_sync_device *const device, void *const hw)
{
    51e4:	b580      	push	{r7, lr}
    51e6:	b082      	sub	sp, #8
    51e8:	af00      	add	r7, sp, #0
    51ea:	6078      	str	r0, [r7, #4]
    51ec:	6039      	str	r1, [r7, #0]
	ASSERT(device);
    51ee:	687b      	ldr	r3, [r7, #4]
    51f0:	1e5a      	subs	r2, r3, #1
    51f2:	4193      	sbcs	r3, r2
    51f4:	b2db      	uxtb	r3, r3
    51f6:	4908      	ldr	r1, [pc, #32]	; (5218 <_usart_sync_init+0x34>)
    51f8:	22a1      	movs	r2, #161	; 0xa1
    51fa:	0018      	movs	r0, r3
    51fc:	f7ff f8b0 	bl	4360 <assert>

	device->hw = hw;
    5200:	687b      	ldr	r3, [r7, #4]
    5202:	683a      	ldr	r2, [r7, #0]
    5204:	601a      	str	r2, [r3, #0]

	return _usart_init(hw);
    5206:	683b      	ldr	r3, [r7, #0]
    5208:	0018      	movs	r0, r3
    520a:	f000 f8a3 	bl	5354 <_usart_init>
    520e:	0003      	movs	r3, r0
}
    5210:	0018      	movs	r0, r3
    5212:	46bd      	mov	sp, r7
    5214:	b002      	add	sp, #8
    5216:	bd80      	pop	{r7, pc}
    5218:	00008fbc 	.word	0x00008fbc

0000521c <_usart_sync_write_byte>:

/**
 * \brief Write a byte to the given SERCOM USART instance
 */
void _usart_sync_write_byte(struct _usart_sync_device *const device, uint8_t data)
{
    521c:	b580      	push	{r7, lr}
    521e:	b082      	sub	sp, #8
    5220:	af00      	add	r7, sp, #0
    5222:	6078      	str	r0, [r7, #4]
    5224:	000a      	movs	r2, r1
    5226:	1cfb      	adds	r3, r7, #3
    5228:	701a      	strb	r2, [r3, #0]
	hri_sercomusart_write_DATA_reg(device->hw, data);
    522a:	687b      	ldr	r3, [r7, #4]
    522c:	681a      	ldr	r2, [r3, #0]
    522e:	1cfb      	adds	r3, r7, #3
    5230:	781b      	ldrb	r3, [r3, #0]
    5232:	b29b      	uxth	r3, r3
    5234:	0019      	movs	r1, r3
    5236:	0010      	movs	r0, r2
    5238:	f7ff ff97 	bl	516a <hri_sercomusart_write_DATA_reg>
}
    523c:	46c0      	nop			; (mov r8, r8)
    523e:	46bd      	mov	sp, r7
    5240:	b002      	add	sp, #8
    5242:	bd80      	pop	{r7, pc}

00005244 <_usart_sync_read_byte>:

/**
 * \brief Read a byte from the given SERCOM USART instance
 */
uint8_t _usart_sync_read_byte(const struct _usart_sync_device *const device)
{
    5244:	b580      	push	{r7, lr}
    5246:	b082      	sub	sp, #8
    5248:	af00      	add	r7, sp, #0
    524a:	6078      	str	r0, [r7, #4]
	return hri_sercomusart_read_DATA_reg(device->hw);
    524c:	687b      	ldr	r3, [r7, #4]
    524e:	681b      	ldr	r3, [r3, #0]
    5250:	0018      	movs	r0, r3
    5252:	f7ff ff99 	bl	5188 <hri_sercomusart_read_DATA_reg>
    5256:	0003      	movs	r3, r0
    5258:	b2db      	uxtb	r3, r3
}
    525a:	0018      	movs	r0, r3
    525c:	46bd      	mov	sp, r7
    525e:	b002      	add	sp, #8
    5260:	bd80      	pop	{r7, pc}

00005262 <_usart_sync_is_ready_to_send>:

/**
 * \brief Check if USART is ready to send next byte
 */
bool _usart_sync_is_ready_to_send(const struct _usart_sync_device *const device)
{
    5262:	b580      	push	{r7, lr}
    5264:	b082      	sub	sp, #8
    5266:	af00      	add	r7, sp, #0
    5268:	6078      	str	r0, [r7, #4]
	return hri_sercomusart_get_interrupt_DRE_bit(device->hw);
    526a:	687b      	ldr	r3, [r7, #4]
    526c:	681b      	ldr	r3, [r3, #0]
    526e:	0018      	movs	r0, r3
    5270:	f7ff fd6d 	bl	4d4e <hri_sercomusart_get_interrupt_DRE_bit>
    5274:	0003      	movs	r3, r0
}
    5276:	0018      	movs	r0, r3
    5278:	46bd      	mov	sp, r7
    527a:	b002      	add	sp, #8
    527c:	bd80      	pop	{r7, pc}

0000527e <_usart_sync_is_transmit_done>:

/**
 * \brief Check if USART transmission complete
 */
bool _usart_sync_is_transmit_done(const struct _usart_sync_device *const device)
{
    527e:	b580      	push	{r7, lr}
    5280:	b082      	sub	sp, #8
    5282:	af00      	add	r7, sp, #0
    5284:	6078      	str	r0, [r7, #4]
	return hri_sercomusart_get_interrupt_TXC_bit(device->hw);
    5286:	687b      	ldr	r3, [r7, #4]
    5288:	681b      	ldr	r3, [r3, #0]
    528a:	0018      	movs	r0, r3
    528c:	f7ff fd70 	bl	4d70 <hri_sercomusart_get_interrupt_TXC_bit>
    5290:	0003      	movs	r3, r0
}
    5292:	0018      	movs	r0, r3
    5294:	46bd      	mov	sp, r7
    5296:	b002      	add	sp, #8
    5298:	bd80      	pop	{r7, pc}

0000529a <_usart_sync_is_byte_received>:

/**
 * \brief Check if there is data received by USART
 */
bool _usart_sync_is_byte_received(const struct _usart_sync_device *const device)
{
    529a:	b580      	push	{r7, lr}
    529c:	b082      	sub	sp, #8
    529e:	af00      	add	r7, sp, #0
    52a0:	6078      	str	r0, [r7, #4]
	return hri_sercomusart_get_interrupt_RXC_bit(device->hw);
    52a2:	687b      	ldr	r3, [r7, #4]
    52a4:	681b      	ldr	r3, [r3, #0]
    52a6:	0018      	movs	r0, r3
    52a8:	f7ff fd73 	bl	4d92 <hri_sercomusart_get_interrupt_RXC_bit>
    52ac:	0003      	movs	r3, r0
}
    52ae:	0018      	movs	r0, r3
    52b0:	46bd      	mov	sp, r7
    52b2:	b002      	add	sp, #8
    52b4:	bd80      	pop	{r7, pc}
	...

000052b8 <_sercom_get_hardware_index>:

/**
 * \brief Retrieve ordinal number of the given sercom hardware instance
 */
static uint8_t _sercom_get_hardware_index(const void *const hw)
{
    52b8:	b580      	push	{r7, lr}
    52ba:	b082      	sub	sp, #8
    52bc:	af00      	add	r7, sp, #0
    52be:	6078      	str	r0, [r7, #4]
#ifdef _UNIT_TEST_
	return ((uint32_t)hw - (uint32_t)SERCOM0) / sizeof(Sercom);
#endif

	return ((uint32_t)hw - (uint32_t)SERCOM0) >> 10;
    52c0:	687b      	ldr	r3, [r7, #4]
    52c2:	4a04      	ldr	r2, [pc, #16]	; (52d4 <_sercom_get_hardware_index+0x1c>)
    52c4:	4694      	mov	ip, r2
    52c6:	4463      	add	r3, ip
    52c8:	0a9b      	lsrs	r3, r3, #10
    52ca:	b2db      	uxtb	r3, r3
}
    52cc:	0018      	movs	r0, r3
    52ce:	46bd      	mov	sp, r7
    52d0:	b002      	add	sp, #8
    52d2:	bd80      	pop	{r7, pc}
    52d4:	bdfff800 	.word	0xbdfff800

000052d8 <_get_sercom_index>:
 * \param[in] hw The pointer to hardware instance

 * \return The ordinal number of the given sercom hardware instance
 */
static uint8_t _get_sercom_index(const void *const hw)
{
    52d8:	b590      	push	{r4, r7, lr}
    52da:	b085      	sub	sp, #20
    52dc:	af00      	add	r7, sp, #0
    52de:	6078      	str	r0, [r7, #4]
	uint8_t sercom_offset = _sercom_get_hardware_index(hw);
    52e0:	230e      	movs	r3, #14
    52e2:	18fc      	adds	r4, r7, r3
    52e4:	687b      	ldr	r3, [r7, #4]
    52e6:	0018      	movs	r0, r3
    52e8:	f7ff ffe6 	bl	52b8 <_sercom_get_hardware_index>
    52ec:	0003      	movs	r3, r0
    52ee:	7023      	strb	r3, [r4, #0]
	uint8_t i;

	for (i = 0; i < ARRAY_SIZE(_usarts); i++) {
    52f0:	230f      	movs	r3, #15
    52f2:	18fb      	adds	r3, r7, r3
    52f4:	2200      	movs	r2, #0
    52f6:	701a      	strb	r2, [r3, #0]
    52f8:	e015      	b.n	5326 <_get_sercom_index+0x4e>
		if (_usarts[i].number == sercom_offset) {
    52fa:	230f      	movs	r3, #15
    52fc:	18fb      	adds	r3, r7, r3
    52fe:	781a      	ldrb	r2, [r3, #0]
    5300:	4b11      	ldr	r3, [pc, #68]	; (5348 <_get_sercom_index+0x70>)
    5302:	0112      	lsls	r2, r2, #4
    5304:	5cd3      	ldrb	r3, [r2, r3]
    5306:	220e      	movs	r2, #14
    5308:	18ba      	adds	r2, r7, r2
    530a:	7812      	ldrb	r2, [r2, #0]
    530c:	429a      	cmp	r2, r3
    530e:	d103      	bne.n	5318 <_get_sercom_index+0x40>
			return i;
    5310:	230f      	movs	r3, #15
    5312:	18fb      	adds	r3, r7, r3
    5314:	781b      	ldrb	r3, [r3, #0]
    5316:	e012      	b.n	533e <_get_sercom_index+0x66>
	for (i = 0; i < ARRAY_SIZE(_usarts); i++) {
    5318:	230f      	movs	r3, #15
    531a:	18fb      	adds	r3, r7, r3
    531c:	781a      	ldrb	r2, [r3, #0]
    531e:	230f      	movs	r3, #15
    5320:	18fb      	adds	r3, r7, r3
    5322:	3201      	adds	r2, #1
    5324:	701a      	strb	r2, [r3, #0]
    5326:	230f      	movs	r3, #15
    5328:	18fb      	adds	r3, r7, r3
    532a:	781b      	ldrb	r3, [r3, #0]
    532c:	2b00      	cmp	r3, #0
    532e:	d0e4      	beq.n	52fa <_get_sercom_index+0x22>
		}
	}

	ASSERT(false);
    5330:	4a06      	ldr	r2, [pc, #24]	; (534c <_get_sercom_index+0x74>)
    5332:	4b07      	ldr	r3, [pc, #28]	; (5350 <_get_sercom_index+0x78>)
    5334:	0019      	movs	r1, r3
    5336:	2000      	movs	r0, #0
    5338:	f7ff f812 	bl	4360 <assert>
	return 0;
    533c:	2300      	movs	r3, #0
}
    533e:	0018      	movs	r0, r3
    5340:	46bd      	mov	sp, r7
    5342:	b005      	add	sp, #20
    5344:	bd90      	pop	{r4, r7, pc}
    5346:	46c0      	nop			; (mov r8, r8)
    5348:	20000000 	.word	0x20000000
    534c:	0000022a 	.word	0x0000022a
    5350:	00008fbc 	.word	0x00008fbc

00005354 <_usart_init>:
 * \param[in] hw The pointer to hardware instance
 *
 * \return The status of initialization
 */
static int32_t _usart_init(void *const hw)
{
    5354:	b590      	push	{r4, r7, lr}
    5356:	b085      	sub	sp, #20
    5358:	af00      	add	r7, sp, #0
    535a:	6078      	str	r0, [r7, #4]
	uint8_t i = _get_sercom_index(hw);
    535c:	230f      	movs	r3, #15
    535e:	18fc      	adds	r4, r7, r3
    5360:	687b      	ldr	r3, [r7, #4]
    5362:	0018      	movs	r0, r3
    5364:	f7ff ffb8 	bl	52d8 <_get_sercom_index>
    5368:	0003      	movs	r3, r0
    536a:	7023      	strb	r3, [r4, #0]

	hri_sercomusart_wait_for_sync(hw);
    536c:	687b      	ldr	r3, [r7, #4]
    536e:	0018      	movs	r0, r3
    5370:	f7ff fc86 	bl	4c80 <hri_sercomusart_wait_for_sync>
	if (hri_sercomusart_get_CTRLA_reg(hw, SERCOM_USART_CTRLA_ENABLE)) {
    5374:	687b      	ldr	r3, [r7, #4]
    5376:	2102      	movs	r1, #2
    5378:	0018      	movs	r0, r3
    537a:	f7ff fda1 	bl	4ec0 <hri_sercomusart_get_CTRLA_reg>
    537e:	1e03      	subs	r3, r0, #0
    5380:	d008      	beq.n	5394 <_usart_init+0x40>
		hri_sercomusart_write_CTRLA_reg(hw, 0);
    5382:	687b      	ldr	r3, [r7, #4]
    5384:	2100      	movs	r1, #0
    5386:	0018      	movs	r0, r3
    5388:	f7ff fdaf 	bl	4eea <hri_sercomusart_write_CTRLA_reg>
		hri_sercomusart_wait_for_sync(hw);
    538c:	687b      	ldr	r3, [r7, #4]
    538e:	0018      	movs	r0, r3
    5390:	f7ff fc76 	bl	4c80 <hri_sercomusart_wait_for_sync>
	}
	hri_sercomusart_write_CTRLA_reg(hw, SERCOM_USART_CTRLA_SWRST);
    5394:	687b      	ldr	r3, [r7, #4]
    5396:	2101      	movs	r1, #1
    5398:	0018      	movs	r0, r3
    539a:	f7ff fda6 	bl	4eea <hri_sercomusart_write_CTRLA_reg>
	hri_sercomusart_wait_for_sync(hw);
    539e:	687b      	ldr	r3, [r7, #4]
    53a0:	0018      	movs	r0, r3
    53a2:	f7ff fc6d 	bl	4c80 <hri_sercomusart_wait_for_sync>

	hri_sercomusart_write_CTRLA_reg(hw, _usarts[i].ctrl_a);
    53a6:	230f      	movs	r3, #15
    53a8:	18fb      	adds	r3, r7, r3
    53aa:	781b      	ldrb	r3, [r3, #0]
    53ac:	4a1a      	ldr	r2, [pc, #104]	; (5418 <_usart_init+0xc4>)
    53ae:	011b      	lsls	r3, r3, #4
    53b0:	18d3      	adds	r3, r2, r3
    53b2:	3304      	adds	r3, #4
    53b4:	681a      	ldr	r2, [r3, #0]
    53b6:	687b      	ldr	r3, [r7, #4]
    53b8:	0011      	movs	r1, r2
    53ba:	0018      	movs	r0, r3
    53bc:	f7ff fd95 	bl	4eea <hri_sercomusart_write_CTRLA_reg>
	hri_sercomusart_write_CTRLB_reg(hw, _usarts[i].ctrl_b);
    53c0:	230f      	movs	r3, #15
    53c2:	18fb      	adds	r3, r7, r3
    53c4:	781b      	ldrb	r3, [r3, #0]
    53c6:	4a14      	ldr	r2, [pc, #80]	; (5418 <_usart_init+0xc4>)
    53c8:	011b      	lsls	r3, r3, #4
    53ca:	18d3      	adds	r3, r2, r3
    53cc:	3308      	adds	r3, #8
    53ce:	681a      	ldr	r2, [r3, #0]
    53d0:	687b      	ldr	r3, [r7, #4]
    53d2:	0011      	movs	r1, r2
    53d4:	0018      	movs	r0, r3
    53d6:	f7ff fe1a 	bl	500e <hri_sercomusart_write_CTRLB_reg>
	hri_sercomusart_write_BAUD_reg(hw, _usarts[i].baud);
    53da:	230f      	movs	r3, #15
    53dc:	18fb      	adds	r3, r7, r3
    53de:	781b      	ldrb	r3, [r3, #0]
    53e0:	4a0d      	ldr	r2, [pc, #52]	; (5418 <_usart_init+0xc4>)
    53e2:	011b      	lsls	r3, r3, #4
    53e4:	18d3      	adds	r3, r2, r3
    53e6:	330c      	adds	r3, #12
    53e8:	881a      	ldrh	r2, [r3, #0]
    53ea:	687b      	ldr	r3, [r7, #4]
    53ec:	0011      	movs	r1, r2
    53ee:	0018      	movs	r0, r3
    53f0:	f7ff fe59 	bl	50a6 <hri_sercomusart_write_BAUD_reg>
	hri_sercomusart_write_DBGCTRL_reg(hw, _usarts[i].debug_ctrl);
    53f4:	230f      	movs	r3, #15
    53f6:	18fb      	adds	r3, r7, r3
    53f8:	781b      	ldrb	r3, [r3, #0]
    53fa:	4a07      	ldr	r2, [pc, #28]	; (5418 <_usart_init+0xc4>)
    53fc:	011b      	lsls	r3, r3, #4
    53fe:	18d3      	adds	r3, r2, r3
    5400:	330e      	adds	r3, #14
    5402:	781a      	ldrb	r2, [r3, #0]
    5404:	687b      	ldr	r3, [r7, #4]
    5406:	0011      	movs	r1, r2
    5408:	0018      	movs	r0, r3
    540a:	f7ff fe1f 	bl	504c <hri_sercomusart_write_DBGCTRL_reg>

	return ERR_NONE;
    540e:	2300      	movs	r3, #0
}
    5410:	0018      	movs	r0, r3
    5412:	46bd      	mov	sp, r7
    5414:	b005      	add	sp, #20
    5416:	bd90      	pop	{r4, r7, pc}
    5418:	20000000 	.word	0x20000000

0000541c <_get_i2cm_index>:
 * \param[in] hw The pointer to hardware instance

 * \return The ordinal number of the given sercom hardware instance
 */
static uint8_t _get_i2cm_index(const void *const hw)
{
    541c:	b590      	push	{r4, r7, lr}
    541e:	b085      	sub	sp, #20
    5420:	af00      	add	r7, sp, #0
    5422:	6078      	str	r0, [r7, #4]
	uint8_t sercom_offset = _sercom_get_hardware_index(hw);
    5424:	230e      	movs	r3, #14
    5426:	18fc      	adds	r4, r7, r3
    5428:	687b      	ldr	r3, [r7, #4]
    542a:	0018      	movs	r0, r3
    542c:	f7ff ff44 	bl	52b8 <_sercom_get_hardware_index>
    5430:	0003      	movs	r3, r0
    5432:	7023      	strb	r3, [r4, #0]
	uint8_t i;

	for (i = 0; i < ARRAY_SIZE(_i2cms); i++) {
    5434:	230f      	movs	r3, #15
    5436:	18fb      	adds	r3, r7, r3
    5438:	2200      	movs	r2, #0
    543a:	701a      	strb	r2, [r3, #0]
    543c:	e018      	b.n	5470 <_get_i2cm_index+0x54>
		if (_i2cms[i].number == sercom_offset) {
    543e:	230f      	movs	r3, #15
    5440:	18fb      	adds	r3, r7, r3
    5442:	781a      	ldrb	r2, [r3, #0]
    5444:	4912      	ldr	r1, [pc, #72]	; (5490 <_get_i2cm_index+0x74>)
    5446:	0013      	movs	r3, r2
    5448:	005b      	lsls	r3, r3, #1
    544a:	189b      	adds	r3, r3, r2
    544c:	00db      	lsls	r3, r3, #3
    544e:	5c5b      	ldrb	r3, [r3, r1]
    5450:	220e      	movs	r2, #14
    5452:	18ba      	adds	r2, r7, r2
    5454:	7812      	ldrb	r2, [r2, #0]
    5456:	429a      	cmp	r2, r3
    5458:	d103      	bne.n	5462 <_get_i2cm_index+0x46>
			return i;
    545a:	230f      	movs	r3, #15
    545c:	18fb      	adds	r3, r7, r3
    545e:	781b      	ldrb	r3, [r3, #0]
    5460:	e012      	b.n	5488 <_get_i2cm_index+0x6c>
	for (i = 0; i < ARRAY_SIZE(_i2cms); i++) {
    5462:	230f      	movs	r3, #15
    5464:	18fb      	adds	r3, r7, r3
    5466:	781a      	ldrb	r2, [r3, #0]
    5468:	230f      	movs	r3, #15
    546a:	18fb      	adds	r3, r7, r3
    546c:	3201      	adds	r2, #1
    546e:	701a      	strb	r2, [r3, #0]
    5470:	230f      	movs	r3, #15
    5472:	18fb      	adds	r3, r7, r3
    5474:	781b      	ldrb	r3, [r3, #0]
    5476:	2b00      	cmp	r3, #0
    5478:	d0e1      	beq.n	543e <_get_i2cm_index+0x22>
		}
	}

	ASSERT(false);
    547a:	4a06      	ldr	r2, [pc, #24]	; (5494 <_get_i2cm_index+0x78>)
    547c:	4b06      	ldr	r3, [pc, #24]	; (5498 <_get_i2cm_index+0x7c>)
    547e:	0019      	movs	r1, r3
    5480:	2000      	movs	r0, #0
    5482:	f7fe ff6d 	bl	4360 <assert>
	return 0;
    5486:	2300      	movs	r3, #0
}
    5488:	0018      	movs	r0, r3
    548a:	46bd      	mov	sp, r7
    548c:	b005      	add	sp, #20
    548e:	bd90      	pop	{r4, r7, pc}
    5490:	20000010 	.word	0x20000010
    5494:	00000366 	.word	0x00000366
    5498:	00008fbc 	.word	0x00008fbc

0000549c <_sercom_i2c_send_stop>:

static inline void _sercom_i2c_send_stop(void *const hw)
{
    549c:	b580      	push	{r7, lr}
    549e:	b082      	sub	sp, #8
    54a0:	af00      	add	r7, sp, #0
    54a2:	6078      	str	r0, [r7, #4]
	hri_sercomi2cm_set_CTRLB_CMD_bf(hw, CMD_STOP);
    54a4:	687b      	ldr	r3, [r7, #4]
    54a6:	2103      	movs	r1, #3
    54a8:	0018      	movs	r0, r3
    54aa:	f7ff fd7d 	bl	4fa8 <hri_sercomi2cm_set_CTRLB_CMD_bf>
}
    54ae:	46c0      	nop			; (mov r8, r8)
    54b0:	46bd      	mov	sp, r7
    54b2:	b002      	add	sp, #8
    54b4:	bd80      	pop	{r7, pc}
	...

000054b8 <_sercom_i2c_sync_analyse_flags>:

/**
 * \brief SERCOM I2CM analyze hardware status and transfer next byte
 */
static inline int32_t _sercom_i2c_sync_analyse_flags(void *const hw, uint32_t flags, struct _i2c_m_msg *const msg)
{
    54b8:	b590      	push	{r4, r7, lr}
    54ba:	b087      	sub	sp, #28
    54bc:	af00      	add	r7, sp, #0
    54be:	60f8      	str	r0, [r7, #12]
    54c0:	60b9      	str	r1, [r7, #8]
    54c2:	607a      	str	r2, [r7, #4]
	uint16_t status = hri_sercomi2cm_read_STATUS_reg(hw);
    54c4:	2316      	movs	r3, #22
    54c6:	18fc      	adds	r4, r7, r3
    54c8:	68fb      	ldr	r3, [r7, #12]
    54ca:	0018      	movs	r0, r3
    54cc:	f7ff fe7b 	bl	51c6 <hri_sercomi2cm_read_STATUS_reg>
    54d0:	0003      	movs	r3, r0
    54d2:	8023      	strh	r3, [r4, #0]

	if (flags & MB_FLAG) {
    54d4:	68bb      	ldr	r3, [r7, #8]
    54d6:	2201      	movs	r2, #1
    54d8:	4013      	ands	r3, r2
    54da:	d100      	bne.n	54de <_sercom_i2c_sync_analyse_flags+0x26>
    54dc:	e079      	b.n	55d2 <_sercom_i2c_sync_analyse_flags+0x11a>
		/* tx error */
		if (status & SERCOM_I2CM_STATUS_ARBLOST) {
    54de:	2316      	movs	r3, #22
    54e0:	18fb      	adds	r3, r7, r3
    54e2:	881b      	ldrh	r3, [r3, #0]
    54e4:	2202      	movs	r2, #2
    54e6:	4013      	ands	r3, r2
    54e8:	d020      	beq.n	552c <_sercom_i2c_sync_analyse_flags+0x74>
			hri_sercomi2cm_clear_interrupt_MB_bit(hw);
    54ea:	68fb      	ldr	r3, [r7, #12]
    54ec:	0018      	movs	r0, r3
    54ee:	f7ff fbd7 	bl	4ca0 <hri_sercomi2cm_clear_interrupt_MB_bit>
			msg->flags |= I2C_M_FAIL;
    54f2:	687b      	ldr	r3, [r7, #4]
    54f4:	885b      	ldrh	r3, [r3, #2]
    54f6:	b29b      	uxth	r3, r3
    54f8:	2280      	movs	r2, #128	; 0x80
    54fa:	0152      	lsls	r2, r2, #5
    54fc:	4313      	orrs	r3, r2
    54fe:	b29a      	uxth	r2, r3
    5500:	687b      	ldr	r3, [r7, #4]
    5502:	805a      	strh	r2, [r3, #2]
			msg->flags &= ~I2C_M_BUSY;
    5504:	687b      	ldr	r3, [r7, #4]
    5506:	885b      	ldrh	r3, [r3, #2]
    5508:	b29b      	uxth	r3, r3
    550a:	4a5a      	ldr	r2, [pc, #360]	; (5674 <_sercom_i2c_sync_analyse_flags+0x1bc>)
    550c:	4013      	ands	r3, r2
    550e:	b29a      	uxth	r2, r3
    5510:	687b      	ldr	r3, [r7, #4]
    5512:	805a      	strh	r2, [r3, #2]

			if (status & SERCOM_I2CM_STATUS_BUSERR) {
    5514:	2316      	movs	r3, #22
    5516:	18fb      	adds	r3, r7, r3
    5518:	881b      	ldrh	r3, [r3, #0]
    551a:	2201      	movs	r2, #1
    551c:	4013      	ands	r3, r2
    551e:	d002      	beq.n	5526 <_sercom_i2c_sync_analyse_flags+0x6e>
				return I2C_ERR_BUS;
    5520:	2305      	movs	r3, #5
    5522:	425b      	negs	r3, r3
    5524:	e0a2      	b.n	566c <_sercom_i2c_sync_analyse_flags+0x1b4>
			}

			return I2C_ERR_BAD_ADDRESS;
    5526:	2304      	movs	r3, #4
    5528:	425b      	negs	r3, r3
    552a:	e09f      	b.n	566c <_sercom_i2c_sync_analyse_flags+0x1b4>
		} else {
			if (status & SERCOM_I2CM_STATUS_RXNACK) {
    552c:	2316      	movs	r3, #22
    552e:	18fb      	adds	r3, r7, r3
    5530:	881b      	ldrh	r3, [r3, #0]
    5532:	2204      	movs	r2, #4
    5534:	4013      	ands	r3, r2
    5536:	d021      	beq.n	557c <_sercom_i2c_sync_analyse_flags+0xc4>

				/* Slave rejects to receive more data */
				if (msg->len > 0) {
    5538:	687b      	ldr	r3, [r7, #4]
    553a:	685b      	ldr	r3, [r3, #4]
    553c:	2b00      	cmp	r3, #0
    553e:	dd08      	ble.n	5552 <_sercom_i2c_sync_analyse_flags+0x9a>
					msg->flags |= I2C_M_FAIL;
    5540:	687b      	ldr	r3, [r7, #4]
    5542:	885b      	ldrh	r3, [r3, #2]
    5544:	b29b      	uxth	r3, r3
    5546:	2280      	movs	r2, #128	; 0x80
    5548:	0152      	lsls	r2, r2, #5
    554a:	4313      	orrs	r3, r2
    554c:	b29a      	uxth	r2, r3
    554e:	687b      	ldr	r3, [r7, #4]
    5550:	805a      	strh	r2, [r3, #2]
				}

				if (msg->flags & I2C_M_STOP) {
    5552:	687b      	ldr	r3, [r7, #4]
    5554:	885b      	ldrh	r3, [r3, #2]
    5556:	b29b      	uxth	r3, r3
    5558:	b21b      	sxth	r3, r3
    555a:	2b00      	cmp	r3, #0
    555c:	da03      	bge.n	5566 <_sercom_i2c_sync_analyse_flags+0xae>
					_sercom_i2c_send_stop(hw);
    555e:	68fb      	ldr	r3, [r7, #12]
    5560:	0018      	movs	r0, r3
    5562:	f7ff ff9b 	bl	549c <_sercom_i2c_send_stop>
				}

				msg->flags &= ~I2C_M_BUSY;
    5566:	687b      	ldr	r3, [r7, #4]
    5568:	885b      	ldrh	r3, [r3, #2]
    556a:	b29b      	uxth	r3, r3
    556c:	4a41      	ldr	r2, [pc, #260]	; (5674 <_sercom_i2c_sync_analyse_flags+0x1bc>)
    556e:	4013      	ands	r3, r2
    5570:	b29a      	uxth	r2, r3
    5572:	687b      	ldr	r3, [r7, #4]
    5574:	805a      	strh	r2, [r3, #2]

				return I2C_NACK;
    5576:	2302      	movs	r3, #2
    5578:	425b      	negs	r3, r3
    557a:	e077      	b.n	566c <_sercom_i2c_sync_analyse_flags+0x1b4>
			}

			if (msg->len == 0) {
    557c:	687b      	ldr	r3, [r7, #4]
    557e:	685b      	ldr	r3, [r3, #4]
    5580:	2b00      	cmp	r3, #0
    5582:	d112      	bne.n	55aa <_sercom_i2c_sync_analyse_flags+0xf2>
				if (msg->flags & I2C_M_STOP) {
    5584:	687b      	ldr	r3, [r7, #4]
    5586:	885b      	ldrh	r3, [r3, #2]
    5588:	b29b      	uxth	r3, r3
    558a:	b21b      	sxth	r3, r3
    558c:	2b00      	cmp	r3, #0
    558e:	da03      	bge.n	5598 <_sercom_i2c_sync_analyse_flags+0xe0>
					_sercom_i2c_send_stop(hw);
    5590:	68fb      	ldr	r3, [r7, #12]
    5592:	0018      	movs	r0, r3
    5594:	f7ff ff82 	bl	549c <_sercom_i2c_send_stop>
				}

				msg->flags &= ~I2C_M_BUSY;
    5598:	687b      	ldr	r3, [r7, #4]
    559a:	885b      	ldrh	r3, [r3, #2]
    559c:	b29b      	uxth	r3, r3
    559e:	4a35      	ldr	r2, [pc, #212]	; (5674 <_sercom_i2c_sync_analyse_flags+0x1bc>)
    55a0:	4013      	ands	r3, r2
    55a2:	b29a      	uxth	r2, r3
    55a4:	687b      	ldr	r3, [r7, #4]
    55a6:	805a      	strh	r2, [r3, #2]
    55a8:	e011      	b.n	55ce <_sercom_i2c_sync_analyse_flags+0x116>
			} else {
				hri_sercomi2cm_write_DATA_reg(hw, *msg->buffer);
    55aa:	687b      	ldr	r3, [r7, #4]
    55ac:	689b      	ldr	r3, [r3, #8]
    55ae:	781a      	ldrb	r2, [r3, #0]
    55b0:	68fb      	ldr	r3, [r7, #12]
    55b2:	0011      	movs	r1, r2
    55b4:	0018      	movs	r0, r3
    55b6:	f7ff fda4 	bl	5102 <hri_sercomi2cm_write_DATA_reg>
				msg->buffer++;
    55ba:	687b      	ldr	r3, [r7, #4]
    55bc:	689b      	ldr	r3, [r3, #8]
    55be:	1c5a      	adds	r2, r3, #1
    55c0:	687b      	ldr	r3, [r7, #4]
    55c2:	609a      	str	r2, [r3, #8]
				msg->len--;
    55c4:	687b      	ldr	r3, [r7, #4]
    55c6:	685b      	ldr	r3, [r3, #4]
    55c8:	1e5a      	subs	r2, r3, #1
    55ca:	687b      	ldr	r3, [r7, #4]
    55cc:	605a      	str	r2, [r3, #4]
			}

			return I2C_OK;
    55ce:	2300      	movs	r3, #0
    55d0:	e04c      	b.n	566c <_sercom_i2c_sync_analyse_flags+0x1b4>
		}
	} else if (flags & SB_FLAG) {
    55d2:	68bb      	ldr	r3, [r7, #8]
    55d4:	2202      	movs	r2, #2
    55d6:	4013      	ands	r3, r2
    55d8:	d047      	beq.n	566a <_sercom_i2c_sync_analyse_flags+0x1b2>
		if ((msg->len) && !(status & SERCOM_I2CM_STATUS_RXNACK)) {
    55da:	687b      	ldr	r3, [r7, #4]
    55dc:	685b      	ldr	r3, [r3, #4]
    55de:	2b00      	cmp	r3, #0
    55e0:	d03c      	beq.n	565c <_sercom_i2c_sync_analyse_flags+0x1a4>
    55e2:	2316      	movs	r3, #22
    55e4:	18fb      	adds	r3, r7, r3
    55e6:	881b      	ldrh	r3, [r3, #0]
    55e8:	2204      	movs	r2, #4
    55ea:	4013      	ands	r3, r2
    55ec:	d136      	bne.n	565c <_sercom_i2c_sync_analyse_flags+0x1a4>
			msg->len--;
    55ee:	687b      	ldr	r3, [r7, #4]
    55f0:	685b      	ldr	r3, [r3, #4]
    55f2:	1e5a      	subs	r2, r3, #1
    55f4:	687b      	ldr	r3, [r7, #4]
    55f6:	605a      	str	r2, [r3, #4]

			/* last byte, send nack */
			if (msg->len == 0) {
    55f8:	687b      	ldr	r3, [r7, #4]
    55fa:	685b      	ldr	r3, [r3, #4]
    55fc:	2b00      	cmp	r3, #0
    55fe:	d103      	bne.n	5608 <_sercom_i2c_sync_analyse_flags+0x150>
				hri_sercomi2cm_set_CTRLB_ACKACT_bit(hw);
    5600:	68fb      	ldr	r3, [r7, #12]
    5602:	0018      	movs	r0, r3
    5604:	f7ff fca8 	bl	4f58 <hri_sercomi2cm_set_CTRLB_ACKACT_bit>
			}

			if (msg->len == 0) {
    5608:	687b      	ldr	r3, [r7, #4]
    560a:	685b      	ldr	r3, [r3, #4]
    560c:	2b00      	cmp	r3, #0
    560e:	d115      	bne.n	563c <_sercom_i2c_sync_analyse_flags+0x184>
				if (msg->flags & I2C_M_STOP) {
    5610:	687b      	ldr	r3, [r7, #4]
    5612:	885b      	ldrh	r3, [r3, #2]
    5614:	b29b      	uxth	r3, r3
    5616:	b21b      	sxth	r3, r3
    5618:	2b00      	cmp	r3, #0
    561a:	da07      	bge.n	562c <_sercom_i2c_sync_analyse_flags+0x174>
					hri_sercomi2cm_clear_CTRLB_SMEN_bit(hw);
    561c:	68fb      	ldr	r3, [r7, #12]
    561e:	0018      	movs	r0, r3
    5620:	f7ff fc86 	bl	4f30 <hri_sercomi2cm_clear_CTRLB_SMEN_bit>
					_sercom_i2c_send_stop(hw);
    5624:	68fb      	ldr	r3, [r7, #12]
    5626:	0018      	movs	r0, r3
    5628:	f7ff ff38 	bl	549c <_sercom_i2c_send_stop>
				}

				msg->flags &= ~I2C_M_BUSY;
    562c:	687b      	ldr	r3, [r7, #4]
    562e:	885b      	ldrh	r3, [r3, #2]
    5630:	b29b      	uxth	r3, r3
    5632:	4a10      	ldr	r2, [pc, #64]	; (5674 <_sercom_i2c_sync_analyse_flags+0x1bc>)
    5634:	4013      	ands	r3, r2
    5636:	b29a      	uxth	r2, r3
    5638:	687b      	ldr	r3, [r7, #4]
    563a:	805a      	strh	r2, [r3, #2]

			/* Accessing DATA.DATA auto-triggers I2C bus operations.
			 * The operation performed depends on the state of
			 * CTRLB.ACKACT, CTRLB.SMEN
			 **/
			*msg->buffer++ = hri_sercomi2cm_read_DATA_reg(hw);
    563c:	687b      	ldr	r3, [r7, #4]
    563e:	689c      	ldr	r4, [r3, #8]
    5640:	1c62      	adds	r2, r4, #1
    5642:	687b      	ldr	r3, [r7, #4]
    5644:	609a      	str	r2, [r3, #8]
    5646:	68fb      	ldr	r3, [r7, #12]
    5648:	0018      	movs	r0, r3
    564a:	f7ff fd69 	bl	5120 <hri_sercomi2cm_read_DATA_reg>
    564e:	0003      	movs	r3, r0
    5650:	7023      	strb	r3, [r4, #0]
		} else {
			hri_sercomi2cm_clear_interrupt_SB_bit(hw);
			return I2C_NACK;
		}

		hri_sercomi2cm_clear_interrupt_SB_bit(hw);
    5652:	68fb      	ldr	r3, [r7, #12]
    5654:	0018      	movs	r0, r3
    5656:	f7ff fb2e 	bl	4cb6 <hri_sercomi2cm_clear_interrupt_SB_bit>
    565a:	e006      	b.n	566a <_sercom_i2c_sync_analyse_flags+0x1b2>
			hri_sercomi2cm_clear_interrupt_SB_bit(hw);
    565c:	68fb      	ldr	r3, [r7, #12]
    565e:	0018      	movs	r0, r3
    5660:	f7ff fb29 	bl	4cb6 <hri_sercomi2cm_clear_interrupt_SB_bit>
			return I2C_NACK;
    5664:	2302      	movs	r3, #2
    5666:	425b      	negs	r3, r3
    5668:	e000      	b.n	566c <_sercom_i2c_sync_analyse_flags+0x1b4>
	}

	return I2C_OK;
    566a:	2300      	movs	r3, #0
}
    566c:	0018      	movs	r0, r3
    566e:	46bd      	mov	sp, r7
    5670:	b007      	add	sp, #28
    5672:	bd90      	pop	{r4, r7, pc}
    5674:	fffffeff 	.word	0xfffffeff

00005678 <_i2c_m_sync_init>:
 * \brief Initialize sercom i2c module to use in sync mode
 *
 * \param[in] i2c_dev The pointer to i2c device
 */
int32_t _i2c_m_sync_init(struct _i2c_m_sync_device *const i2c_dev, void *const hw)
{
    5678:	b590      	push	{r4, r7, lr}
    567a:	b085      	sub	sp, #20
    567c:	af00      	add	r7, sp, #0
    567e:	6078      	str	r0, [r7, #4]
    5680:	6039      	str	r1, [r7, #0]
	uint8_t i = _get_i2cm_index(hw);
    5682:	230f      	movs	r3, #15
    5684:	18fc      	adds	r4, r7, r3
    5686:	683b      	ldr	r3, [r7, #0]
    5688:	0018      	movs	r0, r3
    568a:	f7ff fec7 	bl	541c <_get_i2cm_index>
    568e:	0003      	movs	r3, r0
    5690:	7023      	strb	r3, [r4, #0]

	ASSERT(i2c_dev);
    5692:	687b      	ldr	r3, [r7, #4]
    5694:	1e5a      	subs	r2, r3, #1
    5696:	4193      	sbcs	r3, r2
    5698:	b2db      	uxtb	r3, r3
    569a:	4a35      	ldr	r2, [pc, #212]	; (5770 <_i2c_m_sync_init+0xf8>)
    569c:	4935      	ldr	r1, [pc, #212]	; (5774 <_i2c_m_sync_init+0xfc>)
    569e:	0018      	movs	r0, r3
    56a0:	f7fe fe5e 	bl	4360 <assert>

	i2c_dev->hw = hw;
    56a4:	687b      	ldr	r3, [r7, #4]
    56a6:	683a      	ldr	r2, [r7, #0]
    56a8:	611a      	str	r2, [r3, #16]

	hri_sercomi2cm_wait_for_sync(hw);
    56aa:	683b      	ldr	r3, [r7, #0]
    56ac:	0018      	movs	r0, r3
    56ae:	f7ff fab7 	bl	4c20 <hri_sercomi2cm_wait_for_sync>
	if (hri_sercomi2cm_get_CTRLA_reg(hw, SERCOM_I2CM_CTRLA_ENABLE)) {
    56b2:	683b      	ldr	r3, [r7, #0]
    56b4:	2102      	movs	r1, #2
    56b6:	0018      	movs	r0, r3
    56b8:	f7ff fb8e 	bl	4dd8 <hri_sercomi2cm_get_CTRLA_reg>
    56bc:	1e03      	subs	r3, r0, #0
    56be:	d008      	beq.n	56d2 <_i2c_m_sync_init+0x5a>
		hri_sercomi2cm_write_CTRLA_reg(hw, 0);
    56c0:	683b      	ldr	r3, [r7, #0]
    56c2:	2100      	movs	r1, #0
    56c4:	0018      	movs	r0, r3
    56c6:	f7ff fb9c 	bl	4e02 <hri_sercomi2cm_write_CTRLA_reg>
		hri_sercomi2cm_wait_for_sync(hw);
    56ca:	683b      	ldr	r3, [r7, #0]
    56cc:	0018      	movs	r0, r3
    56ce:	f7ff faa7 	bl	4c20 <hri_sercomi2cm_wait_for_sync>
	}
	hri_sercomi2cm_write_CTRLA_reg(hw, SERCOM_I2CM_CTRLA_SWRST);
    56d2:	683b      	ldr	r3, [r7, #0]
    56d4:	2101      	movs	r1, #1
    56d6:	0018      	movs	r0, r3
    56d8:	f7ff fb93 	bl	4e02 <hri_sercomi2cm_write_CTRLA_reg>
	hri_sercomi2cm_wait_for_sync(hw);
    56dc:	683b      	ldr	r3, [r7, #0]
    56de:	0018      	movs	r0, r3
    56e0:	f7ff fa9e 	bl	4c20 <hri_sercomi2cm_wait_for_sync>

	hri_sercomi2cm_write_CTRLA_reg(hw, _i2cms[i].ctrl_a & ~SERCOM_I2CM_CTRLA_ENABLE);
    56e4:	230f      	movs	r3, #15
    56e6:	18fb      	adds	r3, r7, r3
    56e8:	781a      	ldrb	r2, [r3, #0]
    56ea:	4923      	ldr	r1, [pc, #140]	; (5778 <_i2c_m_sync_init+0x100>)
    56ec:	0013      	movs	r3, r2
    56ee:	005b      	lsls	r3, r3, #1
    56f0:	189b      	adds	r3, r3, r2
    56f2:	00db      	lsls	r3, r3, #3
    56f4:	18cb      	adds	r3, r1, r3
    56f6:	3304      	adds	r3, #4
    56f8:	681b      	ldr	r3, [r3, #0]
    56fa:	2202      	movs	r2, #2
    56fc:	4393      	bics	r3, r2
    56fe:	001a      	movs	r2, r3
    5700:	683b      	ldr	r3, [r7, #0]
    5702:	0011      	movs	r1, r2
    5704:	0018      	movs	r0, r3
    5706:	f7ff fb7c 	bl	4e02 <hri_sercomi2cm_write_CTRLA_reg>
	hri_sercomi2cm_write_CTRLB_reg(hw, _i2cms[i].ctrl_b);
    570a:	230f      	movs	r3, #15
    570c:	18fb      	adds	r3, r7, r3
    570e:	781a      	ldrb	r2, [r3, #0]
    5710:	4919      	ldr	r1, [pc, #100]	; (5778 <_i2c_m_sync_init+0x100>)
    5712:	0013      	movs	r3, r2
    5714:	005b      	lsls	r3, r3, #1
    5716:	189b      	adds	r3, r3, r2
    5718:	00db      	lsls	r3, r3, #3
    571a:	18cb      	adds	r3, r1, r3
    571c:	3308      	adds	r3, #8
    571e:	681a      	ldr	r2, [r3, #0]
    5720:	683b      	ldr	r3, [r7, #0]
    5722:	0011      	movs	r1, r2
    5724:	0018      	movs	r0, r3
    5726:	f7ff fc56 	bl	4fd6 <hri_sercomi2cm_write_CTRLB_reg>
	hri_sercomi2cm_write_BAUD_reg(hw, _i2cms[i].baud);
    572a:	230f      	movs	r3, #15
    572c:	18fb      	adds	r3, r7, r3
    572e:	781a      	ldrb	r2, [r3, #0]
    5730:	4911      	ldr	r1, [pc, #68]	; (5778 <_i2c_m_sync_init+0x100>)
    5732:	0013      	movs	r3, r2
    5734:	005b      	lsls	r3, r3, #1
    5736:	189b      	adds	r3, r3, r2
    5738:	00db      	lsls	r3, r3, #3
    573a:	18cb      	adds	r3, r1, r3
    573c:	330c      	adds	r3, #12
    573e:	881a      	ldrh	r2, [r3, #0]
    5740:	683b      	ldr	r3, [r7, #0]
    5742:	0011      	movs	r1, r2
    5744:	0018      	movs	r0, r3
    5746:	f7ff fc90 	bl	506a <hri_sercomi2cm_write_BAUD_reg>

	i2c_dev->service.trise = _i2cms[i].trise;
    574a:	230f      	movs	r3, #15
    574c:	18fb      	adds	r3, r7, r3
    574e:	781a      	ldrb	r2, [r3, #0]
    5750:	4909      	ldr	r1, [pc, #36]	; (5778 <_i2c_m_sync_init+0x100>)
    5752:	0013      	movs	r3, r2
    5754:	005b      	lsls	r3, r3, #1
    5756:	189b      	adds	r3, r3, r2
    5758:	00db      	lsls	r3, r3, #3
    575a:	18cb      	adds	r3, r1, r3
    575c:	3310      	adds	r3, #16
    575e:	881a      	ldrh	r2, [r3, #0]
    5760:	687b      	ldr	r3, [r7, #4]
    5762:	81da      	strh	r2, [r3, #14]

	return ERR_NONE;
    5764:	2300      	movs	r3, #0
}
    5766:	0018      	movs	r0, r3
    5768:	46bd      	mov	sp, r7
    576a:	b005      	add	sp, #20
    576c:	bd90      	pop	{r4, r7, pc}
    576e:	46c0      	nop			; (mov r8, r8)
    5770:	000004d7 	.word	0x000004d7
    5774:	00008fbc 	.word	0x00008fbc
    5778:	20000010 	.word	0x20000010

0000577c <_i2c_m_sync_enable>:
 * \brief Enable the i2c master module
 *
 * \param[in] i2c_dev The pointer to i2c device
 */
int32_t _i2c_m_sync_enable(struct _i2c_m_sync_device *const i2c_dev)
{
    577c:	b580      	push	{r7, lr}
    577e:	b086      	sub	sp, #24
    5780:	af00      	add	r7, sp, #0
    5782:	6078      	str	r0, [r7, #4]
	int   timeout         = 65535;
    5784:	4b20      	ldr	r3, [pc, #128]	; (5808 <_i2c_m_sync_enable+0x8c>)
    5786:	617b      	str	r3, [r7, #20]
	int   timeout_attempt = 4;
    5788:	2304      	movs	r3, #4
    578a:	613b      	str	r3, [r7, #16]
	void *hw              = i2c_dev->hw;
    578c:	687b      	ldr	r3, [r7, #4]
    578e:	691b      	ldr	r3, [r3, #16]
    5790:	60fb      	str	r3, [r7, #12]

	ASSERT(i2c_dev);
    5792:	687b      	ldr	r3, [r7, #4]
    5794:	1e5a      	subs	r2, r3, #1
    5796:	4193      	sbcs	r3, r2
    5798:	b2d8      	uxtb	r0, r3
    579a:	23a1      	movs	r3, #161	; 0xa1
    579c:	00da      	lsls	r2, r3, #3
    579e:	4b1b      	ldr	r3, [pc, #108]	; (580c <_i2c_m_sync_enable+0x90>)
    57a0:	0019      	movs	r1, r3
    57a2:	f7fe fddd 	bl	4360 <assert>
	ASSERT(i2c_dev->hw);
    57a6:	687b      	ldr	r3, [r7, #4]
    57a8:	691b      	ldr	r3, [r3, #16]
    57aa:	1e5a      	subs	r2, r3, #1
    57ac:	4193      	sbcs	r3, r2
    57ae:	b2db      	uxtb	r3, r3
    57b0:	4a17      	ldr	r2, [pc, #92]	; (5810 <_i2c_m_sync_enable+0x94>)
    57b2:	4916      	ldr	r1, [pc, #88]	; (580c <_i2c_m_sync_enable+0x90>)
    57b4:	0018      	movs	r0, r3
    57b6:	f7fe fdd3 	bl	4360 <assert>

	hri_sercomi2cm_set_CTRLA_ENABLE_bit(hw);
    57ba:	68fb      	ldr	r3, [r7, #12]
    57bc:	0018      	movs	r0, r3
    57be:	f7ff faf9 	bl	4db4 <hri_sercomi2cm_set_CTRLA_ENABLE_bit>

	while (hri_sercomi2cm_read_STATUS_BUSSTATE_bf(hw) != I2C_IDLE) {
    57c2:	e014      	b.n	57ee <_i2c_m_sync_enable+0x72>
		timeout--;
    57c4:	697b      	ldr	r3, [r7, #20]
    57c6:	3b01      	subs	r3, #1
    57c8:	617b      	str	r3, [r7, #20]

		if (timeout <= 0) {
    57ca:	697b      	ldr	r3, [r7, #20]
    57cc:	2b00      	cmp	r3, #0
    57ce:	dc0e      	bgt.n	57ee <_i2c_m_sync_enable+0x72>
			if (--timeout_attempt)
    57d0:	693b      	ldr	r3, [r7, #16]
    57d2:	3b01      	subs	r3, #1
    57d4:	613b      	str	r3, [r7, #16]
    57d6:	693b      	ldr	r3, [r7, #16]
    57d8:	2b00      	cmp	r3, #0
    57da:	d005      	beq.n	57e8 <_i2c_m_sync_enable+0x6c>
				timeout = 65535;
    57dc:	4b0a      	ldr	r3, [pc, #40]	; (5808 <_i2c_m_sync_enable+0x8c>)
    57de:	617b      	str	r3, [r7, #20]
			else
				return I2C_ERR_BUSY;
			((Sercom *)hw)->I2CM.STATUS.reg = SERCOM_I2CM_STATUS_BUSSTATE(I2C_IDLE);
    57e0:	68fb      	ldr	r3, [r7, #12]
    57e2:	2210      	movs	r2, #16
    57e4:	821a      	strh	r2, [r3, #16]
    57e6:	e002      	b.n	57ee <_i2c_m_sync_enable+0x72>
				return I2C_ERR_BUSY;
    57e8:	2306      	movs	r3, #6
    57ea:	425b      	negs	r3, r3
    57ec:	e007      	b.n	57fe <_i2c_m_sync_enable+0x82>
	while (hri_sercomi2cm_read_STATUS_BUSSTATE_bf(hw) != I2C_IDLE) {
    57ee:	68fb      	ldr	r3, [r7, #12]
    57f0:	0018      	movs	r0, r3
    57f2:	f7ff fcd4 	bl	519e <hri_sercomi2cm_read_STATUS_BUSSTATE_bf>
    57f6:	0003      	movs	r3, r0
    57f8:	2b01      	cmp	r3, #1
    57fa:	d1e3      	bne.n	57c4 <_i2c_m_sync_enable+0x48>
		}
	}

	return ERR_NONE;
    57fc:	2300      	movs	r3, #0
}
    57fe:	0018      	movs	r0, r3
    5800:	46bd      	mov	sp, r7
    5802:	b006      	add	sp, #24
    5804:	bd80      	pop	{r7, pc}
    5806:	46c0      	nop			; (mov r8, r8)
    5808:	0000ffff 	.word	0x0000ffff
    580c:	00008fbc 	.word	0x00008fbc
    5810:	00000509 	.word	0x00000509

00005814 <_sercom_i2c_sync_wait_bus>:
 * \return Bus response status.
 * \retval 0 Bus response status OK
 * \retval <0 Bus response fail
 */
inline static int32_t _sercom_i2c_sync_wait_bus(struct _i2c_m_sync_device *const i2c_dev, uint32_t *flags)
{
    5814:	b580      	push	{r7, lr}
    5816:	b084      	sub	sp, #16
    5818:	af00      	add	r7, sp, #0
    581a:	6078      	str	r0, [r7, #4]
    581c:	6039      	str	r1, [r7, #0]
	uint32_t timeout = 65535;
    581e:	4b12      	ldr	r3, [pc, #72]	; (5868 <_sercom_i2c_sync_wait_bus+0x54>)
    5820:	60fb      	str	r3, [r7, #12]
	void *   hw      = i2c_dev->hw;
    5822:	687b      	ldr	r3, [r7, #4]
    5824:	691b      	ldr	r3, [r3, #16]
    5826:	60bb      	str	r3, [r7, #8]

	do {
		*flags = hri_sercomi2cm_read_INTFLAG_reg(hw);
    5828:	68bb      	ldr	r3, [r7, #8]
    582a:	0018      	movs	r0, r3
    582c:	f7ff fa4e 	bl	4ccc <hri_sercomi2cm_read_INTFLAG_reg>
    5830:	0003      	movs	r3, r0
    5832:	001a      	movs	r2, r3
    5834:	683b      	ldr	r3, [r7, #0]
    5836:	601a      	str	r2, [r3, #0]

		if (timeout-- == 0) {
    5838:	68fb      	ldr	r3, [r7, #12]
    583a:	1e5a      	subs	r2, r3, #1
    583c:	60fa      	str	r2, [r7, #12]
    583e:	2b00      	cmp	r3, #0
    5840:	d102      	bne.n	5848 <_sercom_i2c_sync_wait_bus+0x34>
			return I2C_ERR_BUS;
    5842:	2305      	movs	r3, #5
    5844:	425b      	negs	r3, r3
    5846:	e00a      	b.n	585e <_sercom_i2c_sync_wait_bus+0x4a>
		}
	} while (!(*flags & MB_FLAG) && !(*flags & SB_FLAG));
    5848:	683b      	ldr	r3, [r7, #0]
    584a:	681b      	ldr	r3, [r3, #0]
    584c:	2201      	movs	r2, #1
    584e:	4013      	ands	r3, r2
    5850:	d104      	bne.n	585c <_sercom_i2c_sync_wait_bus+0x48>
    5852:	683b      	ldr	r3, [r7, #0]
    5854:	681b      	ldr	r3, [r3, #0]
    5856:	2202      	movs	r2, #2
    5858:	4013      	ands	r3, r2
    585a:	d0e5      	beq.n	5828 <_sercom_i2c_sync_wait_bus+0x14>

	return I2C_OK;
    585c:	2300      	movs	r3, #0
}
    585e:	0018      	movs	r0, r3
    5860:	46bd      	mov	sp, r7
    5862:	b004      	add	sp, #16
    5864:	bd80      	pop	{r7, pc}
    5866:	46c0      	nop			; (mov r8, r8)
    5868:	0000ffff 	.word	0x0000ffff

0000586c <_sercom_i2c_sync_send_address>:
 * \brief Send the slave address to bus, which will start the transfer
 *
 * \param[in] i2c_dev The pointer to i2c device
 */
static int32_t _sercom_i2c_sync_send_address(struct _i2c_m_sync_device *const i2c_dev)
{
    586c:	b580      	push	{r7, lr}
    586e:	b086      	sub	sp, #24
    5870:	af00      	add	r7, sp, #0
    5872:	6078      	str	r0, [r7, #4]
	void *             hw  = i2c_dev->hw;
    5874:	687b      	ldr	r3, [r7, #4]
    5876:	691b      	ldr	r3, [r3, #16]
    5878:	617b      	str	r3, [r7, #20]
	struct _i2c_m_msg *msg = &i2c_dev->service.msg;
    587a:	687b      	ldr	r3, [r7, #4]
    587c:	613b      	str	r3, [r7, #16]
	uint32_t           flags;

	ASSERT(i2c_dev);
    587e:	687b      	ldr	r3, [r7, #4]
    5880:	1e5a      	subs	r2, r3, #1
    5882:	4193      	sbcs	r3, r2
    5884:	b2db      	uxtb	r3, r3
    5886:	4a18      	ldr	r2, [pc, #96]	; (58e8 <_sercom_i2c_sync_send_address+0x7c>)
    5888:	4918      	ldr	r1, [pc, #96]	; (58ec <_sercom_i2c_sync_send_address+0x80>)
    588a:	0018      	movs	r0, r3
    588c:	f7fe fd68 	bl	4360 <assert>

	hri_sercomi2cm_clear_CTRLB_ACKACT_bit(hw);
    5890:	697b      	ldr	r3, [r7, #20]
    5892:	0018      	movs	r0, r3
    5894:	f7ff fb74 	bl	4f80 <hri_sercomi2cm_clear_CTRLB_ACKACT_bit>

	hri_sercomi2cm_write_ADDR_reg(hw, ((msg->addr & SEVEN_ADDR_MASK) << 1) | (msg->flags & I2C_M_RD ? I2C_M_RD : 0x0));
    5898:	693b      	ldr	r3, [r7, #16]
    589a:	881b      	ldrh	r3, [r3, #0]
    589c:	005b      	lsls	r3, r3, #1
    589e:	b25a      	sxtb	r2, r3
    58a0:	693b      	ldr	r3, [r7, #16]
    58a2:	885b      	ldrh	r3, [r3, #2]
    58a4:	b29b      	uxth	r3, r3
    58a6:	0019      	movs	r1, r3
    58a8:	2301      	movs	r3, #1
    58aa:	400b      	ands	r3, r1
    58ac:	1e59      	subs	r1, r3, #1
    58ae:	418b      	sbcs	r3, r1
    58b0:	b2db      	uxtb	r3, r3
    58b2:	b25b      	sxtb	r3, r3
    58b4:	4313      	orrs	r3, r2
    58b6:	b25b      	sxtb	r3, r3
    58b8:	b2da      	uxtb	r2, r3
    58ba:	697b      	ldr	r3, [r7, #20]
    58bc:	0011      	movs	r1, r2
    58be:	0018      	movs	r0, r3
    58c0:	f7ff fc00 	bl	50c4 <hri_sercomi2cm_write_ADDR_reg>

	_sercom_i2c_sync_wait_bus(i2c_dev, &flags);
    58c4:	230c      	movs	r3, #12
    58c6:	18fa      	adds	r2, r7, r3
    58c8:	687b      	ldr	r3, [r7, #4]
    58ca:	0011      	movs	r1, r2
    58cc:	0018      	movs	r0, r3
    58ce:	f7ff ffa1 	bl	5814 <_sercom_i2c_sync_wait_bus>
	return _sercom_i2c_sync_analyse_flags(hw, flags, msg);
    58d2:	68f9      	ldr	r1, [r7, #12]
    58d4:	693a      	ldr	r2, [r7, #16]
    58d6:	697b      	ldr	r3, [r7, #20]
    58d8:	0018      	movs	r0, r3
    58da:	f7ff fded 	bl	54b8 <_sercom_i2c_sync_analyse_flags>
    58de:	0003      	movs	r3, r0
}
    58e0:	0018      	movs	r0, r3
    58e2:	46bd      	mov	sp, r7
    58e4:	b006      	add	sp, #24
    58e6:	bd80      	pop	{r7, pc}
    58e8:	00000581 	.word	0x00000581
    58ec:	00008fbc 	.word	0x00008fbc

000058f0 <_i2c_m_sync_transfer>:
 * \return Transfer status.
 * \retval 0 Transfer success
 * \retval <0 Transfer fail or partial fail, return the error code
 */
int32_t _i2c_m_sync_transfer(struct _i2c_m_sync_device *const i2c_dev, struct _i2c_m_msg *msg)
{
    58f0:	b590      	push	{r4, r7, lr}
    58f2:	b087      	sub	sp, #28
    58f4:	af00      	add	r7, sp, #0
    58f6:	6078      	str	r0, [r7, #4]
    58f8:	6039      	str	r1, [r7, #0]
	uint32_t flags;
	int      ret;
	void *   hw = i2c_dev->hw;
    58fa:	687b      	ldr	r3, [r7, #4]
    58fc:	691b      	ldr	r3, [r3, #16]
    58fe:	613b      	str	r3, [r7, #16]

	ASSERT(i2c_dev);
    5900:	687b      	ldr	r3, [r7, #4]
    5902:	1e5a      	subs	r2, r3, #1
    5904:	4193      	sbcs	r3, r2
    5906:	b2db      	uxtb	r3, r3
    5908:	4a3d      	ldr	r2, [pc, #244]	; (5a00 <_i2c_m_sync_transfer+0x110>)
    590a:	493e      	ldr	r1, [pc, #248]	; (5a04 <_i2c_m_sync_transfer+0x114>)
    590c:	0018      	movs	r0, r3
    590e:	f7fe fd27 	bl	4360 <assert>
	ASSERT(i2c_dev->hw);
    5912:	687b      	ldr	r3, [r7, #4]
    5914:	691b      	ldr	r3, [r3, #16]
    5916:	1e5a      	subs	r2, r3, #1
    5918:	4193      	sbcs	r3, r2
    591a:	b2db      	uxtb	r3, r3
    591c:	4a3a      	ldr	r2, [pc, #232]	; (5a08 <_i2c_m_sync_transfer+0x118>)
    591e:	4939      	ldr	r1, [pc, #228]	; (5a04 <_i2c_m_sync_transfer+0x114>)
    5920:	0018      	movs	r0, r3
    5922:	f7fe fd1d 	bl	4360 <assert>
	ASSERT(msg);
    5926:	683b      	ldr	r3, [r7, #0]
    5928:	1e5a      	subs	r2, r3, #1
    592a:	4193      	sbcs	r3, r2
    592c:	b2db      	uxtb	r3, r3
    592e:	4a37      	ldr	r2, [pc, #220]	; (5a0c <_i2c_m_sync_transfer+0x11c>)
    5930:	4934      	ldr	r1, [pc, #208]	; (5a04 <_i2c_m_sync_transfer+0x114>)
    5932:	0018      	movs	r0, r3
    5934:	f7fe fd14 	bl	4360 <assert>

	if (i2c_dev->service.msg.flags & I2C_M_BUSY) {
    5938:	687b      	ldr	r3, [r7, #4]
    593a:	885b      	ldrh	r3, [r3, #2]
    593c:	b29b      	uxth	r3, r3
    593e:	001a      	movs	r2, r3
    5940:	2380      	movs	r3, #128	; 0x80
    5942:	005b      	lsls	r3, r3, #1
    5944:	4013      	ands	r3, r2
    5946:	d002      	beq.n	594e <_i2c_m_sync_transfer+0x5e>
		return I2C_ERR_BUSY;
    5948:	2306      	movs	r3, #6
    594a:	425b      	negs	r3, r3
    594c:	e054      	b.n	59f8 <_i2c_m_sync_transfer+0x108>
	}

	msg->flags |= I2C_M_BUSY;
    594e:	683b      	ldr	r3, [r7, #0]
    5950:	885b      	ldrh	r3, [r3, #2]
    5952:	b29b      	uxth	r3, r3
    5954:	2280      	movs	r2, #128	; 0x80
    5956:	0052      	lsls	r2, r2, #1
    5958:	4313      	orrs	r3, r2
    595a:	b29a      	uxth	r2, r3
    595c:	683b      	ldr	r3, [r7, #0]
    595e:	805a      	strh	r2, [r3, #2]
	i2c_dev->service.msg = *msg;
    5960:	687b      	ldr	r3, [r7, #4]
    5962:	683a      	ldr	r2, [r7, #0]
    5964:	ca13      	ldmia	r2!, {r0, r1, r4}
    5966:	c313      	stmia	r3!, {r0, r1, r4}
	hri_sercomi2cm_set_CTRLB_SMEN_bit(hw);
    5968:	693b      	ldr	r3, [r7, #16]
    596a:	0018      	movs	r0, r3
    596c:	f7ff facd 	bl	4f0a <hri_sercomi2cm_set_CTRLB_SMEN_bit>

	ret = _sercom_i2c_sync_send_address(i2c_dev);
    5970:	687b      	ldr	r3, [r7, #4]
    5972:	0018      	movs	r0, r3
    5974:	f7ff ff7a 	bl	586c <_sercom_i2c_sync_send_address>
    5978:	0003      	movs	r3, r0
    597a:	617b      	str	r3, [r7, #20]

	if (ret) {
    597c:	697b      	ldr	r3, [r7, #20]
    597e:	2b00      	cmp	r3, #0
    5980:	d031      	beq.n	59e6 <_i2c_m_sync_transfer+0xf6>
		i2c_dev->service.msg.flags &= ~I2C_M_BUSY;
    5982:	687b      	ldr	r3, [r7, #4]
    5984:	885b      	ldrh	r3, [r3, #2]
    5986:	b29b      	uxth	r3, r3
    5988:	4a21      	ldr	r2, [pc, #132]	; (5a10 <_i2c_m_sync_transfer+0x120>)
    598a:	4013      	ands	r3, r2
    598c:	b29a      	uxth	r2, r3
    598e:	687b      	ldr	r3, [r7, #4]
    5990:	805a      	strh	r2, [r3, #2]

		return ret;
    5992:	697b      	ldr	r3, [r7, #20]
    5994:	e030      	b.n	59f8 <_i2c_m_sync_transfer+0x108>
	}

	while (i2c_dev->service.msg.flags & I2C_M_BUSY) {
		ret = _sercom_i2c_sync_wait_bus(i2c_dev, &flags);
    5996:	230c      	movs	r3, #12
    5998:	18fa      	adds	r2, r7, r3
    599a:	687b      	ldr	r3, [r7, #4]
    599c:	0011      	movs	r1, r2
    599e:	0018      	movs	r0, r3
    59a0:	f7ff ff38 	bl	5814 <_sercom_i2c_sync_wait_bus>
    59a4:	0003      	movs	r3, r0
    59a6:	617b      	str	r3, [r7, #20]

		if (ret) {
    59a8:	697b      	ldr	r3, [r7, #20]
    59aa:	2b00      	cmp	r3, #0
    59ac:	d013      	beq.n	59d6 <_i2c_m_sync_transfer+0xe6>
			if (msg->flags & I2C_M_STOP) {
    59ae:	683b      	ldr	r3, [r7, #0]
    59b0:	885b      	ldrh	r3, [r3, #2]
    59b2:	b29b      	uxth	r3, r3
    59b4:	b21b      	sxth	r3, r3
    59b6:	2b00      	cmp	r3, #0
    59b8:	da03      	bge.n	59c2 <_i2c_m_sync_transfer+0xd2>
				_sercom_i2c_send_stop(hw);
    59ba:	693b      	ldr	r3, [r7, #16]
    59bc:	0018      	movs	r0, r3
    59be:	f7ff fd6d 	bl	549c <_sercom_i2c_send_stop>
			}

			i2c_dev->service.msg.flags &= ~I2C_M_BUSY;
    59c2:	687b      	ldr	r3, [r7, #4]
    59c4:	885b      	ldrh	r3, [r3, #2]
    59c6:	b29b      	uxth	r3, r3
    59c8:	4a11      	ldr	r2, [pc, #68]	; (5a10 <_i2c_m_sync_transfer+0x120>)
    59ca:	4013      	ands	r3, r2
    59cc:	b29a      	uxth	r2, r3
    59ce:	687b      	ldr	r3, [r7, #4]
    59d0:	805a      	strh	r2, [r3, #2]

			return ret;
    59d2:	697b      	ldr	r3, [r7, #20]
    59d4:	e010      	b.n	59f8 <_i2c_m_sync_transfer+0x108>
		}

		ret = _sercom_i2c_sync_analyse_flags(hw, flags, &i2c_dev->service.msg);
    59d6:	68f9      	ldr	r1, [r7, #12]
    59d8:	687a      	ldr	r2, [r7, #4]
    59da:	693b      	ldr	r3, [r7, #16]
    59dc:	0018      	movs	r0, r3
    59de:	f7ff fd6b 	bl	54b8 <_sercom_i2c_sync_analyse_flags>
    59e2:	0003      	movs	r3, r0
    59e4:	617b      	str	r3, [r7, #20]
	while (i2c_dev->service.msg.flags & I2C_M_BUSY) {
    59e6:	687b      	ldr	r3, [r7, #4]
    59e8:	885b      	ldrh	r3, [r3, #2]
    59ea:	b29b      	uxth	r3, r3
    59ec:	001a      	movs	r2, r3
    59ee:	2380      	movs	r3, #128	; 0x80
    59f0:	005b      	lsls	r3, r3, #1
    59f2:	4013      	ands	r3, r2
    59f4:	d1cf      	bne.n	5996 <_i2c_m_sync_transfer+0xa6>
	}

	return ret;
    59f6:	697b      	ldr	r3, [r7, #20]
}
    59f8:	0018      	movs	r0, r3
    59fa:	46bd      	mov	sp, r7
    59fc:	b007      	add	sp, #28
    59fe:	bd90      	pop	{r4, r7, pc}
    5a00:	0000059b 	.word	0x0000059b
    5a04:	00008fbc 	.word	0x00008fbc
    5a08:	0000059c 	.word	0x0000059c
    5a0c:	0000059d 	.word	0x0000059d
    5a10:	fffffeff 	.word	0xfffffeff

00005a14 <_spi_sync_enable>:
 *  \param[in] hw Pointer to the hardware register base.
 *
 * \return Enabling status
 */
static int32_t _spi_sync_enable(void *const hw)
{
    5a14:	b580      	push	{r7, lr}
    5a16:	b082      	sub	sp, #8
    5a18:	af00      	add	r7, sp, #0
    5a1a:	6078      	str	r0, [r7, #4]
	if (hri_sercomspi_is_syncing(hw)) {
    5a1c:	687b      	ldr	r3, [r7, #4]
    5a1e:	0018      	movs	r0, r3
    5a20:	f7ff f91e 	bl	4c60 <hri_sercomspi_is_syncing>
    5a24:	1e03      	subs	r3, r0, #0
    5a26:	d002      	beq.n	5a2e <_spi_sync_enable+0x1a>
		return ERR_BUSY;
    5a28:	2304      	movs	r3, #4
    5a2a:	425b      	negs	r3, r3
    5a2c:	e004      	b.n	5a38 <_spi_sync_enable+0x24>
	}

	hri_sercomspi_set_CTRLA_ENABLE_bit(hw);
    5a2e:	687b      	ldr	r3, [r7, #4]
    5a30:	0018      	movs	r0, r3
    5a32:	f7ff f9f6 	bl	4e22 <hri_sercomspi_set_CTRLA_ENABLE_bit>

	return ERR_NONE;
    5a36:	2300      	movs	r3, #0
}
    5a38:	0018      	movs	r0, r3
    5a3a:	46bd      	mov	sp, r7
    5a3c:	b002      	add	sp, #8
    5a3e:	bd80      	pop	{r7, pc}

00005a40 <_spi_load_regs_master>:
 *  are ignored.
 *  \param[in, out] hw Pointer to the hardware register base.
 *  \param[in] regs Pointer to register configuration values.
 */
static inline void _spi_load_regs_master(void *const hw, const struct sercomspi_regs_cfg *regs)
{
    5a40:	b580      	push	{r7, lr}
    5a42:	b082      	sub	sp, #8
    5a44:	af00      	add	r7, sp, #0
    5a46:	6078      	str	r0, [r7, #4]
    5a48:	6039      	str	r1, [r7, #0]
	ASSERT(hw && regs);
    5a4a:	687b      	ldr	r3, [r7, #4]
    5a4c:	2b00      	cmp	r3, #0
    5a4e:	d004      	beq.n	5a5a <_spi_load_regs_master+0x1a>
    5a50:	683b      	ldr	r3, [r7, #0]
    5a52:	2b00      	cmp	r3, #0
    5a54:	d001      	beq.n	5a5a <_spi_load_regs_master+0x1a>
    5a56:	2301      	movs	r3, #1
    5a58:	e000      	b.n	5a5c <_spi_load_regs_master+0x1c>
    5a5a:	2300      	movs	r3, #0
    5a5c:	1c1a      	adds	r2, r3, #0
    5a5e:	2301      	movs	r3, #1
    5a60:	4013      	ands	r3, r2
    5a62:	b2db      	uxtb	r3, r3
    5a64:	4a1f      	ldr	r2, [pc, #124]	; (5ae4 <_spi_load_regs_master+0xa4>)
    5a66:	4920      	ldr	r1, [pc, #128]	; (5ae8 <_spi_load_regs_master+0xa8>)
    5a68:	0018      	movs	r0, r3
    5a6a:	f7fe fc79 	bl	4360 <assert>
	hri_sercomspi_write_CTRLA_reg(
	    hw, regs->ctrla & ~(SERCOM_SPI_CTRLA_IBON | SERCOM_SPI_CTRLA_ENABLE | SERCOM_SPI_CTRLA_SWRST));
    5a6e:	683b      	ldr	r3, [r7, #0]
    5a70:	781a      	ldrb	r2, [r3, #0]
    5a72:	7859      	ldrb	r1, [r3, #1]
    5a74:	0209      	lsls	r1, r1, #8
    5a76:	430a      	orrs	r2, r1
    5a78:	7899      	ldrb	r1, [r3, #2]
    5a7a:	0409      	lsls	r1, r1, #16
    5a7c:	430a      	orrs	r2, r1
    5a7e:	78db      	ldrb	r3, [r3, #3]
    5a80:	061b      	lsls	r3, r3, #24
    5a82:	4313      	orrs	r3, r2
    5a84:	001a      	movs	r2, r3
	hri_sercomspi_write_CTRLA_reg(
    5a86:	4b19      	ldr	r3, [pc, #100]	; (5aec <_spi_load_regs_master+0xac>)
    5a88:	401a      	ands	r2, r3
    5a8a:	687b      	ldr	r3, [r7, #4]
    5a8c:	0011      	movs	r1, r2
    5a8e:	0018      	movs	r0, r3
    5a90:	f7ff fa06 	bl	4ea0 <hri_sercomspi_write_CTRLA_reg>
	hri_sercomspi_write_CTRLB_reg(
	    hw, (regs->ctrlb & ~(SERCOM_SPI_CTRLB_AMODE_Msk | SERCOM_SPI_CTRLB_PLOADEN)) | (SERCOM_SPI_CTRLB_RXEN));
    5a94:	683b      	ldr	r3, [r7, #0]
    5a96:	791a      	ldrb	r2, [r3, #4]
    5a98:	7959      	ldrb	r1, [r3, #5]
    5a9a:	0209      	lsls	r1, r1, #8
    5a9c:	430a      	orrs	r2, r1
    5a9e:	7999      	ldrb	r1, [r3, #6]
    5aa0:	0409      	lsls	r1, r1, #16
    5aa2:	430a      	orrs	r2, r1
    5aa4:	79db      	ldrb	r3, [r3, #7]
    5aa6:	061b      	lsls	r3, r3, #24
    5aa8:	4313      	orrs	r3, r2
    5aaa:	001a      	movs	r2, r3
    5aac:	4b10      	ldr	r3, [pc, #64]	; (5af0 <_spi_load_regs_master+0xb0>)
    5aae:	4013      	ands	r3, r2
	hri_sercomspi_write_CTRLB_reg(
    5ab0:	2280      	movs	r2, #128	; 0x80
    5ab2:	0292      	lsls	r2, r2, #10
    5ab4:	431a      	orrs	r2, r3
    5ab6:	687b      	ldr	r3, [r7, #4]
    5ab8:	0011      	movs	r1, r2
    5aba:	0018      	movs	r0, r3
    5abc:	f7ff fa9b 	bl	4ff6 <hri_sercomspi_write_CTRLB_reg>
	hri_sercomspi_write_BAUD_reg(hw, regs->baud);
    5ac0:	683b      	ldr	r3, [r7, #0]
    5ac2:	7b1a      	ldrb	r2, [r3, #12]
    5ac4:	687b      	ldr	r3, [r7, #4]
    5ac6:	0011      	movs	r1, r2
    5ac8:	0018      	movs	r0, r3
    5aca:	f7ff fadd 	bl	5088 <hri_sercomspi_write_BAUD_reg>
	hri_sercomspi_write_DBGCTRL_reg(hw, regs->dbgctrl);
    5ace:	683b      	ldr	r3, [r7, #0]
    5ad0:	7b5a      	ldrb	r2, [r3, #13]
    5ad2:	687b      	ldr	r3, [r7, #4]
    5ad4:	0011      	movs	r1, r2
    5ad6:	0018      	movs	r0, r3
    5ad8:	f7ff faa9 	bl	502e <hri_sercomspi_write_DBGCTRL_reg>
}
    5adc:	46c0      	nop			; (mov r8, r8)
    5ade:	46bd      	mov	sp, r7
    5ae0:	b002      	add	sp, #8
    5ae2:	bd80      	pop	{r7, pc}
    5ae4:	00000872 	.word	0x00000872
    5ae8:	00008fbc 	.word	0x00008fbc
    5aec:	fffffefc 	.word	0xfffffefc
    5af0:	fffd3fbf 	.word	0xfffd3fbf

00005af4 <_spi_load_regs_slave>:
 *  are ignored.
 *  \param[in, out] hw Pointer to the hardware register base.
 *  \param[in] regs Pointer to register configuration values.
 */
static inline void _spi_load_regs_slave(void *const hw, const struct sercomspi_regs_cfg *regs)
{
    5af4:	b580      	push	{r7, lr}
    5af6:	b082      	sub	sp, #8
    5af8:	af00      	add	r7, sp, #0
    5afa:	6078      	str	r0, [r7, #4]
    5afc:	6039      	str	r1, [r7, #0]
	ASSERT(hw && regs);
    5afe:	687b      	ldr	r3, [r7, #4]
    5b00:	2b00      	cmp	r3, #0
    5b02:	d004      	beq.n	5b0e <_spi_load_regs_slave+0x1a>
    5b04:	683b      	ldr	r3, [r7, #0]
    5b06:	2b00      	cmp	r3, #0
    5b08:	d001      	beq.n	5b0e <_spi_load_regs_slave+0x1a>
    5b0a:	2301      	movs	r3, #1
    5b0c:	e000      	b.n	5b10 <_spi_load_regs_slave+0x1c>
    5b0e:	2300      	movs	r3, #0
    5b10:	1c1a      	adds	r2, r3, #0
    5b12:	2301      	movs	r3, #1
    5b14:	4013      	ands	r3, r2
    5b16:	b2db      	uxtb	r3, r3
    5b18:	4a26      	ldr	r2, [pc, #152]	; (5bb4 <_spi_load_regs_slave+0xc0>)
    5b1a:	4927      	ldr	r1, [pc, #156]	; (5bb8 <_spi_load_regs_slave+0xc4>)
    5b1c:	0018      	movs	r0, r3
    5b1e:	f7fe fc1f 	bl	4360 <assert>
	hri_sercomspi_write_CTRLA_reg(
	    hw, regs->ctrla & ~(SERCOM_SPI_CTRLA_IBON | SERCOM_SPI_CTRLA_ENABLE | SERCOM_SPI_CTRLA_SWRST));
    5b22:	683b      	ldr	r3, [r7, #0]
    5b24:	781a      	ldrb	r2, [r3, #0]
    5b26:	7859      	ldrb	r1, [r3, #1]
    5b28:	0209      	lsls	r1, r1, #8
    5b2a:	430a      	orrs	r2, r1
    5b2c:	7899      	ldrb	r1, [r3, #2]
    5b2e:	0409      	lsls	r1, r1, #16
    5b30:	430a      	orrs	r2, r1
    5b32:	78db      	ldrb	r3, [r3, #3]
    5b34:	061b      	lsls	r3, r3, #24
    5b36:	4313      	orrs	r3, r2
    5b38:	001a      	movs	r2, r3
	hri_sercomspi_write_CTRLA_reg(
    5b3a:	4b20      	ldr	r3, [pc, #128]	; (5bbc <_spi_load_regs_slave+0xc8>)
    5b3c:	401a      	ands	r2, r3
    5b3e:	687b      	ldr	r3, [r7, #4]
    5b40:	0011      	movs	r1, r2
    5b42:	0018      	movs	r0, r3
    5b44:	f7ff f9ac 	bl	4ea0 <hri_sercomspi_write_CTRLA_reg>
	hri_sercomspi_write_CTRLB_reg(hw, regs->ctrlb | (SERCOM_SPI_CTRLB_RXEN | SERCOM_SPI_CTRLB_PLOADEN));
    5b48:	683b      	ldr	r3, [r7, #0]
    5b4a:	791a      	ldrb	r2, [r3, #4]
    5b4c:	7959      	ldrb	r1, [r3, #5]
    5b4e:	0209      	lsls	r1, r1, #8
    5b50:	430a      	orrs	r2, r1
    5b52:	7999      	ldrb	r1, [r3, #6]
    5b54:	0409      	lsls	r1, r1, #16
    5b56:	430a      	orrs	r2, r1
    5b58:	79db      	ldrb	r3, [r3, #7]
    5b5a:	061b      	lsls	r3, r3, #24
    5b5c:	4313      	orrs	r3, r2
    5b5e:	001a      	movs	r2, r3
    5b60:	4b17      	ldr	r3, [pc, #92]	; (5bc0 <_spi_load_regs_slave+0xcc>)
    5b62:	431a      	orrs	r2, r3
    5b64:	687b      	ldr	r3, [r7, #4]
    5b66:	0011      	movs	r1, r2
    5b68:	0018      	movs	r0, r3
    5b6a:	f7ff fa44 	bl	4ff6 <hri_sercomspi_write_CTRLB_reg>
	hri_sercomspi_write_ADDR_reg(hw, regs->addr);
    5b6e:	683b      	ldr	r3, [r7, #0]
    5b70:	7a1a      	ldrb	r2, [r3, #8]
    5b72:	7a59      	ldrb	r1, [r3, #9]
    5b74:	0209      	lsls	r1, r1, #8
    5b76:	430a      	orrs	r2, r1
    5b78:	7a99      	ldrb	r1, [r3, #10]
    5b7a:	0409      	lsls	r1, r1, #16
    5b7c:	430a      	orrs	r2, r1
    5b7e:	7adb      	ldrb	r3, [r3, #11]
    5b80:	061b      	lsls	r3, r3, #24
    5b82:	4313      	orrs	r3, r2
    5b84:	001a      	movs	r2, r3
    5b86:	687b      	ldr	r3, [r7, #4]
    5b88:	0011      	movs	r1, r2
    5b8a:	0018      	movs	r0, r3
    5b8c:	f7ff faad 	bl	50ea <hri_sercomspi_write_ADDR_reg>
	hri_sercomspi_write_DBGCTRL_reg(hw, regs->dbgctrl);
    5b90:	683b      	ldr	r3, [r7, #0]
    5b92:	7b5a      	ldrb	r2, [r3, #13]
    5b94:	687b      	ldr	r3, [r7, #4]
    5b96:	0011      	movs	r1, r2
    5b98:	0018      	movs	r0, r3
    5b9a:	f7ff fa48 	bl	502e <hri_sercomspi_write_DBGCTRL_reg>
	while (hri_sercomspi_is_syncing(hw))
    5b9e:	46c0      	nop			; (mov r8, r8)
    5ba0:	687b      	ldr	r3, [r7, #4]
    5ba2:	0018      	movs	r0, r3
    5ba4:	f7ff f85c 	bl	4c60 <hri_sercomspi_is_syncing>
    5ba8:	1e03      	subs	r3, r0, #0
    5baa:	d1f9      	bne.n	5ba0 <_spi_load_regs_slave+0xac>
		;
}
    5bac:	46c0      	nop			; (mov r8, r8)
    5bae:	46bd      	mov	sp, r7
    5bb0:	b002      	add	sp, #8
    5bb2:	bd80      	pop	{r7, pc}
    5bb4:	00000883 	.word	0x00000883
    5bb8:	00008fbc 	.word	0x00008fbc
    5bbc:	fffffefc 	.word	0xfffffefc
    5bc0:	00020040 	.word	0x00020040

00005bc4 <_spi_get_regs>:
/** \brief Return the pointer to register settings of specific SERCOM
 *  \param[in] hw_addr The hardware register base address.
 *  \return Pointer to register settings of specific SERCOM.
 */
static inline const struct sercomspi_regs_cfg *_spi_get_regs(const uint32_t hw_addr)
{
    5bc4:	b590      	push	{r4, r7, lr}
    5bc6:	b085      	sub	sp, #20
    5bc8:	af00      	add	r7, sp, #0
    5bca:	6078      	str	r0, [r7, #4]
	uint8_t n = _sercom_get_hardware_index((const void *)hw_addr);
    5bcc:	687b      	ldr	r3, [r7, #4]
    5bce:	220e      	movs	r2, #14
    5bd0:	18bc      	adds	r4, r7, r2
    5bd2:	0018      	movs	r0, r3
    5bd4:	f7ff fb70 	bl	52b8 <_sercom_get_hardware_index>
    5bd8:	0003      	movs	r3, r0
    5bda:	7023      	strb	r3, [r4, #0]
	uint8_t i;

	for (i = 0; i < sizeof(sercomspi_regs) / sizeof(struct sercomspi_regs_cfg); i++) {
    5bdc:	230f      	movs	r3, #15
    5bde:	18fb      	adds	r3, r7, r3
    5be0:	2200      	movs	r2, #0
    5be2:	701a      	strb	r2, [r3, #0]
    5be4:	e01a      	b.n	5c1c <_spi_get_regs+0x58>
		if (sercomspi_regs[i].n == n) {
    5be6:	230f      	movs	r3, #15
    5be8:	18fb      	adds	r3, r7, r3
    5bea:	781b      	ldrb	r3, [r3, #0]
    5bec:	4a10      	ldr	r2, [pc, #64]	; (5c30 <_spi_get_regs+0x6c>)
    5bee:	011b      	lsls	r3, r3, #4
    5bf0:	18d3      	adds	r3, r2, r3
    5bf2:	330f      	adds	r3, #15
    5bf4:	781b      	ldrb	r3, [r3, #0]
    5bf6:	220e      	movs	r2, #14
    5bf8:	18ba      	adds	r2, r7, r2
    5bfa:	7812      	ldrb	r2, [r2, #0]
    5bfc:	429a      	cmp	r2, r3
    5bfe:	d106      	bne.n	5c0e <_spi_get_regs+0x4a>
			return &sercomspi_regs[i];
    5c00:	230f      	movs	r3, #15
    5c02:	18fb      	adds	r3, r7, r3
    5c04:	781b      	ldrb	r3, [r3, #0]
    5c06:	011a      	lsls	r2, r3, #4
    5c08:	4b09      	ldr	r3, [pc, #36]	; (5c30 <_spi_get_regs+0x6c>)
    5c0a:	18d3      	adds	r3, r2, r3
    5c0c:	e00c      	b.n	5c28 <_spi_get_regs+0x64>
	for (i = 0; i < sizeof(sercomspi_regs) / sizeof(struct sercomspi_regs_cfg); i++) {
    5c0e:	230f      	movs	r3, #15
    5c10:	18fb      	adds	r3, r7, r3
    5c12:	781a      	ldrb	r2, [r3, #0]
    5c14:	230f      	movs	r3, #15
    5c16:	18fb      	adds	r3, r7, r3
    5c18:	3201      	adds	r2, #1
    5c1a:	701a      	strb	r2, [r3, #0]
    5c1c:	230f      	movs	r3, #15
    5c1e:	18fb      	adds	r3, r7, r3
    5c20:	781b      	ldrb	r3, [r3, #0]
    5c22:	2b01      	cmp	r3, #1
    5c24:	d9df      	bls.n	5be6 <_spi_get_regs+0x22>
		}
	}

	return NULL;
    5c26:	2300      	movs	r3, #0
}
    5c28:	0018      	movs	r0, r3
    5c2a:	46bd      	mov	sp, r7
    5c2c:	b005      	add	sp, #20
    5c2e:	bd90      	pop	{r4, r7, pc}
    5c30:	00008fd8 	.word	0x00008fd8

00005c34 <_spi_m_sync_init>:

int32_t _spi_m_sync_init(struct _spi_m_sync_dev *dev, void *const hw)
{
    5c34:	b580      	push	{r7, lr}
    5c36:	b084      	sub	sp, #16
    5c38:	af00      	add	r7, sp, #0
    5c3a:	6078      	str	r0, [r7, #4]
    5c3c:	6039      	str	r1, [r7, #0]
	const struct sercomspi_regs_cfg *regs = _spi_get_regs((uint32_t)hw);
    5c3e:	683b      	ldr	r3, [r7, #0]
    5c40:	0018      	movs	r0, r3
    5c42:	f7ff ffbf 	bl	5bc4 <_spi_get_regs>
    5c46:	0003      	movs	r3, r0
    5c48:	60fb      	str	r3, [r7, #12]

	ASSERT(dev && hw);
    5c4a:	687b      	ldr	r3, [r7, #4]
    5c4c:	2b00      	cmp	r3, #0
    5c4e:	d004      	beq.n	5c5a <_spi_m_sync_init+0x26>
    5c50:	683b      	ldr	r3, [r7, #0]
    5c52:	2b00      	cmp	r3, #0
    5c54:	d001      	beq.n	5c5a <_spi_m_sync_init+0x26>
    5c56:	2301      	movs	r3, #1
    5c58:	e000      	b.n	5c5c <_spi_m_sync_init+0x28>
    5c5a:	2300      	movs	r3, #0
    5c5c:	1c1a      	adds	r2, r3, #0
    5c5e:	2301      	movs	r3, #1
    5c60:	4013      	ands	r3, r2
    5c62:	b2db      	uxtb	r3, r3
    5c64:	4a30      	ldr	r2, [pc, #192]	; (5d28 <_spi_m_sync_init+0xf4>)
    5c66:	4931      	ldr	r1, [pc, #196]	; (5d2c <_spi_m_sync_init+0xf8>)
    5c68:	0018      	movs	r0, r3
    5c6a:	f7fe fb79 	bl	4360 <assert>

	if (regs == NULL) {
    5c6e:	68fb      	ldr	r3, [r7, #12]
    5c70:	2b00      	cmp	r3, #0
    5c72:	d102      	bne.n	5c7a <_spi_m_sync_init+0x46>
		return ERR_INVALID_ARG;
    5c74:	230d      	movs	r3, #13
    5c76:	425b      	negs	r3, r3
    5c78:	e051      	b.n	5d1e <_spi_m_sync_init+0xea>
	}

	hri_sercomspi_wait_for_sync(hw);
    5c7a:	683b      	ldr	r3, [r7, #0]
    5c7c:	0018      	movs	r0, r3
    5c7e:	f7fe ffdf 	bl	4c40 <hri_sercomspi_wait_for_sync>
	if (hri_sercomspi_get_CTRLA_reg(hw, SERCOM_SPI_CTRLA_ENABLE)) {
    5c82:	683b      	ldr	r3, [r7, #0]
    5c84:	2102      	movs	r1, #2
    5c86:	0018      	movs	r0, r3
    5c88:	f7ff f8f5 	bl	4e76 <hri_sercomspi_get_CTRLA_reg>
    5c8c:	1e03      	subs	r3, r0, #0
    5c8e:	d008      	beq.n	5ca2 <_spi_m_sync_init+0x6e>
		hri_sercomspi_write_CTRLA_reg(hw, 0);
    5c90:	683b      	ldr	r3, [r7, #0]
    5c92:	2100      	movs	r1, #0
    5c94:	0018      	movs	r0, r3
    5c96:	f7ff f903 	bl	4ea0 <hri_sercomspi_write_CTRLA_reg>
		hri_sercomspi_wait_for_sync(hw);
    5c9a:	683b      	ldr	r3, [r7, #0]
    5c9c:	0018      	movs	r0, r3
    5c9e:	f7fe ffcf 	bl	4c40 <hri_sercomspi_wait_for_sync>
	}
	hri_sercomspi_write_CTRLA_reg(hw, SERCOM_SPI_CTRLA_SWRST);
    5ca2:	683b      	ldr	r3, [r7, #0]
    5ca4:	2101      	movs	r1, #1
    5ca6:	0018      	movs	r0, r3
    5ca8:	f7ff f8fa 	bl	4ea0 <hri_sercomspi_write_CTRLA_reg>
	hri_sercomspi_wait_for_sync(hw);
    5cac:	683b      	ldr	r3, [r7, #0]
    5cae:	0018      	movs	r0, r3
    5cb0:	f7fe ffc6 	bl	4c40 <hri_sercomspi_wait_for_sync>

	dev->prvt = hw;
    5cb4:	687b      	ldr	r3, [r7, #4]
    5cb6:	683a      	ldr	r2, [r7, #0]
    5cb8:	601a      	str	r2, [r3, #0]

	if ((regs->ctrla & SERCOM_SPI_CTRLA_MODE_Msk) == SERCOM_USART_CTRLA_MODE_SPI_SLAVE) {
    5cba:	68fb      	ldr	r3, [r7, #12]
    5cbc:	781a      	ldrb	r2, [r3, #0]
    5cbe:	7859      	ldrb	r1, [r3, #1]
    5cc0:	0209      	lsls	r1, r1, #8
    5cc2:	430a      	orrs	r2, r1
    5cc4:	7899      	ldrb	r1, [r3, #2]
    5cc6:	0409      	lsls	r1, r1, #16
    5cc8:	430a      	orrs	r2, r1
    5cca:	78db      	ldrb	r3, [r3, #3]
    5ccc:	061b      	lsls	r3, r3, #24
    5cce:	4313      	orrs	r3, r2
    5cd0:	001a      	movs	r2, r3
    5cd2:	231c      	movs	r3, #28
    5cd4:	4013      	ands	r3, r2
    5cd6:	2b08      	cmp	r3, #8
    5cd8:	d106      	bne.n	5ce8 <_spi_m_sync_init+0xb4>
		_spi_load_regs_slave(hw, regs);
    5cda:	68fa      	ldr	r2, [r7, #12]
    5cdc:	683b      	ldr	r3, [r7, #0]
    5cde:	0011      	movs	r1, r2
    5ce0:	0018      	movs	r0, r3
    5ce2:	f7ff ff07 	bl	5af4 <_spi_load_regs_slave>
    5ce6:	e005      	b.n	5cf4 <_spi_m_sync_init+0xc0>
	} else {
		_spi_load_regs_master(hw, regs);
    5ce8:	68fa      	ldr	r2, [r7, #12]
    5cea:	683b      	ldr	r3, [r7, #0]
    5cec:	0011      	movs	r1, r2
    5cee:	0018      	movs	r0, r3
    5cf0:	f7ff fea6 	bl	5a40 <_spi_load_regs_master>
	}

	/* Load character size from default hardware configuration */
	dev->char_size = ((regs->ctrlb & SERCOM_SPI_CTRLB_CHSIZE_Msk) == 0) ? 1 : 2;
    5cf4:	68fb      	ldr	r3, [r7, #12]
    5cf6:	791a      	ldrb	r2, [r3, #4]
    5cf8:	7959      	ldrb	r1, [r3, #5]
    5cfa:	0209      	lsls	r1, r1, #8
    5cfc:	430a      	orrs	r2, r1
    5cfe:	7999      	ldrb	r1, [r3, #6]
    5d00:	0409      	lsls	r1, r1, #16
    5d02:	430a      	orrs	r2, r1
    5d04:	79db      	ldrb	r3, [r3, #7]
    5d06:	061b      	lsls	r3, r3, #24
    5d08:	4313      	orrs	r3, r2
    5d0a:	001a      	movs	r2, r3
    5d0c:	2307      	movs	r3, #7
    5d0e:	4013      	ands	r3, r2
    5d10:	d101      	bne.n	5d16 <_spi_m_sync_init+0xe2>
    5d12:	2201      	movs	r2, #1
    5d14:	e000      	b.n	5d18 <_spi_m_sync_init+0xe4>
    5d16:	2202      	movs	r2, #2
    5d18:	687b      	ldr	r3, [r7, #4]
    5d1a:	711a      	strb	r2, [r3, #4]

	return ERR_NONE;
    5d1c:	2300      	movs	r3, #0
}
    5d1e:	0018      	movs	r0, r3
    5d20:	46bd      	mov	sp, r7
    5d22:	b004      	add	sp, #16
    5d24:	bd80      	pop	{r7, pc}
    5d26:	46c0      	nop			; (mov r8, r8)
    5d28:	000008a3 	.word	0x000008a3
    5d2c:	00008fbc 	.word	0x00008fbc

00005d30 <_spi_m_sync_enable>:

	return _spi_deinit(hw);
}

int32_t _spi_m_sync_enable(struct _spi_m_sync_dev *dev)
{
    5d30:	b580      	push	{r7, lr}
    5d32:	b082      	sub	sp, #8
    5d34:	af00      	add	r7, sp, #0
    5d36:	6078      	str	r0, [r7, #4]
	ASSERT(dev && dev->prvt);
    5d38:	687b      	ldr	r3, [r7, #4]
    5d3a:	2b00      	cmp	r3, #0
    5d3c:	d005      	beq.n	5d4a <_spi_m_sync_enable+0x1a>
    5d3e:	687b      	ldr	r3, [r7, #4]
    5d40:	681b      	ldr	r3, [r3, #0]
    5d42:	2b00      	cmp	r3, #0
    5d44:	d001      	beq.n	5d4a <_spi_m_sync_enable+0x1a>
    5d46:	2301      	movs	r3, #1
    5d48:	e000      	b.n	5d4c <_spi_m_sync_enable+0x1c>
    5d4a:	2300      	movs	r3, #0
    5d4c:	1c1a      	adds	r2, r3, #0
    5d4e:	2301      	movs	r3, #1
    5d50:	4013      	ands	r3, r2
    5d52:	b2db      	uxtb	r3, r3
    5d54:	4a07      	ldr	r2, [pc, #28]	; (5d74 <_spi_m_sync_enable+0x44>)
    5d56:	4908      	ldr	r1, [pc, #32]	; (5d78 <_spi_m_sync_enable+0x48>)
    5d58:	0018      	movs	r0, r3
    5d5a:	f7fe fb01 	bl	4360 <assert>

	return _spi_sync_enable(dev->prvt);
    5d5e:	687b      	ldr	r3, [r7, #4]
    5d60:	681b      	ldr	r3, [r3, #0]
    5d62:	0018      	movs	r0, r3
    5d64:	f7ff fe56 	bl	5a14 <_spi_sync_enable>
    5d68:	0003      	movs	r3, r0
}
    5d6a:	0018      	movs	r0, r3
    5d6c:	46bd      	mov	sp, r7
    5d6e:	b002      	add	sp, #8
    5d70:	bd80      	pop	{r7, pc}
    5d72:	46c0      	nop			; (mov r8, r8)
    5d74:	0000090a 	.word	0x0000090a
    5d78:	00008fbc 	.word	0x00008fbc

00005d7c <_spi_wait_bus_idle>:
	return _spi_set_data_order(dev->prvt, dord);
}

/** Wait until SPI bus idle. */
static inline void _spi_wait_bus_idle(void *const hw)
{
    5d7c:	b580      	push	{r7, lr}
    5d7e:	b082      	sub	sp, #8
    5d80:	af00      	add	r7, sp, #0
    5d82:	6078      	str	r0, [r7, #4]
	while (!(hri_sercomspi_get_INTFLAG_reg(hw, SERCOM_SPI_INTFLAG_TXC | SERCOM_SPI_INTFLAG_DRE))) {
    5d84:	46c0      	nop			; (mov r8, r8)
    5d86:	687b      	ldr	r3, [r7, #4]
    5d88:	2103      	movs	r1, #3
    5d8a:	0018      	movs	r0, r3
    5d8c:	f7fe ffa9 	bl	4ce2 <hri_sercomspi_get_INTFLAG_reg>
    5d90:	1e03      	subs	r3, r0, #0
    5d92:	d0f8      	beq.n	5d86 <_spi_wait_bus_idle+0xa>
		;
	}
	hri_sercomspi_clear_INTFLAG_reg(hw, SERCOM_SPI_INTFLAG_TXC | SERCOM_SPI_INTFLAG_DRE);
    5d94:	687b      	ldr	r3, [r7, #4]
    5d96:	2103      	movs	r1, #3
    5d98:	0018      	movs	r0, r3
    5d9a:	f7fe ffc9 	bl	4d30 <hri_sercomspi_clear_INTFLAG_reg>
}
    5d9e:	46c0      	nop			; (mov r8, r8)
    5da0:	46bd      	mov	sp, r7
    5da2:	b002      	add	sp, #8
    5da4:	bd80      	pop	{r7, pc}

00005da6 <_spi_rx_check>:
	uint8_t char_size;
};

/** Check interrupt flag of RXC and update transaction runtime information. */
static inline bool _spi_rx_check(void *const hw, const uint32_t iflag, struct _spi_trans_ctrl *ctrl)
{
    5da6:	b580      	push	{r7, lr}
    5da8:	b086      	sub	sp, #24
    5daa:	af00      	add	r7, sp, #0
    5dac:	60f8      	str	r0, [r7, #12]
    5dae:	60b9      	str	r1, [r7, #8]
    5db0:	607a      	str	r2, [r7, #4]
	uint32_t data;

	if (!(iflag & SERCOM_SPI_INTFLAG_RXC)) {
    5db2:	68bb      	ldr	r3, [r7, #8]
    5db4:	2204      	movs	r2, #4
    5db6:	4013      	ands	r3, r2
    5db8:	d101      	bne.n	5dbe <_spi_rx_check+0x18>
		return false;
    5dba:	2300      	movs	r3, #0
    5dbc:	e024      	b.n	5e08 <_spi_rx_check+0x62>
	}

	data = hri_sercomspi_read_DATA_reg(hw);
    5dbe:	68fb      	ldr	r3, [r7, #12]
    5dc0:	0018      	movs	r0, r3
    5dc2:	f7ff f9c7 	bl	5154 <hri_sercomspi_read_DATA_reg>
    5dc6:	0003      	movs	r3, r0
    5dc8:	617b      	str	r3, [r7, #20]

	if (ctrl->rxbuf) {
    5dca:	687b      	ldr	r3, [r7, #4]
    5dcc:	685b      	ldr	r3, [r3, #4]
    5dce:	2b00      	cmp	r3, #0
    5dd0:	d014      	beq.n	5dfc <_spi_rx_check+0x56>
		*ctrl->rxbuf++ = (uint8_t)data;
    5dd2:	687b      	ldr	r3, [r7, #4]
    5dd4:	685b      	ldr	r3, [r3, #4]
    5dd6:	1c59      	adds	r1, r3, #1
    5dd8:	687a      	ldr	r2, [r7, #4]
    5dda:	6051      	str	r1, [r2, #4]
    5ddc:	697a      	ldr	r2, [r7, #20]
    5dde:	b2d2      	uxtb	r2, r2
    5de0:	701a      	strb	r2, [r3, #0]

		if (ctrl->char_size > 1) {
    5de2:	687b      	ldr	r3, [r7, #4]
    5de4:	7c1b      	ldrb	r3, [r3, #16]
    5de6:	2b01      	cmp	r3, #1
    5de8:	d908      	bls.n	5dfc <_spi_rx_check+0x56>
			*ctrl->rxbuf++ = (uint8_t)(data >> 8);
    5dea:	687b      	ldr	r3, [r7, #4]
    5dec:	685b      	ldr	r3, [r3, #4]
    5dee:	1c59      	adds	r1, r3, #1
    5df0:	687a      	ldr	r2, [r7, #4]
    5df2:	6051      	str	r1, [r2, #4]
    5df4:	697a      	ldr	r2, [r7, #20]
    5df6:	0a12      	lsrs	r2, r2, #8
    5df8:	b2d2      	uxtb	r2, r2
    5dfa:	701a      	strb	r2, [r3, #0]
		}
	}

	ctrl->rxcnt++;
    5dfc:	687b      	ldr	r3, [r7, #4]
    5dfe:	68db      	ldr	r3, [r3, #12]
    5e00:	1c5a      	adds	r2, r3, #1
    5e02:	687b      	ldr	r3, [r7, #4]
    5e04:	60da      	str	r2, [r3, #12]
	return true;
    5e06:	2301      	movs	r3, #1
}
    5e08:	0018      	movs	r0, r3
    5e0a:	46bd      	mov	sp, r7
    5e0c:	b006      	add	sp, #24
    5e0e:	bd80      	pop	{r7, pc}

00005e10 <_spi_tx_check>:

/** Check interrupt flag of DRE and update transaction runtime information. */
static inline void _spi_tx_check(void *const hw, const uint32_t iflag, struct _spi_trans_ctrl *ctrl)
{
    5e10:	b580      	push	{r7, lr}
    5e12:	b086      	sub	sp, #24
    5e14:	af00      	add	r7, sp, #0
    5e16:	60f8      	str	r0, [r7, #12]
    5e18:	60b9      	str	r1, [r7, #8]
    5e1a:	607a      	str	r2, [r7, #4]
	uint32_t data;

	if (!(SERCOM_SPI_INTFLAG_DRE & iflag)) {
    5e1c:	68bb      	ldr	r3, [r7, #8]
    5e1e:	2201      	movs	r2, #1
    5e20:	4013      	ands	r3, r2
    5e22:	d02b      	beq.n	5e7c <_spi_tx_check+0x6c>
		return;
	}

	if (ctrl->txbuf) {
    5e24:	687b      	ldr	r3, [r7, #4]
    5e26:	681b      	ldr	r3, [r3, #0]
    5e28:	2b00      	cmp	r3, #0
    5e2a:	d018      	beq.n	5e5e <_spi_tx_check+0x4e>
		data = *ctrl->txbuf++;
    5e2c:	687b      	ldr	r3, [r7, #4]
    5e2e:	681b      	ldr	r3, [r3, #0]
    5e30:	1c59      	adds	r1, r3, #1
    5e32:	687a      	ldr	r2, [r7, #4]
    5e34:	6011      	str	r1, [r2, #0]
    5e36:	781b      	ldrb	r3, [r3, #0]
    5e38:	617b      	str	r3, [r7, #20]

		if (ctrl->char_size > 1) {
    5e3a:	687b      	ldr	r3, [r7, #4]
    5e3c:	7c1b      	ldrb	r3, [r3, #16]
    5e3e:	2b01      	cmp	r3, #1
    5e40:	d90f      	bls.n	5e62 <_spi_tx_check+0x52>
			data |= (*ctrl->txbuf) << 8;
    5e42:	687b      	ldr	r3, [r7, #4]
    5e44:	681b      	ldr	r3, [r3, #0]
    5e46:	781b      	ldrb	r3, [r3, #0]
    5e48:	021b      	lsls	r3, r3, #8
    5e4a:	001a      	movs	r2, r3
    5e4c:	697b      	ldr	r3, [r7, #20]
    5e4e:	4313      	orrs	r3, r2
    5e50:	617b      	str	r3, [r7, #20]
			ctrl->txbuf++;
    5e52:	687b      	ldr	r3, [r7, #4]
    5e54:	681b      	ldr	r3, [r3, #0]
    5e56:	1c5a      	adds	r2, r3, #1
    5e58:	687b      	ldr	r3, [r7, #4]
    5e5a:	601a      	str	r2, [r3, #0]
    5e5c:	e001      	b.n	5e62 <_spi_tx_check+0x52>
		}
	} else {
		data = SPI_DUMMY_CHAR;
    5e5e:	4b09      	ldr	r3, [pc, #36]	; (5e84 <_spi_tx_check+0x74>)
    5e60:	617b      	str	r3, [r7, #20]
	}

	ctrl->txcnt++;
    5e62:	687b      	ldr	r3, [r7, #4]
    5e64:	689b      	ldr	r3, [r3, #8]
    5e66:	1c5a      	adds	r2, r3, #1
    5e68:	687b      	ldr	r3, [r7, #4]
    5e6a:	609a      	str	r2, [r3, #8]
	hri_sercomspi_write_DATA_reg(hw, data);
    5e6c:	697b      	ldr	r3, [r7, #20]
    5e6e:	b29a      	uxth	r2, r3
    5e70:	68fb      	ldr	r3, [r7, #12]
    5e72:	0011      	movs	r1, r2
    5e74:	0018      	movs	r0, r3
    5e76:	f7ff f95e 	bl	5136 <hri_sercomspi_write_DATA_reg>
    5e7a:	e000      	b.n	5e7e <_spi_tx_check+0x6e>
		return;
    5e7c:	46c0      	nop			; (mov r8, r8)
}
    5e7e:	46bd      	mov	sp, r7
    5e80:	b006      	add	sp, #24
    5e82:	bd80      	pop	{r7, pc}
    5e84:	000001ff 	.word	0x000001ff

00005e88 <_spi_m_sync_trans>:

int32_t _spi_m_sync_trans(struct _spi_m_sync_dev *dev, const struct spi_msg *msg)
{
    5e88:	b580      	push	{r7, lr}
    5e8a:	b08a      	sub	sp, #40	; 0x28
    5e8c:	af00      	add	r7, sp, #0
    5e8e:	6078      	str	r0, [r7, #4]
    5e90:	6039      	str	r1, [r7, #0]
	void *                 hw   = dev->prvt;
    5e92:	687b      	ldr	r3, [r7, #4]
    5e94:	681b      	ldr	r3, [r3, #0]
    5e96:	627b      	str	r3, [r7, #36]	; 0x24
	int32_t                rc   = 0;
    5e98:	2300      	movs	r3, #0
    5e9a:	623b      	str	r3, [r7, #32]
	struct _spi_trans_ctrl ctrl = {msg->txbuf, msg->rxbuf, 0, 0, dev->char_size};
    5e9c:	683b      	ldr	r3, [r7, #0]
    5e9e:	681a      	ldr	r2, [r3, #0]
    5ea0:	2308      	movs	r3, #8
    5ea2:	18fb      	adds	r3, r7, r3
    5ea4:	601a      	str	r2, [r3, #0]
    5ea6:	683b      	ldr	r3, [r7, #0]
    5ea8:	685a      	ldr	r2, [r3, #4]
    5eaa:	2308      	movs	r3, #8
    5eac:	18fb      	adds	r3, r7, r3
    5eae:	605a      	str	r2, [r3, #4]
    5eb0:	2308      	movs	r3, #8
    5eb2:	18fb      	adds	r3, r7, r3
    5eb4:	2200      	movs	r2, #0
    5eb6:	609a      	str	r2, [r3, #8]
    5eb8:	2308      	movs	r3, #8
    5eba:	18fb      	adds	r3, r7, r3
    5ebc:	2200      	movs	r2, #0
    5ebe:	60da      	str	r2, [r3, #12]
    5ec0:	687b      	ldr	r3, [r7, #4]
    5ec2:	791a      	ldrb	r2, [r3, #4]
    5ec4:	2308      	movs	r3, #8
    5ec6:	18fb      	adds	r3, r7, r3
    5ec8:	741a      	strb	r2, [r3, #16]

	ASSERT(dev && hw);
    5eca:	687b      	ldr	r3, [r7, #4]
    5ecc:	2b00      	cmp	r3, #0
    5ece:	d004      	beq.n	5eda <_spi_m_sync_trans+0x52>
    5ed0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    5ed2:	2b00      	cmp	r3, #0
    5ed4:	d001      	beq.n	5eda <_spi_m_sync_trans+0x52>
    5ed6:	2301      	movs	r3, #1
    5ed8:	e000      	b.n	5edc <_spi_m_sync_trans+0x54>
    5eda:	2300      	movs	r3, #0
    5edc:	1c1a      	adds	r2, r3, #0
    5ede:	2301      	movs	r3, #1
    5ee0:	4013      	ands	r3, r2
    5ee2:	b2db      	uxtb	r3, r3
    5ee4:	4a2d      	ldr	r2, [pc, #180]	; (5f9c <_spi_m_sync_trans+0x114>)
    5ee6:	492e      	ldr	r1, [pc, #184]	; (5fa0 <_spi_m_sync_trans+0x118>)
    5ee8:	0018      	movs	r0, r3
    5eea:	f7fe fa39 	bl	4360 <assert>

	/* If settings are not applied (pending), we can not go on */
	if (hri_sercomspi_is_syncing(hw)) {
    5eee:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    5ef0:	0018      	movs	r0, r3
    5ef2:	f7fe feb5 	bl	4c60 <hri_sercomspi_is_syncing>
    5ef6:	1e03      	subs	r3, r0, #0
    5ef8:	d002      	beq.n	5f00 <_spi_m_sync_trans+0x78>
		return ERR_BUSY;
    5efa:	2304      	movs	r3, #4
    5efc:	425b      	negs	r3, r3
    5efe:	e048      	b.n	5f92 <_spi_m_sync_trans+0x10a>
	}

	/* SPI must be enabled to start synchronous transfer */
	if (!hri_sercomspi_get_CTRLA_ENABLE_bit(hw)) {
    5f00:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    5f02:	0018      	movs	r0, r3
    5f04:	f7fe ff9f 	bl	4e46 <hri_sercomspi_get_CTRLA_ENABLE_bit>
    5f08:	0003      	movs	r3, r0
    5f0a:	001a      	movs	r2, r3
    5f0c:	2301      	movs	r3, #1
    5f0e:	4053      	eors	r3, r2
    5f10:	b2db      	uxtb	r3, r3
    5f12:	2b00      	cmp	r3, #0
    5f14:	d002      	beq.n	5f1c <_spi_m_sync_trans+0x94>
		return ERR_NOT_INITIALIZED;
    5f16:	2314      	movs	r3, #20
    5f18:	425b      	negs	r3, r3
    5f1a:	e03a      	b.n	5f92 <_spi_m_sync_trans+0x10a>
	}

	for (;;) {
		uint32_t iflag = hri_sercomspi_read_INTFLAG_reg(hw);
    5f1c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    5f1e:	0018      	movs	r0, r3
    5f20:	f7fe fefb 	bl	4d1a <hri_sercomspi_read_INTFLAG_reg>
    5f24:	0003      	movs	r3, r0
    5f26:	61fb      	str	r3, [r7, #28]

		if (!_spi_rx_check(hw, iflag, &ctrl)) {
    5f28:	2308      	movs	r3, #8
    5f2a:	18fa      	adds	r2, r7, r3
    5f2c:	69f9      	ldr	r1, [r7, #28]
    5f2e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    5f30:	0018      	movs	r0, r3
    5f32:	f7ff ff38 	bl	5da6 <_spi_rx_check>
    5f36:	0003      	movs	r3, r0
    5f38:	001a      	movs	r2, r3
    5f3a:	2301      	movs	r3, #1
    5f3c:	4053      	eors	r3, r2
    5f3e:	b2db      	uxtb	r3, r3
    5f40:	2b00      	cmp	r3, #0
    5f42:	d00e      	beq.n	5f62 <_spi_m_sync_trans+0xda>
			/* In master mode, do not start next byte before previous byte received
			 * to make better output waveform */
			if (ctrl.rxcnt >= ctrl.txcnt) {
    5f44:	2308      	movs	r3, #8
    5f46:	18fb      	adds	r3, r7, r3
    5f48:	68da      	ldr	r2, [r3, #12]
    5f4a:	2308      	movs	r3, #8
    5f4c:	18fb      	adds	r3, r7, r3
    5f4e:	689b      	ldr	r3, [r3, #8]
    5f50:	429a      	cmp	r2, r3
    5f52:	d306      	bcc.n	5f62 <_spi_m_sync_trans+0xda>
				_spi_tx_check(hw, iflag, &ctrl);
    5f54:	2308      	movs	r3, #8
    5f56:	18fa      	adds	r2, r7, r3
    5f58:	69f9      	ldr	r1, [r7, #28]
    5f5a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    5f5c:	0018      	movs	r0, r3
    5f5e:	f7ff ff57 	bl	5e10 <_spi_tx_check>
			}
		}

		if (ctrl.txcnt >= msg->size && ctrl.rxcnt >= msg->size) {
    5f62:	2308      	movs	r3, #8
    5f64:	18fb      	adds	r3, r7, r3
    5f66:	689a      	ldr	r2, [r3, #8]
    5f68:	683b      	ldr	r3, [r7, #0]
    5f6a:	689b      	ldr	r3, [r3, #8]
    5f6c:	429a      	cmp	r2, r3
    5f6e:	d3d5      	bcc.n	5f1c <_spi_m_sync_trans+0x94>
    5f70:	2308      	movs	r3, #8
    5f72:	18fb      	adds	r3, r7, r3
    5f74:	68da      	ldr	r2, [r3, #12]
    5f76:	683b      	ldr	r3, [r7, #0]
    5f78:	689b      	ldr	r3, [r3, #8]
    5f7a:	429a      	cmp	r2, r3
    5f7c:	d3ce      	bcc.n	5f1c <_spi_m_sync_trans+0x94>
			rc = ctrl.txcnt;
    5f7e:	2308      	movs	r3, #8
    5f80:	18fb      	adds	r3, r7, r3
    5f82:	689b      	ldr	r3, [r3, #8]
    5f84:	623b      	str	r3, [r7, #32]
			break;
    5f86:	46c0      	nop			; (mov r8, r8)
		}
	}
	/* Wait until SPI bus idle */
	_spi_wait_bus_idle(hw);
    5f88:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    5f8a:	0018      	movs	r0, r3
    5f8c:	f7ff fef6 	bl	5d7c <_spi_wait_bus_idle>

	return rc;
    5f90:	6a3b      	ldr	r3, [r7, #32]
}
    5f92:	0018      	movs	r0, r3
    5f94:	46bd      	mov	sp, r7
    5f96:	b00a      	add	sp, #40	; 0x28
    5f98:	bd80      	pop	{r7, pc}
    5f9a:	46c0      	nop			; (mov r8, r8)
    5f9c:	00000a01 	.word	0x00000a01
    5fa0:	00008fbc 	.word	0x00008fbc

00005fa4 <hri_gclk_get_STATUS_SYNCBUSY_bit>:
{
    5fa4:	b580      	push	{r7, lr}
    5fa6:	b082      	sub	sp, #8
    5fa8:	af00      	add	r7, sp, #0
    5faa:	6078      	str	r0, [r7, #4]
	return (((Gclk *)hw)->STATUS.reg & GCLK_STATUS_SYNCBUSY) >> GCLK_STATUS_SYNCBUSY_Pos;
    5fac:	687b      	ldr	r3, [r7, #4]
    5fae:	785b      	ldrb	r3, [r3, #1]
    5fb0:	b2db      	uxtb	r3, r3
    5fb2:	09db      	lsrs	r3, r3, #7
    5fb4:	2201      	movs	r2, #1
    5fb6:	4013      	ands	r3, r2
    5fb8:	1e5a      	subs	r2, r3, #1
    5fba:	4193      	sbcs	r3, r2
    5fbc:	b2db      	uxtb	r3, r3
}
    5fbe:	0018      	movs	r0, r3
    5fc0:	46bd      	mov	sp, r7
    5fc2:	b002      	add	sp, #8
    5fc4:	bd80      	pop	{r7, pc}

00005fc6 <hri_sysctrl_get_PCLKSR_OSC32KRDY_bit>:
{
	return (((Sysctrl *)hw)->PCLKSR.reg & SYSCTRL_PCLKSR_XOSC32KRDY) >> SYSCTRL_PCLKSR_XOSC32KRDY_Pos;
}

static inline bool hri_sysctrl_get_PCLKSR_OSC32KRDY_bit(const void *const hw)
{
    5fc6:	b580      	push	{r7, lr}
    5fc8:	b082      	sub	sp, #8
    5fca:	af00      	add	r7, sp, #0
    5fcc:	6078      	str	r0, [r7, #4]
	return (((Sysctrl *)hw)->PCLKSR.reg & SYSCTRL_PCLKSR_OSC32KRDY) >> SYSCTRL_PCLKSR_OSC32KRDY_Pos;
    5fce:	687b      	ldr	r3, [r7, #4]
    5fd0:	68db      	ldr	r3, [r3, #12]
    5fd2:	089b      	lsrs	r3, r3, #2
    5fd4:	2201      	movs	r2, #1
    5fd6:	4013      	ands	r3, r2
    5fd8:	1e5a      	subs	r2, r3, #1
    5fda:	4193      	sbcs	r3, r2
    5fdc:	b2db      	uxtb	r3, r3
}
    5fde:	0018      	movs	r0, r3
    5fe0:	46bd      	mov	sp, r7
    5fe2:	b002      	add	sp, #8
    5fe4:	bd80      	pop	{r7, pc}

00005fe6 <hri_sysctrl_get_PCLKSR_OSC8MRDY_bit>:

static inline bool hri_sysctrl_get_PCLKSR_OSC8MRDY_bit(const void *const hw)
{
    5fe6:	b580      	push	{r7, lr}
    5fe8:	b082      	sub	sp, #8
    5fea:	af00      	add	r7, sp, #0
    5fec:	6078      	str	r0, [r7, #4]
	return (((Sysctrl *)hw)->PCLKSR.reg & SYSCTRL_PCLKSR_OSC8MRDY) >> SYSCTRL_PCLKSR_OSC8MRDY_Pos;
    5fee:	687b      	ldr	r3, [r7, #4]
    5ff0:	68db      	ldr	r3, [r3, #12]
    5ff2:	08db      	lsrs	r3, r3, #3
    5ff4:	2201      	movs	r2, #1
    5ff6:	4013      	ands	r3, r2
    5ff8:	1e5a      	subs	r2, r3, #1
    5ffa:	4193      	sbcs	r3, r2
    5ffc:	b2db      	uxtb	r3, r3
}
    5ffe:	0018      	movs	r0, r3
    6000:	46bd      	mov	sp, r7
    6002:	b002      	add	sp, #8
    6004:	bd80      	pop	{r7, pc}

00006006 <hri_sysctrl_get_PCLKSR_DFLLRDY_bit>:

static inline bool hri_sysctrl_get_PCLKSR_DFLLRDY_bit(const void *const hw)
{
    6006:	b580      	push	{r7, lr}
    6008:	b082      	sub	sp, #8
    600a:	af00      	add	r7, sp, #0
    600c:	6078      	str	r0, [r7, #4]
	return (((Sysctrl *)hw)->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY) >> SYSCTRL_PCLKSR_DFLLRDY_Pos;
    600e:	687b      	ldr	r3, [r7, #4]
    6010:	68db      	ldr	r3, [r3, #12]
    6012:	091b      	lsrs	r3, r3, #4
    6014:	2201      	movs	r2, #1
    6016:	4013      	ands	r3, r2
    6018:	1e5a      	subs	r2, r3, #1
    601a:	4193      	sbcs	r3, r2
    601c:	b2db      	uxtb	r3, r3
}
    601e:	0018      	movs	r0, r3
    6020:	46bd      	mov	sp, r7
    6022:	b002      	add	sp, #8
    6024:	bd80      	pop	{r7, pc}

00006026 <hri_sysctrl_get_PCLKSR_reg>:
{
	return (((Sysctrl *)hw)->PCLKSR.reg & SYSCTRL_PCLKSR_B33SRDY) >> SYSCTRL_PCLKSR_B33SRDY_Pos;
}

static inline hri_sysctrl_pclksr_reg_t hri_sysctrl_get_PCLKSR_reg(const void *const hw, hri_sysctrl_pclksr_reg_t mask)
{
    6026:	b580      	push	{r7, lr}
    6028:	b084      	sub	sp, #16
    602a:	af00      	add	r7, sp, #0
    602c:	6078      	str	r0, [r7, #4]
    602e:	6039      	str	r1, [r7, #0]
	uint32_t tmp;
	tmp = ((Sysctrl *)hw)->PCLKSR.reg;
    6030:	687b      	ldr	r3, [r7, #4]
    6032:	68db      	ldr	r3, [r3, #12]
    6034:	60fb      	str	r3, [r7, #12]
	tmp &= mask;
    6036:	68fb      	ldr	r3, [r7, #12]
    6038:	683a      	ldr	r2, [r7, #0]
    603a:	4013      	ands	r3, r2
    603c:	60fb      	str	r3, [r7, #12]
	return tmp;
    603e:	68fb      	ldr	r3, [r7, #12]
}
    6040:	0018      	movs	r0, r3
    6042:	46bd      	mov	sp, r7
    6044:	b004      	add	sp, #16
    6046:	bd80      	pop	{r7, pc}

00006048 <hri_sysctrl_set_OSC32K_ONDEMAND_bit>:
	((Sysctrl *)hw)->OSC32K.reg ^= SYSCTRL_OSC32K_RUNSTDBY;
	SYSCTRL_CRITICAL_SECTION_LEAVE();
}

static inline void hri_sysctrl_set_OSC32K_ONDEMAND_bit(const void *const hw)
{
    6048:	b580      	push	{r7, lr}
    604a:	b082      	sub	sp, #8
    604c:	af00      	add	r7, sp, #0
    604e:	6078      	str	r0, [r7, #4]
	SYSCTRL_CRITICAL_SECTION_ENTER();
	((Sysctrl *)hw)->OSC32K.reg |= SYSCTRL_OSC32K_ONDEMAND;
    6050:	687b      	ldr	r3, [r7, #4]
    6052:	699b      	ldr	r3, [r3, #24]
    6054:	2280      	movs	r2, #128	; 0x80
    6056:	431a      	orrs	r2, r3
    6058:	687b      	ldr	r3, [r7, #4]
    605a:	619a      	str	r2, [r3, #24]
	SYSCTRL_CRITICAL_SECTION_LEAVE();
}
    605c:	46c0      	nop			; (mov r8, r8)
    605e:	46bd      	mov	sp, r7
    6060:	b002      	add	sp, #8
    6062:	bd80      	pop	{r7, pc}

00006064 <hri_sysctrl_read_OSC32K_CALIB_bf>:
	((Sysctrl *)hw)->OSC32K.reg ^= SYSCTRL_OSC32K_CALIB(mask);
	SYSCTRL_CRITICAL_SECTION_LEAVE();
}

static inline hri_sysctrl_osc32k_reg_t hri_sysctrl_read_OSC32K_CALIB_bf(const void *const hw)
{
    6064:	b580      	push	{r7, lr}
    6066:	b084      	sub	sp, #16
    6068:	af00      	add	r7, sp, #0
    606a:	6078      	str	r0, [r7, #4]
	uint32_t tmp;
	tmp = ((Sysctrl *)hw)->OSC32K.reg;
    606c:	687b      	ldr	r3, [r7, #4]
    606e:	699b      	ldr	r3, [r3, #24]
    6070:	60fb      	str	r3, [r7, #12]
	tmp = (tmp & SYSCTRL_OSC32K_CALIB_Msk) >> SYSCTRL_OSC32K_CALIB_Pos;
    6072:	68fb      	ldr	r3, [r7, #12]
    6074:	0c1b      	lsrs	r3, r3, #16
    6076:	227f      	movs	r2, #127	; 0x7f
    6078:	4013      	ands	r3, r2
    607a:	60fb      	str	r3, [r7, #12]
	return tmp;
    607c:	68fb      	ldr	r3, [r7, #12]
}
    607e:	0018      	movs	r0, r3
    6080:	46bd      	mov	sp, r7
    6082:	b004      	add	sp, #16
    6084:	bd80      	pop	{r7, pc}

00006086 <hri_sysctrl_write_OSC32K_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sysctrl_write_OSC32K_reg(const void *const hw, hri_sysctrl_osc32k_reg_t data)
{
    6086:	b580      	push	{r7, lr}
    6088:	b082      	sub	sp, #8
    608a:	af00      	add	r7, sp, #0
    608c:	6078      	str	r0, [r7, #4]
    608e:	6039      	str	r1, [r7, #0]
	SYSCTRL_CRITICAL_SECTION_ENTER();
	((Sysctrl *)hw)->OSC32K.reg = data;
    6090:	687b      	ldr	r3, [r7, #4]
    6092:	683a      	ldr	r2, [r7, #0]
    6094:	619a      	str	r2, [r3, #24]
	SYSCTRL_CRITICAL_SECTION_LEAVE();
}
    6096:	46c0      	nop			; (mov r8, r8)
    6098:	46bd      	mov	sp, r7
    609a:	b002      	add	sp, #8
    609c:	bd80      	pop	{r7, pc}

0000609e <hri_sysctrl_read_OSCULP32K_CALIB_bf>:
	((Sysctrl *)hw)->OSCULP32K.reg ^= SYSCTRL_OSCULP32K_CALIB(mask);
	SYSCTRL_CRITICAL_SECTION_LEAVE();
}

static inline hri_sysctrl_osculp32k_reg_t hri_sysctrl_read_OSCULP32K_CALIB_bf(const void *const hw)
{
    609e:	b580      	push	{r7, lr}
    60a0:	b084      	sub	sp, #16
    60a2:	af00      	add	r7, sp, #0
    60a4:	6078      	str	r0, [r7, #4]
	uint8_t tmp;
	tmp = ((Sysctrl *)hw)->OSCULP32K.reg;
    60a6:	230f      	movs	r3, #15
    60a8:	18fb      	adds	r3, r7, r3
    60aa:	687a      	ldr	r2, [r7, #4]
    60ac:	7f12      	ldrb	r2, [r2, #28]
    60ae:	701a      	strb	r2, [r3, #0]
	tmp = (tmp & SYSCTRL_OSCULP32K_CALIB_Msk) >> SYSCTRL_OSCULP32K_CALIB_Pos;
    60b0:	230f      	movs	r3, #15
    60b2:	18fb      	adds	r3, r7, r3
    60b4:	220f      	movs	r2, #15
    60b6:	18ba      	adds	r2, r7, r2
    60b8:	7812      	ldrb	r2, [r2, #0]
    60ba:	211f      	movs	r1, #31
    60bc:	400a      	ands	r2, r1
    60be:	701a      	strb	r2, [r3, #0]
	return tmp;
    60c0:	230f      	movs	r3, #15
    60c2:	18fb      	adds	r3, r7, r3
    60c4:	781b      	ldrb	r3, [r3, #0]
}
    60c6:	0018      	movs	r0, r3
    60c8:	46bd      	mov	sp, r7
    60ca:	b004      	add	sp, #16
    60cc:	bd80      	pop	{r7, pc}

000060ce <hri_sysctrl_write_OSCULP32K_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sysctrl_write_OSCULP32K_reg(const void *const hw, hri_sysctrl_osculp32k_reg_t data)
{
    60ce:	b580      	push	{r7, lr}
    60d0:	b082      	sub	sp, #8
    60d2:	af00      	add	r7, sp, #0
    60d4:	6078      	str	r0, [r7, #4]
    60d6:	000a      	movs	r2, r1
    60d8:	1cfb      	adds	r3, r7, #3
    60da:	701a      	strb	r2, [r3, #0]
	SYSCTRL_CRITICAL_SECTION_ENTER();
	((Sysctrl *)hw)->OSCULP32K.reg = data;
    60dc:	687b      	ldr	r3, [r7, #4]
    60de:	1cfa      	adds	r2, r7, #3
    60e0:	7812      	ldrb	r2, [r2, #0]
    60e2:	771a      	strb	r2, [r3, #28]
	SYSCTRL_CRITICAL_SECTION_LEAVE();
}
    60e4:	46c0      	nop			; (mov r8, r8)
    60e6:	46bd      	mov	sp, r7
    60e8:	b002      	add	sp, #8
    60ea:	bd80      	pop	{r7, pc}

000060ec <hri_sysctrl_set_OSC8M_ONDEMAND_bit>:
	((Sysctrl *)hw)->OSC8M.reg ^= SYSCTRL_OSC8M_RUNSTDBY;
	SYSCTRL_CRITICAL_SECTION_LEAVE();
}

static inline void hri_sysctrl_set_OSC8M_ONDEMAND_bit(const void *const hw)
{
    60ec:	b580      	push	{r7, lr}
    60ee:	b082      	sub	sp, #8
    60f0:	af00      	add	r7, sp, #0
    60f2:	6078      	str	r0, [r7, #4]
	SYSCTRL_CRITICAL_SECTION_ENTER();
	((Sysctrl *)hw)->OSC8M.reg |= SYSCTRL_OSC8M_ONDEMAND;
    60f4:	687b      	ldr	r3, [r7, #4]
    60f6:	6a1b      	ldr	r3, [r3, #32]
    60f8:	2280      	movs	r2, #128	; 0x80
    60fa:	431a      	orrs	r2, r3
    60fc:	687b      	ldr	r3, [r7, #4]
    60fe:	621a      	str	r2, [r3, #32]
	SYSCTRL_CRITICAL_SECTION_LEAVE();
}
    6100:	46c0      	nop			; (mov r8, r8)
    6102:	46bd      	mov	sp, r7
    6104:	b002      	add	sp, #8
    6106:	bd80      	pop	{r7, pc}

00006108 <hri_sysctrl_read_OSC8M_CALIB_bf>:
	((Sysctrl *)hw)->OSC8M.reg ^= SYSCTRL_OSC8M_CALIB(mask);
	SYSCTRL_CRITICAL_SECTION_LEAVE();
}

static inline hri_sysctrl_osc8m_reg_t hri_sysctrl_read_OSC8M_CALIB_bf(const void *const hw)
{
    6108:	b580      	push	{r7, lr}
    610a:	b084      	sub	sp, #16
    610c:	af00      	add	r7, sp, #0
    610e:	6078      	str	r0, [r7, #4]
	uint32_t tmp;
	tmp = ((Sysctrl *)hw)->OSC8M.reg;
    6110:	687b      	ldr	r3, [r7, #4]
    6112:	6a1b      	ldr	r3, [r3, #32]
    6114:	60fb      	str	r3, [r7, #12]
	tmp = (tmp & SYSCTRL_OSC8M_CALIB_Msk) >> SYSCTRL_OSC8M_CALIB_Pos;
    6116:	68fb      	ldr	r3, [r7, #12]
    6118:	0c1b      	lsrs	r3, r3, #16
    611a:	051b      	lsls	r3, r3, #20
    611c:	0d1b      	lsrs	r3, r3, #20
    611e:	60fb      	str	r3, [r7, #12]
	return tmp;
    6120:	68fb      	ldr	r3, [r7, #12]
}
    6122:	0018      	movs	r0, r3
    6124:	46bd      	mov	sp, r7
    6126:	b004      	add	sp, #16
    6128:	bd80      	pop	{r7, pc}

0000612a <hri_sysctrl_read_OSC8M_FRANGE_bf>:
	((Sysctrl *)hw)->OSC8M.reg ^= SYSCTRL_OSC8M_FRANGE(mask);
	SYSCTRL_CRITICAL_SECTION_LEAVE();
}

static inline hri_sysctrl_osc8m_reg_t hri_sysctrl_read_OSC8M_FRANGE_bf(const void *const hw)
{
    612a:	b580      	push	{r7, lr}
    612c:	b084      	sub	sp, #16
    612e:	af00      	add	r7, sp, #0
    6130:	6078      	str	r0, [r7, #4]
	uint32_t tmp;
	tmp = ((Sysctrl *)hw)->OSC8M.reg;
    6132:	687b      	ldr	r3, [r7, #4]
    6134:	6a1b      	ldr	r3, [r3, #32]
    6136:	60fb      	str	r3, [r7, #12]
	tmp = (tmp & SYSCTRL_OSC8M_FRANGE_Msk) >> SYSCTRL_OSC8M_FRANGE_Pos;
    6138:	68fb      	ldr	r3, [r7, #12]
    613a:	0f9b      	lsrs	r3, r3, #30
    613c:	60fb      	str	r3, [r7, #12]
	return tmp;
    613e:	68fb      	ldr	r3, [r7, #12]
}
    6140:	0018      	movs	r0, r3
    6142:	46bd      	mov	sp, r7
    6144:	b004      	add	sp, #16
    6146:	bd80      	pop	{r7, pc}

00006148 <hri_sysctrl_write_OSC8M_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sysctrl_write_OSC8M_reg(const void *const hw, hri_sysctrl_osc8m_reg_t data)
{
    6148:	b580      	push	{r7, lr}
    614a:	b082      	sub	sp, #8
    614c:	af00      	add	r7, sp, #0
    614e:	6078      	str	r0, [r7, #4]
    6150:	6039      	str	r1, [r7, #0]
	SYSCTRL_CRITICAL_SECTION_ENTER();
	((Sysctrl *)hw)->OSC8M.reg = data;
    6152:	687b      	ldr	r3, [r7, #4]
    6154:	683a      	ldr	r2, [r7, #0]
    6156:	621a      	str	r2, [r3, #32]
	SYSCTRL_CRITICAL_SECTION_LEAVE();
}
    6158:	46c0      	nop			; (mov r8, r8)
    615a:	46bd      	mov	sp, r7
    615c:	b002      	add	sp, #8
    615e:	bd80      	pop	{r7, pc}

00006160 <hri_sysctrl_get_DFLLCTRL_MODE_bit>:
	((Sysctrl *)hw)->DFLLCTRL.reg |= SYSCTRL_DFLLCTRL_MODE;
	SYSCTRL_CRITICAL_SECTION_LEAVE();
}

static inline bool hri_sysctrl_get_DFLLCTRL_MODE_bit(const void *const hw)
{
    6160:	b580      	push	{r7, lr}
    6162:	b084      	sub	sp, #16
    6164:	af00      	add	r7, sp, #0
    6166:	6078      	str	r0, [r7, #4]
	uint16_t tmp;
	tmp = ((Sysctrl *)hw)->DFLLCTRL.reg;
    6168:	230e      	movs	r3, #14
    616a:	18fb      	adds	r3, r7, r3
    616c:	687a      	ldr	r2, [r7, #4]
    616e:	8c92      	ldrh	r2, [r2, #36]	; 0x24
    6170:	801a      	strh	r2, [r3, #0]
	tmp = (tmp & SYSCTRL_DFLLCTRL_MODE) >> SYSCTRL_DFLLCTRL_MODE_Pos;
    6172:	230e      	movs	r3, #14
    6174:	18fb      	adds	r3, r7, r3
    6176:	881b      	ldrh	r3, [r3, #0]
    6178:	089b      	lsrs	r3, r3, #2
    617a:	b29a      	uxth	r2, r3
    617c:	230e      	movs	r3, #14
    617e:	18fb      	adds	r3, r7, r3
    6180:	2101      	movs	r1, #1
    6182:	400a      	ands	r2, r1
    6184:	801a      	strh	r2, [r3, #0]
	return (bool)tmp;
    6186:	230e      	movs	r3, #14
    6188:	18fb      	adds	r3, r7, r3
    618a:	881b      	ldrh	r3, [r3, #0]
    618c:	1e5a      	subs	r2, r3, #1
    618e:	4193      	sbcs	r3, r2
    6190:	b2db      	uxtb	r3, r3
}
    6192:	0018      	movs	r0, r3
    6194:	46bd      	mov	sp, r7
    6196:	b004      	add	sp, #16
    6198:	bd80      	pop	{r7, pc}

0000619a <hri_sysctrl_set_DFLLCTRL_ONDEMAND_bit>:
	((Sysctrl *)hw)->DFLLCTRL.reg ^= SYSCTRL_DFLLCTRL_RUNSTDBY;
	SYSCTRL_CRITICAL_SECTION_LEAVE();
}

static inline void hri_sysctrl_set_DFLLCTRL_ONDEMAND_bit(const void *const hw)
{
    619a:	b580      	push	{r7, lr}
    619c:	b082      	sub	sp, #8
    619e:	af00      	add	r7, sp, #0
    61a0:	6078      	str	r0, [r7, #4]
	SYSCTRL_CRITICAL_SECTION_ENTER();
	((Sysctrl *)hw)->DFLLCTRL.reg |= SYSCTRL_DFLLCTRL_ONDEMAND;
    61a2:	687b      	ldr	r3, [r7, #4]
    61a4:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
    61a6:	b29b      	uxth	r3, r3
    61a8:	2280      	movs	r2, #128	; 0x80
    61aa:	4313      	orrs	r3, r2
    61ac:	b29a      	uxth	r2, r3
    61ae:	687b      	ldr	r3, [r7, #4]
    61b0:	849a      	strh	r2, [r3, #36]	; 0x24
	SYSCTRL_CRITICAL_SECTION_LEAVE();
}
    61b2:	46c0      	nop			; (mov r8, r8)
    61b4:	46bd      	mov	sp, r7
    61b6:	b002      	add	sp, #8
    61b8:	bd80      	pop	{r7, pc}

000061ba <hri_sysctrl_write_DFLLCTRL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sysctrl_write_DFLLCTRL_reg(const void *const hw, hri_sysctrl_dfllctrl_reg_t data)
{
    61ba:	b580      	push	{r7, lr}
    61bc:	b082      	sub	sp, #8
    61be:	af00      	add	r7, sp, #0
    61c0:	6078      	str	r0, [r7, #4]
    61c2:	000a      	movs	r2, r1
    61c4:	1cbb      	adds	r3, r7, #2
    61c6:	801a      	strh	r2, [r3, #0]
	SYSCTRL_CRITICAL_SECTION_ENTER();
	((Sysctrl *)hw)->DFLLCTRL.reg = data;
    61c8:	687b      	ldr	r3, [r7, #4]
    61ca:	1cba      	adds	r2, r7, #2
    61cc:	8812      	ldrh	r2, [r2, #0]
    61ce:	849a      	strh	r2, [r3, #36]	; 0x24
	SYSCTRL_CRITICAL_SECTION_LEAVE();
}
    61d0:	46c0      	nop			; (mov r8, r8)
    61d2:	46bd      	mov	sp, r7
    61d4:	b002      	add	sp, #8
    61d6:	bd80      	pop	{r7, pc}

000061d8 <hri_sysctrl_write_DFLLVAL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sysctrl_write_DFLLVAL_reg(const void *const hw, hri_sysctrl_dfllval_reg_t data)
{
    61d8:	b580      	push	{r7, lr}
    61da:	b082      	sub	sp, #8
    61dc:	af00      	add	r7, sp, #0
    61de:	6078      	str	r0, [r7, #4]
    61e0:	6039      	str	r1, [r7, #0]
	SYSCTRL_CRITICAL_SECTION_ENTER();
	((Sysctrl *)hw)->DFLLVAL.reg = data;
    61e2:	687b      	ldr	r3, [r7, #4]
    61e4:	683a      	ldr	r2, [r7, #0]
    61e6:	629a      	str	r2, [r3, #40]	; 0x28
	SYSCTRL_CRITICAL_SECTION_LEAVE();
}
    61e8:	46c0      	nop			; (mov r8, r8)
    61ea:	46bd      	mov	sp, r7
    61ec:	b002      	add	sp, #8
    61ee:	bd80      	pop	{r7, pc}

000061f0 <hri_sysctrl_write_DFLLMUL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sysctrl_write_DFLLMUL_reg(const void *const hw, hri_sysctrl_dfllmul_reg_t data)
{
    61f0:	b580      	push	{r7, lr}
    61f2:	b082      	sub	sp, #8
    61f4:	af00      	add	r7, sp, #0
    61f6:	6078      	str	r0, [r7, #4]
    61f8:	6039      	str	r1, [r7, #0]
	SYSCTRL_CRITICAL_SECTION_ENTER();
	((Sysctrl *)hw)->DFLLMUL.reg = data;
    61fa:	687b      	ldr	r3, [r7, #4]
    61fc:	683a      	ldr	r2, [r7, #0]
    61fe:	62da      	str	r2, [r3, #44]	; 0x2c
	SYSCTRL_CRITICAL_SECTION_LEAVE();
}
    6200:	46c0      	nop			; (mov r8, r8)
    6202:	46bd      	mov	sp, r7
    6204:	b002      	add	sp, #8
    6206:	bd80      	pop	{r7, pc}

00006208 <_sysctrl_init_sources>:
 * \brief Initializes clock generators
 *
 * All GCLK generators are running when this function returns.
 */
void _sysctrl_init_sources(void)
{
    6208:	b580      	push	{r7, lr}
    620a:	b082      	sub	sp, #8
    620c:	af00      	add	r7, sp, #0
	void *   hw = (void *)SYSCTRL;
    620e:	4b34      	ldr	r3, [pc, #208]	; (62e0 <_sysctrl_init_sources+0xd8>)
    6210:	607b      	str	r3, [r7, #4]
	        | (CONF_XOSC_RUNSTDBY << SYSCTRL_XOSC_RUNSTDBY_Pos) | (CONF_XOSC_XTALEN << SYSCTRL_XOSC_XTALEN_Pos)
	        | (CONF_XOSC_ENABLE << SYSCTRL_XOSC_ENABLE_Pos));
#endif

#if CONF_OSC8M_CONFIG == 1
	calib = hri_sysctrl_read_OSC8M_CALIB_bf(hw);
    6212:	687b      	ldr	r3, [r7, #4]
    6214:	0018      	movs	r0, r3
    6216:	f7ff ff77 	bl	6108 <hri_sysctrl_read_OSC8M_CALIB_bf>
    621a:	0002      	movs	r2, r0
    621c:	1cbb      	adds	r3, r7, #2
    621e:	801a      	strh	r2, [r3, #0]

	hri_sysctrl_write_OSC8M_reg(hw,
	                            SYSCTRL_OSC8M_FRANGE(hri_sysctrl_read_OSC8M_FRANGE_bf(hw)) |
    6220:	687b      	ldr	r3, [r7, #4]
    6222:	0018      	movs	r0, r3
    6224:	f7ff ff81 	bl	612a <hri_sysctrl_read_OSC8M_FRANGE_bf>
    6228:	0003      	movs	r3, r0
    622a:	079a      	lsls	r2, r3, #30
#if CONF_OSC8M_OVERWRITE_CALIBRATION == 1
	                                SYSCTRL_OSC8M_CALIB(CONF_OSC8M_CALIB) |
#else
	                                SYSCTRL_OSC8M_CALIB(calib) |
    622c:	1cbb      	adds	r3, r7, #2
    622e:	881b      	ldrh	r3, [r3, #0]
    6230:	041b      	lsls	r3, r3, #16
    6232:	0019      	movs	r1, r3
    6234:	4b2b      	ldr	r3, [pc, #172]	; (62e4 <_sysctrl_init_sources+0xdc>)
    6236:	400b      	ands	r3, r1
	                            SYSCTRL_OSC8M_FRANGE(hri_sysctrl_read_OSC8M_FRANGE_bf(hw)) |
    6238:	4313      	orrs	r3, r2
	hri_sysctrl_write_OSC8M_reg(hw,
    623a:	4a2b      	ldr	r2, [pc, #172]	; (62e8 <_sysctrl_init_sources+0xe0>)
    623c:	431a      	orrs	r2, r3
    623e:	687b      	ldr	r3, [r7, #4]
    6240:	0011      	movs	r1, r2
    6242:	0018      	movs	r0, r3
    6244:	f7ff ff80 	bl	6148 <hri_sysctrl_write_OSC8M_reg>
	                                | (CONF_OSC8M_RUNSTDBY << SYSCTRL_OSC8M_RUNSTDBY_Pos)
	                                | (CONF_OSC8M_ENABLE << SYSCTRL_OSC8M_ENABLE_Pos));
#endif

#if CONF_OSC32K_CONFIG == 1
	calib = hri_sysctrl_read_OSC32K_CALIB_bf(hw);
    6248:	687b      	ldr	r3, [r7, #4]
    624a:	0018      	movs	r0, r3
    624c:	f7ff ff0a 	bl	6064 <hri_sysctrl_read_OSC32K_CALIB_bf>
    6250:	0002      	movs	r2, r0
    6252:	1cbb      	adds	r3, r7, #2
    6254:	801a      	strh	r2, [r3, #0]
	hri_sysctrl_write_OSC32K_reg(
	    hw,
#if CONF_OSC32K_OVERWRITE_CALIBRATION == 1
	    SYSCTRL_OSC32K_CALIB(CONF_OSC32K_CALIB) |
#else
	    SYSCTRL_OSC32K_CALIB(calib) |
    6256:	1cbb      	adds	r3, r7, #2
    6258:	881b      	ldrh	r3, [r3, #0]
    625a:	041b      	lsls	r3, r3, #16
    625c:	001a      	movs	r2, r3
#endif
	        (CONF_OSC32K_WRTLOCK << SYSCTRL_OSC32K_WRTLOCK_Pos) | SYSCTRL_OSC32K_STARTUP(CONF_OSC32K_STARTUP)
	        | (CONF_OSC32K_RUNSTDBY << SYSCTRL_OSC32K_RUNSTDBY_Pos) | (CONF_OSC32K_EN1K << SYSCTRL_OSC32K_EN1K_Pos)
    625e:	23fe      	movs	r3, #254	; 0xfe
    6260:	03db      	lsls	r3, r3, #15
    6262:	4013      	ands	r3, r2
	        | (CONF_OSC32K_EN32K << SYSCTRL_OSC32K_EN32K_Pos) | (1 << SYSCTRL_OSC32K_ENABLE_Pos));
    6264:	220e      	movs	r2, #14
    6266:	431a      	orrs	r2, r3
	hri_sysctrl_write_OSC32K_reg(
    6268:	687b      	ldr	r3, [r7, #4]
    626a:	0011      	movs	r1, r2
    626c:	0018      	movs	r0, r3
    626e:	f7ff ff0a 	bl	6086 <hri_sysctrl_write_OSC32K_reg>
	/* Enable OSC32K anyway since GCLK configuration may need it to sync */
	hri_sysctrl_set_OSC32K_ENABLE_bit(hw);
#endif

#if CONF_OSCULP32K_CONFIG == 1
	calib = hri_sysctrl_read_OSCULP32K_CALIB_bf(hw);
    6272:	687b      	ldr	r3, [r7, #4]
    6274:	0018      	movs	r0, r3
    6276:	f7ff ff12 	bl	609e <hri_sysctrl_read_OSCULP32K_CALIB_bf>
    627a:	0003      	movs	r3, r0
    627c:	001a      	movs	r2, r3
    627e:	1cbb      	adds	r3, r7, #2
    6280:	801a      	strh	r2, [r3, #0]

	hri_sysctrl_write_OSCULP32K_reg(hw,
    6282:	1cbb      	adds	r3, r7, #2
    6284:	881b      	ldrh	r3, [r3, #0]
    6286:	b2db      	uxtb	r3, r3
    6288:	221f      	movs	r2, #31
    628a:	4013      	ands	r3, r2
    628c:	b2da      	uxtb	r2, r3
    628e:	687b      	ldr	r3, [r7, #4]
    6290:	0011      	movs	r1, r2
    6292:	0018      	movs	r0, r3
    6294:	f7ff ff1b 	bl	60ce <hri_sysctrl_write_OSCULP32K_reg>
#endif
#endif

#if CONF_OSC32K_CONFIG == 1
#if CONF_OSC32K_ENABLE == 1
	while (!hri_sysctrl_get_PCLKSR_OSC32KRDY_bit(hw))
    6298:	46c0      	nop			; (mov r8, r8)
    629a:	687b      	ldr	r3, [r7, #4]
    629c:	0018      	movs	r0, r3
    629e:	f7ff fe92 	bl	5fc6 <hri_sysctrl_get_PCLKSR_OSC32KRDY_bit>
    62a2:	0003      	movs	r3, r0
    62a4:	001a      	movs	r2, r3
    62a6:	2301      	movs	r3, #1
    62a8:	4053      	eors	r3, r2
    62aa:	b2db      	uxtb	r3, r3
    62ac:	2b00      	cmp	r3, #0
    62ae:	d1f4      	bne.n	629a <_sysctrl_init_sources+0x92>
		;
#endif
#if CONF_OSC32K_ONDEMAND == 1
	hri_sysctrl_set_OSC32K_ONDEMAND_bit(hw);
    62b0:	687b      	ldr	r3, [r7, #4]
    62b2:	0018      	movs	r0, r3
    62b4:	f7ff fec8 	bl	6048 <hri_sysctrl_set_OSC32K_ONDEMAND_bit>
#endif
#endif

#if CONF_OSC8M_CONFIG == 1
#if CONF_OSC8M_ENABLE == 1
	while (!hri_sysctrl_get_PCLKSR_OSC8MRDY_bit(hw))
    62b8:	46c0      	nop			; (mov r8, r8)
    62ba:	687b      	ldr	r3, [r7, #4]
    62bc:	0018      	movs	r0, r3
    62be:	f7ff fe92 	bl	5fe6 <hri_sysctrl_get_PCLKSR_OSC8MRDY_bit>
    62c2:	0003      	movs	r3, r0
    62c4:	001a      	movs	r2, r3
    62c6:	2301      	movs	r3, #1
    62c8:	4053      	eors	r3, r2
    62ca:	b2db      	uxtb	r3, r3
    62cc:	2b00      	cmp	r3, #0
    62ce:	d1f4      	bne.n	62ba <_sysctrl_init_sources+0xb2>
		;
#endif
#if CONF_OSC8M_ONDEMAND == 1
	hri_sysctrl_set_OSC8M_ONDEMAND_bit(hw);
    62d0:	687b      	ldr	r3, [r7, #4]
    62d2:	0018      	movs	r0, r3
    62d4:	f7ff ff0a 	bl	60ec <hri_sysctrl_set_OSC8M_ONDEMAND_bit>
#endif
#endif

	(void)calib, (void)hw;
}
    62d8:	46c0      	nop			; (mov r8, r8)
    62da:	46bd      	mov	sp, r7
    62dc:	b002      	add	sp, #8
    62de:	bd80      	pop	{r7, pc}
    62e0:	40000800 	.word	0x40000800
    62e4:	0fff0000 	.word	0x0fff0000
    62e8:	00000302 	.word	0x00000302

000062ec <_sysctrl_init_referenced_generators>:

void _sysctrl_init_referenced_generators(void)
{
    62ec:	b580      	push	{r7, lr}
    62ee:	b084      	sub	sp, #16
    62f0:	af00      	add	r7, sp, #0
	void *hw = (void *)SYSCTRL;
    62f2:	4b35      	ldr	r3, [pc, #212]	; (63c8 <_sysctrl_init_referenced_generators+0xdc>)
    62f4:	60fb      	str	r3, [r7, #12]
#if CONF_DFLL_MODE != CONF_DFLL_OPEN_LOOP_MODE
	hri_gclk_write_CLKCTRL_reg(GCLK,
	                           GCLK_CLKCTRL_ID(0) | GCLK_CLKCTRL_GEN(CONF_DFLL_GCLK) | (1 << GCLK_CLKCTRL_CLKEN_Pos));
#endif

	hri_sysctrl_write_DFLLCTRL_reg(hw, SYSCTRL_DFLLCTRL_ENABLE);
    62f6:	68fb      	ldr	r3, [r7, #12]
    62f8:	2102      	movs	r1, #2
    62fa:	0018      	movs	r0, r3
    62fc:	f7ff ff5d 	bl	61ba <hri_sysctrl_write_DFLLCTRL_reg>
	while (!hri_sysctrl_get_PCLKSR_DFLLRDY_bit(hw))
    6300:	46c0      	nop			; (mov r8, r8)
    6302:	68fb      	ldr	r3, [r7, #12]
    6304:	0018      	movs	r0, r3
    6306:	f7ff fe7e 	bl	6006 <hri_sysctrl_get_PCLKSR_DFLLRDY_bit>
    630a:	0003      	movs	r3, r0
    630c:	001a      	movs	r2, r3
    630e:	2301      	movs	r3, #1
    6310:	4053      	eors	r3, r2
    6312:	b2db      	uxtb	r3, r3
    6314:	2b00      	cmp	r3, #0
    6316:	d1f4      	bne.n	6302 <_sysctrl_init_referenced_generators+0x16>
		;

	hri_sysctrl_write_DFLLMUL_reg(hw,
    6318:	4a2c      	ldr	r2, [pc, #176]	; (63cc <_sysctrl_init_referenced_generators+0xe0>)
    631a:	68fb      	ldr	r3, [r7, #12]
    631c:	0011      	movs	r1, r2
    631e:	0018      	movs	r0, r3
    6320:	f7ff ff66 	bl	61f0 <hri_sysctrl_write_DFLLMUL_reg>
	                              SYSCTRL_DFLLMUL_CSTEP(CONF_DFLL_CSTEP) | SYSCTRL_DFLLMUL_FSTEP(CONF_DFLL_FSTEP)
	                                  | SYSCTRL_DFLLMUL_MUL(CONF_DFLL_MUL));
	hri_sysctrl_write_DFLLVAL_reg(hw, CONF_DFLLVAL);
    6324:	4b2a      	ldr	r3, [pc, #168]	; (63d0 <_sysctrl_init_referenced_generators+0xe4>)
    6326:	681b      	ldr	r3, [r3, #0]
    6328:	0e9b      	lsrs	r3, r3, #26
    632a:	2b3f      	cmp	r3, #63	; 0x3f
    632c:	d009      	beq.n	6342 <_sysctrl_init_referenced_generators+0x56>
    632e:	4b28      	ldr	r3, [pc, #160]	; (63d0 <_sysctrl_init_referenced_generators+0xe4>)
    6330:	681b      	ldr	r3, [r3, #0]
    6332:	0e9b      	lsrs	r3, r3, #26
    6334:	029b      	lsls	r3, r3, #10
    6336:	041b      	lsls	r3, r3, #16
    6338:	0c1b      	lsrs	r3, r3, #16
    633a:	2280      	movs	r2, #128	; 0x80
    633c:	0092      	lsls	r2, r2, #2
    633e:	4313      	orrs	r3, r2
    6340:	e001      	b.n	6346 <_sysctrl_init_referenced_generators+0x5a>
    6342:	23fc      	movs	r3, #252	; 0xfc
    6344:	01db      	lsls	r3, r3, #7
    6346:	68fa      	ldr	r2, [r7, #12]
    6348:	0019      	movs	r1, r3
    634a:	0010      	movs	r0, r2
    634c:	f7ff ff44 	bl	61d8 <hri_sysctrl_write_DFLLVAL_reg>

	hri_sysctrl_dfllctrl_reg_t tmp
    6350:	230a      	movs	r3, #10
    6352:	18fb      	adds	r3, r7, r3
    6354:	2202      	movs	r2, #2
    6356:	801a      	strh	r2, [r3, #0]
	    = (CONF_DFLL_QLDIS << SYSCTRL_DFLLCTRL_QLDIS_Pos) | (CONF_DFLL_CCDIS << SYSCTRL_DFLLCTRL_CCDIS_Pos)
	      | (CONF_DFLL_RUNSTDBY << SYSCTRL_DFLLCTRL_RUNSTDBY_Pos) | (CONF_DFLL_LLAW << SYSCTRL_DFLLCTRL_LLAW_Pos)
	      | (CONF_DFLL_STABLE << SYSCTRL_DFLLCTRL_STABLE_Pos) | (CONF_DFLL_MODE << SYSCTRL_DFLLCTRL_MODE_Pos)
	      | (CONF_DFLL_ENABLE << SYSCTRL_DFLLCTRL_ENABLE_Pos);

	hri_sysctrl_write_DFLLCTRL_reg(hw, tmp);
    6358:	230a      	movs	r3, #10
    635a:	18fb      	adds	r3, r7, r3
    635c:	881a      	ldrh	r2, [r3, #0]
    635e:	68fb      	ldr	r3, [r7, #12]
    6360:	0011      	movs	r1, r2
    6362:	0018      	movs	r0, r3
    6364:	f7ff ff29 	bl	61ba <hri_sysctrl_write_DFLLCTRL_reg>
#endif

#if CONF_DFLL_CONFIG == 1
#if CONF_DFLL_ENABLE == 1
	if (hri_sysctrl_get_DFLLCTRL_MODE_bit(hw)) {
    6368:	68fb      	ldr	r3, [r7, #12]
    636a:	0018      	movs	r0, r3
    636c:	f7ff fef8 	bl	6160 <hri_sysctrl_get_DFLLCTRL_MODE_bit>
    6370:	1e03      	subs	r3, r0, #0
    6372:	d00d      	beq.n	6390 <_sysctrl_init_referenced_generators+0xa4>
		hri_sysctrl_pclksr_reg_t status_mask
    6374:	23d0      	movs	r3, #208	; 0xd0
    6376:	607b      	str	r3, [r7, #4]
		    = SYSCTRL_PCLKSR_DFLLRDY | SYSCTRL_PCLKSR_DFLLLCKF | SYSCTRL_PCLKSR_DFLLLCKC;

		while (hri_sysctrl_get_PCLKSR_reg(hw, status_mask) != status_mask)
    6378:	46c0      	nop			; (mov r8, r8)
    637a:	687a      	ldr	r2, [r7, #4]
    637c:	68fb      	ldr	r3, [r7, #12]
    637e:	0011      	movs	r1, r2
    6380:	0018      	movs	r0, r3
    6382:	f7ff fe50 	bl	6026 <hri_sysctrl_get_PCLKSR_reg>
    6386:	0002      	movs	r2, r0
    6388:	687b      	ldr	r3, [r7, #4]
    638a:	429a      	cmp	r2, r3
    638c:	d1f5      	bne.n	637a <_sysctrl_init_referenced_generators+0x8e>
    638e:	e00b      	b.n	63a8 <_sysctrl_init_referenced_generators+0xbc>
			;
	} else {
		while (!hri_sysctrl_get_PCLKSR_DFLLRDY_bit(hw))
    6390:	46c0      	nop			; (mov r8, r8)
    6392:	68fb      	ldr	r3, [r7, #12]
    6394:	0018      	movs	r0, r3
    6396:	f7ff fe36 	bl	6006 <hri_sysctrl_get_PCLKSR_DFLLRDY_bit>
    639a:	0003      	movs	r3, r0
    639c:	001a      	movs	r2, r3
    639e:	2301      	movs	r3, #1
    63a0:	4053      	eors	r3, r2
    63a2:	b2db      	uxtb	r3, r3
    63a4:	2b00      	cmp	r3, #0
    63a6:	d1f4      	bne.n	6392 <_sysctrl_init_referenced_generators+0xa6>
			;
	}
#endif
#if CONF_DFLL_ONDEMAND == 1
	hri_sysctrl_set_DFLLCTRL_ONDEMAND_bit(hw);
    63a8:	68fb      	ldr	r3, [r7, #12]
    63aa:	0018      	movs	r0, r3
    63ac:	f7ff fef5 	bl	619a <hri_sysctrl_set_DFLLCTRL_ONDEMAND_bit>
#endif
#endif

#if CONF_DFLL_CONFIG == 1
	while (hri_gclk_get_STATUS_SYNCBUSY_bit(GCLK))
    63b0:	46c0      	nop			; (mov r8, r8)
    63b2:	4b08      	ldr	r3, [pc, #32]	; (63d4 <_sysctrl_init_referenced_generators+0xe8>)
    63b4:	0018      	movs	r0, r3
    63b6:	f7ff fdf5 	bl	5fa4 <hri_gclk_get_STATUS_SYNCBUSY_bit>
    63ba:	1e03      	subs	r3, r0, #0
    63bc:	d1f9      	bne.n	63b2 <_sysctrl_init_referenced_generators+0xc6>
	/* Disable after all possible configurations needs sync written. */
	hri_sysctrl_clear_OSC32K_ENABLE_bit(hw);
#endif

	(void)hw;
}
    63be:	46c0      	nop			; (mov r8, r8)
    63c0:	46bd      	mov	sp, r7
    63c2:	b004      	add	sp, #16
    63c4:	bd80      	pop	{r7, pc}
    63c6:	46c0      	nop			; (mov r8, r8)
    63c8:	40000800 	.word	0x40000800
    63cc:	04010000 	.word	0x04010000
    63d0:	00806024 	.word	0x00806024
    63d4:	40000c00 	.word	0x40000c00

000063d8 <_system_time_init>:

/**
 * \brief Initialize system time module
 */
void _system_time_init(void *const hw)
{
    63d8:	b580      	push	{r7, lr}
    63da:	b082      	sub	sp, #8
    63dc:	af00      	add	r7, sp, #0
    63de:	6078      	str	r0, [r7, #4]
	(void)hw;
	SysTick->LOAD = (0xFFFFFF << SysTick_LOAD_RELOAD_Pos);
    63e0:	4b04      	ldr	r3, [pc, #16]	; (63f4 <_system_time_init+0x1c>)
    63e2:	4a05      	ldr	r2, [pc, #20]	; (63f8 <_system_time_init+0x20>)
    63e4:	605a      	str	r2, [r3, #4]
	SysTick->CTRL = (1 << SysTick_CTRL_ENABLE_Pos) | (CONF_SYSTICK_TICKINT << SysTick_CTRL_TICKINT_Pos)
    63e6:	4b03      	ldr	r3, [pc, #12]	; (63f4 <_system_time_init+0x1c>)
    63e8:	2205      	movs	r2, #5
    63ea:	601a      	str	r2, [r3, #0]
	                | (1 << SysTick_CTRL_CLKSOURCE_Pos);
}
    63ec:	46c0      	nop			; (mov r8, r8)
    63ee:	46bd      	mov	sp, r7
    63f0:	b002      	add	sp, #8
    63f2:	bd80      	pop	{r7, pc}
    63f4:	e000e010 	.word	0xe000e010
    63f8:	00ffffff 	.word	0x00ffffff

000063fc <_delay_init>:
/**
 * \brief Initialize delay functionality
 */
void _delay_init(void *const hw)
{
    63fc:	b580      	push	{r7, lr}
    63fe:	b082      	sub	sp, #8
    6400:	af00      	add	r7, sp, #0
    6402:	6078      	str	r0, [r7, #4]
	_system_time_init(hw);
    6404:	687b      	ldr	r3, [r7, #4]
    6406:	0018      	movs	r0, r3
    6408:	f7ff ffe6 	bl	63d8 <_system_time_init>
}
    640c:	46c0      	nop			; (mov r8, r8)
    640e:	46bd      	mov	sp, r7
    6410:	b002      	add	sp, #8
    6412:	bd80      	pop	{r7, pc}

00006414 <_delay_cycles>:
}
/**
 * \brief Delay loop to delay n number of cycles
 */
void _delay_cycles(void *const hw, uint32_t cycles)
{
    6414:	b580      	push	{r7, lr}
    6416:	b084      	sub	sp, #16
    6418:	af00      	add	r7, sp, #0
    641a:	6078      	str	r0, [r7, #4]
    641c:	6039      	str	r1, [r7, #0]
	(void)hw;
	uint8_t  n   = cycles >> 24;
    641e:	683b      	ldr	r3, [r7, #0]
    6420:	0e1a      	lsrs	r2, r3, #24
    6422:	230f      	movs	r3, #15
    6424:	18fb      	adds	r3, r7, r3
    6426:	701a      	strb	r2, [r3, #0]
	uint32_t buf = cycles;
    6428:	683b      	ldr	r3, [r7, #0]
    642a:	60bb      	str	r3, [r7, #8]

	while (n--) {
    642c:	e011      	b.n	6452 <_delay_cycles+0x3e>
		SysTick->LOAD = 0xFFFFFF;
    642e:	4b16      	ldr	r3, [pc, #88]	; (6488 <_delay_cycles+0x74>)
    6430:	4a16      	ldr	r2, [pc, #88]	; (648c <_delay_cycles+0x78>)
    6432:	605a      	str	r2, [r3, #4]
		SysTick->VAL  = 0xFFFFFF;
    6434:	4b14      	ldr	r3, [pc, #80]	; (6488 <_delay_cycles+0x74>)
    6436:	4a15      	ldr	r2, [pc, #84]	; (648c <_delay_cycles+0x78>)
    6438:	609a      	str	r2, [r3, #8]
		while (!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk))
    643a:	46c0      	nop			; (mov r8, r8)
    643c:	4b12      	ldr	r3, [pc, #72]	; (6488 <_delay_cycles+0x74>)
    643e:	681a      	ldr	r2, [r3, #0]
    6440:	2380      	movs	r3, #128	; 0x80
    6442:	025b      	lsls	r3, r3, #9
    6444:	4013      	ands	r3, r2
    6446:	d0f9      	beq.n	643c <_delay_cycles+0x28>
			;
		buf -= 0xFFFFFF;
    6448:	68bb      	ldr	r3, [r7, #8]
    644a:	4a11      	ldr	r2, [pc, #68]	; (6490 <_delay_cycles+0x7c>)
    644c:	4694      	mov	ip, r2
    644e:	4463      	add	r3, ip
    6450:	60bb      	str	r3, [r7, #8]
	while (n--) {
    6452:	230f      	movs	r3, #15
    6454:	18fb      	adds	r3, r7, r3
    6456:	781b      	ldrb	r3, [r3, #0]
    6458:	220f      	movs	r2, #15
    645a:	18ba      	adds	r2, r7, r2
    645c:	1e59      	subs	r1, r3, #1
    645e:	7011      	strb	r1, [r2, #0]
    6460:	2b00      	cmp	r3, #0
    6462:	d1e4      	bne.n	642e <_delay_cycles+0x1a>
	}

	SysTick->LOAD = buf;
    6464:	4b08      	ldr	r3, [pc, #32]	; (6488 <_delay_cycles+0x74>)
    6466:	68ba      	ldr	r2, [r7, #8]
    6468:	605a      	str	r2, [r3, #4]
	SysTick->VAL  = buf;
    646a:	4b07      	ldr	r3, [pc, #28]	; (6488 <_delay_cycles+0x74>)
    646c:	68ba      	ldr	r2, [r7, #8]
    646e:	609a      	str	r2, [r3, #8]
	while (!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk))
    6470:	46c0      	nop			; (mov r8, r8)
    6472:	4b05      	ldr	r3, [pc, #20]	; (6488 <_delay_cycles+0x74>)
    6474:	681a      	ldr	r2, [r3, #0]
    6476:	2380      	movs	r3, #128	; 0x80
    6478:	025b      	lsls	r3, r3, #9
    647a:	4013      	ands	r3, r2
    647c:	d0f9      	beq.n	6472 <_delay_cycles+0x5e>
		;
}
    647e:	46c0      	nop			; (mov r8, r8)
    6480:	46bd      	mov	sp, r7
    6482:	b004      	add	sp, #16
    6484:	bd80      	pop	{r7, pc}
    6486:	46c0      	nop			; (mov r8, r8)
    6488:	e000e010 	.word	0xe000e010
    648c:	00ffffff 	.word	0x00ffffff
    6490:	ff000001 	.word	0xff000001

00006494 <hri_gclk_write_CLKCTRL_reg>:
{
    6494:	b580      	push	{r7, lr}
    6496:	b082      	sub	sp, #8
    6498:	af00      	add	r7, sp, #0
    649a:	6078      	str	r0, [r7, #4]
    649c:	000a      	movs	r2, r1
    649e:	1cbb      	adds	r3, r7, #2
    64a0:	801a      	strh	r2, [r3, #0]
	((Gclk *)hw)->CLKCTRL.reg = data;
    64a2:	687b      	ldr	r3, [r7, #4]
    64a4:	1cba      	adds	r2, r7, #2
    64a6:	8812      	ldrh	r2, [r2, #0]
    64a8:	805a      	strh	r2, [r3, #2]
}
    64aa:	46c0      	nop			; (mov r8, r8)
    64ac:	46bd      	mov	sp, r7
    64ae:	b002      	add	sp, #8
    64b0:	bd80      	pop	{r7, pc}

000064b2 <hri_port_set_DIR_reg>:
{
    64b2:	b580      	push	{r7, lr}
    64b4:	b084      	sub	sp, #16
    64b6:	af00      	add	r7, sp, #0
    64b8:	60f8      	str	r0, [r7, #12]
    64ba:	607a      	str	r2, [r7, #4]
    64bc:	230b      	movs	r3, #11
    64be:	18fb      	adds	r3, r7, r3
    64c0:	1c0a      	adds	r2, r1, #0
    64c2:	701a      	strb	r2, [r3, #0]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    64c4:	230b      	movs	r3, #11
    64c6:	18fb      	adds	r3, r7, r3
    64c8:	781b      	ldrb	r3, [r3, #0]
    64ca:	68fa      	ldr	r2, [r7, #12]
    64cc:	01db      	lsls	r3, r3, #7
    64ce:	18d3      	adds	r3, r2, r3
    64d0:	3308      	adds	r3, #8
    64d2:	687a      	ldr	r2, [r7, #4]
    64d4:	601a      	str	r2, [r3, #0]
}
    64d6:	46c0      	nop			; (mov r8, r8)
    64d8:	46bd      	mov	sp, r7
    64da:	b004      	add	sp, #16
    64dc:	bd80      	pop	{r7, pc}

000064de <hri_port_read_DIR_reg>:
{
    64de:	b580      	push	{r7, lr}
    64e0:	b082      	sub	sp, #8
    64e2:	af00      	add	r7, sp, #0
    64e4:	6078      	str	r0, [r7, #4]
    64e6:	000a      	movs	r2, r1
    64e8:	1cfb      	adds	r3, r7, #3
    64ea:	701a      	strb	r2, [r3, #0]
	return ((Port *)hw)->Group[submodule_index].DIR.reg;
    64ec:	1cfb      	adds	r3, r7, #3
    64ee:	781a      	ldrb	r2, [r3, #0]
    64f0:	687b      	ldr	r3, [r7, #4]
    64f2:	01d2      	lsls	r2, r2, #7
    64f4:	58d3      	ldr	r3, [r2, r3]
}
    64f6:	0018      	movs	r0, r3
    64f8:	46bd      	mov	sp, r7
    64fa:	b002      	add	sp, #8
    64fc:	bd80      	pop	{r7, pc}

000064fe <hri_port_clear_DIR_reg>:
{
    64fe:	b580      	push	{r7, lr}
    6500:	b084      	sub	sp, #16
    6502:	af00      	add	r7, sp, #0
    6504:	60f8      	str	r0, [r7, #12]
    6506:	607a      	str	r2, [r7, #4]
    6508:	230b      	movs	r3, #11
    650a:	18fb      	adds	r3, r7, r3
    650c:	1c0a      	adds	r2, r1, #0
    650e:	701a      	strb	r2, [r3, #0]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    6510:	230b      	movs	r3, #11
    6512:	18fb      	adds	r3, r7, r3
    6514:	781b      	ldrb	r3, [r3, #0]
    6516:	68fa      	ldr	r2, [r7, #12]
    6518:	01db      	lsls	r3, r3, #7
    651a:	18d3      	adds	r3, r2, r3
    651c:	3304      	adds	r3, #4
    651e:	687a      	ldr	r2, [r7, #4]
    6520:	601a      	str	r2, [r3, #0]
}
    6522:	46c0      	nop			; (mov r8, r8)
    6524:	46bd      	mov	sp, r7
    6526:	b004      	add	sp, #16
    6528:	bd80      	pop	{r7, pc}

0000652a <hri_port_set_OUT_reg>:
{
    652a:	b580      	push	{r7, lr}
    652c:	b084      	sub	sp, #16
    652e:	af00      	add	r7, sp, #0
    6530:	60f8      	str	r0, [r7, #12]
    6532:	607a      	str	r2, [r7, #4]
    6534:	230b      	movs	r3, #11
    6536:	18fb      	adds	r3, r7, r3
    6538:	1c0a      	adds	r2, r1, #0
    653a:	701a      	strb	r2, [r3, #0]
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    653c:	230b      	movs	r3, #11
    653e:	18fb      	adds	r3, r7, r3
    6540:	781b      	ldrb	r3, [r3, #0]
    6542:	68fa      	ldr	r2, [r7, #12]
    6544:	01db      	lsls	r3, r3, #7
    6546:	18d3      	adds	r3, r2, r3
    6548:	3318      	adds	r3, #24
    654a:	687a      	ldr	r2, [r7, #4]
    654c:	601a      	str	r2, [r3, #0]
}
    654e:	46c0      	nop			; (mov r8, r8)
    6550:	46bd      	mov	sp, r7
    6552:	b004      	add	sp, #16
    6554:	bd80      	pop	{r7, pc}

00006556 <hri_port_read_OUT_reg>:
{
    6556:	b580      	push	{r7, lr}
    6558:	b082      	sub	sp, #8
    655a:	af00      	add	r7, sp, #0
    655c:	6078      	str	r0, [r7, #4]
    655e:	000a      	movs	r2, r1
    6560:	1cfb      	adds	r3, r7, #3
    6562:	701a      	strb	r2, [r3, #0]
	return ((Port *)hw)->Group[submodule_index].OUT.reg;
    6564:	1cfb      	adds	r3, r7, #3
    6566:	781b      	ldrb	r3, [r3, #0]
    6568:	687a      	ldr	r2, [r7, #4]
    656a:	01db      	lsls	r3, r3, #7
    656c:	18d3      	adds	r3, r2, r3
    656e:	3310      	adds	r3, #16
    6570:	681b      	ldr	r3, [r3, #0]
}
    6572:	0018      	movs	r0, r3
    6574:	46bd      	mov	sp, r7
    6576:	b002      	add	sp, #8
    6578:	bd80      	pop	{r7, pc}

0000657a <hri_port_clear_OUT_reg>:
{
    657a:	b580      	push	{r7, lr}
    657c:	b084      	sub	sp, #16
    657e:	af00      	add	r7, sp, #0
    6580:	60f8      	str	r0, [r7, #12]
    6582:	607a      	str	r2, [r7, #4]
    6584:	230b      	movs	r3, #11
    6586:	18fb      	adds	r3, r7, r3
    6588:	1c0a      	adds	r2, r1, #0
    658a:	701a      	strb	r2, [r3, #0]
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    658c:	230b      	movs	r3, #11
    658e:	18fb      	adds	r3, r7, r3
    6590:	781b      	ldrb	r3, [r3, #0]
    6592:	68fa      	ldr	r2, [r7, #12]
    6594:	01db      	lsls	r3, r3, #7
    6596:	18d3      	adds	r3, r2, r3
    6598:	3314      	adds	r3, #20
    659a:	687a      	ldr	r2, [r7, #4]
    659c:	601a      	str	r2, [r3, #0]
}
    659e:	46c0      	nop			; (mov r8, r8)
    65a0:	46bd      	mov	sp, r7
    65a2:	b004      	add	sp, #16
    65a4:	bd80      	pop	{r7, pc}

000065a6 <hri_port_read_IN_reg>:
{
    65a6:	b580      	push	{r7, lr}
    65a8:	b082      	sub	sp, #8
    65aa:	af00      	add	r7, sp, #0
    65ac:	6078      	str	r0, [r7, #4]
    65ae:	000a      	movs	r2, r1
    65b0:	1cfb      	adds	r3, r7, #3
    65b2:	701a      	strb	r2, [r3, #0]
	return ((Port *)hw)->Group[submodule_index].IN.reg;
    65b4:	1cfb      	adds	r3, r7, #3
    65b6:	781b      	ldrb	r3, [r3, #0]
    65b8:	687a      	ldr	r2, [r7, #4]
    65ba:	01db      	lsls	r3, r3, #7
    65bc:	18d3      	adds	r3, r2, r3
    65be:	3320      	adds	r3, #32
    65c0:	681b      	ldr	r3, [r3, #0]
}
    65c2:	0018      	movs	r0, r3
    65c4:	46bd      	mov	sp, r7
    65c6:	b002      	add	sp, #8
    65c8:	bd80      	pop	{r7, pc}

000065ca <hri_port_write_PMUX_PMUXE_bf>:
{
    65ca:	b590      	push	{r4, r7, lr}
    65cc:	b085      	sub	sp, #20
    65ce:	af00      	add	r7, sp, #0
    65d0:	6078      	str	r0, [r7, #4]
    65d2:	000c      	movs	r4, r1
    65d4:	0010      	movs	r0, r2
    65d6:	0019      	movs	r1, r3
    65d8:	1cfb      	adds	r3, r7, #3
    65da:	1c22      	adds	r2, r4, #0
    65dc:	701a      	strb	r2, [r3, #0]
    65de:	1cbb      	adds	r3, r7, #2
    65e0:	1c02      	adds	r2, r0, #0
    65e2:	701a      	strb	r2, [r3, #0]
    65e4:	1c7b      	adds	r3, r7, #1
    65e6:	1c0a      	adds	r2, r1, #0
    65e8:	701a      	strb	r2, [r3, #0]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
    65ea:	1cfb      	adds	r3, r7, #3
    65ec:	7819      	ldrb	r1, [r3, #0]
    65ee:	1cbb      	adds	r3, r7, #2
    65f0:	781a      	ldrb	r2, [r3, #0]
    65f2:	230f      	movs	r3, #15
    65f4:	18fb      	adds	r3, r7, r3
    65f6:	6878      	ldr	r0, [r7, #4]
    65f8:	2430      	movs	r4, #48	; 0x30
    65fa:	01c9      	lsls	r1, r1, #7
    65fc:	1841      	adds	r1, r0, r1
    65fe:	188a      	adds	r2, r1, r2
    6600:	1912      	adds	r2, r2, r4
    6602:	7812      	ldrb	r2, [r2, #0]
    6604:	701a      	strb	r2, [r3, #0]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
    6606:	230f      	movs	r3, #15
    6608:	18fb      	adds	r3, r7, r3
    660a:	220f      	movs	r2, #15
    660c:	18ba      	adds	r2, r7, r2
    660e:	7812      	ldrb	r2, [r2, #0]
    6610:	210f      	movs	r1, #15
    6612:	438a      	bics	r2, r1
    6614:	701a      	strb	r2, [r3, #0]
	tmp |= PORT_PMUX_PMUXE(data);
    6616:	1c7b      	adds	r3, r7, #1
    6618:	781b      	ldrb	r3, [r3, #0]
    661a:	220f      	movs	r2, #15
    661c:	4013      	ands	r3, r2
    661e:	b2d9      	uxtb	r1, r3
    6620:	230f      	movs	r3, #15
    6622:	18fb      	adds	r3, r7, r3
    6624:	220f      	movs	r2, #15
    6626:	18ba      	adds	r2, r7, r2
    6628:	7812      	ldrb	r2, [r2, #0]
    662a:	430a      	orrs	r2, r1
    662c:	701a      	strb	r2, [r3, #0]
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
    662e:	1cfb      	adds	r3, r7, #3
    6630:	781a      	ldrb	r2, [r3, #0]
    6632:	1cbb      	adds	r3, r7, #2
    6634:	781b      	ldrb	r3, [r3, #0]
    6636:	6879      	ldr	r1, [r7, #4]
    6638:	2030      	movs	r0, #48	; 0x30
    663a:	01d2      	lsls	r2, r2, #7
    663c:	188a      	adds	r2, r1, r2
    663e:	18d3      	adds	r3, r2, r3
    6640:	181b      	adds	r3, r3, r0
    6642:	220f      	movs	r2, #15
    6644:	18ba      	adds	r2, r7, r2
    6646:	7812      	ldrb	r2, [r2, #0]
    6648:	701a      	strb	r2, [r3, #0]
}
    664a:	46c0      	nop			; (mov r8, r8)
    664c:	46bd      	mov	sp, r7
    664e:	b005      	add	sp, #20
    6650:	bd90      	pop	{r4, r7, pc}

00006652 <hri_port_write_PMUX_PMUXO_bf>:
{
    6652:	b590      	push	{r4, r7, lr}
    6654:	b085      	sub	sp, #20
    6656:	af00      	add	r7, sp, #0
    6658:	6078      	str	r0, [r7, #4]
    665a:	000c      	movs	r4, r1
    665c:	0010      	movs	r0, r2
    665e:	0019      	movs	r1, r3
    6660:	1cfb      	adds	r3, r7, #3
    6662:	1c22      	adds	r2, r4, #0
    6664:	701a      	strb	r2, [r3, #0]
    6666:	1cbb      	adds	r3, r7, #2
    6668:	1c02      	adds	r2, r0, #0
    666a:	701a      	strb	r2, [r3, #0]
    666c:	1c7b      	adds	r3, r7, #1
    666e:	1c0a      	adds	r2, r1, #0
    6670:	701a      	strb	r2, [r3, #0]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
    6672:	1cfb      	adds	r3, r7, #3
    6674:	7819      	ldrb	r1, [r3, #0]
    6676:	1cbb      	adds	r3, r7, #2
    6678:	781a      	ldrb	r2, [r3, #0]
    667a:	230f      	movs	r3, #15
    667c:	18fb      	adds	r3, r7, r3
    667e:	6878      	ldr	r0, [r7, #4]
    6680:	2430      	movs	r4, #48	; 0x30
    6682:	01c9      	lsls	r1, r1, #7
    6684:	1841      	adds	r1, r0, r1
    6686:	188a      	adds	r2, r1, r2
    6688:	1912      	adds	r2, r2, r4
    668a:	7812      	ldrb	r2, [r2, #0]
    668c:	701a      	strb	r2, [r3, #0]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
    668e:	230f      	movs	r3, #15
    6690:	18fb      	adds	r3, r7, r3
    6692:	220f      	movs	r2, #15
    6694:	18ba      	adds	r2, r7, r2
    6696:	7812      	ldrb	r2, [r2, #0]
    6698:	210f      	movs	r1, #15
    669a:	400a      	ands	r2, r1
    669c:	701a      	strb	r2, [r3, #0]
	tmp |= PORT_PMUX_PMUXO(data);
    669e:	1c7b      	adds	r3, r7, #1
    66a0:	781b      	ldrb	r3, [r3, #0]
    66a2:	011b      	lsls	r3, r3, #4
    66a4:	b2d9      	uxtb	r1, r3
    66a6:	230f      	movs	r3, #15
    66a8:	18fb      	adds	r3, r7, r3
    66aa:	220f      	movs	r2, #15
    66ac:	18ba      	adds	r2, r7, r2
    66ae:	7812      	ldrb	r2, [r2, #0]
    66b0:	430a      	orrs	r2, r1
    66b2:	701a      	strb	r2, [r3, #0]
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
    66b4:	1cfb      	adds	r3, r7, #3
    66b6:	781a      	ldrb	r2, [r3, #0]
    66b8:	1cbb      	adds	r3, r7, #2
    66ba:	781b      	ldrb	r3, [r3, #0]
    66bc:	6879      	ldr	r1, [r7, #4]
    66be:	2030      	movs	r0, #48	; 0x30
    66c0:	01d2      	lsls	r2, r2, #7
    66c2:	188a      	adds	r2, r1, r2
    66c4:	18d3      	adds	r3, r2, r3
    66c6:	181b      	adds	r3, r3, r0
    66c8:	220f      	movs	r2, #15
    66ca:	18ba      	adds	r2, r7, r2
    66cc:	7812      	ldrb	r2, [r2, #0]
    66ce:	701a      	strb	r2, [r3, #0]
}
    66d0:	46c0      	nop			; (mov r8, r8)
    66d2:	46bd      	mov	sp, r7
    66d4:	b005      	add	sp, #20
    66d6:	bd90      	pop	{r4, r7, pc}

000066d8 <hri_port_write_PINCFG_PMUXEN_bit>:
{
    66d8:	b590      	push	{r4, r7, lr}
    66da:	b085      	sub	sp, #20
    66dc:	af00      	add	r7, sp, #0
    66de:	6078      	str	r0, [r7, #4]
    66e0:	000c      	movs	r4, r1
    66e2:	0010      	movs	r0, r2
    66e4:	0019      	movs	r1, r3
    66e6:	1cfb      	adds	r3, r7, #3
    66e8:	1c22      	adds	r2, r4, #0
    66ea:	701a      	strb	r2, [r3, #0]
    66ec:	1cbb      	adds	r3, r7, #2
    66ee:	1c02      	adds	r2, r0, #0
    66f0:	701a      	strb	r2, [r3, #0]
    66f2:	1c7b      	adds	r3, r7, #1
    66f4:	1c0a      	adds	r2, r1, #0
    66f6:	701a      	strb	r2, [r3, #0]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    66f8:	1cfb      	adds	r3, r7, #3
    66fa:	7819      	ldrb	r1, [r3, #0]
    66fc:	1cbb      	adds	r3, r7, #2
    66fe:	781a      	ldrb	r2, [r3, #0]
    6700:	230f      	movs	r3, #15
    6702:	18fb      	adds	r3, r7, r3
    6704:	6878      	ldr	r0, [r7, #4]
    6706:	2440      	movs	r4, #64	; 0x40
    6708:	01c9      	lsls	r1, r1, #7
    670a:	1841      	adds	r1, r0, r1
    670c:	188a      	adds	r2, r1, r2
    670e:	1912      	adds	r2, r2, r4
    6710:	7812      	ldrb	r2, [r2, #0]
    6712:	701a      	strb	r2, [r3, #0]
	tmp &= ~PORT_PINCFG_PMUXEN;
    6714:	230f      	movs	r3, #15
    6716:	18fb      	adds	r3, r7, r3
    6718:	220f      	movs	r2, #15
    671a:	18ba      	adds	r2, r7, r2
    671c:	7812      	ldrb	r2, [r2, #0]
    671e:	2101      	movs	r1, #1
    6720:	438a      	bics	r2, r1
    6722:	701a      	strb	r2, [r3, #0]
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
    6724:	1c7b      	adds	r3, r7, #1
    6726:	7819      	ldrb	r1, [r3, #0]
    6728:	230f      	movs	r3, #15
    672a:	18fb      	adds	r3, r7, r3
    672c:	220f      	movs	r2, #15
    672e:	18ba      	adds	r2, r7, r2
    6730:	7812      	ldrb	r2, [r2, #0]
    6732:	430a      	orrs	r2, r1
    6734:	701a      	strb	r2, [r3, #0]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    6736:	1cfb      	adds	r3, r7, #3
    6738:	781a      	ldrb	r2, [r3, #0]
    673a:	1cbb      	adds	r3, r7, #2
    673c:	781b      	ldrb	r3, [r3, #0]
    673e:	6879      	ldr	r1, [r7, #4]
    6740:	2040      	movs	r0, #64	; 0x40
    6742:	01d2      	lsls	r2, r2, #7
    6744:	188a      	adds	r2, r1, r2
    6746:	18d3      	adds	r3, r2, r3
    6748:	181b      	adds	r3, r3, r0
    674a:	220f      	movs	r2, #15
    674c:	18ba      	adds	r2, r7, r2
    674e:	7812      	ldrb	r2, [r2, #0]
    6750:	701a      	strb	r2, [r3, #0]
}
    6752:	46c0      	nop			; (mov r8, r8)
    6754:	46bd      	mov	sp, r7
    6756:	b005      	add	sp, #20
    6758:	bd90      	pop	{r4, r7, pc}

0000675a <hri_port_set_PINCFG_PULLEN_bit>:
{
    675a:	b5b0      	push	{r4, r5, r7, lr}
    675c:	b082      	sub	sp, #8
    675e:	af00      	add	r7, sp, #0
    6760:	6078      	str	r0, [r7, #4]
    6762:	0008      	movs	r0, r1
    6764:	0011      	movs	r1, r2
    6766:	1cfb      	adds	r3, r7, #3
    6768:	1c02      	adds	r2, r0, #0
    676a:	701a      	strb	r2, [r3, #0]
    676c:	1cbb      	adds	r3, r7, #2
    676e:	1c0a      	adds	r2, r1, #0
    6770:	701a      	strb	r2, [r3, #0]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg |= PORT_PINCFG_PULLEN;
    6772:	1cfb      	adds	r3, r7, #3
    6774:	781a      	ldrb	r2, [r3, #0]
    6776:	1cbb      	adds	r3, r7, #2
    6778:	781b      	ldrb	r3, [r3, #0]
    677a:	1cf9      	adds	r1, r7, #3
    677c:	7808      	ldrb	r0, [r1, #0]
    677e:	1cb9      	adds	r1, r7, #2
    6780:	7809      	ldrb	r1, [r1, #0]
    6782:	687c      	ldr	r4, [r7, #4]
    6784:	2540      	movs	r5, #64	; 0x40
    6786:	01c0      	lsls	r0, r0, #7
    6788:	1820      	adds	r0, r4, r0
    678a:	1841      	adds	r1, r0, r1
    678c:	1949      	adds	r1, r1, r5
    678e:	7809      	ldrb	r1, [r1, #0]
    6790:	b2c9      	uxtb	r1, r1
    6792:	2004      	movs	r0, #4
    6794:	4301      	orrs	r1, r0
    6796:	b2cc      	uxtb	r4, r1
    6798:	6879      	ldr	r1, [r7, #4]
    679a:	2040      	movs	r0, #64	; 0x40
    679c:	01d2      	lsls	r2, r2, #7
    679e:	188a      	adds	r2, r1, r2
    67a0:	18d3      	adds	r3, r2, r3
    67a2:	181b      	adds	r3, r3, r0
    67a4:	1c22      	adds	r2, r4, #0
    67a6:	701a      	strb	r2, [r3, #0]
}
    67a8:	46c0      	nop			; (mov r8, r8)
    67aa:	46bd      	mov	sp, r7
    67ac:	b002      	add	sp, #8
    67ae:	bdb0      	pop	{r4, r5, r7, pc}

000067b0 <hri_port_clear_PINCFG_PULLEN_bit>:
{
    67b0:	b5b0      	push	{r4, r5, r7, lr}
    67b2:	b082      	sub	sp, #8
    67b4:	af00      	add	r7, sp, #0
    67b6:	6078      	str	r0, [r7, #4]
    67b8:	0008      	movs	r0, r1
    67ba:	0011      	movs	r1, r2
    67bc:	1cfb      	adds	r3, r7, #3
    67be:	1c02      	adds	r2, r0, #0
    67c0:	701a      	strb	r2, [r3, #0]
    67c2:	1cbb      	adds	r3, r7, #2
    67c4:	1c0a      	adds	r2, r1, #0
    67c6:	701a      	strb	r2, [r3, #0]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
    67c8:	1cfb      	adds	r3, r7, #3
    67ca:	781a      	ldrb	r2, [r3, #0]
    67cc:	1cbb      	adds	r3, r7, #2
    67ce:	781b      	ldrb	r3, [r3, #0]
    67d0:	1cf9      	adds	r1, r7, #3
    67d2:	7808      	ldrb	r0, [r1, #0]
    67d4:	1cb9      	adds	r1, r7, #2
    67d6:	7809      	ldrb	r1, [r1, #0]
    67d8:	687c      	ldr	r4, [r7, #4]
    67da:	2540      	movs	r5, #64	; 0x40
    67dc:	01c0      	lsls	r0, r0, #7
    67de:	1820      	adds	r0, r4, r0
    67e0:	1841      	adds	r1, r0, r1
    67e2:	1949      	adds	r1, r1, r5
    67e4:	7809      	ldrb	r1, [r1, #0]
    67e6:	b2c9      	uxtb	r1, r1
    67e8:	2004      	movs	r0, #4
    67ea:	4381      	bics	r1, r0
    67ec:	b2cc      	uxtb	r4, r1
    67ee:	6879      	ldr	r1, [r7, #4]
    67f0:	2040      	movs	r0, #64	; 0x40
    67f2:	01d2      	lsls	r2, r2, #7
    67f4:	188a      	adds	r2, r1, r2
    67f6:	18d3      	adds	r3, r2, r3
    67f8:	181b      	adds	r3, r3, r0
    67fa:	1c22      	adds	r2, r4, #0
    67fc:	701a      	strb	r2, [r3, #0]
}
    67fe:	46c0      	nop			; (mov r8, r8)
    6800:	46bd      	mov	sp, r7
    6802:	b002      	add	sp, #8
    6804:	bdb0      	pop	{r4, r5, r7, pc}

00006806 <hri_port_write_WRCONFIG_reg>:
{
    6806:	b580      	push	{r7, lr}
    6808:	b084      	sub	sp, #16
    680a:	af00      	add	r7, sp, #0
    680c:	60f8      	str	r0, [r7, #12]
    680e:	607a      	str	r2, [r7, #4]
    6810:	230b      	movs	r3, #11
    6812:	18fb      	adds	r3, r7, r3
    6814:	1c0a      	adds	r2, r1, #0
    6816:	701a      	strb	r2, [r3, #0]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    6818:	230b      	movs	r3, #11
    681a:	18fb      	adds	r3, r7, r3
    681c:	781b      	ldrb	r3, [r3, #0]
    681e:	68fa      	ldr	r2, [r7, #12]
    6820:	01db      	lsls	r3, r3, #7
    6822:	18d3      	adds	r3, r2, r3
    6824:	3328      	adds	r3, #40	; 0x28
    6826:	687a      	ldr	r2, [r7, #4]
    6828:	601a      	str	r2, [r3, #0]
}
    682a:	46c0      	nop			; (mov r8, r8)
    682c:	46bd      	mov	sp, r7
    682e:	b004      	add	sp, #16
    6830:	bd80      	pop	{r7, pc}
	...

00006834 <_gpio_set_direction>:
{
    6834:	b580      	push	{r7, lr}
    6836:	b082      	sub	sp, #8
    6838:	af00      	add	r7, sp, #0
    683a:	6039      	str	r1, [r7, #0]
    683c:	0011      	movs	r1, r2
    683e:	1dfb      	adds	r3, r7, #7
    6840:	1c02      	adds	r2, r0, #0
    6842:	701a      	strb	r2, [r3, #0]
    6844:	1dbb      	adds	r3, r7, #6
    6846:	1c0a      	adds	r2, r1, #0
    6848:	701a      	strb	r2, [r3, #0]
	switch (direction) {
    684a:	1dbb      	adds	r3, r7, #6
    684c:	781b      	ldrb	r3, [r3, #0]
    684e:	2b01      	cmp	r3, #1
    6850:	d023      	beq.n	689a <_gpio_set_direction+0x66>
    6852:	2b02      	cmp	r3, #2
    6854:	d03f      	beq.n	68d6 <_gpio_set_direction+0xa2>
    6856:	2b00      	cmp	r3, #0
    6858:	d15d      	bne.n	6916 <_gpio_set_direction+0xe2>
		hri_port_clear_DIR_reg(PORT_IOBUS, port, mask);
    685a:	683a      	ldr	r2, [r7, #0]
    685c:	1dfb      	adds	r3, r7, #7
    685e:	7819      	ldrb	r1, [r3, #0]
    6860:	23c0      	movs	r3, #192	; 0xc0
    6862:	05db      	lsls	r3, r3, #23
    6864:	0018      	movs	r0, r3
    6866:	f7ff fe4a 	bl	64fe <hri_port_clear_DIR_reg>
		hri_port_write_WRCONFIG_reg(PORT, port, PORT_WRCONFIG_WRPINCFG | (mask & 0xffff));
    686a:	683b      	ldr	r3, [r7, #0]
    686c:	041b      	lsls	r3, r3, #16
    686e:	0c1b      	lsrs	r3, r3, #16
    6870:	2280      	movs	r2, #128	; 0x80
    6872:	05d2      	lsls	r2, r2, #23
    6874:	431a      	orrs	r2, r3
    6876:	1dfb      	adds	r3, r7, #7
    6878:	781b      	ldrb	r3, [r3, #0]
    687a:	482c      	ldr	r0, [pc, #176]	; (692c <_gpio_set_direction+0xf8>)
    687c:	0019      	movs	r1, r3
    687e:	f7ff ffc2 	bl	6806 <hri_port_write_WRCONFIG_reg>
		    PORT, port, PORT_WRCONFIG_HWSEL | PORT_WRCONFIG_WRPINCFG | ((mask & 0xffff0000) >> 16));
    6882:	683b      	ldr	r3, [r7, #0]
    6884:	0c1b      	lsrs	r3, r3, #16
		hri_port_write_WRCONFIG_reg(
    6886:	22c0      	movs	r2, #192	; 0xc0
    6888:	0612      	lsls	r2, r2, #24
    688a:	431a      	orrs	r2, r3
    688c:	1dfb      	adds	r3, r7, #7
    688e:	781b      	ldrb	r3, [r3, #0]
    6890:	4826      	ldr	r0, [pc, #152]	; (692c <_gpio_set_direction+0xf8>)
    6892:	0019      	movs	r1, r3
    6894:	f7ff ffb7 	bl	6806 <hri_port_write_WRCONFIG_reg>
		break;
    6898:	e043      	b.n	6922 <_gpio_set_direction+0xee>
		hri_port_clear_DIR_reg(PORT_IOBUS, port, mask);
    689a:	683a      	ldr	r2, [r7, #0]
    689c:	1dfb      	adds	r3, r7, #7
    689e:	7819      	ldrb	r1, [r3, #0]
    68a0:	23c0      	movs	r3, #192	; 0xc0
    68a2:	05db      	lsls	r3, r3, #23
    68a4:	0018      	movs	r0, r3
    68a6:	f7ff fe2a 	bl	64fe <hri_port_clear_DIR_reg>
		hri_port_write_WRCONFIG_reg(PORT, port, PORT_WRCONFIG_WRPINCFG | PORT_WRCONFIG_INEN | (mask & 0xffff));
    68aa:	683b      	ldr	r3, [r7, #0]
    68ac:	041b      	lsls	r3, r3, #16
    68ae:	0c1b      	lsrs	r3, r3, #16
    68b0:	4a1f      	ldr	r2, [pc, #124]	; (6930 <_gpio_set_direction+0xfc>)
    68b2:	431a      	orrs	r2, r3
    68b4:	1dfb      	adds	r3, r7, #7
    68b6:	781b      	ldrb	r3, [r3, #0]
    68b8:	481c      	ldr	r0, [pc, #112]	; (692c <_gpio_set_direction+0xf8>)
    68ba:	0019      	movs	r1, r3
    68bc:	f7ff ffa3 	bl	6806 <hri_port_write_WRCONFIG_reg>
		                                | ((mask & 0xffff0000) >> 16));
    68c0:	683b      	ldr	r3, [r7, #0]
    68c2:	0c1b      	lsrs	r3, r3, #16
		hri_port_write_WRCONFIG_reg(PORT,
    68c4:	4a1b      	ldr	r2, [pc, #108]	; (6934 <_gpio_set_direction+0x100>)
    68c6:	431a      	orrs	r2, r3
    68c8:	1dfb      	adds	r3, r7, #7
    68ca:	781b      	ldrb	r3, [r3, #0]
    68cc:	4817      	ldr	r0, [pc, #92]	; (692c <_gpio_set_direction+0xf8>)
    68ce:	0019      	movs	r1, r3
    68d0:	f7ff ff99 	bl	6806 <hri_port_write_WRCONFIG_reg>
		break;
    68d4:	e025      	b.n	6922 <_gpio_set_direction+0xee>
		hri_port_set_DIR_reg(PORT_IOBUS, port, mask);
    68d6:	683a      	ldr	r2, [r7, #0]
    68d8:	1dfb      	adds	r3, r7, #7
    68da:	7819      	ldrb	r1, [r3, #0]
    68dc:	23c0      	movs	r3, #192	; 0xc0
    68de:	05db      	lsls	r3, r3, #23
    68e0:	0018      	movs	r0, r3
    68e2:	f7ff fde6 	bl	64b2 <hri_port_set_DIR_reg>
		hri_port_write_WRCONFIG_reg(PORT, port, PORT_WRCONFIG_WRPINCFG | (mask & 0xffff));
    68e6:	683b      	ldr	r3, [r7, #0]
    68e8:	041b      	lsls	r3, r3, #16
    68ea:	0c1b      	lsrs	r3, r3, #16
    68ec:	2280      	movs	r2, #128	; 0x80
    68ee:	05d2      	lsls	r2, r2, #23
    68f0:	431a      	orrs	r2, r3
    68f2:	1dfb      	adds	r3, r7, #7
    68f4:	781b      	ldrb	r3, [r3, #0]
    68f6:	480d      	ldr	r0, [pc, #52]	; (692c <_gpio_set_direction+0xf8>)
    68f8:	0019      	movs	r1, r3
    68fa:	f7ff ff84 	bl	6806 <hri_port_write_WRCONFIG_reg>
		    PORT, port, PORT_WRCONFIG_HWSEL | PORT_WRCONFIG_WRPINCFG | ((mask & 0xffff0000) >> 16));
    68fe:	683b      	ldr	r3, [r7, #0]
    6900:	0c1b      	lsrs	r3, r3, #16
		hri_port_write_WRCONFIG_reg(
    6902:	22c0      	movs	r2, #192	; 0xc0
    6904:	0612      	lsls	r2, r2, #24
    6906:	431a      	orrs	r2, r3
    6908:	1dfb      	adds	r3, r7, #7
    690a:	781b      	ldrb	r3, [r3, #0]
    690c:	4807      	ldr	r0, [pc, #28]	; (692c <_gpio_set_direction+0xf8>)
    690e:	0019      	movs	r1, r3
    6910:	f7ff ff79 	bl	6806 <hri_port_write_WRCONFIG_reg>
		break;
    6914:	e005      	b.n	6922 <_gpio_set_direction+0xee>
		ASSERT(false);
    6916:	4b08      	ldr	r3, [pc, #32]	; (6938 <_gpio_set_direction+0x104>)
    6918:	2245      	movs	r2, #69	; 0x45
    691a:	0019      	movs	r1, r3
    691c:	2000      	movs	r0, #0
    691e:	f7fd fd1f 	bl	4360 <assert>
}
    6922:	46c0      	nop			; (mov r8, r8)
    6924:	46bd      	mov	sp, r7
    6926:	b002      	add	sp, #8
    6928:	bd80      	pop	{r7, pc}
    692a:	46c0      	nop			; (mov r8, r8)
    692c:	41004400 	.word	0x41004400
    6930:	40020000 	.word	0x40020000
    6934:	c0020000 	.word	0xc0020000
    6938:	00008ff8 	.word	0x00008ff8

0000693c <_gpio_set_level>:
{
    693c:	b580      	push	{r7, lr}
    693e:	b082      	sub	sp, #8
    6940:	af00      	add	r7, sp, #0
    6942:	6039      	str	r1, [r7, #0]
    6944:	0011      	movs	r1, r2
    6946:	1dfb      	adds	r3, r7, #7
    6948:	1c02      	adds	r2, r0, #0
    694a:	701a      	strb	r2, [r3, #0]
    694c:	1dbb      	adds	r3, r7, #6
    694e:	1c0a      	adds	r2, r1, #0
    6950:	701a      	strb	r2, [r3, #0]
	if (level) {
    6952:	1dbb      	adds	r3, r7, #6
    6954:	781b      	ldrb	r3, [r3, #0]
    6956:	2b00      	cmp	r3, #0
    6958:	d008      	beq.n	696c <_gpio_set_level+0x30>
		hri_port_set_OUT_reg(PORT_IOBUS, port, mask);
    695a:	683a      	ldr	r2, [r7, #0]
    695c:	1dfb      	adds	r3, r7, #7
    695e:	7819      	ldrb	r1, [r3, #0]
    6960:	23c0      	movs	r3, #192	; 0xc0
    6962:	05db      	lsls	r3, r3, #23
    6964:	0018      	movs	r0, r3
    6966:	f7ff fde0 	bl	652a <hri_port_set_OUT_reg>
}
    696a:	e007      	b.n	697c <_gpio_set_level+0x40>
		hri_port_clear_OUT_reg(PORT_IOBUS, port, mask);
    696c:	683a      	ldr	r2, [r7, #0]
    696e:	1dfb      	adds	r3, r7, #7
    6970:	7819      	ldrb	r1, [r3, #0]
    6972:	23c0      	movs	r3, #192	; 0xc0
    6974:	05db      	lsls	r3, r3, #23
    6976:	0018      	movs	r0, r3
    6978:	f7ff fdff 	bl	657a <hri_port_clear_OUT_reg>
}
    697c:	46c0      	nop			; (mov r8, r8)
    697e:	46bd      	mov	sp, r7
    6980:	b002      	add	sp, #8
    6982:	bd80      	pop	{r7, pc}

00006984 <_gpio_get_level>:
{
    6984:	b580      	push	{r7, lr}
    6986:	b086      	sub	sp, #24
    6988:	af00      	add	r7, sp, #0
    698a:	0002      	movs	r2, r0
    698c:	1dfb      	adds	r3, r7, #7
    698e:	701a      	strb	r2, [r3, #0]
	CRITICAL_SECTION_ENTER();
    6990:	230c      	movs	r3, #12
    6992:	18fb      	adds	r3, r7, r3
    6994:	0018      	movs	r0, r3
    6996:	f7fd f806 	bl	39a6 <atomic_enter_critical>
	uint32_t dir_tmp = hri_port_read_DIR_reg(PORT_IOBUS, port);
    699a:	1dfb      	adds	r3, r7, #7
    699c:	781a      	ldrb	r2, [r3, #0]
    699e:	23c0      	movs	r3, #192	; 0xc0
    69a0:	05db      	lsls	r3, r3, #23
    69a2:	0011      	movs	r1, r2
    69a4:	0018      	movs	r0, r3
    69a6:	f7ff fd9a 	bl	64de <hri_port_read_DIR_reg>
    69aa:	0003      	movs	r3, r0
    69ac:	617b      	str	r3, [r7, #20]
	tmp = hri_port_read_IN_reg(PORT, port) & ~dir_tmp;
    69ae:	1dfb      	adds	r3, r7, #7
    69b0:	781b      	ldrb	r3, [r3, #0]
    69b2:	4a11      	ldr	r2, [pc, #68]	; (69f8 <_gpio_get_level+0x74>)
    69b4:	0019      	movs	r1, r3
    69b6:	0010      	movs	r0, r2
    69b8:	f7ff fdf5 	bl	65a6 <hri_port_read_IN_reg>
    69bc:	0002      	movs	r2, r0
    69be:	697b      	ldr	r3, [r7, #20]
    69c0:	43db      	mvns	r3, r3
    69c2:	4013      	ands	r3, r2
    69c4:	613b      	str	r3, [r7, #16]
	tmp |= hri_port_read_OUT_reg(PORT_IOBUS, port) & dir_tmp;
    69c6:	1dfb      	adds	r3, r7, #7
    69c8:	781a      	ldrb	r2, [r3, #0]
    69ca:	23c0      	movs	r3, #192	; 0xc0
    69cc:	05db      	lsls	r3, r3, #23
    69ce:	0011      	movs	r1, r2
    69d0:	0018      	movs	r0, r3
    69d2:	f7ff fdc0 	bl	6556 <hri_port_read_OUT_reg>
    69d6:	0002      	movs	r2, r0
    69d8:	697b      	ldr	r3, [r7, #20]
    69da:	4013      	ands	r3, r2
    69dc:	693a      	ldr	r2, [r7, #16]
    69de:	4313      	orrs	r3, r2
    69e0:	613b      	str	r3, [r7, #16]
	CRITICAL_SECTION_LEAVE();
    69e2:	230c      	movs	r3, #12
    69e4:	18fb      	adds	r3, r7, r3
    69e6:	0018      	movs	r0, r3
    69e8:	f7fc ffee 	bl	39c8 <atomic_leave_critical>
	return tmp;
    69ec:	693b      	ldr	r3, [r7, #16]
}
    69ee:	0018      	movs	r0, r3
    69f0:	46bd      	mov	sp, r7
    69f2:	b006      	add	sp, #24
    69f4:	bd80      	pop	{r7, pc}
    69f6:	46c0      	nop			; (mov r8, r8)
    69f8:	41004400 	.word	0x41004400

000069fc <_gpio_set_pin_pull_mode>:
{
    69fc:	b590      	push	{r4, r7, lr}
    69fe:	b083      	sub	sp, #12
    6a00:	af00      	add	r7, sp, #0
    6a02:	0004      	movs	r4, r0
    6a04:	0008      	movs	r0, r1
    6a06:	0011      	movs	r1, r2
    6a08:	1dfb      	adds	r3, r7, #7
    6a0a:	1c22      	adds	r2, r4, #0
    6a0c:	701a      	strb	r2, [r3, #0]
    6a0e:	1dbb      	adds	r3, r7, #6
    6a10:	1c02      	adds	r2, r0, #0
    6a12:	701a      	strb	r2, [r3, #0]
    6a14:	1d7b      	adds	r3, r7, #5
    6a16:	1c0a      	adds	r2, r1, #0
    6a18:	701a      	strb	r2, [r3, #0]
	switch (pull_mode) {
    6a1a:	1d7b      	adds	r3, r7, #5
    6a1c:	781b      	ldrb	r3, [r3, #0]
    6a1e:	2b01      	cmp	r3, #1
    6a20:	d00c      	beq.n	6a3c <_gpio_set_pin_pull_mode+0x40>
    6a22:	2b02      	cmp	r3, #2
    6a24:	d029      	beq.n	6a7a <_gpio_set_pin_pull_mode+0x7e>
    6a26:	2b00      	cmp	r3, #0
    6a28:	d146      	bne.n	6ab8 <_gpio_set_pin_pull_mode+0xbc>
		hri_port_clear_PINCFG_PULLEN_bit(PORT, port, pin);
    6a2a:	1dbb      	adds	r3, r7, #6
    6a2c:	781a      	ldrb	r2, [r3, #0]
    6a2e:	1dfb      	adds	r3, r7, #7
    6a30:	781b      	ldrb	r3, [r3, #0]
    6a32:	4827      	ldr	r0, [pc, #156]	; (6ad0 <_gpio_set_pin_pull_mode+0xd4>)
    6a34:	0019      	movs	r1, r3
    6a36:	f7ff febb 	bl	67b0 <hri_port_clear_PINCFG_PULLEN_bit>
		break;
    6a3a:	e044      	b.n	6ac6 <_gpio_set_pin_pull_mode+0xca>
		hri_port_clear_DIR_reg(PORT_IOBUS, port, 1U << pin);
    6a3c:	1dbb      	adds	r3, r7, #6
    6a3e:	781b      	ldrb	r3, [r3, #0]
    6a40:	2201      	movs	r2, #1
    6a42:	409a      	lsls	r2, r3
    6a44:	1dfb      	adds	r3, r7, #7
    6a46:	7819      	ldrb	r1, [r3, #0]
    6a48:	23c0      	movs	r3, #192	; 0xc0
    6a4a:	05db      	lsls	r3, r3, #23
    6a4c:	0018      	movs	r0, r3
    6a4e:	f7ff fd56 	bl	64fe <hri_port_clear_DIR_reg>
		hri_port_set_PINCFG_PULLEN_bit(PORT, port, pin);
    6a52:	1dbb      	adds	r3, r7, #6
    6a54:	781a      	ldrb	r2, [r3, #0]
    6a56:	1dfb      	adds	r3, r7, #7
    6a58:	781b      	ldrb	r3, [r3, #0]
    6a5a:	481d      	ldr	r0, [pc, #116]	; (6ad0 <_gpio_set_pin_pull_mode+0xd4>)
    6a5c:	0019      	movs	r1, r3
    6a5e:	f7ff fe7c 	bl	675a <hri_port_set_PINCFG_PULLEN_bit>
		hri_port_set_OUT_reg(PORT_IOBUS, port, 1U << pin);
    6a62:	1dbb      	adds	r3, r7, #6
    6a64:	781b      	ldrb	r3, [r3, #0]
    6a66:	2201      	movs	r2, #1
    6a68:	409a      	lsls	r2, r3
    6a6a:	1dfb      	adds	r3, r7, #7
    6a6c:	7819      	ldrb	r1, [r3, #0]
    6a6e:	23c0      	movs	r3, #192	; 0xc0
    6a70:	05db      	lsls	r3, r3, #23
    6a72:	0018      	movs	r0, r3
    6a74:	f7ff fd59 	bl	652a <hri_port_set_OUT_reg>
		break;
    6a78:	e025      	b.n	6ac6 <_gpio_set_pin_pull_mode+0xca>
		hri_port_clear_DIR_reg(PORT_IOBUS, port, 1U << pin);
    6a7a:	1dbb      	adds	r3, r7, #6
    6a7c:	781b      	ldrb	r3, [r3, #0]
    6a7e:	2201      	movs	r2, #1
    6a80:	409a      	lsls	r2, r3
    6a82:	1dfb      	adds	r3, r7, #7
    6a84:	7819      	ldrb	r1, [r3, #0]
    6a86:	23c0      	movs	r3, #192	; 0xc0
    6a88:	05db      	lsls	r3, r3, #23
    6a8a:	0018      	movs	r0, r3
    6a8c:	f7ff fd37 	bl	64fe <hri_port_clear_DIR_reg>
		hri_port_set_PINCFG_PULLEN_bit(PORT, port, pin);
    6a90:	1dbb      	adds	r3, r7, #6
    6a92:	781a      	ldrb	r2, [r3, #0]
    6a94:	1dfb      	adds	r3, r7, #7
    6a96:	781b      	ldrb	r3, [r3, #0]
    6a98:	480d      	ldr	r0, [pc, #52]	; (6ad0 <_gpio_set_pin_pull_mode+0xd4>)
    6a9a:	0019      	movs	r1, r3
    6a9c:	f7ff fe5d 	bl	675a <hri_port_set_PINCFG_PULLEN_bit>
		hri_port_clear_OUT_reg(PORT_IOBUS, port, 1U << pin);
    6aa0:	1dbb      	adds	r3, r7, #6
    6aa2:	781b      	ldrb	r3, [r3, #0]
    6aa4:	2201      	movs	r2, #1
    6aa6:	409a      	lsls	r2, r3
    6aa8:	1dfb      	adds	r3, r7, #7
    6aaa:	7819      	ldrb	r1, [r3, #0]
    6aac:	23c0      	movs	r3, #192	; 0xc0
    6aae:	05db      	lsls	r3, r3, #23
    6ab0:	0018      	movs	r0, r3
    6ab2:	f7ff fd62 	bl	657a <hri_port_clear_OUT_reg>
		break;
    6ab6:	e006      	b.n	6ac6 <_gpio_set_pin_pull_mode+0xca>
		ASSERT(false);
    6ab8:	4b06      	ldr	r3, [pc, #24]	; (6ad4 <_gpio_set_pin_pull_mode+0xd8>)
    6aba:	2288      	movs	r2, #136	; 0x88
    6abc:	0019      	movs	r1, r3
    6abe:	2000      	movs	r0, #0
    6ac0:	f7fd fc4e 	bl	4360 <assert>
		break;
    6ac4:	46c0      	nop			; (mov r8, r8)
}
    6ac6:	46c0      	nop			; (mov r8, r8)
    6ac8:	46bd      	mov	sp, r7
    6aca:	b003      	add	sp, #12
    6acc:	bd90      	pop	{r4, r7, pc}
    6ace:	46c0      	nop			; (mov r8, r8)
    6ad0:	41004400 	.word	0x41004400
    6ad4:	00008ff8 	.word	0x00008ff8

00006ad8 <_gpio_set_pin_function>:
{
    6ad8:	b590      	push	{r4, r7, lr}
    6ada:	b085      	sub	sp, #20
    6adc:	af00      	add	r7, sp, #0
    6ade:	6078      	str	r0, [r7, #4]
    6ae0:	6039      	str	r1, [r7, #0]
	uint8_t port = GPIO_PORT(gpio);
    6ae2:	687b      	ldr	r3, [r7, #4]
    6ae4:	095a      	lsrs	r2, r3, #5
    6ae6:	230f      	movs	r3, #15
    6ae8:	18fb      	adds	r3, r7, r3
    6aea:	701a      	strb	r2, [r3, #0]
	uint8_t pin  = GPIO_PIN(gpio);
    6aec:	687b      	ldr	r3, [r7, #4]
    6aee:	b2da      	uxtb	r2, r3
    6af0:	230e      	movs	r3, #14
    6af2:	18fb      	adds	r3, r7, r3
    6af4:	211f      	movs	r1, #31
    6af6:	400a      	ands	r2, r1
    6af8:	701a      	strb	r2, [r3, #0]
	if (function == GPIO_PIN_FUNCTION_OFF) {
    6afa:	683b      	ldr	r3, [r7, #0]
    6afc:	3301      	adds	r3, #1
    6afe:	d10a      	bne.n	6b16 <_gpio_set_pin_function+0x3e>
		hri_port_write_PINCFG_PMUXEN_bit(PORT, port, pin, false);
    6b00:	230e      	movs	r3, #14
    6b02:	18fb      	adds	r3, r7, r3
    6b04:	781a      	ldrb	r2, [r3, #0]
    6b06:	230f      	movs	r3, #15
    6b08:	18fb      	adds	r3, r7, r3
    6b0a:	7819      	ldrb	r1, [r3, #0]
    6b0c:	481b      	ldr	r0, [pc, #108]	; (6b7c <_gpio_set_pin_function+0xa4>)
    6b0e:	2300      	movs	r3, #0
    6b10:	f7ff fde2 	bl	66d8 <hri_port_write_PINCFG_PMUXEN_bit>
}
    6b14:	e02e      	b.n	6b74 <_gpio_set_pin_function+0x9c>
		hri_port_write_PINCFG_PMUXEN_bit(PORT, port, pin, true);
    6b16:	230e      	movs	r3, #14
    6b18:	18fb      	adds	r3, r7, r3
    6b1a:	781a      	ldrb	r2, [r3, #0]
    6b1c:	230f      	movs	r3, #15
    6b1e:	18fb      	adds	r3, r7, r3
    6b20:	7819      	ldrb	r1, [r3, #0]
    6b22:	4816      	ldr	r0, [pc, #88]	; (6b7c <_gpio_set_pin_function+0xa4>)
    6b24:	2301      	movs	r3, #1
    6b26:	f7ff fdd7 	bl	66d8 <hri_port_write_PINCFG_PMUXEN_bit>
		if (pin & 1) {
    6b2a:	230e      	movs	r3, #14
    6b2c:	18fb      	adds	r3, r7, r3
    6b2e:	781b      	ldrb	r3, [r3, #0]
    6b30:	2201      	movs	r2, #1
    6b32:	4013      	ands	r3, r2
    6b34:	d00f      	beq.n	6b56 <_gpio_set_pin_function+0x7e>
			hri_port_write_PMUX_PMUXO_bf(PORT, port, pin >> 1, function & 0xffff);
    6b36:	230e      	movs	r3, #14
    6b38:	18fb      	adds	r3, r7, r3
    6b3a:	781b      	ldrb	r3, [r3, #0]
    6b3c:	085b      	lsrs	r3, r3, #1
    6b3e:	b2da      	uxtb	r2, r3
    6b40:	683b      	ldr	r3, [r7, #0]
    6b42:	b2d8      	uxtb	r0, r3
    6b44:	230f      	movs	r3, #15
    6b46:	18fb      	adds	r3, r7, r3
    6b48:	7819      	ldrb	r1, [r3, #0]
    6b4a:	4c0c      	ldr	r4, [pc, #48]	; (6b7c <_gpio_set_pin_function+0xa4>)
    6b4c:	0003      	movs	r3, r0
    6b4e:	0020      	movs	r0, r4
    6b50:	f7ff fd7f 	bl	6652 <hri_port_write_PMUX_PMUXO_bf>
}
    6b54:	e00e      	b.n	6b74 <_gpio_set_pin_function+0x9c>
			hri_port_write_PMUX_PMUXE_bf(PORT, port, pin >> 1, function & 0xffff);
    6b56:	230e      	movs	r3, #14
    6b58:	18fb      	adds	r3, r7, r3
    6b5a:	781b      	ldrb	r3, [r3, #0]
    6b5c:	085b      	lsrs	r3, r3, #1
    6b5e:	b2da      	uxtb	r2, r3
    6b60:	683b      	ldr	r3, [r7, #0]
    6b62:	b2d8      	uxtb	r0, r3
    6b64:	230f      	movs	r3, #15
    6b66:	18fb      	adds	r3, r7, r3
    6b68:	7819      	ldrb	r1, [r3, #0]
    6b6a:	4c04      	ldr	r4, [pc, #16]	; (6b7c <_gpio_set_pin_function+0xa4>)
    6b6c:	0003      	movs	r3, r0
    6b6e:	0020      	movs	r0, r4
    6b70:	f7ff fd2b 	bl	65ca <hri_port_write_PMUX_PMUXE_bf>
}
    6b74:	46c0      	nop			; (mov r8, r8)
    6b76:	46bd      	mov	sp, r7
    6b78:	b005      	add	sp, #20
    6b7a:	bd90      	pop	{r4, r7, pc}
    6b7c:	41004400 	.word	0x41004400

00006b80 <gpio_set_pin_pull_mode>:
{
    6b80:	b580      	push	{r7, lr}
    6b82:	b082      	sub	sp, #8
    6b84:	af00      	add	r7, sp, #0
    6b86:	0002      	movs	r2, r0
    6b88:	1dfb      	adds	r3, r7, #7
    6b8a:	701a      	strb	r2, [r3, #0]
    6b8c:	1dbb      	adds	r3, r7, #6
    6b8e:	1c0a      	adds	r2, r1, #0
    6b90:	701a      	strb	r2, [r3, #0]
	_gpio_set_pin_pull_mode((enum gpio_port)GPIO_PORT(pin), pin & 0x1F, pull_mode);
    6b92:	1dfb      	adds	r3, r7, #7
    6b94:	781b      	ldrb	r3, [r3, #0]
    6b96:	095b      	lsrs	r3, r3, #5
    6b98:	b2d8      	uxtb	r0, r3
    6b9a:	1dfb      	adds	r3, r7, #7
    6b9c:	781b      	ldrb	r3, [r3, #0]
    6b9e:	221f      	movs	r2, #31
    6ba0:	4013      	ands	r3, r2
    6ba2:	b2d9      	uxtb	r1, r3
    6ba4:	1dbb      	adds	r3, r7, #6
    6ba6:	781b      	ldrb	r3, [r3, #0]
    6ba8:	001a      	movs	r2, r3
    6baa:	f7ff ff27 	bl	69fc <_gpio_set_pin_pull_mode>
}
    6bae:	46c0      	nop			; (mov r8, r8)
    6bb0:	46bd      	mov	sp, r7
    6bb2:	b002      	add	sp, #8
    6bb4:	bd80      	pop	{r7, pc}

00006bb6 <gpio_set_pin_function>:
{
    6bb6:	b580      	push	{r7, lr}
    6bb8:	b082      	sub	sp, #8
    6bba:	af00      	add	r7, sp, #0
    6bbc:	6078      	str	r0, [r7, #4]
    6bbe:	6039      	str	r1, [r7, #0]
	_gpio_set_pin_function(pin, function);
    6bc0:	683a      	ldr	r2, [r7, #0]
    6bc2:	687b      	ldr	r3, [r7, #4]
    6bc4:	0011      	movs	r1, r2
    6bc6:	0018      	movs	r0, r3
    6bc8:	f7ff ff86 	bl	6ad8 <_gpio_set_pin_function>
}
    6bcc:	46c0      	nop			; (mov r8, r8)
    6bce:	46bd      	mov	sp, r7
    6bd0:	b002      	add	sp, #8
    6bd2:	bd80      	pop	{r7, pc}

00006bd4 <gpio_set_pin_direction>:
{
    6bd4:	b580      	push	{r7, lr}
    6bd6:	b082      	sub	sp, #8
    6bd8:	af00      	add	r7, sp, #0
    6bda:	0002      	movs	r2, r0
    6bdc:	1dfb      	adds	r3, r7, #7
    6bde:	701a      	strb	r2, [r3, #0]
    6be0:	1dbb      	adds	r3, r7, #6
    6be2:	1c0a      	adds	r2, r1, #0
    6be4:	701a      	strb	r2, [r3, #0]
	_gpio_set_direction((enum gpio_port)GPIO_PORT(pin), 1U << GPIO_PIN(pin), direction);
    6be6:	1dfb      	adds	r3, r7, #7
    6be8:	781b      	ldrb	r3, [r3, #0]
    6bea:	095b      	lsrs	r3, r3, #5
    6bec:	b2d8      	uxtb	r0, r3
    6bee:	1dfb      	adds	r3, r7, #7
    6bf0:	781b      	ldrb	r3, [r3, #0]
    6bf2:	221f      	movs	r2, #31
    6bf4:	4013      	ands	r3, r2
    6bf6:	2201      	movs	r2, #1
    6bf8:	409a      	lsls	r2, r3
    6bfa:	0011      	movs	r1, r2
    6bfc:	1dbb      	adds	r3, r7, #6
    6bfe:	781b      	ldrb	r3, [r3, #0]
    6c00:	001a      	movs	r2, r3
    6c02:	f7ff fe17 	bl	6834 <_gpio_set_direction>
}
    6c06:	46c0      	nop			; (mov r8, r8)
    6c08:	46bd      	mov	sp, r7
    6c0a:	b002      	add	sp, #8
    6c0c:	bd80      	pop	{r7, pc}

00006c0e <gpio_set_pin_level>:
{
    6c0e:	b580      	push	{r7, lr}
    6c10:	b082      	sub	sp, #8
    6c12:	af00      	add	r7, sp, #0
    6c14:	0002      	movs	r2, r0
    6c16:	1dfb      	adds	r3, r7, #7
    6c18:	701a      	strb	r2, [r3, #0]
    6c1a:	1dbb      	adds	r3, r7, #6
    6c1c:	1c0a      	adds	r2, r1, #0
    6c1e:	701a      	strb	r2, [r3, #0]
	_gpio_set_level((enum gpio_port)GPIO_PORT(pin), 1U << GPIO_PIN(pin), level);
    6c20:	1dfb      	adds	r3, r7, #7
    6c22:	781b      	ldrb	r3, [r3, #0]
    6c24:	095b      	lsrs	r3, r3, #5
    6c26:	b2d8      	uxtb	r0, r3
    6c28:	1dfb      	adds	r3, r7, #7
    6c2a:	781b      	ldrb	r3, [r3, #0]
    6c2c:	221f      	movs	r2, #31
    6c2e:	4013      	ands	r3, r2
    6c30:	2201      	movs	r2, #1
    6c32:	409a      	lsls	r2, r3
    6c34:	0011      	movs	r1, r2
    6c36:	1dbb      	adds	r3, r7, #6
    6c38:	781b      	ldrb	r3, [r3, #0]
    6c3a:	001a      	movs	r2, r3
    6c3c:	f7ff fe7e 	bl	693c <_gpio_set_level>
}
    6c40:	46c0      	nop			; (mov r8, r8)
    6c42:	46bd      	mov	sp, r7
    6c44:	b002      	add	sp, #8
    6c46:	bd80      	pop	{r7, pc}

00006c48 <gpio_get_pin_level>:
 * Reads the level on pins connected to a port
 *
 * \param[in] pin       The pin number for device
 */
static inline bool gpio_get_pin_level(const uint8_t pin)
{
    6c48:	b580      	push	{r7, lr}
    6c4a:	b082      	sub	sp, #8
    6c4c:	af00      	add	r7, sp, #0
    6c4e:	0002      	movs	r2, r0
    6c50:	1dfb      	adds	r3, r7, #7
    6c52:	701a      	strb	r2, [r3, #0]
	return (bool)(_gpio_get_level((enum gpio_port)GPIO_PORT(pin)) & (0x01U << GPIO_PIN(pin)));
    6c54:	1dfb      	adds	r3, r7, #7
    6c56:	781b      	ldrb	r3, [r3, #0]
    6c58:	095b      	lsrs	r3, r3, #5
    6c5a:	b2db      	uxtb	r3, r3
    6c5c:	0018      	movs	r0, r3
    6c5e:	f7ff fe91 	bl	6984 <_gpio_get_level>
    6c62:	0001      	movs	r1, r0
    6c64:	1dfb      	adds	r3, r7, #7
    6c66:	781b      	ldrb	r3, [r3, #0]
    6c68:	221f      	movs	r2, #31
    6c6a:	4013      	ands	r3, r2
    6c6c:	2201      	movs	r2, #1
    6c6e:	409a      	lsls	r2, r3
    6c70:	0013      	movs	r3, r2
    6c72:	400b      	ands	r3, r1
    6c74:	1e5a      	subs	r2, r3, #1
    6c76:	4193      	sbcs	r3, r2
    6c78:	b2db      	uxtb	r3, r3
}
    6c7a:	0018      	movs	r0, r3
    6c7c:	46bd      	mov	sp, r7
    6c7e:	b002      	add	sp, #8
    6c80:	bd80      	pop	{r7, pc}
	...

00006c84 <_gclk_enable_channel>:
{
    6c84:	b580      	push	{r7, lr}
    6c86:	b082      	sub	sp, #8
    6c88:	af00      	add	r7, sp, #0
    6c8a:	0002      	movs	r2, r0
    6c8c:	1dfb      	adds	r3, r7, #7
    6c8e:	701a      	strb	r2, [r3, #0]
    6c90:	1dbb      	adds	r3, r7, #6
    6c92:	1c0a      	adds	r2, r1, #0
    6c94:	701a      	strb	r2, [r3, #0]
	                           GCLK_CLKCTRL_ID(channel) | GCLK_CLKCTRL_GEN(source) | (1 << GCLK_CLKCTRL_CLKEN_Pos));
    6c96:	1dfb      	adds	r3, r7, #7
    6c98:	781b      	ldrb	r3, [r3, #0]
    6c9a:	b29b      	uxth	r3, r3
    6c9c:	223f      	movs	r2, #63	; 0x3f
    6c9e:	4013      	ands	r3, r2
    6ca0:	b29a      	uxth	r2, r3
    6ca2:	1dbb      	adds	r3, r7, #6
    6ca4:	781b      	ldrb	r3, [r3, #0]
    6ca6:	b29b      	uxth	r3, r3
    6ca8:	021b      	lsls	r3, r3, #8
    6caa:	b299      	uxth	r1, r3
    6cac:	23f0      	movs	r3, #240	; 0xf0
    6cae:	011b      	lsls	r3, r3, #4
    6cb0:	400b      	ands	r3, r1
    6cb2:	b29b      	uxth	r3, r3
    6cb4:	4313      	orrs	r3, r2
    6cb6:	b29b      	uxth	r3, r3
	hri_gclk_write_CLKCTRL_reg(GCLK,
    6cb8:	2280      	movs	r2, #128	; 0x80
    6cba:	01d2      	lsls	r2, r2, #7
    6cbc:	4313      	orrs	r3, r2
    6cbe:	b29b      	uxth	r3, r3
    6cc0:	4a04      	ldr	r2, [pc, #16]	; (6cd4 <_gclk_enable_channel+0x50>)
    6cc2:	0019      	movs	r1, r3
    6cc4:	0010      	movs	r0, r2
    6cc6:	f7ff fbe5 	bl	6494 <hri_gclk_write_CLKCTRL_reg>
}
    6cca:	46c0      	nop			; (mov r8, r8)
    6ccc:	46bd      	mov	sp, r7
    6cce:	b002      	add	sp, #8
    6cd0:	bd80      	pop	{r7, pc}
    6cd2:	46c0      	nop			; (mov r8, r8)
    6cd4:	40000c00 	.word	0x40000c00

00006cd8 <_pm_get_ahb_index>:
{
    6cd8:	b580      	push	{r7, lr}
    6cda:	b082      	sub	sp, #8
    6cdc:	af00      	add	r7, sp, #0
    6cde:	6078      	str	r0, [r7, #4]
	if ((uint32_t)module == (uint32_t)PM_BUS_APBA) {
    6ce0:	687b      	ldr	r3, [r7, #4]
    6ce2:	2b01      	cmp	r3, #1
    6ce4:	d101      	bne.n	6cea <_pm_get_ahb_index+0x12>
		return 0;
    6ce6:	2300      	movs	r3, #0
    6ce8:	e017      	b.n	6d1a <_pm_get_ahb_index+0x42>
	} else if ((uint32_t)module == (uint32_t)PM_BUS_APBB) {
    6cea:	687b      	ldr	r3, [r7, #4]
    6cec:	2b02      	cmp	r3, #2
    6cee:	d101      	bne.n	6cf4 <_pm_get_ahb_index+0x1c>
		return 1;
    6cf0:	2301      	movs	r3, #1
    6cf2:	e012      	b.n	6d1a <_pm_get_ahb_index+0x42>
	} else if ((uint32_t)module == (uint32_t)PM_BUS_APBC) {
    6cf4:	687b      	ldr	r3, [r7, #4]
    6cf6:	2b03      	cmp	r3, #3
    6cf8:	d101      	bne.n	6cfe <_pm_get_ahb_index+0x26>
		return 2;
    6cfa:	2302      	movs	r3, #2
    6cfc:	e00d      	b.n	6d1a <_pm_get_ahb_index+0x42>
	if ((uint32_t)module == (uint32_t)DSU) {
    6cfe:	687b      	ldr	r3, [r7, #4]
    6d00:	4a08      	ldr	r2, [pc, #32]	; (6d24 <_pm_get_ahb_index+0x4c>)
    6d02:	4293      	cmp	r3, r2
    6d04:	d101      	bne.n	6d0a <_pm_get_ahb_index+0x32>
		return 3;
    6d06:	2303      	movs	r3, #3
    6d08:	e007      	b.n	6d1a <_pm_get_ahb_index+0x42>
	} else if ((uint32_t)module == (uint32_t)NVMCTRL) {
    6d0a:	687b      	ldr	r3, [r7, #4]
    6d0c:	4a06      	ldr	r2, [pc, #24]	; (6d28 <_pm_get_ahb_index+0x50>)
    6d0e:	4293      	cmp	r3, r2
    6d10:	d101      	bne.n	6d16 <_pm_get_ahb_index+0x3e>
		return 4;
    6d12:	2304      	movs	r3, #4
    6d14:	e001      	b.n	6d1a <_pm_get_ahb_index+0x42>
	return ERR_INVALID_ARG;
    6d16:	230d      	movs	r3, #13
    6d18:	425b      	negs	r3, r3
}
    6d1a:	0018      	movs	r0, r3
    6d1c:	46bd      	mov	sp, r7
    6d1e:	b002      	add	sp, #8
    6d20:	bd80      	pop	{r7, pc}
    6d22:	46c0      	nop			; (mov r8, r8)
    6d24:	41002000 	.word	0x41002000
    6d28:	41004000 	.word	0x41004000

00006d2c <_pm_get_apbb_index>:
{
    6d2c:	b580      	push	{r7, lr}
    6d2e:	b082      	sub	sp, #8
    6d30:	af00      	add	r7, sp, #0
    6d32:	6078      	str	r0, [r7, #4]
	if ((uint32_t)module == (uint32_t)PAC1) {
    6d34:	687a      	ldr	r2, [r7, #4]
    6d36:	2382      	movs	r3, #130	; 0x82
    6d38:	05db      	lsls	r3, r3, #23
    6d3a:	429a      	cmp	r2, r3
    6d3c:	d101      	bne.n	6d42 <_pm_get_apbb_index+0x16>
		return 0;
    6d3e:	2300      	movs	r3, #0
    6d40:	e013      	b.n	6d6a <_pm_get_apbb_index+0x3e>
	} else if ((uint32_t)module == (uint32_t)DSU) {
    6d42:	687b      	ldr	r3, [r7, #4]
    6d44:	4a0b      	ldr	r2, [pc, #44]	; (6d74 <_pm_get_apbb_index+0x48>)
    6d46:	4293      	cmp	r3, r2
    6d48:	d101      	bne.n	6d4e <_pm_get_apbb_index+0x22>
		return 1;
    6d4a:	2301      	movs	r3, #1
    6d4c:	e00d      	b.n	6d6a <_pm_get_apbb_index+0x3e>
	} else if ((uint32_t)module == (uint32_t)NVMCTRL) {
    6d4e:	687b      	ldr	r3, [r7, #4]
    6d50:	4a09      	ldr	r2, [pc, #36]	; (6d78 <_pm_get_apbb_index+0x4c>)
    6d52:	4293      	cmp	r3, r2
    6d54:	d101      	bne.n	6d5a <_pm_get_apbb_index+0x2e>
		return 2;
    6d56:	2302      	movs	r3, #2
    6d58:	e007      	b.n	6d6a <_pm_get_apbb_index+0x3e>
	if ((uint32_t)module == (uint32_t)PORT) {
    6d5a:	687b      	ldr	r3, [r7, #4]
    6d5c:	4a07      	ldr	r2, [pc, #28]	; (6d7c <_pm_get_apbb_index+0x50>)
    6d5e:	4293      	cmp	r3, r2
    6d60:	d101      	bne.n	6d66 <_pm_get_apbb_index+0x3a>
		return 3;
    6d62:	2303      	movs	r3, #3
    6d64:	e001      	b.n	6d6a <_pm_get_apbb_index+0x3e>
	return ERR_INVALID_ARG;
    6d66:	230d      	movs	r3, #13
    6d68:	425b      	negs	r3, r3
}
    6d6a:	0018      	movs	r0, r3
    6d6c:	46bd      	mov	sp, r7
    6d6e:	b002      	add	sp, #8
    6d70:	bd80      	pop	{r7, pc}
    6d72:	46c0      	nop			; (mov r8, r8)
    6d74:	41002000 	.word	0x41002000
    6d78:	41004000 	.word	0x41004000
    6d7c:	41004400 	.word	0x41004400

00006d80 <_pm_enable_bus_clock>:
{
    6d80:	b580      	push	{r7, lr}
    6d82:	b084      	sub	sp, #16
    6d84:	af00      	add	r7, sp, #0
    6d86:	0002      	movs	r2, r0
    6d88:	6039      	str	r1, [r7, #0]
    6d8a:	1dfb      	adds	r3, r7, #7
    6d8c:	701a      	strb	r2, [r3, #0]
	uint32_t peripheral = ((uint32_t)module & 0x0000ff00) >> 10;
    6d8e:	683b      	ldr	r3, [r7, #0]
    6d90:	0a9b      	lsrs	r3, r3, #10
    6d92:	223f      	movs	r2, #63	; 0x3f
    6d94:	4013      	ands	r3, r2
    6d96:	60fb      	str	r3, [r7, #12]
	switch (bus) {
    6d98:	1dfb      	adds	r3, r7, #7
    6d9a:	781b      	ldrb	r3, [r3, #0]
    6d9c:	2b01      	cmp	r3, #1
    6d9e:	d01e      	beq.n	6dde <_pm_enable_bus_clock+0x5e>
    6da0:	dc02      	bgt.n	6da8 <_pm_enable_bus_clock+0x28>
    6da2:	2b00      	cmp	r3, #0
    6da4:	d005      	beq.n	6db2 <_pm_enable_bus_clock+0x32>
    6da6:	e044      	b.n	6e32 <_pm_enable_bus_clock+0xb2>
    6da8:	2b02      	cmp	r3, #2
    6daa:	d022      	beq.n	6df2 <_pm_enable_bus_clock+0x72>
    6dac:	2b03      	cmp	r3, #3
    6dae:	d036      	beq.n	6e1e <_pm_enable_bus_clock+0x9e>
    6db0:	e03f      	b.n	6e32 <_pm_enable_bus_clock+0xb2>
		if (_pm_get_ahb_index(module) >= 0) {
    6db2:	683b      	ldr	r3, [r7, #0]
    6db4:	0018      	movs	r0, r3
    6db6:	f7ff ff8f 	bl	6cd8 <_pm_get_ahb_index>
    6dba:	1e03      	subs	r3, r0, #0
    6dbc:	db40      	blt.n	6e40 <_pm_enable_bus_clock+0xc0>
			peripheral = (uint32_t)_pm_get_ahb_index(module);
    6dbe:	683b      	ldr	r3, [r7, #0]
    6dc0:	0018      	movs	r0, r3
    6dc2:	f7ff ff89 	bl	6cd8 <_pm_get_ahb_index>
    6dc6:	0003      	movs	r3, r0
    6dc8:	60fb      	str	r3, [r7, #12]
			PM->AHBMASK.reg |= 1 << peripheral;
    6dca:	4b21      	ldr	r3, [pc, #132]	; (6e50 <_pm_enable_bus_clock+0xd0>)
    6dcc:	4a20      	ldr	r2, [pc, #128]	; (6e50 <_pm_enable_bus_clock+0xd0>)
    6dce:	6952      	ldr	r2, [r2, #20]
    6dd0:	2001      	movs	r0, #1
    6dd2:	68f9      	ldr	r1, [r7, #12]
    6dd4:	4088      	lsls	r0, r1
    6dd6:	0001      	movs	r1, r0
    6dd8:	430a      	orrs	r2, r1
    6dda:	615a      	str	r2, [r3, #20]
		break;
    6ddc:	e030      	b.n	6e40 <_pm_enable_bus_clock+0xc0>
		PM->APBAMASK.reg |= 1 << peripheral;
    6dde:	4b1c      	ldr	r3, [pc, #112]	; (6e50 <_pm_enable_bus_clock+0xd0>)
    6de0:	4a1b      	ldr	r2, [pc, #108]	; (6e50 <_pm_enable_bus_clock+0xd0>)
    6de2:	6992      	ldr	r2, [r2, #24]
    6de4:	2001      	movs	r0, #1
    6de6:	68f9      	ldr	r1, [r7, #12]
    6de8:	4088      	lsls	r0, r1
    6dea:	0001      	movs	r1, r0
    6dec:	430a      	orrs	r2, r1
    6dee:	619a      	str	r2, [r3, #24]
		break;
    6df0:	e029      	b.n	6e46 <_pm_enable_bus_clock+0xc6>
		if (_pm_get_apbb_index(module) >= 0) {
    6df2:	683b      	ldr	r3, [r7, #0]
    6df4:	0018      	movs	r0, r3
    6df6:	f7ff ff99 	bl	6d2c <_pm_get_apbb_index>
    6dfa:	1e03      	subs	r3, r0, #0
    6dfc:	db22      	blt.n	6e44 <_pm_enable_bus_clock+0xc4>
			peripheral = (uint32_t)_pm_get_apbb_index(module);
    6dfe:	683b      	ldr	r3, [r7, #0]
    6e00:	0018      	movs	r0, r3
    6e02:	f7ff ff93 	bl	6d2c <_pm_get_apbb_index>
    6e06:	0003      	movs	r3, r0
    6e08:	60fb      	str	r3, [r7, #12]
			PM->APBBMASK.reg |= 1 << peripheral;
    6e0a:	4b11      	ldr	r3, [pc, #68]	; (6e50 <_pm_enable_bus_clock+0xd0>)
    6e0c:	4a10      	ldr	r2, [pc, #64]	; (6e50 <_pm_enable_bus_clock+0xd0>)
    6e0e:	69d2      	ldr	r2, [r2, #28]
    6e10:	2001      	movs	r0, #1
    6e12:	68f9      	ldr	r1, [r7, #12]
    6e14:	4088      	lsls	r0, r1
    6e16:	0001      	movs	r1, r0
    6e18:	430a      	orrs	r2, r1
    6e1a:	61da      	str	r2, [r3, #28]
		break;
    6e1c:	e012      	b.n	6e44 <_pm_enable_bus_clock+0xc4>
		PM->APBCMASK.reg |= 1 << peripheral;
    6e1e:	4b0c      	ldr	r3, [pc, #48]	; (6e50 <_pm_enable_bus_clock+0xd0>)
    6e20:	4a0b      	ldr	r2, [pc, #44]	; (6e50 <_pm_enable_bus_clock+0xd0>)
    6e22:	6a12      	ldr	r2, [r2, #32]
    6e24:	2001      	movs	r0, #1
    6e26:	68f9      	ldr	r1, [r7, #12]
    6e28:	4088      	lsls	r0, r1
    6e2a:	0001      	movs	r1, r0
    6e2c:	430a      	orrs	r2, r1
    6e2e:	621a      	str	r2, [r3, #32]
		break;
    6e30:	e009      	b.n	6e46 <_pm_enable_bus_clock+0xc6>
		ASSERT(false);
    6e32:	4b08      	ldr	r3, [pc, #32]	; (6e54 <_pm_enable_bus_clock+0xd4>)
    6e34:	228d      	movs	r2, #141	; 0x8d
    6e36:	0019      	movs	r1, r3
    6e38:	2000      	movs	r0, #0
    6e3a:	f7fd fa91 	bl	4360 <assert>
		break;
    6e3e:	e002      	b.n	6e46 <_pm_enable_bus_clock+0xc6>
		break;
    6e40:	46c0      	nop			; (mov r8, r8)
    6e42:	e000      	b.n	6e46 <_pm_enable_bus_clock+0xc6>
		break;
    6e44:	46c0      	nop			; (mov r8, r8)
}
    6e46:	46c0      	nop			; (mov r8, r8)
    6e48:	46bd      	mov	sp, r7
    6e4a:	b004      	add	sp, #16
    6e4c:	bd80      	pop	{r7, pc}
    6e4e:	46c0      	nop			; (mov r8, r8)
    6e50:	40000400 	.word	0x40000400
    6e54:	00009014 	.word	0x00009014

00006e58 <RF_IRQ_Enable>:
struct io_descriptor *lcd_spi;
struct io_descriptor *rf_spi;



void RF_IRQ_Enable(void){
    6e58:	b580      	push	{r7, lr}
    6e5a:	af00      	add	r7, sp, #0
	ext_irq_register(RF_IRQ, RF_int_Handler);
    6e5c:	4b05      	ldr	r3, [pc, #20]	; (6e74 <RF_IRQ_Enable+0x1c>)
    6e5e:	0019      	movs	r1, r3
    6e60:	203e      	movs	r0, #62	; 0x3e
    6e62:	f7fc fe17 	bl	3a94 <ext_irq_register>
	spi_m_sync_enable(&RF_SPI);
    6e66:	4b04      	ldr	r3, [pc, #16]	; (6e78 <RF_IRQ_Enable+0x20>)
    6e68:	0018      	movs	r0, r3
    6e6a:	f7fd f8c9 	bl	4000 <spi_m_sync_enable>
}
    6e6e:	46c0      	nop			; (mov r8, r8)
    6e70:	46bd      	mov	sp, r7
    6e72:	bd80      	pop	{r7, pc}
    6e74:	00006ea5 	.word	0x00006ea5
    6e78:	20000810 	.word	0x20000810

00006e7c <rf_isReady>:


uint8_t int_count = 0;
bool rf_isReady(){
    6e7c:	b580      	push	{r7, lr}
    6e7e:	af00      	add	r7, sp, #0
	if (int_count != 0){
    6e80:	4b07      	ldr	r3, [pc, #28]	; (6ea0 <rf_isReady+0x24>)
    6e82:	781b      	ldrb	r3, [r3, #0]
    6e84:	2b00      	cmp	r3, #0
    6e86:	d006      	beq.n	6e96 <rf_isReady+0x1a>
		data_ready();
    6e88:	f000 fd44 	bl	7914 <data_ready>
		int_count = 0;
    6e8c:	4b04      	ldr	r3, [pc, #16]	; (6ea0 <rf_isReady+0x24>)
    6e8e:	2200      	movs	r2, #0
    6e90:	701a      	strb	r2, [r3, #0]
		return true;
    6e92:	2301      	movs	r3, #1
    6e94:	e000      	b.n	6e98 <rf_isReady+0x1c>
	}
	return false;
    6e96:	2300      	movs	r3, #0
}
    6e98:	0018      	movs	r0, r3
    6e9a:	46bd      	mov	sp, r7
    6e9c:	bd80      	pop	{r7, pc}
    6e9e:	46c0      	nop			; (mov r8, r8)
    6ea0:	200007d0 	.word	0x200007d0

00006ea4 <RF_int_Handler>:

void RF_int_Handler(void){
    6ea4:	b580      	push	{r7, lr}
    6ea6:	af00      	add	r7, sp, #0
	int_count++;
    6ea8:	4b04      	ldr	r3, [pc, #16]	; (6ebc <RF_int_Handler+0x18>)
    6eaa:	781b      	ldrb	r3, [r3, #0]
    6eac:	3301      	adds	r3, #1
    6eae:	b2da      	uxtb	r2, r3
    6eb0:	4b02      	ldr	r3, [pc, #8]	; (6ebc <RF_int_Handler+0x18>)
    6eb2:	701a      	strb	r2, [r3, #0]
	//gpio_toggle_pin_level(LED);
	
}
    6eb4:	46c0      	nop			; (mov r8, r8)
    6eb6:	46bd      	mov	sp, r7
    6eb8:	bd80      	pop	{r7, pc}
    6eba:	46c0      	nop			; (mov r8, r8)
    6ebc:	200007d0 	.word	0x200007d0

00006ec0 <RFM69_ReadBuff>:
	io_write(rf_spi, &addr, 1);
	io_read(rf_spi,&addr,1);
	return addr;
}

void RFM69_ReadBuff(uint8_t* buff, uint16_t len){
    6ec0:	b580      	push	{r7, lr}
    6ec2:	b082      	sub	sp, #8
    6ec4:	af00      	add	r7, sp, #0
    6ec6:	6078      	str	r0, [r7, #4]
    6ec8:	000a      	movs	r2, r1
    6eca:	1cbb      	adds	r3, r7, #2
    6ecc:	801a      	strh	r2, [r3, #0]
	//spi_m_sync_get_io_descriptor(&RF_SPI, &io);
	//spi_m_sync_enable(&VFD_SPI);
	io_read(rf_spi,buff,len);
    6ece:	4b06      	ldr	r3, [pc, #24]	; (6ee8 <RFM69_ReadBuff+0x28>)
    6ed0:	6818      	ldr	r0, [r3, #0]
    6ed2:	1cbb      	adds	r3, r7, #2
    6ed4:	881a      	ldrh	r2, [r3, #0]
    6ed6:	687b      	ldr	r3, [r7, #4]
    6ed8:	0019      	movs	r1, r3
    6eda:	f7fd f829 	bl	3f30 <io_read>
}
    6ede:	46c0      	nop			; (mov r8, r8)
    6ee0:	46bd      	mov	sp, r7
    6ee2:	b002      	add	sp, #8
    6ee4:	bd80      	pop	{r7, pc}
    6ee6:	46c0      	nop			; (mov r8, r8)
    6ee8:	2000080c 	.word	0x2000080c

00006eec <RFM69_WriteBuff>:

void RFM69_WriteBuff(uint8_t* buff, uint16_t len){
    6eec:	b580      	push	{r7, lr}
    6eee:	b082      	sub	sp, #8
    6ef0:	af00      	add	r7, sp, #0
    6ef2:	6078      	str	r0, [r7, #4]
    6ef4:	000a      	movs	r2, r1
    6ef6:	1cbb      	adds	r3, r7, #2
    6ef8:	801a      	strh	r2, [r3, #0]
	//spi_m_sync_get_io_descriptor(&RF_SPI, &io);
	//spi_m_sync_enable(&VFD_SPI);
	io_write(rf_spi,buff,len);
    6efa:	4b06      	ldr	r3, [pc, #24]	; (6f14 <RFM69_WriteBuff+0x28>)
    6efc:	6818      	ldr	r0, [r3, #0]
    6efe:	1cbb      	adds	r3, r7, #2
    6f00:	881a      	ldrh	r2, [r3, #0]
    6f02:	687b      	ldr	r3, [r7, #4]
    6f04:	0019      	movs	r1, r3
    6f06:	f7fc ffeb 	bl	3ee0 <io_write>
}
    6f0a:	46c0      	nop			; (mov r8, r8)
    6f0c:	46bd      	mov	sp, r7
    6f0e:	b002      	add	sp, #8
    6f10:	bd80      	pop	{r7, pc}
    6f12:	46c0      	nop			; (mov r8, r8)
    6f14:	2000080c 	.word	0x2000080c

00006f18 <RFM_69_sel>:



void RFM_69_sel(bool arg){
    6f18:	b580      	push	{r7, lr}
    6f1a:	b082      	sub	sp, #8
    6f1c:	af00      	add	r7, sp, #0
    6f1e:	0002      	movs	r2, r0
    6f20:	1dfb      	adds	r3, r7, #7
    6f22:	701a      	strb	r2, [r3, #0]
	gpio_set_pin_level(RF_CS , arg);
    6f24:	1dfb      	adds	r3, r7, #7
    6f26:	781b      	ldrb	r3, [r3, #0]
    6f28:	0019      	movs	r1, r3
    6f2a:	201c      	movs	r0, #28
    6f2c:	f7ff fe6f 	bl	6c0e <gpio_set_pin_level>
}
    6f30:	46c0      	nop			; (mov r8, r8)
    6f32:	46bd      	mov	sp, r7
    6f34:	b002      	add	sp, #8
    6f36:	bd80      	pop	{r7, pc}

00006f38 <SPI_write>:

void SPI_write(uint8_t arg){
    6f38:	b580      	push	{r7, lr}
    6f3a:	b084      	sub	sp, #16
    6f3c:	af00      	add	r7, sp, #0
    6f3e:	0002      	movs	r2, r0
    6f40:	1dfb      	adds	r3, r7, #7
    6f42:	701a      	strb	r2, [r3, #0]
	uint8_t *addr_ptr = &arg;
    6f44:	1dfb      	adds	r3, r7, #7
    6f46:	60fb      	str	r3, [r7, #12]
	//struct io_descriptor *io;
	//spi_m_sync_get_io_descriptor(&RF_SPI, &io); ///<<< EXP
	//spi_m_sync_enable(&RF_SPI);
	io_write(rf_spi, &arg, 1);	
    6f48:	4b05      	ldr	r3, [pc, #20]	; (6f60 <SPI_write+0x28>)
    6f4a:	681b      	ldr	r3, [r3, #0]
    6f4c:	1df9      	adds	r1, r7, #7
    6f4e:	2201      	movs	r2, #1
    6f50:	0018      	movs	r0, r3
    6f52:	f7fc ffc5 	bl	3ee0 <io_write>
}
    6f56:	46c0      	nop			; (mov r8, r8)
    6f58:	46bd      	mov	sp, r7
    6f5a:	b004      	add	sp, #16
    6f5c:	bd80      	pop	{r7, pc}
    6f5e:	46c0      	nop			; (mov r8, r8)
    6f60:	2000080c 	.word	0x2000080c

00006f64 <SPI_read>:


uint8_t SPI_read(){
    6f64:	b580      	push	{r7, lr}
    6f66:	b082      	sub	sp, #8
    6f68:	af00      	add	r7, sp, #0
	uint8_t data_byte = 0;
    6f6a:	1dfb      	adds	r3, r7, #7
    6f6c:	2200      	movs	r2, #0
    6f6e:	701a      	strb	r2, [r3, #0]
	//spi_m_sync_get_io_descriptor(&RF_SPI, &io); ///<<< EXP
	io_read(rf_spi,&data_byte,1);
    6f70:	4b06      	ldr	r3, [pc, #24]	; (6f8c <SPI_read+0x28>)
    6f72:	681b      	ldr	r3, [r3, #0]
    6f74:	1df9      	adds	r1, r7, #7
    6f76:	2201      	movs	r2, #1
    6f78:	0018      	movs	r0, r3
    6f7a:	f7fc ffd9 	bl	3f30 <io_read>
	return data_byte;
    6f7e:	1dfb      	adds	r3, r7, #7
    6f80:	781b      	ldrb	r3, [r3, #0]
}
    6f82:	0018      	movs	r0, r3
    6f84:	46bd      	mov	sp, r7
    6f86:	b002      	add	sp, #8
    6f88:	bd80      	pop	{r7, pc}
    6f8a:	46c0      	nop			; (mov r8, r8)
    6f8c:	2000080c 	.word	0x2000080c

00006f90 <get_io0>:

bool get_io0(){
    6f90:	b580      	push	{r7, lr}
    6f92:	af00      	add	r7, sp, #0
	return gpio_get_pin_level(RF_IRQ);
    6f94:	203e      	movs	r0, #62	; 0x3e
    6f96:	f7ff fe57 	bl	6c48 <gpio_get_pin_level>
    6f9a:	0003      	movs	r3, r0
}
    6f9c:	0018      	movs	r0, r3
    6f9e:	46bd      	mov	sp, r7
    6fa0:	bd80      	pop	{r7, pc}
	...

00006fa4 <EXT_SPI_init>:
	gpio_set_pin_level(LED_G, true);
}

//Display section
void EXT_SPI_init(void)
{
    6fa4:	b580      	push	{r7, lr}
    6fa6:	af00      	add	r7, sp, #0
	_pm_enable_bus_clock(PM_BUS_APBC, SERCOM0);
    6fa8:	4b3a      	ldr	r3, [pc, #232]	; (7094 <EXT_SPI_init+0xf0>)
    6faa:	0019      	movs	r1, r3
    6fac:	2003      	movs	r0, #3
    6fae:	f7ff fee7 	bl	6d80 <_pm_enable_bus_clock>
	_gclk_enable_channel(SERCOM0_GCLK_ID_CORE, CONF_GCLK_SERCOM0_CORE_SRC);
    6fb2:	2100      	movs	r1, #0
    6fb4:	200d      	movs	r0, #13
    6fb6:	f7ff fe65 	bl	6c84 <_gclk_enable_channel>
	
	
	spi_m_sync_init(&EXT_SPI, SERCOM0);
    6fba:	4a36      	ldr	r2, [pc, #216]	; (7094 <EXT_SPI_init+0xf0>)
    6fbc:	4b36      	ldr	r3, [pc, #216]	; (7098 <EXT_SPI_init+0xf4>)
    6fbe:	0011      	movs	r1, r2
    6fc0:	0018      	movs	r0, r3
    6fc2:	f7fc ffdd 	bl	3f80 <spi_m_sync_init>
	spi_m_sync_get_io_descriptor(&EXT_SPI, &lcd_spi);
    6fc6:	4a35      	ldr	r2, [pc, #212]	; (709c <EXT_SPI_init+0xf8>)
    6fc8:	4b33      	ldr	r3, [pc, #204]	; (7098 <EXT_SPI_init+0xf4>)
    6fca:	0011      	movs	r1, r2
    6fcc:	0018      	movs	r0, r3
    6fce:	f7fd f8c1 	bl	4154 <spi_m_sync_get_io_descriptor>
	spi_m_sync_enable(&EXT_SPI);
    6fd2:	4b31      	ldr	r3, [pc, #196]	; (7098 <EXT_SPI_init+0xf4>)
    6fd4:	0018      	movs	r0, r3
    6fd6:	f7fd f813 	bl	4000 <spi_m_sync_enable>
	
	gpio_set_pin_level(PA04, false);
    6fda:	2100      	movs	r1, #0
    6fdc:	2004      	movs	r0, #4
    6fde:	f7ff fe16 	bl	6c0e <gpio_set_pin_level>
	gpio_set_pin_direction(PA04, GPIO_DIRECTION_OUT);
    6fe2:	2102      	movs	r1, #2
    6fe4:	2004      	movs	r0, #4
    6fe6:	f7ff fdf5 	bl	6bd4 <gpio_set_pin_direction>
	gpio_set_pin_function(PA04, PINMUX_PA04D_SERCOM0_PAD0);
    6fea:	4b2d      	ldr	r3, [pc, #180]	; (70a0 <EXT_SPI_init+0xfc>)
    6fec:	0019      	movs	r1, r3
    6fee:	2004      	movs	r0, #4
    6ff0:	f7ff fde1 	bl	6bb6 <gpio_set_pin_function>
	gpio_set_pin_level(PA05, false);
    6ff4:	2100      	movs	r1, #0
    6ff6:	2005      	movs	r0, #5
    6ff8:	f7ff fe09 	bl	6c0e <gpio_set_pin_level>
	gpio_set_pin_direction(PA05, GPIO_DIRECTION_OUT);
    6ffc:	2102      	movs	r1, #2
    6ffe:	2005      	movs	r0, #5
    7000:	f7ff fde8 	bl	6bd4 <gpio_set_pin_direction>
	gpio_set_pin_function(PA05, PINMUX_PA05D_SERCOM0_PAD1);
    7004:	4b27      	ldr	r3, [pc, #156]	; (70a4 <EXT_SPI_init+0x100>)
    7006:	0019      	movs	r1, r3
    7008:	2005      	movs	r0, #5
    700a:	f7ff fdd4 	bl	6bb6 <gpio_set_pin_function>
	gpio_set_pin_direction(PA06, GPIO_DIRECTION_IN);
    700e:	2101      	movs	r1, #1
    7010:	2006      	movs	r0, #6
    7012:	f7ff fddf 	bl	6bd4 <gpio_set_pin_direction>
	gpio_set_pin_pull_mode(PA06, GPIO_PULL_OFF);
    7016:	2100      	movs	r1, #0
    7018:	2006      	movs	r0, #6
    701a:	f7ff fdb1 	bl	6b80 <gpio_set_pin_pull_mode>
	gpio_set_pin_function(PA06, PINMUX_PA06D_SERCOM0_PAD2);
    701e:	4b22      	ldr	r3, [pc, #136]	; (70a8 <EXT_SPI_init+0x104>)
    7020:	0019      	movs	r1, r3
    7022:	2006      	movs	r0, #6
    7024:	f7ff fdc7 	bl	6bb6 <gpio_set_pin_function>
	gpio_set_pin_level(VFD_RST, true);
    7028:	2101      	movs	r1, #1
    702a:	2007      	movs	r0, #7
    702c:	f7ff fdef 	bl	6c0e <gpio_set_pin_level>
	gpio_set_pin_level(FILAMENT_EN, true);
    7030:	2101      	movs	r1, #1
    7032:	2026      	movs	r0, #38	; 0x26
    7034:	f7ff fdeb 	bl	6c0e <gpio_set_pin_level>
	
	//io_write(io, example_VFD_SPI, 12);

	//VFD additional IO setup
	gpio_set_pin_level(VFD_RST, true);
    7038:	2101      	movs	r1, #1
    703a:	2007      	movs	r0, #7
    703c:	f7ff fde7 	bl	6c0e <gpio_set_pin_level>
	gpio_set_pin_direction(VFD_RST, GPIO_DIRECTION_OUT);
    7040:	2102      	movs	r1, #2
    7042:	2007      	movs	r0, #7
    7044:	f7ff fdc6 	bl	6bd4 <gpio_set_pin_direction>
	gpio_set_pin_function(VFD_RST, GPIO_PIN_FUNCTION_OFF);
    7048:	2301      	movs	r3, #1
    704a:	425b      	negs	r3, r3
    704c:	0019      	movs	r1, r3
    704e:	2007      	movs	r0, #7
    7050:	f7ff fdb1 	bl	6bb6 <gpio_set_pin_function>
	
	gpio_set_pin_level(FILAMENT_EN, true);
    7054:	2101      	movs	r1, #1
    7056:	2026      	movs	r0, #38	; 0x26
    7058:	f7ff fdd9 	bl	6c0e <gpio_set_pin_level>
	gpio_set_pin_direction(FILAMENT_EN, GPIO_DIRECTION_OUT);
    705c:	2102      	movs	r1, #2
    705e:	2026      	movs	r0, #38	; 0x26
    7060:	f7ff fdb8 	bl	6bd4 <gpio_set_pin_direction>
	gpio_set_pin_function(FILAMENT_EN, GPIO_PIN_FUNCTION_OFF);	
    7064:	2301      	movs	r3, #1
    7066:	425b      	negs	r3, r3
    7068:	0019      	movs	r1, r3
    706a:	2026      	movs	r0, #38	; 0x26
    706c:	f7ff fda3 	bl	6bb6 <gpio_set_pin_function>
	
	gpio_set_pin_level(VFD_CS, true);
    7070:	2101      	movs	r1, #1
    7072:	2029      	movs	r0, #41	; 0x29
    7074:	f7ff fdcb 	bl	6c0e <gpio_set_pin_level>
	gpio_set_pin_direction(VFD_CS, GPIO_DIRECTION_OUT);
    7078:	2102      	movs	r1, #2
    707a:	2029      	movs	r0, #41	; 0x29
    707c:	f7ff fdaa 	bl	6bd4 <gpio_set_pin_direction>
	gpio_set_pin_function(VFD_CS, GPIO_PIN_FUNCTION_OFF);
    7080:	2301      	movs	r3, #1
    7082:	425b      	negs	r3, r3
    7084:	0019      	movs	r1, r3
    7086:	2029      	movs	r0, #41	; 0x29
    7088:	f7ff fd95 	bl	6bb6 <gpio_set_pin_function>
	
		
}
    708c:	46c0      	nop			; (mov r8, r8)
    708e:	46bd      	mov	sp, r7
    7090:	bd80      	pop	{r7, pc}
    7092:	46c0      	nop			; (mov r8, r8)
    7094:	42000800 	.word	0x42000800
    7098:	20000848 	.word	0x20000848
    709c:	20000868 	.word	0x20000868
    70a0:	00040003 	.word	0x00040003
    70a4:	00050003 	.word	0x00050003
    70a8:	00060003 	.word	0x00060003

000070ac <vfd_write_data>:
void vfd_write_data(uint8_t* buff, uint16_t len){
    70ac:	b580      	push	{r7, lr}
    70ae:	b082      	sub	sp, #8
    70b0:	af00      	add	r7, sp, #0
    70b2:	6078      	str	r0, [r7, #4]
    70b4:	000a      	movs	r2, r1
    70b6:	1cbb      	adds	r3, r7, #2
    70b8:	801a      	strh	r2, [r3, #0]
	//struct io_descriptor *io;
	//spi_m_sync_get_io_descriptor(&EXT_SPI, &io);
	//spi_m_sync_enable(&EXT_SPI);
	io_write(lcd_spi, buff, len);
    70ba:	4b06      	ldr	r3, [pc, #24]	; (70d4 <vfd_write_data+0x28>)
    70bc:	6818      	ldr	r0, [r3, #0]
    70be:	1cbb      	adds	r3, r7, #2
    70c0:	881a      	ldrh	r2, [r3, #0]
    70c2:	687b      	ldr	r3, [r7, #4]
    70c4:	0019      	movs	r1, r3
    70c6:	f7fc ff0b 	bl	3ee0 <io_write>
	
}
    70ca:	46c0      	nop			; (mov r8, r8)
    70cc:	46bd      	mov	sp, r7
    70ce:	b002      	add	sp, #8
    70d0:	bd80      	pop	{r7, pc}
    70d2:	46c0      	nop			; (mov r8, r8)
    70d4:	20000868 	.word	0x20000868

000070d8 <vfd_cs_set>:

void vfd_cs_set(bool state){
    70d8:	b580      	push	{r7, lr}
    70da:	b082      	sub	sp, #8
    70dc:	af00      	add	r7, sp, #0
    70de:	0002      	movs	r2, r0
    70e0:	1dfb      	adds	r3, r7, #7
    70e2:	701a      	strb	r2, [r3, #0]
	gpio_set_pin_level(VFD_CS, !state);
    70e4:	1dfb      	adds	r3, r7, #7
    70e6:	781b      	ldrb	r3, [r3, #0]
    70e8:	1e5a      	subs	r2, r3, #1
    70ea:	4193      	sbcs	r3, r2
    70ec:	b2db      	uxtb	r3, r3
    70ee:	2201      	movs	r2, #1
    70f0:	4053      	eors	r3, r2
    70f2:	b2db      	uxtb	r3, r3
    70f4:	1c1a      	adds	r2, r3, #0
    70f6:	2301      	movs	r3, #1
    70f8:	4013      	ands	r3, r2
    70fa:	b2db      	uxtb	r3, r3
    70fc:	0019      	movs	r1, r3
    70fe:	2029      	movs	r0, #41	; 0x29
    7100:	f7ff fd85 	bl	6c0e <gpio_set_pin_level>
}
    7104:	46c0      	nop			; (mov r8, r8)
    7106:	46bd      	mov	sp, r7
    7108:	b002      	add	sp, #8
    710a:	bd80      	pop	{r7, pc}

0000710c <u8x8_avr_gpio_and_delay>:

uint8_t u8x8_avr_gpio_and_delay(u8x8_t *u8x8, uint8_t msg, uint8_t arg_int, void *arg_ptr){
    710c:	b580      	push	{r7, lr}
    710e:	b084      	sub	sp, #16
    7110:	af00      	add	r7, sp, #0
    7112:	60f8      	str	r0, [r7, #12]
    7114:	0008      	movs	r0, r1
    7116:	0011      	movs	r1, r2
    7118:	607b      	str	r3, [r7, #4]
    711a:	230b      	movs	r3, #11
    711c:	18fb      	adds	r3, r7, r3
    711e:	1c02      	adds	r2, r0, #0
    7120:	701a      	strb	r2, [r3, #0]
    7122:	230a      	movs	r3, #10
    7124:	18fb      	adds	r3, r7, r3
    7126:	1c0a      	adds	r2, r1, #0
    7128:	701a      	strb	r2, [r3, #0]
	//uint8_t cycles;

	switch(msg)
    712a:	230b      	movs	r3, #11
    712c:	18fb      	adds	r3, r7, r3
    712e:	781b      	ldrb	r3, [r3, #0]
    7130:	2b2a      	cmp	r3, #42	; 0x2a
    7132:	d009      	beq.n	7148 <u8x8_avr_gpio_and_delay+0x3c>
    7134:	dc02      	bgt.n	713c <u8x8_avr_gpio_and_delay+0x30>
    7136:	2b29      	cmp	r3, #41	; 0x29
    7138:	d008      	beq.n	714c <u8x8_avr_gpio_and_delay+0x40>
    713a:	e003      	b.n	7144 <u8x8_avr_gpio_and_delay+0x38>
    713c:	2b2b      	cmp	r3, #43	; 0x2b
    713e:	d007      	beq.n	7150 <u8x8_avr_gpio_and_delay+0x44>
    7140:	2b2c      	cmp	r3, #44	; 0x2c
    7142:	d007      	beq.n	7154 <u8x8_avr_gpio_and_delay+0x48>
		case U8X8_MSG_DELAY_10MICRO:    // delay arg_int * 10 micro seconds
		break;
		case U8X8_MSG_DELAY_MILLI:      // delay arg_int * 1 milli second
		break;
		default:
		return 0;
    7144:	2300      	movs	r3, #0
    7146:	e007      	b.n	7158 <u8x8_avr_gpio_and_delay+0x4c>
		break;
    7148:	46c0      	nop			; (mov r8, r8)
    714a:	e004      	b.n	7156 <u8x8_avr_gpio_and_delay+0x4a>
		break;
    714c:	46c0      	nop			; (mov r8, r8)
    714e:	e002      	b.n	7156 <u8x8_avr_gpio_and_delay+0x4a>
		break;
    7150:	46c0      	nop			; (mov r8, r8)
    7152:	e000      	b.n	7156 <u8x8_avr_gpio_and_delay+0x4a>
		break;
    7154:	46c0      	nop			; (mov r8, r8)
	}
	return 0;
    7156:	2300      	movs	r3, #0
}
    7158:	0018      	movs	r0, r3
    715a:	46bd      	mov	sp, r7
    715c:	b004      	add	sp, #16
    715e:	bd80      	pop	{r7, pc}

00007160 <vfd_spi>:
uint8_t vfd_spi(u8x8_t *u8x8, uint8_t msg, uint8_t arg_int, void *arg_ptr)
{
    7160:	b580      	push	{r7, lr}
    7162:	b084      	sub	sp, #16
    7164:	af00      	add	r7, sp, #0
    7166:	60f8      	str	r0, [r7, #12]
    7168:	0008      	movs	r0, r1
    716a:	0011      	movs	r1, r2
    716c:	607b      	str	r3, [r7, #4]
    716e:	230b      	movs	r3, #11
    7170:	18fb      	adds	r3, r7, r3
    7172:	1c02      	adds	r2, r0, #0
    7174:	701a      	strb	r2, [r3, #0]
    7176:	230a      	movs	r3, #10
    7178:	18fb      	adds	r3, r7, r3
    717a:	1c0a      	adds	r2, r1, #0
    717c:	701a      	strb	r2, [r3, #0]
	
	switch(msg)
    717e:	230b      	movs	r3, #11
    7180:	18fb      	adds	r3, r7, r3
    7182:	781b      	ldrb	r3, [r3, #0]
    7184:	3b14      	subs	r3, #20
    7186:	2b0c      	cmp	r3, #12
    7188:	d823      	bhi.n	71d2 <vfd_spi+0x72>
    718a:	009a      	lsls	r2, r3, #2
    718c:	4b14      	ldr	r3, [pc, #80]	; (71e0 <vfd_spi+0x80>)
    718e:	18d3      	adds	r3, r2, r3
    7190:	681b      	ldr	r3, [r3, #0]
    7192:	469f      	mov	pc, r3
	{
		case U8X8_MSG_BYTE_SEND:
		vfd_write_data(arg_ptr, arg_int);
    7194:	230a      	movs	r3, #10
    7196:	18fb      	adds	r3, r7, r3
    7198:	781b      	ldrb	r3, [r3, #0]
    719a:	b29a      	uxth	r2, r3
    719c:	687b      	ldr	r3, [r7, #4]
    719e:	0011      	movs	r1, r2
    71a0:	0018      	movs	r0, r3
    71a2:	f7ff ff83 	bl	70ac <vfd_write_data>
		break;
    71a6:	e016      	b.n	71d6 <vfd_spi+0x76>
		case U8X8_MSG_BYTE_INIT:
		/* disable chipselect */
		vfd_cs_set(false);
    71a8:	2000      	movs	r0, #0
    71aa:	f7ff ff95 	bl	70d8 <vfd_cs_set>
		break;
    71ae:	e012      	b.n	71d6 <vfd_spi+0x76>
		case U8X8_MSG_BYTE_SET_DC:
		u8x8_gpio_SetDC(u8x8, arg_int);
    71b0:	230a      	movs	r3, #10
    71b2:	18fb      	adds	r3, r7, r3
    71b4:	781a      	ldrb	r2, [r3, #0]
    71b6:	68fb      	ldr	r3, [r7, #12]
    71b8:	214a      	movs	r1, #74	; 0x4a
    71ba:	0018      	movs	r0, r3
    71bc:	f7fb fe24 	bl	2e08 <u8x8_gpio_call>
		break;
    71c0:	e009      	b.n	71d6 <vfd_spi+0x76>
		case U8X8_MSG_BYTE_START_TRANSFER:
		vfd_cs_set(true);
    71c2:	2001      	movs	r0, #1
    71c4:	f7ff ff88 	bl	70d8 <vfd_cs_set>
		break;
    71c8:	e005      	b.n	71d6 <vfd_spi+0x76>
		case U8X8_MSG_BYTE_END_TRANSFER:
		vfd_cs_set(false);
    71ca:	2000      	movs	r0, #0
    71cc:	f7ff ff84 	bl	70d8 <vfd_cs_set>
		break;
    71d0:	e001      	b.n	71d6 <vfd_spi+0x76>
		default:
		return 0;
    71d2:	2300      	movs	r3, #0
    71d4:	e000      	b.n	71d8 <vfd_spi+0x78>
	}
	return 1;
    71d6:	2301      	movs	r3, #1
}
    71d8:	0018      	movs	r0, r3
    71da:	46bd      	mov	sp, r7
    71dc:	b004      	add	sp, #16
    71de:	bd80      	pop	{r7, pc}
    71e0:	0000902c 	.word	0x0000902c

000071e4 <RF_SPI_init>:

//RF_Section
void RF_SPI_init(void){
    71e4:	b580      	push	{r7, lr}
    71e6:	af00      	add	r7, sp, #0
	_pm_enable_bus_clock(PM_BUS_APBC, SERCOM1);
    71e8:	4b53      	ldr	r3, [pc, #332]	; (7338 <RF_SPI_init+0x154>)
    71ea:	0019      	movs	r1, r3
    71ec:	2003      	movs	r0, #3
    71ee:	f7ff fdc7 	bl	6d80 <_pm_enable_bus_clock>
	_gclk_enable_channel(SERCOM1_GCLK_ID_CORE, CONF_GCLK_SERCOM1_CORE_SRC);
    71f2:	2100      	movs	r1, #0
    71f4:	200e      	movs	r0, #14
    71f6:	f7ff fd45 	bl	6c84 <_gclk_enable_channel>
	
	spi_m_sync_init(&RF_SPI, SERCOM1);
    71fa:	4a4f      	ldr	r2, [pc, #316]	; (7338 <RF_SPI_init+0x154>)
    71fc:	4b4f      	ldr	r3, [pc, #316]	; (733c <RF_SPI_init+0x158>)
    71fe:	0011      	movs	r1, r2
    7200:	0018      	movs	r0, r3
    7202:	f7fc febd 	bl	3f80 <spi_m_sync_init>
	spi_m_sync_get_io_descriptor(&RF_SPI, &rf_spi);
    7206:	4a4e      	ldr	r2, [pc, #312]	; (7340 <RF_SPI_init+0x15c>)
    7208:	4b4c      	ldr	r3, [pc, #304]	; (733c <RF_SPI_init+0x158>)
    720a:	0011      	movs	r1, r2
    720c:	0018      	movs	r0, r3
    720e:	f7fc ffa1 	bl	4154 <spi_m_sync_get_io_descriptor>
	spi_m_sync_enable(&RF_SPI);
    7212:	4b4a      	ldr	r3, [pc, #296]	; (733c <RF_SPI_init+0x158>)
    7214:	0018      	movs	r0, r3
    7216:	f7fc fef3 	bl	4000 <spi_m_sync_enable>
	
	gpio_set_pin_level(PA00, false);
    721a:	2100      	movs	r1, #0
    721c:	2000      	movs	r0, #0
    721e:	f7ff fcf6 	bl	6c0e <gpio_set_pin_level>
	gpio_set_pin_direction(PA00, GPIO_DIRECTION_OUT);
    7222:	2102      	movs	r1, #2
    7224:	2000      	movs	r0, #0
    7226:	f7ff fcd5 	bl	6bd4 <gpio_set_pin_direction>
	gpio_set_pin_function(PA00, PINMUX_PA00D_SERCOM1_PAD0);
    722a:	2103      	movs	r1, #3
    722c:	2000      	movs	r0, #0
    722e:	f7ff fcc2 	bl	6bb6 <gpio_set_pin_function>
	gpio_set_pin_level(PA01, false);
    7232:	2100      	movs	r1, #0
    7234:	2001      	movs	r0, #1
    7236:	f7ff fcea 	bl	6c0e <gpio_set_pin_level>
	gpio_set_pin_direction(PA01, GPIO_DIRECTION_OUT);
    723a:	2102      	movs	r1, #2
    723c:	2001      	movs	r0, #1
    723e:	f7ff fcc9 	bl	6bd4 <gpio_set_pin_direction>
	gpio_set_pin_function(PA01, PINMUX_PA01D_SERCOM1_PAD1);
    7242:	4b40      	ldr	r3, [pc, #256]	; (7344 <RF_SPI_init+0x160>)
    7244:	0019      	movs	r1, r3
    7246:	2001      	movs	r0, #1
    7248:	f7ff fcb5 	bl	6bb6 <gpio_set_pin_function>
	gpio_set_pin_direction(PA18, GPIO_DIRECTION_IN);
    724c:	2101      	movs	r1, #1
    724e:	2012      	movs	r0, #18
    7250:	f7ff fcc0 	bl	6bd4 <gpio_set_pin_direction>

	gpio_set_pin_pull_mode(PA18, GPIO_PULL_OFF);
    7254:	2100      	movs	r1, #0
    7256:	2012      	movs	r0, #18
    7258:	f7ff fc92 	bl	6b80 <gpio_set_pin_pull_mode>
	gpio_set_pin_function(PA18, PINMUX_PA18C_SERCOM1_PAD2);
    725c:	4b3a      	ldr	r3, [pc, #232]	; (7348 <RF_SPI_init+0x164>)
    725e:	0019      	movs	r1, r3
    7260:	2012      	movs	r0, #18
    7262:	f7ff fca8 	bl	6bb6 <gpio_set_pin_function>
	//Gpio setup
	
	gpio_set_pin_level(RF_RST, false);
    7266:	2100      	movs	r1, #0
    7268:	2002      	movs	r0, #2
    726a:	f7ff fcd0 	bl	6c0e <gpio_set_pin_level>
	gpio_set_pin_direction(RF_RST, GPIO_DIRECTION_OUT);
    726e:	2102      	movs	r1, #2
    7270:	2002      	movs	r0, #2
    7272:	f7ff fcaf 	bl	6bd4 <gpio_set_pin_direction>
	gpio_set_pin_function(RF_RST, GPIO_PIN_FUNCTION_OFF);
    7276:	2301      	movs	r3, #1
    7278:	425b      	negs	r3, r3
    727a:	0019      	movs	r1, r3
    727c:	2002      	movs	r0, #2
    727e:	f7ff fc9a 	bl	6bb6 <gpio_set_pin_function>
	RF_HW_Reset();
    7282:	f000 f863 	bl	734c <RF_HW_Reset>
	//Radio additional IO setup
	gpio_set_pin_level(RF_CS, true);
    7286:	2101      	movs	r1, #1
    7288:	201c      	movs	r0, #28
    728a:	f7ff fcc0 	bl	6c0e <gpio_set_pin_level>
	gpio_set_pin_direction(RF_CS, GPIO_DIRECTION_OUT);
    728e:	2102      	movs	r1, #2
    7290:	201c      	movs	r0, #28
    7292:	f7ff fc9f 	bl	6bd4 <gpio_set_pin_direction>
	gpio_set_pin_function(RF_CS, GPIO_PIN_FUNCTION_OFF);
    7296:	2301      	movs	r3, #1
    7298:	425b      	negs	r3, r3
    729a:	0019      	movs	r1, r3
    729c:	201c      	movs	r0, #28
    729e:	f7ff fc8a 	bl	6bb6 <gpio_set_pin_function>
	
	//SPI Flash additional IO setup
	gpio_set_pin_level(ROM_CS, true);
    72a2:	2101      	movs	r1, #1
    72a4:	2017      	movs	r0, #23
    72a6:	f7ff fcb2 	bl	6c0e <gpio_set_pin_level>
	gpio_set_pin_direction(ROM_CS, GPIO_DIRECTION_OUT);
    72aa:	2102      	movs	r1, #2
    72ac:	2017      	movs	r0, #23
    72ae:	f7ff fc91 	bl	6bd4 <gpio_set_pin_direction>
	gpio_set_pin_function(ROM_CS, GPIO_PIN_FUNCTION_OFF);
    72b2:	2301      	movs	r3, #1
    72b4:	425b      	negs	r3, r3
    72b6:	0019      	movs	r1, r3
    72b8:	2017      	movs	r0, #23
    72ba:	f7ff fc7c 	bl	6bb6 <gpio_set_pin_function>
	
	//MicroSD Flash additional IO setup
	gpio_set_pin_level(LED_SD, false);
    72be:	2100      	movs	r1, #0
    72c0:	2003      	movs	r0, #3
    72c2:	f7ff fca4 	bl	6c0e <gpio_set_pin_level>
	gpio_set_pin_direction(LED_SD, GPIO_DIRECTION_OUT);
    72c6:	2102      	movs	r1, #2
    72c8:	2003      	movs	r0, #3
    72ca:	f7ff fc83 	bl	6bd4 <gpio_set_pin_direction>
	gpio_set_pin_function(LED_SD, GPIO_PIN_FUNCTION_OFF);
    72ce:	2301      	movs	r3, #1
    72d0:	425b      	negs	r3, r3
    72d2:	0019      	movs	r1, r3
    72d4:	2003      	movs	r0, #3
    72d6:	f7ff fc6e 	bl	6bb6 <gpio_set_pin_function>
	
	gpio_set_pin_level(SD_CS, true);
    72da:	2101      	movs	r1, #1
    72dc:	2024      	movs	r0, #36	; 0x24
    72de:	f7ff fc96 	bl	6c0e <gpio_set_pin_level>
	gpio_set_pin_direction(SD_CS, GPIO_DIRECTION_OUT);
    72e2:	2102      	movs	r1, #2
    72e4:	2024      	movs	r0, #36	; 0x24
    72e6:	f7ff fc75 	bl	6bd4 <gpio_set_pin_direction>
	gpio_set_pin_function(SD_CS, GPIO_PIN_FUNCTION_OFF);
    72ea:	2301      	movs	r3, #1
    72ec:	425b      	negs	r3, r3
    72ee:	0019      	movs	r1, r3
    72f0:	2024      	movs	r0, #36	; 0x24
    72f2:	f7ff fc60 	bl	6bb6 <gpio_set_pin_function>

	gpio_set_pin_direction(SD_DETECT, GPIO_DIRECTION_IN);
    72f6:	2101      	movs	r1, #1
    72f8:	2025      	movs	r0, #37	; 0x25
    72fa:	f7ff fc6b 	bl	6bd4 <gpio_set_pin_direction>
	gpio_set_pin_pull_mode(SD_DETECT, GPIO_PULL_OFF);
    72fe:	2100      	movs	r1, #0
    7300:	2025      	movs	r0, #37	; 0x25
    7302:	f7ff fc3d 	bl	6b80 <gpio_set_pin_pull_mode>
	gpio_set_pin_function(SD_DETECT, GPIO_PIN_FUNCTION_OFF);
    7306:	2301      	movs	r3, #1
    7308:	425b      	negs	r3, r3
    730a:	0019      	movs	r1, r3
    730c:	2025      	movs	r0, #37	; 0x25
    730e:	f7ff fc52 	bl	6bb6 <gpio_set_pin_function>

	gpio_set_pin_direction(RF_IRQ, GPIO_DIRECTION_IN);
    7312:	2101      	movs	r1, #1
    7314:	203e      	movs	r0, #62	; 0x3e
    7316:	f7ff fc5d 	bl	6bd4 <gpio_set_pin_direction>
	gpio_set_pin_pull_mode(RF_IRQ, GPIO_PULL_DOWN);
    731a:	2102      	movs	r1, #2
    731c:	203e      	movs	r0, #62	; 0x3e
    731e:	f7ff fc2f 	bl	6b80 <gpio_set_pin_pull_mode>
	gpio_set_pin_function(RF_IRQ, PINMUX_PB30A_EIC_EXTINT14);
    7322:	23f8      	movs	r3, #248	; 0xf8
    7324:	039b      	lsls	r3, r3, #14
    7326:	0019      	movs	r1, r3
    7328:	203e      	movs	r0, #62	; 0x3e
    732a:	f7ff fc44 	bl	6bb6 <gpio_set_pin_function>
	RF_IRQ_Enable();
    732e:	f7ff fd93 	bl	6e58 <RF_IRQ_Enable>
	
}
    7332:	46c0      	nop			; (mov r8, r8)
    7334:	46bd      	mov	sp, r7
    7336:	bd80      	pop	{r7, pc}
    7338:	42000c00 	.word	0x42000c00
    733c:	20000810 	.word	0x20000810
    7340:	2000080c 	.word	0x2000080c
    7344:	00010003 	.word	0x00010003
    7348:	00120002 	.word	0x00120002

0000734c <RF_HW_Reset>:


void RF_HW_Reset(void){
    734c:	b580      	push	{r7, lr}
    734e:	af00      	add	r7, sp, #0
	gpio_set_pin_level(RF_RST, true);
    7350:	2101      	movs	r1, #1
    7352:	2002      	movs	r0, #2
    7354:	f7ff fc5b 	bl	6c0e <gpio_set_pin_level>
	delay_ms(1);
    7358:	2001      	movs	r0, #1
    735a:	f7fc fb57 	bl	3a0c <delay_ms>
	gpio_set_pin_level(RF_RST, false);
    735e:	2100      	movs	r1, #0
    7360:	2002      	movs	r0, #2
    7362:	f7ff fc54 	bl	6c0e <gpio_set_pin_level>
	delay_ms(20);
    7366:	2014      	movs	r0, #20
    7368:	f7fc fb50 	bl	3a0c <delay_ms>
}
    736c:	46c0      	nop			; (mov r8, r8)
    736e:	46bd      	mov	sp, r7
    7370:	bd80      	pop	{r7, pc}
	...

00007374 <EXT_I2C_init>:

//External I2C port


void EXT_I2C_init(void)
{
    7374:	b580      	push	{r7, lr}
    7376:	af00      	add	r7, sp, #0
	_pm_enable_bus_clock(PM_BUS_APBC, SERCOM4);
    7378:	4b18      	ldr	r3, [pc, #96]	; (73dc <EXT_I2C_init+0x68>)
    737a:	0019      	movs	r1, r3
    737c:	2003      	movs	r0, #3
    737e:	f7ff fcff 	bl	6d80 <_pm_enable_bus_clock>
	_gclk_enable_channel(SERCOM4_GCLK_ID_CORE, CONF_GCLK_SERCOM4_CORE_SRC);
    7382:	2100      	movs	r1, #0
    7384:	2011      	movs	r0, #17
    7386:	f7ff fc7d 	bl	6c84 <_gclk_enable_channel>
	_gclk_enable_channel(SERCOM4_GCLK_ID_SLOW, CONF_GCLK_SERCOM4_SLOW_SRC);
    738a:	2103      	movs	r1, #3
    738c:	200c      	movs	r0, #12
    738e:	f7ff fc79 	bl	6c84 <_gclk_enable_channel>
	
	i2c_m_sync_init(&EXT_I2C, SERCOM4);
    7392:	4a12      	ldr	r2, [pc, #72]	; (73dc <EXT_I2C_init+0x68>)
    7394:	4b12      	ldr	r3, [pc, #72]	; (73e0 <EXT_I2C_init+0x6c>)
    7396:	0011      	movs	r1, r2
    7398:	0018      	movs	r0, r3
    739a:	f7fc fd39 	bl	3e10 <i2c_m_sync_init>
	
	gpio_set_pin_pull_mode(PB12, GPIO_PULL_OFF);
    739e:	2100      	movs	r1, #0
    73a0:	202c      	movs	r0, #44	; 0x2c
    73a2:	f7ff fbed 	bl	6b80 <gpio_set_pin_pull_mode>
	gpio_set_pin_function(PB12, PINMUX_PB12C_SERCOM4_PAD0);
    73a6:	4b0f      	ldr	r3, [pc, #60]	; (73e4 <EXT_I2C_init+0x70>)
    73a8:	0019      	movs	r1, r3
    73aa:	202c      	movs	r0, #44	; 0x2c
    73ac:	f7ff fc03 	bl	6bb6 <gpio_set_pin_function>
	gpio_set_pin_pull_mode(PB13, GPIO_PULL_OFF);
    73b0:	2100      	movs	r1, #0
    73b2:	202d      	movs	r0, #45	; 0x2d
    73b4:	f7ff fbe4 	bl	6b80 <gpio_set_pin_pull_mode>
	gpio_set_pin_function(PB13, PINMUX_PB13C_SERCOM4_PAD1);
    73b8:	4b0b      	ldr	r3, [pc, #44]	; (73e8 <EXT_I2C_init+0x74>)
    73ba:	0019      	movs	r1, r3
    73bc:	202d      	movs	r0, #45	; 0x2d
    73be:	f7ff fbfa 	bl	6bb6 <gpio_set_pin_function>
	
	i2c_m_sync_get_io_descriptor(&EXT_I2C, &I2C_io);
    73c2:	4a0a      	ldr	r2, [pc, #40]	; (73ec <EXT_I2C_init+0x78>)
    73c4:	4b06      	ldr	r3, [pc, #24]	; (73e0 <EXT_I2C_init+0x6c>)
    73c6:	0011      	movs	r1, r2
    73c8:	0018      	movs	r0, r3
    73ca:	f7fc fd7a 	bl	3ec2 <i2c_m_sync_get_io_descriptor>
	i2c_m_sync_enable(&EXT_I2C);
    73ce:	4b04      	ldr	r3, [pc, #16]	; (73e0 <EXT_I2C_init+0x6c>)
    73d0:	0018      	movs	r0, r3
    73d2:	f7fc fd49 	bl	3e68 <i2c_m_sync_enable>
}
    73d6:	46c0      	nop			; (mov r8, r8)
    73d8:	46bd      	mov	sp, r7
    73da:	bd80      	pop	{r7, pc}
    73dc:	42001800 	.word	0x42001800
    73e0:	20000828 	.word	0x20000828
    73e4:	002c0002 	.word	0x002c0002
    73e8:	002d0002 	.word	0x002d0002
    73ec:	20000860 	.word	0x20000860

000073f0 <I2C_write_batch>:


bool I2C_write_batch(uint8_t addres, uint8_t *data, uint8_t data_len){
    73f0:	b580      	push	{r7, lr}
    73f2:	b082      	sub	sp, #8
    73f4:	af00      	add	r7, sp, #0
    73f6:	6039      	str	r1, [r7, #0]
    73f8:	0011      	movs	r1, r2
    73fa:	1dfb      	adds	r3, r7, #7
    73fc:	1c02      	adds	r2, r0, #0
    73fe:	701a      	strb	r2, [r3, #0]
    7400:	1dbb      	adds	r3, r7, #6
    7402:	1c0a      	adds	r2, r1, #0
    7404:	701a      	strb	r2, [r3, #0]
	i2c_m_sync_set_slaveaddr(&EXT_I2C, addres, I2C_M_SEVEN);
    7406:	1dfb      	adds	r3, r7, #7
    7408:	781b      	ldrb	r3, [r3, #0]
    740a:	b219      	sxth	r1, r3
    740c:	2380      	movs	r3, #128	; 0x80
    740e:	011a      	lsls	r2, r3, #4
    7410:	4b0a      	ldr	r3, [pc, #40]	; (743c <I2C_write_batch+0x4c>)
    7412:	0018      	movs	r0, r3
    7414:	f7fc fd35 	bl	3e82 <i2c_m_sync_set_slaveaddr>
	return (io_write(I2C_io, (uint8_t *)data, data_len) >= 0) ? true : false;  
    7418:	4b09      	ldr	r3, [pc, #36]	; (7440 <I2C_write_batch+0x50>)
    741a:	6818      	ldr	r0, [r3, #0]
    741c:	1dbb      	adds	r3, r7, #6
    741e:	781b      	ldrb	r3, [r3, #0]
    7420:	b29a      	uxth	r2, r3
    7422:	683b      	ldr	r3, [r7, #0]
    7424:	0019      	movs	r1, r3
    7426:	f7fc fd5b 	bl	3ee0 <io_write>
    742a:	0003      	movs	r3, r0
    742c:	43db      	mvns	r3, r3
    742e:	0fdb      	lsrs	r3, r3, #31
    7430:	b2db      	uxtb	r3, r3
}
    7432:	0018      	movs	r0, r3
    7434:	46bd      	mov	sp, r7
    7436:	b002      	add	sp, #8
    7438:	bd80      	pop	{r7, pc}
    743a:	46c0      	nop			; (mov r8, r8)
    743c:	20000828 	.word	0x20000828
    7440:	20000860 	.word	0x20000860

00007444 <rfm69_init>:
uint8_t promiscuousMode = 0;
unsigned long millis_current;

// freqBand must be selected from 315, 433, 868, 915
void rfm69_init(uint16_t freqBand, uint8_t nodeID, uint8_t networkID)
{	
    7444:	b590      	push	{r4, r7, lr}
    7446:	b085      	sub	sp, #20
    7448:	af00      	add	r7, sp, #0
    744a:	0004      	movs	r4, r0
    744c:	0008      	movs	r0, r1
    744e:	0011      	movs	r1, r2
    7450:	1dbb      	adds	r3, r7, #6
    7452:	1c22      	adds	r2, r4, #0
    7454:	801a      	strh	r2, [r3, #0]
    7456:	1d7b      	adds	r3, r7, #5
    7458:	1c02      	adds	r2, r0, #0
    745a:	701a      	strb	r2, [r3, #0]
    745c:	1d3b      	adds	r3, r7, #4
    745e:	1c0a      	adds	r2, r1, #0
    7460:	701a      	strb	r2, [r3, #0]
	RF_HW_Reset();
    7462:	f7ff ff73 	bl	734c <RF_HW_Reset>
	uint8_t tmp_data = readReg(REG_VERSION);
    7466:	230f      	movs	r3, #15
    7468:	18fc      	adds	r4, r7, r3
    746a:	2010      	movs	r0, #16
    746c:	f000 f87f 	bl	756e <readReg>
    7470:	0003      	movs	r3, r0
    7472:	7023      	strb	r3, [r4, #0]
	//tmp_data = readReg(REG_OPMODE);
	
	writeReg(REG_OPMODE, RF_OPMODE_STANDBY);
    7474:	2104      	movs	r1, #4
    7476:	2001      	movs	r0, #1
    7478:	f000 f898 	bl	75ac <writeReg>
	
	tmp_data = readReg(REG_IRQFLAGS1);
    747c:	230f      	movs	r3, #15
    747e:	18fc      	adds	r4, r7, r3
    7480:	2027      	movs	r0, #39	; 0x27
    7482:	f000 f874 	bl	756e <readReg>
    7486:	0003      	movs	r3, r0
    7488:	7023      	strb	r3, [r4, #0]
	
	writeReg(REG_FIFOTHRESH, 0x8f);
    748a:	218f      	movs	r1, #143	; 0x8f
    748c:	203c      	movs	r0, #60	; 0x3c
    748e:	f000 f88d 	bl	75ac <writeReg>
	writeReg(REG_TESTDAGC, 0x30);
    7492:	2130      	movs	r1, #48	; 0x30
    7494:	206f      	movs	r0, #111	; 0x6f
    7496:	f000 f889 	bl	75ac <writeReg>
	writeReg(REG_TESTPA1, 0x55); //only for HW
    749a:	2155      	movs	r1, #85	; 0x55
    749c:	205a      	movs	r0, #90	; 0x5a
    749e:	f000 f885 	bl	75ac <writeReg>
	writeReg(REG_TESTPA2, 0x70); //only for HW
    74a2:	2170      	movs	r1, #112	; 0x70
    74a4:	205c      	movs	r0, #92	; 0x5c
    74a6:	f000 f881 	bl	75ac <writeReg>
	
	tmp_data = readReg(REG_SYNCCONFIG);
    74aa:	230f      	movs	r3, #15
    74ac:	18fc      	adds	r4, r7, r3
    74ae:	202e      	movs	r0, #46	; 0x2e
    74b0:	f000 f85d 	bl	756e <readReg>
    74b4:	0003      	movs	r3, r0
    74b6:	7023      	strb	r3, [r4, #0]
	writeReg(REG_SYNCVALUE1, 0x2d);
    74b8:	212d      	movs	r1, #45	; 0x2d
    74ba:	202f      	movs	r0, #47	; 0x2f
    74bc:	f000 f876 	bl	75ac <writeReg>
	writeReg(REG_SYNCVALUE2, 0xd4);
    74c0:	21d4      	movs	r1, #212	; 0xd4
    74c2:	2030      	movs	r0, #48	; 0x30
    74c4:	f000 f872 	bl	75ac <writeReg>
	writeReg(REG_SYNCCONFIG, 0x88);
    74c8:	2188      	movs	r1, #136	; 0x88
    74ca:	202e      	movs	r0, #46	; 0x2e
    74cc:	f000 f86e 	bl	75ac <writeReg>
	
	writeReg(REG_DATAMODUL, RF_DATAMODUL_MODULATIONSHAPING_01);
    74d0:	2101      	movs	r1, #1
    74d2:	2002      	movs	r0, #2
    74d4:	f000 f86a 	bl	75ac <writeReg>
	writeReg(REG_BITRATEMSB, 0x00);
    74d8:	2100      	movs	r1, #0
    74da:	2003      	movs	r0, #3
    74dc:	f000 f866 	bl	75ac <writeReg>
	writeReg(REG_BITRATELSB, 0x80);
    74e0:	2180      	movs	r1, #128	; 0x80
    74e2:	2004      	movs	r0, #4
    74e4:	f000 f862 	bl	75ac <writeReg>
	writeReg(REG_FDEVMSB, 0x10);
    74e8:	2110      	movs	r1, #16
    74ea:	2005      	movs	r0, #5
    74ec:	f000 f85e 	bl	75ac <writeReg>
	writeReg(REG_FDEVLSB, 0x00);
    74f0:	2100      	movs	r1, #0
    74f2:	2006      	movs	r0, #6
    74f4:	f000 f85a 	bl	75ac <writeReg>
	
	writeReg(REG_RXBW, RF_RXBW_DCCFREQ_111);
    74f8:	21e0      	movs	r1, #224	; 0xe0
    74fa:	2019      	movs	r0, #25
    74fc:	f000 f856 	bl	75ac <writeReg>
	writeReg(REG_AFCBW, RF_AFCBW_DCCFREQAFC_111);
    7500:	21e0      	movs	r1, #224	; 0xe0
    7502:	201a      	movs	r0, #26
    7504:	f000 f852 	bl	75ac <writeReg>
	writeReg(REG_PACKETCONFIG1, 0xD0);
    7508:	21d0      	movs	r1, #208	; 0xd0
    750a:	2037      	movs	r0, #55	; 0x37
    750c:	f000 f84e 	bl	75ac <writeReg>
	
	writeReg(REG_PREAMBLEMSB, 0x00);
    7510:	2100      	movs	r1, #0
    7512:	202c      	movs	r0, #44	; 0x2c
    7514:	f000 f84a 	bl	75ac <writeReg>
	writeReg(REG_PREAMBLELSB , 0x04);
    7518:	2104      	movs	r1, #4
    751a:	202d      	movs	r0, #45	; 0x2d
    751c:	f000 f846 	bl	75ac <writeReg>
	
	writeReg(REG_FRFMSB, RF_FRFMSB_868);
    7520:	21d9      	movs	r1, #217	; 0xd9
    7522:	2007      	movs	r0, #7
    7524:	f000 f842 	bl	75ac <writeReg>
	writeReg(REG_FRFMID, RF_FRFMID_868);
    7528:	2100      	movs	r1, #0
    752a:	2008      	movs	r0, #8
    752c:	f000 f83e 	bl	75ac <writeReg>
	writeReg(REG_FRFLSB, RF_FRFLSB_868);
    7530:	2100      	movs	r1, #0
    7532:	2009      	movs	r0, #9
    7534:	f000 f83a 	bl	75ac <writeReg>
	
	tmp_data = readReg(REG_PACKETCONFIG2); //2
    7538:	230f      	movs	r3, #15
    753a:	18fc      	adds	r4, r7, r3
    753c:	203d      	movs	r0, #61	; 0x3d
    753e:	f000 f816 	bl	756e <readReg>
    7542:	0003      	movs	r3, r0
    7544:	7023      	strb	r3, [r4, #0]
	writeReg(REG_PACKETCONFIG2, RF_PACKET2_AUTORXRESTART_ON);
    7546:	2102      	movs	r1, #2
    7548:	203d      	movs	r0, #61	; 0x3d
    754a:	f000 f82f 	bl	75ac <writeReg>

	writeReg(REG_PALEVEL, RF_PALEVEL_OUTPUTPOWER_11111);
    754e:	211f      	movs	r1, #31
    7550:	2011      	movs	r0, #17
    7552:	f000 f82b 	bl	75ac <writeReg>
	writeReg(REG_DIOMAPPING1 , RF_DIOMAPPING1_DIO0_01);
    7556:	2140      	movs	r1, #64	; 0x40
    7558:	2025      	movs	r0, #37	; 0x25
    755a:	f000 f827 	bl	75ac <writeReg>
	
	//tmp_data = readReg(REG_OPMODE);
	writeReg(REG_OPMODE, RF_OPMODE_RECEIVER);
    755e:	2110      	movs	r1, #16
    7560:	2001      	movs	r0, #1
    7562:	f000 f823 	bl	75ac <writeReg>
    //while ((readReg(REG_IRQFLAGS1) & RF_IRQFLAGS1_MODEREADY) == 0x00);

    //address = nodeID;
    //setAddress(address);            // setting this node id
    //setNetwork(networkID);
}
    7566:	46c0      	nop			; (mov r8, r8)
    7568:	46bd      	mov	sp, r7
    756a:	b005      	add	sp, #20
    756c:	bd90      	pop	{r4, r7, pc}

0000756e <readReg>:
    setMode(oldMode);
}

// Read byte from register
uint8_t readReg(uint8_t addr)
{
    756e:	b590      	push	{r4, r7, lr}
    7570:	b085      	sub	sp, #20
    7572:	af00      	add	r7, sp, #0
    7574:	0002      	movs	r2, r0
    7576:	1dfb      	adds	r3, r7, #7
    7578:	701a      	strb	r2, [r3, #0]
    RF_select();
    757a:	f000 f9bb 	bl	78f4 <RF_select>
    SPI_write(addr & 0x7F);
    757e:	1dfb      	adds	r3, r7, #7
    7580:	781b      	ldrb	r3, [r3, #0]
    7582:	227f      	movs	r2, #127	; 0x7f
    7584:	4013      	ands	r3, r2
    7586:	b2db      	uxtb	r3, r3
    7588:	0018      	movs	r0, r3
    758a:	f7ff fcd5 	bl	6f38 <SPI_write>
    uint8_t regval = SPI_read();
    758e:	230f      	movs	r3, #15
    7590:	18fc      	adds	r4, r7, r3
    7592:	f7ff fce7 	bl	6f64 <SPI_read>
    7596:	0003      	movs	r3, r0
    7598:	7023      	strb	r3, [r4, #0]
    RF_unselect();
    759a:	f000 f9b3 	bl	7904 <RF_unselect>
    return regval;
    759e:	230f      	movs	r3, #15
    75a0:	18fb      	adds	r3, r7, r3
    75a2:	781b      	ldrb	r3, [r3, #0]
}
    75a4:	0018      	movs	r0, r3
    75a6:	46bd      	mov	sp, r7
    75a8:	b005      	add	sp, #20
    75aa:	bd90      	pop	{r4, r7, pc}

000075ac <writeReg>:

// Write byte to register
void writeReg(uint8_t addr, uint8_t value)
{
    75ac:	b580      	push	{r7, lr}
    75ae:	b082      	sub	sp, #8
    75b0:	af00      	add	r7, sp, #0
    75b2:	0002      	movs	r2, r0
    75b4:	1dfb      	adds	r3, r7, #7
    75b6:	701a      	strb	r2, [r3, #0]
    75b8:	1dbb      	adds	r3, r7, #6
    75ba:	1c0a      	adds	r2, r1, #0
    75bc:	701a      	strb	r2, [r3, #0]
    RF_select();
    75be:	f000 f999 	bl	78f4 <RF_select>
    SPI_write(addr | 0x80);
    75c2:	1dfb      	adds	r3, r7, #7
    75c4:	781b      	ldrb	r3, [r3, #0]
    75c6:	2280      	movs	r2, #128	; 0x80
    75c8:	4252      	negs	r2, r2
    75ca:	4313      	orrs	r3, r2
    75cc:	b2db      	uxtb	r3, r3
    75ce:	0018      	movs	r0, r3
    75d0:	f7ff fcb2 	bl	6f38 <SPI_write>
    SPI_write(value);
    75d4:	1dbb      	adds	r3, r7, #6
    75d6:	781b      	ldrb	r3, [r3, #0]
    75d8:	0018      	movs	r0, r3
    75da:	f7ff fcad 	bl	6f38 <SPI_write>
    RF_unselect();
    75de:	f000 f991 	bl	7904 <RF_unselect>
}
    75e2:	46c0      	nop			; (mov r8, r8)
    75e4:	46bd      	mov	sp, r7
    75e6:	b002      	add	sp, #8
    75e8:	bd80      	pop	{r7, pc}
	...

000075ec <setMode>:
    writeReg(REG_PACKETCONFIG2, (readReg(REG_PACKETCONFIG2) & 0xFE) | (key ? 1:0));
	
}

void setMode(uint8_t newMode)
{
    75ec:	b580      	push	{r7, lr}
    75ee:	b082      	sub	sp, #8
    75f0:	af00      	add	r7, sp, #0
    75f2:	0002      	movs	r2, r0
    75f4:	1dfb      	adds	r3, r7, #7
    75f6:	701a      	strb	r2, [r3, #0]
    if (newMode == mode)
    75f8:	4b46      	ldr	r3, [pc, #280]	; (7714 <setMode+0x128>)
    75fa:	781b      	ldrb	r3, [r3, #0]
    75fc:	b2db      	uxtb	r3, r3
    75fe:	1dfa      	adds	r2, r7, #7
    7600:	7812      	ldrb	r2, [r2, #0]
    7602:	429a      	cmp	r2, r3
    7604:	d100      	bne.n	7608 <setMode+0x1c>
    7606:	e07e      	b.n	7706 <setMode+0x11a>
    return;

    switch (newMode)
    7608:	1dfb      	adds	r3, r7, #7
    760a:	781b      	ldrb	r3, [r3, #0]
    760c:	2b04      	cmp	r3, #4
    760e:	d900      	bls.n	7612 <setMode+0x26>
    7610:	e07b      	b.n	770a <setMode+0x11e>
    7612:	009a      	lsls	r2, r3, #2
    7614:	4b40      	ldr	r3, [pc, #256]	; (7718 <setMode+0x12c>)
    7616:	18d3      	adds	r3, r2, r3
    7618:	681b      	ldr	r3, [r3, #0]
    761a:	469f      	mov	pc, r3
    {
        case RF69_MODE_TX:
            writeReg(REG_OPMODE, (readReg(REG_OPMODE) & 0xE3) | RF_OPMODE_TRANSMITTER);
    761c:	2001      	movs	r0, #1
    761e:	f7ff ffa6 	bl	756e <readReg>
    7622:	0003      	movs	r3, r0
    7624:	b25b      	sxtb	r3, r3
    7626:	221c      	movs	r2, #28
    7628:	4393      	bics	r3, r2
    762a:	b25b      	sxtb	r3, r3
    762c:	220c      	movs	r2, #12
    762e:	4313      	orrs	r3, r2
    7630:	b25b      	sxtb	r3, r3
    7632:	b2db      	uxtb	r3, r3
    7634:	0019      	movs	r1, r3
    7636:	2001      	movs	r0, #1
    7638:	f7ff ffb8 	bl	75ac <writeReg>
            if (isRFM69HW) setHighPowerRegs(1);
    763c:	4b37      	ldr	r3, [pc, #220]	; (771c <setMode+0x130>)
    763e:	781b      	ldrb	r3, [r3, #0]
    7640:	2b00      	cmp	r3, #0
    7642:	d04b      	beq.n	76dc <setMode+0xf0>
    7644:	2001      	movs	r0, #1
    7646:	f000 f86b 	bl	7720 <setHighPowerRegs>
            break;
    764a:	e047      	b.n	76dc <setMode+0xf0>
        case RF69_MODE_RX:
            writeReg(REG_OPMODE, (readReg(REG_OPMODE) & 0xE3) | RF_OPMODE_RECEIVER);
    764c:	2001      	movs	r0, #1
    764e:	f7ff ff8e 	bl	756e <readReg>
    7652:	0003      	movs	r3, r0
    7654:	b25b      	sxtb	r3, r3
    7656:	221c      	movs	r2, #28
    7658:	4393      	bics	r3, r2
    765a:	b25b      	sxtb	r3, r3
    765c:	2210      	movs	r2, #16
    765e:	4313      	orrs	r3, r2
    7660:	b25b      	sxtb	r3, r3
    7662:	b2db      	uxtb	r3, r3
    7664:	0019      	movs	r1, r3
    7666:	2001      	movs	r0, #1
    7668:	f7ff ffa0 	bl	75ac <writeReg>
            if (isRFM69HW) setHighPowerRegs(0);
    766c:	4b2b      	ldr	r3, [pc, #172]	; (771c <setMode+0x130>)
    766e:	781b      	ldrb	r3, [r3, #0]
    7670:	2b00      	cmp	r3, #0
    7672:	d035      	beq.n	76e0 <setMode+0xf4>
    7674:	2000      	movs	r0, #0
    7676:	f000 f853 	bl	7720 <setHighPowerRegs>
            break;
    767a:	e031      	b.n	76e0 <setMode+0xf4>
        case RF69_MODE_SYNTH:
            writeReg(REG_OPMODE, (readReg(REG_OPMODE) & 0xE3) | RF_OPMODE_SYNTHESIZER);
    767c:	2001      	movs	r0, #1
    767e:	f7ff ff76 	bl	756e <readReg>
    7682:	0003      	movs	r3, r0
    7684:	b25b      	sxtb	r3, r3
    7686:	221c      	movs	r2, #28
    7688:	4393      	bics	r3, r2
    768a:	b25b      	sxtb	r3, r3
    768c:	2208      	movs	r2, #8
    768e:	4313      	orrs	r3, r2
    7690:	b25b      	sxtb	r3, r3
    7692:	b2db      	uxtb	r3, r3
    7694:	0019      	movs	r1, r3
    7696:	2001      	movs	r0, #1
    7698:	f7ff ff88 	bl	75ac <writeReg>
            break;
    769c:	e021      	b.n	76e2 <setMode+0xf6>
        case RF69_MODE_STANDBY:
            writeReg(REG_OPMODE, (readReg(REG_OPMODE) & 0xE3) | RF_OPMODE_STANDBY);
    769e:	2001      	movs	r0, #1
    76a0:	f7ff ff65 	bl	756e <readReg>
    76a4:	0003      	movs	r3, r0
    76a6:	b25b      	sxtb	r3, r3
    76a8:	221c      	movs	r2, #28
    76aa:	4393      	bics	r3, r2
    76ac:	b25b      	sxtb	r3, r3
    76ae:	2204      	movs	r2, #4
    76b0:	4313      	orrs	r3, r2
    76b2:	b25b      	sxtb	r3, r3
    76b4:	b2db      	uxtb	r3, r3
    76b6:	0019      	movs	r1, r3
    76b8:	2001      	movs	r0, #1
    76ba:	f7ff ff77 	bl	75ac <writeReg>
            break;
    76be:	e010      	b.n	76e2 <setMode+0xf6>
        case RF69_MODE_SLEEP:
            writeReg(REG_OPMODE, (readReg(REG_OPMODE) & 0xE3) | RF_OPMODE_SLEEP);
    76c0:	2001      	movs	r0, #1
    76c2:	f7ff ff54 	bl	756e <readReg>
    76c6:	0003      	movs	r3, r0
    76c8:	001a      	movs	r2, r3
    76ca:	231c      	movs	r3, #28
    76cc:	439a      	bics	r2, r3
    76ce:	0013      	movs	r3, r2
    76d0:	b2db      	uxtb	r3, r3
    76d2:	0019      	movs	r1, r3
    76d4:	2001      	movs	r0, #1
    76d6:	f7ff ff69 	bl	75ac <writeReg>
            break;
    76da:	e002      	b.n	76e2 <setMode+0xf6>
            break;
    76dc:	46c0      	nop			; (mov r8, r8)
    76de:	e000      	b.n	76e2 <setMode+0xf6>
            break;
    76e0:	46c0      	nop			; (mov r8, r8)
        default:
        return;
    }
    // we are using packet mode, so this check is not really needed
    // but waiting for mode ready is necessary when going from sleep because the FIFO may not be immediately available from previous mode
    while (mode == RF69_MODE_SLEEP && (readReg(REG_IRQFLAGS1) & RF_IRQFLAGS1_MODEREADY) == 0x00); // wait for ModeReady
    76e2:	46c0      	nop			; (mov r8, r8)
    76e4:	4b0b      	ldr	r3, [pc, #44]	; (7714 <setMode+0x128>)
    76e6:	781b      	ldrb	r3, [r3, #0]
    76e8:	b2db      	uxtb	r3, r3
    76ea:	2b00      	cmp	r3, #0
    76ec:	d106      	bne.n	76fc <setMode+0x110>
    76ee:	2027      	movs	r0, #39	; 0x27
    76f0:	f7ff ff3d 	bl	756e <readReg>
    76f4:	0003      	movs	r3, r0
    76f6:	b25b      	sxtb	r3, r3
    76f8:	2b00      	cmp	r3, #0
    76fa:	daf3      	bge.n	76e4 <setMode+0xf8>
    mode = newMode;
    76fc:	4b05      	ldr	r3, [pc, #20]	; (7714 <setMode+0x128>)
    76fe:	1dfa      	adds	r2, r7, #7
    7700:	7812      	ldrb	r2, [r2, #0]
    7702:	701a      	strb	r2, [r3, #0]
    7704:	e002      	b.n	770c <setMode+0x120>
    return;
    7706:	46c0      	nop			; (mov r8, r8)
    7708:	e000      	b.n	770c <setMode+0x120>
        return;
    770a:	46c0      	nop			; (mov r8, r8)
}
    770c:	46bd      	mov	sp, r7
    770e:	b002      	add	sp, #8
    7710:	bd80      	pop	{r7, pc}
    7712:	46c0      	nop			; (mov r8, r8)
    7714:	20000028 	.word	0x20000028
    7718:	00009060 	.word	0x00009060
    771c:	20000029 	.word	0x20000029

00007720 <setHighPowerRegs>:
    
// internal function
void setHighPowerRegs(uint8_t onOff)
{
    7720:	b580      	push	{r7, lr}
    7722:	b082      	sub	sp, #8
    7724:	af00      	add	r7, sp, #0
    7726:	0002      	movs	r2, r0
    7728:	1dfb      	adds	r3, r7, #7
    772a:	701a      	strb	r2, [r3, #0]
    if(onOff==1)
    772c:	1dfb      	adds	r3, r7, #7
    772e:	781b      	ldrb	r3, [r3, #0]
    7730:	2b01      	cmp	r3, #1
    7732:	d108      	bne.n	7746 <setHighPowerRegs+0x26>
    {
    writeReg(REG_TESTPA1, 0x5D);
    7734:	215d      	movs	r1, #93	; 0x5d
    7736:	205a      	movs	r0, #90	; 0x5a
    7738:	f7ff ff38 	bl	75ac <writeReg>
    writeReg(REG_TESTPA2, 0x7C);
    773c:	217c      	movs	r1, #124	; 0x7c
    773e:	205c      	movs	r0, #92	; 0x5c
    7740:	f7ff ff34 	bl	75ac <writeReg>
    else
    {
        writeReg(REG_TESTPA1, 0x55);
        writeReg(REG_TESTPA2, 0x70);
    }
}
    7744:	e007      	b.n	7756 <setHighPowerRegs+0x36>
        writeReg(REG_TESTPA1, 0x55);
    7746:	2155      	movs	r1, #85	; 0x55
    7748:	205a      	movs	r0, #90	; 0x5a
    774a:	f7ff ff2f 	bl	75ac <writeReg>
        writeReg(REG_TESTPA2, 0x70);
    774e:	2170      	movs	r1, #112	; 0x70
    7750:	205c      	movs	r0, #92	; 0x5c
    7752:	f7ff ff2b 	bl	75ac <writeReg>
}
    7756:	46c0      	nop			; (mov r8, r8)
    7758:	46bd      	mov	sp, r7
    775a:	b002      	add	sp, #8
    775c:	bd80      	pop	{r7, pc}
	...

00007760 <setHighPower>:
    
// for RFM69HW only: you must call setHighPower(1) after rfm69_init() or else transmission won't work
void setHighPower(uint8_t onOff) 
{
    7760:	b580      	push	{r7, lr}
    7762:	b082      	sub	sp, #8
    7764:	af00      	add	r7, sp, #0
    7766:	0002      	movs	r2, r0
    7768:	1dfb      	adds	r3, r7, #7
    776a:	701a      	strb	r2, [r3, #0]
    isRFM69HW = onOff;
    776c:	4b18      	ldr	r3, [pc, #96]	; (77d0 <setHighPower+0x70>)
    776e:	1dfa      	adds	r2, r7, #7
    7770:	7812      	ldrb	r2, [r2, #0]
    7772:	701a      	strb	r2, [r3, #0]
    writeReg(REG_OCP, isRFM69HW ? RF_OCP_OFF : RF_OCP_ON);
    7774:	4b16      	ldr	r3, [pc, #88]	; (77d0 <setHighPower+0x70>)
    7776:	781b      	ldrb	r3, [r3, #0]
    7778:	2b00      	cmp	r3, #0
    777a:	d001      	beq.n	7780 <setHighPower+0x20>
    777c:	230f      	movs	r3, #15
    777e:	e000      	b.n	7782 <setHighPower+0x22>
    7780:	231a      	movs	r3, #26
    7782:	0019      	movs	r1, r3
    7784:	2013      	movs	r0, #19
    7786:	f7ff ff11 	bl	75ac <writeReg>

    if (isRFM69HW == 1) // turning ON
    778a:	4b11      	ldr	r3, [pc, #68]	; (77d0 <setHighPower+0x70>)
    778c:	781b      	ldrb	r3, [r3, #0]
    778e:	2b01      	cmp	r3, #1
    7790:	d110      	bne.n	77b4 <setHighPower+0x54>
        writeReg(REG_PALEVEL, (readReg(REG_PALEVEL) & 0x1F) | RF_PALEVEL_PA1_ON | RF_PALEVEL_PA2_ON); // enable P1 & P2 amplifier stages
    7792:	2011      	movs	r0, #17
    7794:	f7ff feeb 	bl	756e <readReg>
    7798:	0003      	movs	r3, r0
    779a:	b25b      	sxtb	r3, r3
    779c:	221f      	movs	r2, #31
    779e:	4013      	ands	r3, r2
    77a0:	b25b      	sxtb	r3, r3
    77a2:	2260      	movs	r2, #96	; 0x60
    77a4:	4313      	orrs	r3, r2
    77a6:	b25b      	sxtb	r3, r3
    77a8:	b2db      	uxtb	r3, r3
    77aa:	0019      	movs	r1, r3
    77ac:	2011      	movs	r0, #17
    77ae:	f7ff fefd 	bl	75ac <writeReg>
    else
        writeReg(REG_PALEVEL, RF_PALEVEL_PA0_ON | RF_PALEVEL_PA1_OFF | RF_PALEVEL_PA2_OFF | powerLevel); // enable P0 only
}
    77b2:	e009      	b.n	77c8 <setHighPower+0x68>
        writeReg(REG_PALEVEL, RF_PALEVEL_PA0_ON | RF_PALEVEL_PA1_OFF | RF_PALEVEL_PA2_OFF | powerLevel); // enable P0 only
    77b4:	4b07      	ldr	r3, [pc, #28]	; (77d4 <setHighPower+0x74>)
    77b6:	781b      	ldrb	r3, [r3, #0]
    77b8:	2280      	movs	r2, #128	; 0x80
    77ba:	4252      	negs	r2, r2
    77bc:	4313      	orrs	r3, r2
    77be:	b2db      	uxtb	r3, r3
    77c0:	0019      	movs	r1, r3
    77c2:	2011      	movs	r0, #17
    77c4:	f7ff fef2 	bl	75ac <writeReg>
}
    77c8:	46c0      	nop			; (mov r8, r8)
    77ca:	46bd      	mov	sp, r7
    77cc:	b002      	add	sp, #8
    77ce:	bd80      	pop	{r7, pc}
    77d0:	20000029 	.word	0x20000029
    77d4:	2000002a 	.word	0x2000002a

000077d8 <readRSSI>:

// get the received signal strength indicator (RSSI)
int16_t readRSSI(uint8_t forceTrigger)
{
    77d8:	b580      	push	{r7, lr}
    77da:	b084      	sub	sp, #16
    77dc:	af00      	add	r7, sp, #0
    77de:	0002      	movs	r2, r0
    77e0:	1dfb      	adds	r3, r7, #7
    77e2:	701a      	strb	r2, [r3, #0]
    int16_t rssi = 0;
    77e4:	230e      	movs	r3, #14
    77e6:	18fb      	adds	r3, r7, r3
    77e8:	2200      	movs	r2, #0
    77ea:	801a      	strh	r2, [r3, #0]
    if (forceTrigger==1)
    77ec:	1dfb      	adds	r3, r7, #7
    77ee:	781b      	ldrb	r3, [r3, #0]
    77f0:	2b01      	cmp	r3, #1
    77f2:	d10c      	bne.n	780e <readRSSI+0x36>
    {
        // RSSI trigger not needed if DAGC is in continuous mode
        writeReg(REG_RSSICONFIG, RF_RSSI_START);
    77f4:	2101      	movs	r1, #1
    77f6:	2023      	movs	r0, #35	; 0x23
    77f8:	f7ff fed8 	bl	75ac <writeReg>
        while ((readReg(REG_RSSICONFIG) & RF_RSSI_DONE) == 0x00); // wait for RSSI_Ready
    77fc:	46c0      	nop			; (mov r8, r8)
    77fe:	2023      	movs	r0, #35	; 0x23
    7800:	f7ff feb5 	bl	756e <readReg>
    7804:	0003      	movs	r3, r0
    7806:	001a      	movs	r2, r3
    7808:	2302      	movs	r3, #2
    780a:	4013      	ands	r3, r2
    780c:	d0f7      	beq.n	77fe <readRSSI+0x26>
    }
    rssi = -readReg(REG_RSSIVALUE);
    780e:	2024      	movs	r0, #36	; 0x24
    7810:	f7ff fead 	bl	756e <readReg>
    7814:	0003      	movs	r3, r0
    7816:	b29b      	uxth	r3, r3
    7818:	425b      	negs	r3, r3
    781a:	b29a      	uxth	r2, r3
    781c:	230e      	movs	r3, #14
    781e:	18fb      	adds	r3, r7, r3
    7820:	801a      	strh	r2, [r3, #0]
    rssi >>= 1;
    7822:	230e      	movs	r3, #14
    7824:	18fb      	adds	r3, r7, r3
    7826:	220e      	movs	r2, #14
    7828:	18ba      	adds	r2, r7, r2
    782a:	2100      	movs	r1, #0
    782c:	5e52      	ldrsh	r2, [r2, r1]
    782e:	1052      	asrs	r2, r2, #1
    7830:	801a      	strh	r2, [r3, #0]
    return rssi;
    7832:	230e      	movs	r3, #14
    7834:	18fb      	adds	r3, r7, r3
    7836:	2200      	movs	r2, #0
    7838:	5e9b      	ldrsh	r3, [r3, r2]
}
    783a:	0018      	movs	r0, r3
    783c:	46bd      	mov	sp, r7
    783e:	b004      	add	sp, #16
    7840:	bd80      	pop	{r7, pc}
	...

00007844 <sendFrame>:

// internal function
void sendFrame(uint8_t toAddress, const void* buffer, uint8_t bufferSize)
{
    7844:	b580      	push	{r7, lr}
    7846:	b082      	sub	sp, #8
    7848:	af00      	add	r7, sp, #0
    784a:	6039      	str	r1, [r7, #0]
    784c:	0011      	movs	r1, r2
    784e:	1dfb      	adds	r3, r7, #7
    7850:	1c02      	adds	r2, r0, #0
    7852:	701a      	strb	r2, [r3, #0]
    7854:	1dbb      	adds	r3, r7, #6
    7856:	1c0a      	adds	r2, r1, #0
    7858:	701a      	strb	r2, [r3, #0]
    setMode(RF69_MODE_STANDBY); // turn off receiver to prevent reception while filling fifo
    785a:	2001      	movs	r0, #1
    785c:	f7ff fec6 	bl	75ec <setMode>
    while ((readReg(REG_IRQFLAGS1) & RF_IRQFLAGS1_MODEREADY) == 0x00); // wait for ModeReady
    7860:	46c0      	nop			; (mov r8, r8)
    7862:	2027      	movs	r0, #39	; 0x27
    7864:	f7ff fe83 	bl	756e <readReg>
    7868:	0003      	movs	r3, r0
    786a:	b25b      	sxtb	r3, r3
    786c:	2b00      	cmp	r3, #0
    786e:	daf8      	bge.n	7862 <sendFrame+0x1e>
    writeReg(REG_DIOMAPPING1, RF_DIOMAPPING1_DIO0_00); // DIO0 is "Packet Sent"
    7870:	2100      	movs	r1, #0
    7872:	2025      	movs	r0, #37	; 0x25
    7874:	f7ff fe9a 	bl	75ac <writeReg>
    if (bufferSize > RF69_MAX_DATA_LEN)
    7878:	1dbb      	adds	r3, r7, #6
    787a:	781b      	ldrb	r3, [r3, #0]
    787c:	2b3d      	cmp	r3, #61	; 0x3d
    787e:	d902      	bls.n	7886 <sendFrame+0x42>
        bufferSize = RF69_MAX_DATA_LEN;
    7880:	1dbb      	adds	r3, r7, #6
    7882:	223d      	movs	r2, #61	; 0x3d
    7884:	701a      	strb	r2, [r3, #0]
    // write to FIFO
    RF_select(); //enable data transfer
    7886:	f000 f835 	bl	78f4 <RF_select>
    SPI_write(REG_FIFO | 0x80);
    788a:	2080      	movs	r0, #128	; 0x80
    788c:	f7ff fb54 	bl	6f38 <SPI_write>
    SPI_write(bufferSize + 3);
    7890:	1dbb      	adds	r3, r7, #6
    7892:	781b      	ldrb	r3, [r3, #0]
    7894:	3303      	adds	r3, #3
    7896:	b2db      	uxtb	r3, r3
    7898:	0018      	movs	r0, r3
    789a:	f7ff fb4d 	bl	6f38 <SPI_write>
    SPI_write(toAddress);
    789e:	1dfb      	adds	r3, r7, #7
    78a0:	781b      	ldrb	r3, [r3, #0]
    78a2:	0018      	movs	r0, r3
    78a4:	f7ff fb48 	bl	6f38 <SPI_write>
    SPI_write(address);
    78a8:	4b11      	ldr	r3, [pc, #68]	; (78f0 <sendFrame+0xac>)
    78aa:	781b      	ldrb	r3, [r3, #0]
    78ac:	0018      	movs	r0, r3
    78ae:	f7ff fb43 	bl	6f38 <SPI_write>
    SPI_write(255);
    78b2:	20ff      	movs	r0, #255	; 0xff
    78b4:	f7ff fb40 	bl	6f38 <SPI_write>
    SPI_write(240);
    78b8:	20f0      	movs	r0, #240	; 0xf0
    78ba:	f7ff fb3d 	bl	6f38 <SPI_write>
  
	RFM69_WriteBuff(buffer, bufferSize-3);
    78be:	1dbb      	adds	r3, r7, #6
    78c0:	781b      	ldrb	r3, [r3, #0]
    78c2:	b29b      	uxth	r3, r3
    78c4:	3b03      	subs	r3, #3
    78c6:	b29a      	uxth	r2, r3
    78c8:	683b      	ldr	r3, [r7, #0]
    78ca:	0011      	movs	r1, r2
    78cc:	0018      	movs	r0, r3
    78ce:	f7ff fb0d 	bl	6eec <RFM69_WriteBuff>
    RF_unselect();
    78d2:	f000 f817 	bl	7904 <RF_unselect>
    // no need to wait for transmit mode to be ready since its handled by the radio
    setMode(RF69_MODE_TX);
    78d6:	2004      	movs	r0, #4
    78d8:	f7ff fe88 	bl	75ec <setMode>
    delay_ms(5);
    78dc:	2005      	movs	r0, #5
    78de:	f7fc f895 	bl	3a0c <delay_ms>
		//}
		//delay_ms(10);
		//timeout--;
	//}
	 // wait for PacketSent
	setMode(RF69_MODE_STANDBY);
    78e2:	2001      	movs	r0, #1
    78e4:	f7ff fe82 	bl	75ec <setMode>
}
    78e8:	46c0      	nop			; (mov r8, r8)
    78ea:	46bd      	mov	sp, r7
    78ec:	b002      	add	sp, #8
    78ee:	bd80      	pop	{r7, pc}
    78f0:	200008ae 	.word	0x200008ae

000078f4 <RF_select>:
    //if (!inISR) sei();
}

// Enable SPI transfer
void RF_select()
{
    78f4:	b580      	push	{r7, lr}
    78f6:	af00      	add	r7, sp, #0
    RFM_69_sel(false);
    78f8:	2000      	movs	r0, #0
    78fa:	f7ff fb0d 	bl	6f18 <RFM_69_sel>
}
    78fe:	46c0      	nop			; (mov r8, r8)
    7900:	46bd      	mov	sp, r7
    7902:	bd80      	pop	{r7, pc}

00007904 <RF_unselect>:

// Disable SPI transfer
void RF_unselect()
{
    7904:	b580      	push	{r7, lr}
    7906:	af00      	add	r7, sp, #0
     RFM_69_sel(true);
    7908:	2001      	movs	r0, #1
    790a:	f7ff fb05 	bl	6f18 <RFM_69_sel>
}
    790e:	46c0      	nop			; (mov r8, r8)
    7910:	46bd      	mov	sp, r7
    7912:	bd80      	pop	{r7, pc}

00007914 <data_ready>:

// Interrupt Service Routine

 data_ready(){
    7914:	b590      	push	{r4, r7, lr}
    7916:	b083      	sub	sp, #12
    7918:	af00      	add	r7, sp, #0
	if (readReg(REG_IRQFLAGS2) & RF_IRQFLAGS2_PAYLOADREADY)
    791a:	2028      	movs	r0, #40	; 0x28
    791c:	f7ff fe27 	bl	756e <readReg>
    7920:	0003      	movs	r3, r0
    7922:	001a      	movs	r2, r3
    7924:	2304      	movs	r3, #4
    7926:	4013      	ands	r3, r2
    7928:	d04f      	beq.n	79ca <data_ready+0xb6>
	{
		uint8_t read_data = readReg(REG_IRQFLAGS2);
    792a:	1dfc      	adds	r4, r7, #7
    792c:	2028      	movs	r0, #40	; 0x28
    792e:	f7ff fe1e 	bl	756e <readReg>
    7932:	0003      	movs	r3, r0
    7934:	7023      	strb	r3, [r4, #0]
		read_data = readReg(REG_RSSIVALUE);
    7936:	1dfc      	adds	r4, r7, #7
    7938:	2024      	movs	r0, #36	; 0x24
    793a:	f7ff fe18 	bl	756e <readReg>
    793e:	0003      	movs	r3, r0
    7940:	7023      	strb	r3, [r4, #0]
		read_data = readReg(REG_OPMODE);
    7942:	1dfc      	adds	r4, r7, #7
    7944:	2001      	movs	r0, #1
    7946:	f7ff fe12 	bl	756e <readReg>
    794a:	0003      	movs	r3, r0
    794c:	7023      	strb	r3, [r4, #0]
		writeReg(REG_OPMODE , RF69_MODE_TX);
    794e:	2104      	movs	r1, #4
    7950:	2001      	movs	r0, #1
    7952:	f7ff fe2b 	bl	75ac <writeReg>
		read_data = readReg(REG_IRQFLAGS1);
    7956:	1dfc      	adds	r4, r7, #7
    7958:	2027      	movs	r0, #39	; 0x27
    795a:	f7ff fe08 	bl	756e <readReg>
    795e:	0003      	movs	r3, r0
    7960:	7023      	strb	r3, [r4, #0]
		
		RF_select();
    7962:	f7ff ffc7 	bl	78f4 <RF_select>
		SPI_write(REG_FIFO);
    7966:	2000      	movs	r0, #0
    7968:	f7ff fae6 	bl	6f38 <SPI_write>
		RFM69_ReadBuff(&rx_header, 5);
    796c:	4b19      	ldr	r3, [pc, #100]	; (79d4 <data_ready+0xc0>)
    796e:	2105      	movs	r1, #5
    7970:	0018      	movs	r0, r3
    7972:	f7ff faa5 	bl	6ec0 <RFM69_ReadBuff>
		RFM69_ReadBuff(&DATA, rx_header[0]);
    7976:	4b17      	ldr	r3, [pc, #92]	; (79d4 <data_ready+0xc0>)
    7978:	781b      	ldrb	r3, [r3, #0]
    797a:	b2db      	uxtb	r3, r3
    797c:	b29a      	uxth	r2, r3
    797e:	4b16      	ldr	r3, [pc, #88]	; (79d8 <data_ready+0xc4>)
    7980:	0011      	movs	r1, r2
    7982:	0018      	movs	r0, r3
    7984:	f7ff fa9c 	bl	6ec0 <RFM69_ReadBuff>
		RF_unselect();
    7988:	f7ff ffbc 	bl	7904 <RF_unselect>
		//rx_ready = 1;
		//Треба перевірити перший байт, там довжина посилки
		
		writeReg(REG_DIOMAPPING1 , 0x40);
    798c:	2140      	movs	r1, #64	; 0x40
    798e:	2025      	movs	r0, #37	; 0x25
    7990:	f7ff fe0c 	bl	75ac <writeReg>
		read_data = readReg(REG_OPMODE);
    7994:	1dfc      	adds	r4, r7, #7
    7996:	2001      	movs	r0, #1
    7998:	f7ff fde9 	bl	756e <readReg>
    799c:	0003      	movs	r3, r0
    799e:	7023      	strb	r3, [r4, #0]
		writeReg(REG_OPMODE , 0x10);
    79a0:	2110      	movs	r1, #16
    79a2:	2001      	movs	r0, #1
    79a4:	f7ff fe02 	bl	75ac <writeReg>
		
		//uint16_t timeout = RF69_TX_LIMIT_MS/10;
		while (readReg(REG_IRQFLAGS1) == 0xD9)//{
    79a8:	e002      	b.n	79b0 <data_ready+0x9c>
			//delay_ms(10);
			//timeout--;
			//}
			
			setMode(RF69_MODE_STANDBY);
    79aa:	2001      	movs	r0, #1
    79ac:	f7ff fe1e 	bl	75ec <setMode>
		while (readReg(REG_IRQFLAGS1) == 0xD9)//{
    79b0:	2027      	movs	r0, #39	; 0x27
    79b2:	f7ff fddc 	bl	756e <readReg>
    79b6:	0003      	movs	r3, r0
    79b8:	2bd9      	cmp	r3, #217	; 0xd9
    79ba:	d0f6      	beq.n	79aa <data_ready+0x96>
			RSSI = readRSSI(0);
    79bc:	2000      	movs	r0, #0
    79be:	f7ff ff0b 	bl	77d8 <readRSSI>
    79c2:	0003      	movs	r3, r0
    79c4:	001a      	movs	r2, r3
    79c6:	4b05      	ldr	r3, [pc, #20]	; (79dc <data_ready+0xc8>)
    79c8:	801a      	strh	r2, [r3, #0]
	}
	//set_led();
	
	//reset_led();
	}
    79ca:	46c0      	nop			; (mov r8, r8)
    79cc:	46bd      	mov	sp, r7
    79ce:	b003      	add	sp, #12
    79d0:	bd90      	pop	{r4, r7, pc}
    79d2:	46c0      	nop			; (mov r8, r8)
    79d4:	200008b8 	.word	0x200008b8
    79d8:	20000870 	.word	0x20000870
    79dc:	200008b0 	.word	0x200008b0

000079e0 <lastRSSI>:

int16_t lastRSSI(){
    79e0:	b580      	push	{r7, lr}
    79e2:	af00      	add	r7, sp, #0
	return RSSI;
    79e4:	4b02      	ldr	r3, [pc, #8]	; (79f0 <lastRSSI+0x10>)
    79e6:	881b      	ldrh	r3, [r3, #0]
    79e8:	b21b      	sxth	r3, r3
    79ea:	0018      	movs	r0, r3
    79ec:	46bd      	mov	sp, r7
    79ee:	bd80      	pop	{r7, pc}
    79f0:	200008b0 	.word	0x200008b0

000079f4 <hri_port_set_OUT_reg>:
{
    79f4:	b580      	push	{r7, lr}
    79f6:	b084      	sub	sp, #16
    79f8:	af00      	add	r7, sp, #0
    79fa:	60f8      	str	r0, [r7, #12]
    79fc:	607a      	str	r2, [r7, #4]
    79fe:	230b      	movs	r3, #11
    7a00:	18fb      	adds	r3, r7, r3
    7a02:	1c0a      	adds	r2, r1, #0
    7a04:	701a      	strb	r2, [r3, #0]
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    7a06:	230b      	movs	r3, #11
    7a08:	18fb      	adds	r3, r7, r3
    7a0a:	781b      	ldrb	r3, [r3, #0]
    7a0c:	68fa      	ldr	r2, [r7, #12]
    7a0e:	01db      	lsls	r3, r3, #7
    7a10:	18d3      	adds	r3, r2, r3
    7a12:	3318      	adds	r3, #24
    7a14:	687a      	ldr	r2, [r7, #4]
    7a16:	601a      	str	r2, [r3, #0]
}
    7a18:	46c0      	nop			; (mov r8, r8)
    7a1a:	46bd      	mov	sp, r7
    7a1c:	b004      	add	sp, #16
    7a1e:	bd80      	pop	{r7, pc}

00007a20 <hri_port_clear_OUT_reg>:
{
    7a20:	b580      	push	{r7, lr}
    7a22:	b084      	sub	sp, #16
    7a24:	af00      	add	r7, sp, #0
    7a26:	60f8      	str	r0, [r7, #12]
    7a28:	607a      	str	r2, [r7, #4]
    7a2a:	230b      	movs	r3, #11
    7a2c:	18fb      	adds	r3, r7, r3
    7a2e:	1c0a      	adds	r2, r1, #0
    7a30:	701a      	strb	r2, [r3, #0]
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    7a32:	230b      	movs	r3, #11
    7a34:	18fb      	adds	r3, r7, r3
    7a36:	781b      	ldrb	r3, [r3, #0]
    7a38:	68fa      	ldr	r2, [r7, #12]
    7a3a:	01db      	lsls	r3, r3, #7
    7a3c:	18d3      	adds	r3, r2, r3
    7a3e:	3314      	adds	r3, #20
    7a40:	687a      	ldr	r2, [r7, #4]
    7a42:	601a      	str	r2, [r3, #0]
}
    7a44:	46c0      	nop			; (mov r8, r8)
    7a46:	46bd      	mov	sp, r7
    7a48:	b004      	add	sp, #16
    7a4a:	bd80      	pop	{r7, pc}

00007a4c <_gpio_set_level>:
{
    7a4c:	b580      	push	{r7, lr}
    7a4e:	b082      	sub	sp, #8
    7a50:	af00      	add	r7, sp, #0
    7a52:	6039      	str	r1, [r7, #0]
    7a54:	0011      	movs	r1, r2
    7a56:	1dfb      	adds	r3, r7, #7
    7a58:	1c02      	adds	r2, r0, #0
    7a5a:	701a      	strb	r2, [r3, #0]
    7a5c:	1dbb      	adds	r3, r7, #6
    7a5e:	1c0a      	adds	r2, r1, #0
    7a60:	701a      	strb	r2, [r3, #0]
	if (level) {
    7a62:	1dbb      	adds	r3, r7, #6
    7a64:	781b      	ldrb	r3, [r3, #0]
    7a66:	2b00      	cmp	r3, #0
    7a68:	d008      	beq.n	7a7c <_gpio_set_level+0x30>
		hri_port_set_OUT_reg(PORT_IOBUS, port, mask);
    7a6a:	683a      	ldr	r2, [r7, #0]
    7a6c:	1dfb      	adds	r3, r7, #7
    7a6e:	7819      	ldrb	r1, [r3, #0]
    7a70:	23c0      	movs	r3, #192	; 0xc0
    7a72:	05db      	lsls	r3, r3, #23
    7a74:	0018      	movs	r0, r3
    7a76:	f7ff ffbd 	bl	79f4 <hri_port_set_OUT_reg>
}
    7a7a:	e007      	b.n	7a8c <_gpio_set_level+0x40>
		hri_port_clear_OUT_reg(PORT_IOBUS, port, mask);
    7a7c:	683a      	ldr	r2, [r7, #0]
    7a7e:	1dfb      	adds	r3, r7, #7
    7a80:	7819      	ldrb	r1, [r3, #0]
    7a82:	23c0      	movs	r3, #192	; 0xc0
    7a84:	05db      	lsls	r3, r3, #23
    7a86:	0018      	movs	r0, r3
    7a88:	f7ff ffca 	bl	7a20 <hri_port_clear_OUT_reg>
}
    7a8c:	46c0      	nop			; (mov r8, r8)
    7a8e:	46bd      	mov	sp, r7
    7a90:	b002      	add	sp, #8
    7a92:	bd80      	pop	{r7, pc}

00007a94 <gpio_set_pin_level>:
{
    7a94:	b580      	push	{r7, lr}
    7a96:	b082      	sub	sp, #8
    7a98:	af00      	add	r7, sp, #0
    7a9a:	0002      	movs	r2, r0
    7a9c:	1dfb      	adds	r3, r7, #7
    7a9e:	701a      	strb	r2, [r3, #0]
    7aa0:	1dbb      	adds	r3, r7, #6
    7aa2:	1c0a      	adds	r2, r1, #0
    7aa4:	701a      	strb	r2, [r3, #0]
	_gpio_set_level((enum gpio_port)GPIO_PORT(pin), 1U << GPIO_PIN(pin), level);
    7aa6:	1dfb      	adds	r3, r7, #7
    7aa8:	781b      	ldrb	r3, [r3, #0]
    7aaa:	095b      	lsrs	r3, r3, #5
    7aac:	b2d8      	uxtb	r0, r3
    7aae:	1dfb      	adds	r3, r7, #7
    7ab0:	781b      	ldrb	r3, [r3, #0]
    7ab2:	221f      	movs	r2, #31
    7ab4:	4013      	ands	r3, r2
    7ab6:	2201      	movs	r2, #1
    7ab8:	409a      	lsls	r2, r3
    7aba:	0011      	movs	r1, r2
    7abc:	1dbb      	adds	r3, r7, #6
    7abe:	781b      	ldrb	r3, [r3, #0]
    7ac0:	001a      	movs	r2, r3
    7ac2:	f7ff ffc3 	bl	7a4c <_gpio_set_level>
}
    7ac6:	46c0      	nop			; (mov r8, r8)
    7ac8:	46bd      	mov	sp, r7
    7aca:	b002      	add	sp, #8
    7acc:	bd80      	pop	{r7, pc}
	...

00007ad0 <main>:
uint32_t pack_counter = 0;
uint32_t last_pkg_time;
uint8_t rf_tx_str[32] = "\0";

int main(void)
{
    7ad0:	b5f0      	push	{r4, r5, r6, r7, lr}
    7ad2:	46c6      	mov	lr, r8
    7ad4:	b500      	push	{lr}
    7ad6:	b0ac      	sub	sp, #176	; 0xb0
    7ad8:	af04      	add	r7, sp, #16
	/* Initializes MCU, drivers and middleware */
	atmel_start_init();
    7ada:	f7f8 fb13 	bl	104 <atmel_start_init>
	
	EXT_SPI_init();
    7ade:	f7ff fa61 	bl	6fa4 <EXT_SPI_init>
	RF_SPI_init();
    7ae2:	f7ff fb7f 	bl	71e4 <RF_SPI_init>
	EXT_I2C_init();
    7ae6:	f7ff fc45 	bl	7374 <EXT_I2C_init>
	
	rfm69_init(868, NODEID, NETWORKID);
    7aea:	23d9      	movs	r3, #217	; 0xd9
    7aec:	009b      	lsls	r3, r3, #2
    7aee:	2221      	movs	r2, #33	; 0x21
    7af0:	2103      	movs	r1, #3
    7af2:	0018      	movs	r0, r3
    7af4:	f7ff fca6 	bl	7444 <rfm69_init>
	setHighPower(true);
    7af8:	2001      	movs	r0, #1
    7afa:	f7ff fe31 	bl	7760 <setHighPower>
	
	
	
	//EXTERNAL_IRQ_0_example();
	
	uint8_t debug_str[] = "                    \n\r";
    7afe:	237c      	movs	r3, #124	; 0x7c
    7b00:	2208      	movs	r2, #8
    7b02:	4694      	mov	ip, r2
    7b04:	44bc      	add	ip, r7
    7b06:	4463      	add	r3, ip
    7b08:	4af2      	ldr	r2, [pc, #968]	; (7ed4 <main+0x404>)
    7b0a:	ca13      	ldmia	r2!, {r0, r1, r4}
    7b0c:	c313      	stmia	r3!, {r0, r1, r4}
    7b0e:	ca03      	ldmia	r2!, {r0, r1}
    7b10:	c303      	stmia	r3!, {r0, r1}
    7b12:	8811      	ldrh	r1, [r2, #0]
    7b14:	8019      	strh	r1, [r3, #0]
    7b16:	7892      	ldrb	r2, [r2, #2]
    7b18:	709a      	strb	r2, [r3, #2]
	uint8_t rf_str[] =    "                    \n\r";
    7b1a:	2364      	movs	r3, #100	; 0x64
    7b1c:	2208      	movs	r2, #8
    7b1e:	4694      	mov	ip, r2
    7b20:	44bc      	add	ip, r7
    7b22:	4463      	add	r3, ip
    7b24:	4aeb      	ldr	r2, [pc, #940]	; (7ed4 <main+0x404>)
    7b26:	ca13      	ldmia	r2!, {r0, r1, r4}
    7b28:	c313      	stmia	r3!, {r0, r1, r4}
    7b2a:	ca03      	ldmia	r2!, {r0, r1}
    7b2c:	c303      	stmia	r3!, {r0, r1}
    7b2e:	8811      	ldrh	r1, [r2, #0]
    7b30:	8019      	strh	r1, [r3, #0]
    7b32:	7892      	ldrb	r2, [r2, #2]
    7b34:	709a      	strb	r2, [r3, #2]
	
	
	
	//LED_Panel
		uint8_t led_val;
		uint8_t panel_addr = 0x64;
    7b36:	2397      	movs	r3, #151	; 0x97
    7b38:	2208      	movs	r2, #8
    7b3a:	4694      	mov	ip, r2
    7b3c:	44bc      	add	ip, r7
    7b3e:	4463      	add	r3, ip
    7b40:	2264      	movs	r2, #100	; 0x64
    7b42:	701a      	strb	r2, [r3, #0]
		#define  r_part 2
		#define  g_part 1
		#define  b_part 3
		
		uint8_t reset_cmd[] = {0xa5, 0x5a};
    7b44:	2360      	movs	r3, #96	; 0x60
    7b46:	2208      	movs	r2, #8
    7b48:	4694      	mov	ip, r2
    7b4a:	44bc      	add	ip, r7
    7b4c:	4463      	add	r3, ip
    7b4e:	4ae2      	ldr	r2, [pc, #904]	; (7ed8 <main+0x408>)
    7b50:	8812      	ldrh	r2, [r2, #0]
    7b52:	801a      	strh	r2, [r3, #0]
		uint8_t init_cmd[] = {0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0xAA, 0xAA, 0xAA, 0xAA};
    7b54:	2344      	movs	r3, #68	; 0x44
    7b56:	2208      	movs	r2, #8
    7b58:	4694      	mov	ip, r2
    7b5a:	44bc      	add	ip, r7
    7b5c:	4463      	add	r3, ip
    7b5e:	4adf      	ldr	r2, [pc, #892]	; (7edc <main+0x40c>)
    7b60:	ca13      	ldmia	r2!, {r0, r1, r4}
    7b62:	c313      	stmia	r3!, {r0, r1, r4}
    7b64:	ca13      	ldmia	r2!, {r0, r1, r4}
    7b66:	c313      	stmia	r3!, {r0, r1, r4}
    7b68:	7812      	ldrb	r2, [r2, #0]
    7b6a:	701a      	strb	r2, [r3, #0]
		uint8_t led_data[] = {0xa2, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f};
    7b6c:	2330      	movs	r3, #48	; 0x30
    7b6e:	2208      	movs	r2, #8
    7b70:	4694      	mov	ip, r2
    7b72:	44bc      	add	ip, r7
    7b74:	4463      	add	r3, ip
    7b76:	4ada      	ldr	r2, [pc, #872]	; (7ee0 <main+0x410>)
    7b78:	ca13      	ldmia	r2!, {r0, r1, r4}
    7b7a:	c313      	stmia	r3!, {r0, r1, r4}
    7b7c:	6811      	ldr	r1, [r2, #0]
    7b7e:	6019      	str	r1, [r3, #0]
    7b80:	7912      	ldrb	r2, [r2, #4]
    7b82:	711a      	strb	r2, [r3, #4]
		
		uint8_t led1[]= {0xa2, 0, 0, 0};
    7b84:	232c      	movs	r3, #44	; 0x2c
    7b86:	2208      	movs	r2, #8
    7b88:	4694      	mov	ip, r2
    7b8a:	44bc      	add	ip, r7
    7b8c:	4463      	add	r3, ip
    7b8e:	22a2      	movs	r2, #162	; 0xa2
    7b90:	701a      	strb	r2, [r3, #0]
    7b92:	232c      	movs	r3, #44	; 0x2c
    7b94:	2208      	movs	r2, #8
    7b96:	4694      	mov	ip, r2
    7b98:	44bc      	add	ip, r7
    7b9a:	4463      	add	r3, ip
    7b9c:	2200      	movs	r2, #0
    7b9e:	705a      	strb	r2, [r3, #1]
    7ba0:	232c      	movs	r3, #44	; 0x2c
    7ba2:	2208      	movs	r2, #8
    7ba4:	4694      	mov	ip, r2
    7ba6:	44bc      	add	ip, r7
    7ba8:	4463      	add	r3, ip
    7baa:	2200      	movs	r2, #0
    7bac:	709a      	strb	r2, [r3, #2]
    7bae:	232c      	movs	r3, #44	; 0x2c
    7bb0:	2208      	movs	r2, #8
    7bb2:	4694      	mov	ip, r2
    7bb4:	44bc      	add	ip, r7
    7bb6:	4463      	add	r3, ip
    7bb8:	2200      	movs	r2, #0
    7bba:	70da      	strb	r2, [r3, #3]
		uint8_t led2[]= {0xa5, 0, 0, 0};
    7bbc:	2328      	movs	r3, #40	; 0x28
    7bbe:	2208      	movs	r2, #8
    7bc0:	4694      	mov	ip, r2
    7bc2:	44bc      	add	ip, r7
    7bc4:	4463      	add	r3, ip
    7bc6:	22a5      	movs	r2, #165	; 0xa5
    7bc8:	701a      	strb	r2, [r3, #0]
    7bca:	2328      	movs	r3, #40	; 0x28
    7bcc:	2208      	movs	r2, #8
    7bce:	4694      	mov	ip, r2
    7bd0:	44bc      	add	ip, r7
    7bd2:	4463      	add	r3, ip
    7bd4:	2200      	movs	r2, #0
    7bd6:	705a      	strb	r2, [r3, #1]
    7bd8:	2328      	movs	r3, #40	; 0x28
    7bda:	2208      	movs	r2, #8
    7bdc:	4694      	mov	ip, r2
    7bde:	44bc      	add	ip, r7
    7be0:	4463      	add	r3, ip
    7be2:	2200      	movs	r2, #0
    7be4:	709a      	strb	r2, [r3, #2]
    7be6:	2328      	movs	r3, #40	; 0x28
    7be8:	2208      	movs	r2, #8
    7bea:	4694      	mov	ip, r2
    7bec:	44bc      	add	ip, r7
    7bee:	4463      	add	r3, ip
    7bf0:	2200      	movs	r2, #0
    7bf2:	70da      	strb	r2, [r3, #3]
		
		uint8_t led3[]= {0xa8, 0, 0, 0};
    7bf4:	2324      	movs	r3, #36	; 0x24
    7bf6:	2208      	movs	r2, #8
    7bf8:	4694      	mov	ip, r2
    7bfa:	44bc      	add	ip, r7
    7bfc:	4463      	add	r3, ip
    7bfe:	22a8      	movs	r2, #168	; 0xa8
    7c00:	701a      	strb	r2, [r3, #0]
    7c02:	2324      	movs	r3, #36	; 0x24
    7c04:	2208      	movs	r2, #8
    7c06:	4694      	mov	ip, r2
    7c08:	44bc      	add	ip, r7
    7c0a:	4463      	add	r3, ip
    7c0c:	2200      	movs	r2, #0
    7c0e:	705a      	strb	r2, [r3, #1]
    7c10:	2324      	movs	r3, #36	; 0x24
    7c12:	2208      	movs	r2, #8
    7c14:	4694      	mov	ip, r2
    7c16:	44bc      	add	ip, r7
    7c18:	4463      	add	r3, ip
    7c1a:	2200      	movs	r2, #0
    7c1c:	709a      	strb	r2, [r3, #2]
    7c1e:	2324      	movs	r3, #36	; 0x24
    7c20:	2208      	movs	r2, #8
    7c22:	4694      	mov	ip, r2
    7c24:	44bc      	add	ip, r7
    7c26:	4463      	add	r3, ip
    7c28:	2200      	movs	r2, #0
    7c2a:	70da      	strb	r2, [r3, #3]
		uint8_t led4[]= {0xab, 0, 25, 0};
    7c2c:	2320      	movs	r3, #32
    7c2e:	2208      	movs	r2, #8
    7c30:	4694      	mov	ip, r2
    7c32:	44bc      	add	ip, r7
    7c34:	4463      	add	r3, ip
    7c36:	4aab      	ldr	r2, [pc, #684]	; (7ee4 <main+0x414>)
    7c38:	6812      	ldr	r2, [r2, #0]
    7c3a:	601a      	str	r2, [r3, #0]
		uint8_t led5[]= {0xae, 0, 25, 0};
    7c3c:	231c      	movs	r3, #28
    7c3e:	2208      	movs	r2, #8
    7c40:	4694      	mov	ip, r2
    7c42:	44bc      	add	ip, r7
    7c44:	4463      	add	r3, ip
    7c46:	4aa8      	ldr	r2, [pc, #672]	; (7ee8 <main+0x418>)
    7c48:	6812      	ldr	r2, [r2, #0]
    7c4a:	601a      	str	r2, [r3, #0]
		uint8_t ext_led[] = {0xb1, 64};
    7c4c:	2318      	movs	r3, #24
    7c4e:	2208      	movs	r2, #8
    7c50:	4694      	mov	ip, r2
    7c52:	44bc      	add	ip, r7
    7c54:	4463      	add	r3, ip
    7c56:	4aa5      	ldr	r2, [pc, #660]	; (7eec <main+0x41c>)
    7c58:	8812      	ldrh	r2, [r2, #0]
    7c5a:	801a      	strh	r2, [r3, #0]
	//End LED Panel
	
	
	
	u8g2_Setup_gp1287ai_256x50_f(&u8g2, U8G2_R0, vfd_spi, u8x8_avr_gpio_and_delay);
    7c5c:	4ba4      	ldr	r3, [pc, #656]	; (7ef0 <main+0x420>)
    7c5e:	4aa5      	ldr	r2, [pc, #660]	; (7ef4 <main+0x424>)
    7c60:	49a5      	ldr	r1, [pc, #660]	; (7ef8 <main+0x428>)
    7c62:	48a6      	ldr	r0, [pc, #664]	; (7efc <main+0x42c>)
    7c64:	f7f8 fe56 	bl	914 <u8g2_Setup_gp1287ai_256x50_f>
	u8g2_InitDisplay(&u8g2);
    7c68:	4ba4      	ldr	r3, [pc, #656]	; (7efc <main+0x42c>)
    7c6a:	0018      	movs	r0, r3
    7c6c:	f7fa fe23 	bl	28b6 <u8x8_InitDisplay>
	
	u8g2_SetPowerSave(&u8g2, 0);
    7c70:	4ba2      	ldr	r3, [pc, #648]	; (7efc <main+0x42c>)
    7c72:	2100      	movs	r1, #0
    7c74:	0018      	movs	r0, r3
    7c76:	f7fa fe2d 	bl	28d4 <u8x8_SetPowerSave>
	u8g2_SetContrast(&u8g2, 5);
    7c7a:	4ba0      	ldr	r3, [pc, #640]	; (7efc <main+0x42c>)
    7c7c:	2105      	movs	r1, #5
    7c7e:	0018      	movs	r0, r3
    7c80:	f7fa fe3b 	bl	28fa <u8x8_SetContrast>
	//WDT_CLEAR_CLEAR(0x5a);
	
	u8g2_ClearBuffer(&u8g2);
    7c84:	4b9d      	ldr	r3, [pc, #628]	; (7efc <main+0x42c>)
    7c86:	0018      	movs	r0, r3
    7c88:	f7f8 fbb7 	bl	3fa <u8g2_ClearBuffer>
	//WDT->CLEAR.reg=0x5a;
	//u8g2_SetFont(&u8g2, u8g2_font_ncenB14_tr);
	//u8g2_SetFont(&u8g2, u8g2_font_courR08_tr);
	//u8g2_SetFont(&u8g2, u8g2_font_cu12_t_symbols);
	u8g2_SetFont(&u8g2, u8g2_font_Terminal_tr);
    7c8c:	4a9c      	ldr	r2, [pc, #624]	; (7f00 <main+0x430>)
    7c8e:	4b9b      	ldr	r3, [pc, #620]	; (7efc <main+0x42c>)
    7c90:	0011      	movs	r1, r2
    7c92:	0018      	movs	r0, r3
    7c94:	f7f9 fdda 	bl	184c <u8g2_SetFont>
	//u8g2_SetFont(&u8g2, u8g2_font_battery19_tn); //battery icons
	
	/* Replace with your application code */
	 
		
	 GCLK->CLKCTRL.reg = GCLK_CLKCTRL_ID_WDT |
    7c98:	4b9a      	ldr	r3, [pc, #616]	; (7f04 <main+0x434>)
    7c9a:	4a9b      	ldr	r2, [pc, #620]	; (7f08 <main+0x438>)
    7c9c:	805a      	strh	r2, [r3, #2]
	 GCLK_CLKCTRL_CLKEN |
	 GCLK_CLKCTRL_GEN_GCLK3;	
	//WDT->INTENSET.bit.EW  = 0;      // Enable early warning interrupt
	//WDT->EWCTRL.bit.EWOFFSET = 0x0B;  // Early Warning Interrupt Time Offset 0xA
	//WDT->CONFIG.bit.PER    = 0xB;  // Set period for chip reset 0xB 16384 clock cycles
	WDT->CLEAR.bit.CLEAR = 0xA5;
    7c9e:	4b9b      	ldr	r3, [pc, #620]	; (7f0c <main+0x43c>)
    7ca0:	22a5      	movs	r2, #165	; 0xa5
    7ca2:	721a      	strb	r2, [r3, #8]
	#define  input_reg		0x00
	#define  output_reg		0x02
	#define  polarity_reg	0x04
	#define  config_reg		0x06
	
	uint8_t port_expander_off[3] = {output_reg,0x00, 0x00};
    7ca4:	2314      	movs	r3, #20
    7ca6:	2208      	movs	r2, #8
    7ca8:	4694      	mov	ip, r2
    7caa:	44bc      	add	ip, r7
    7cac:	4463      	add	r3, ip
    7cae:	2202      	movs	r2, #2
    7cb0:	701a      	strb	r2, [r3, #0]
    7cb2:	2314      	movs	r3, #20
    7cb4:	2208      	movs	r2, #8
    7cb6:	4694      	mov	ip, r2
    7cb8:	44bc      	add	ip, r7
    7cba:	4463      	add	r3, ip
    7cbc:	2200      	movs	r2, #0
    7cbe:	705a      	strb	r2, [r3, #1]
    7cc0:	2314      	movs	r3, #20
    7cc2:	2208      	movs	r2, #8
    7cc4:	4694      	mov	ip, r2
    7cc6:	44bc      	add	ip, r7
    7cc8:	4463      	add	r3, ip
    7cca:	2200      	movs	r2, #0
    7ccc:	709a      	strb	r2, [r3, #2]
	uint8_t port_expander_on[3] = {output_reg,0x01, 0x00};
    7cce:	2310      	movs	r3, #16
    7cd0:	2208      	movs	r2, #8
    7cd2:	4694      	mov	ip, r2
    7cd4:	44bc      	add	ip, r7
    7cd6:	4463      	add	r3, ip
    7cd8:	4a8d      	ldr	r2, [pc, #564]	; (7f10 <main+0x440>)
    7cda:	8811      	ldrh	r1, [r2, #0]
    7cdc:	8019      	strh	r1, [r3, #0]
    7cde:	7892      	ldrb	r2, [r2, #2]
    7ce0:	709a      	strb	r2, [r3, #2]
	uint8_t port_config[3] = {config_reg, 0x02, 0x00};
    7ce2:	230c      	movs	r3, #12
    7ce4:	2208      	movs	r2, #8
    7ce6:	4694      	mov	ip, r2
    7ce8:	44bc      	add	ip, r7
    7cea:	4463      	add	r3, ip
    7cec:	4a89      	ldr	r2, [pc, #548]	; (7f14 <main+0x444>)
    7cee:	8811      	ldrh	r1, [r2, #0]
    7cf0:	8019      	strh	r1, [r3, #0]
    7cf2:	7892      	ldrb	r2, [r2, #2]
    7cf4:	709a      	strb	r2, [r3, #2]
	uint8_t port_polarity[3] = {polarity_reg, 0x00, 0x00};
    7cf6:	2308      	movs	r3, #8
    7cf8:	2208      	movs	r2, #8
    7cfa:	4694      	mov	ip, r2
    7cfc:	44bc      	add	ip, r7
    7cfe:	4463      	add	r3, ip
    7d00:	2204      	movs	r2, #4
    7d02:	701a      	strb	r2, [r3, #0]
    7d04:	2308      	movs	r3, #8
    7d06:	2208      	movs	r2, #8
    7d08:	4694      	mov	ip, r2
    7d0a:	44bc      	add	ip, r7
    7d0c:	4463      	add	r3, ip
    7d0e:	2200      	movs	r2, #0
    7d10:	705a      	strb	r2, [r3, #1]
    7d12:	2308      	movs	r3, #8
    7d14:	2208      	movs	r2, #8
    7d16:	4694      	mov	ip, r2
    7d18:	44bc      	add	ip, r7
    7d1a:	4463      	add	r3, ip
    7d1c:	2200      	movs	r2, #0
    7d1e:	709a      	strb	r2, [r3, #2]
	
	uint8_t port_state[2];
	uint8_t addr_expander = 0x20; 
    7d20:	2396      	movs	r3, #150	; 0x96
    7d22:	2208      	movs	r2, #8
    7d24:	4694      	mov	ip, r2
    7d26:	44bc      	add	ip, r7
    7d28:	4463      	add	r3, ip
    7d2a:	2220      	movs	r2, #32
    7d2c:	701a      	strb	r2, [r3, #0]
	
	
	I2C_write_batch(addr_expander, port_config, sizeof(port_config));
    7d2e:	230c      	movs	r3, #12
    7d30:	2208      	movs	r2, #8
    7d32:	18ba      	adds	r2, r7, r2
    7d34:	18d1      	adds	r1, r2, r3
    7d36:	2396      	movs	r3, #150	; 0x96
    7d38:	2208      	movs	r2, #8
    7d3a:	4694      	mov	ip, r2
    7d3c:	44bc      	add	ip, r7
    7d3e:	4463      	add	r3, ip
    7d40:	781b      	ldrb	r3, [r3, #0]
    7d42:	2203      	movs	r2, #3
    7d44:	0018      	movs	r0, r3
    7d46:	f7ff fb53 	bl	73f0 <I2C_write_batch>
	I2C_write_batch(addr_expander, port_polarity, sizeof(port_polarity));
    7d4a:	2308      	movs	r3, #8
    7d4c:	2208      	movs	r2, #8
    7d4e:	18ba      	adds	r2, r7, r2
    7d50:	18d1      	adds	r1, r2, r3
    7d52:	2396      	movs	r3, #150	; 0x96
    7d54:	2208      	movs	r2, #8
    7d56:	4694      	mov	ip, r2
    7d58:	44bc      	add	ip, r7
    7d5a:	4463      	add	r3, ip
    7d5c:	781b      	ldrb	r3, [r3, #0]
    7d5e:	2203      	movs	r2, #3
    7d60:	0018      	movs	r0, r3
    7d62:	f7ff fb45 	bl	73f0 <I2C_write_batch>
	
	
	while (1) {
	
		WDT->CLEAR.bit.CLEAR = 0xA5;
    7d66:	4b69      	ldr	r3, [pc, #420]	; (7f0c <main+0x43c>)
    7d68:	22a5      	movs	r2, #165	; 0xa5
    7d6a:	721a      	strb	r2, [r3, #8]
		while(WDT->STATUS.bit.SYNCBUSY);
    7d6c:	46c0      	nop			; (mov r8, r8)
    7d6e:	4b67      	ldr	r3, [pc, #412]	; (7f0c <main+0x43c>)
    7d70:	79db      	ldrb	r3, [r3, #7]
    7d72:	061b      	lsls	r3, r3, #24
    7d74:	0fdb      	lsrs	r3, r3, #31
    7d76:	b2db      	uxtb	r3, r3
    7d78:	2b00      	cmp	r3, #0
    7d7a:	d1f8      	bne.n	7d6e <main+0x29e>
		
		//gpio_toggle_pin_level(LED_G);
		//gpio_toggle_pin_level(LED_SD);
		//gpio_toggle_pin_level(LED_R);
		
		u8g2_ClearBuffer(&u8g2);
    7d7c:	4b5f      	ldr	r3, [pc, #380]	; (7efc <main+0x42c>)
    7d7e:	0018      	movs	r0, r3
    7d80:	f7f8 fb3b 	bl	3fa <u8g2_ClearBuffer>
		u8g2_DrawRFrame(&u8g2, 0, 0, 256 ,48, 5);
    7d84:	2380      	movs	r3, #128	; 0x80
    7d86:	005a      	lsls	r2, r3, #1
    7d88:	485c      	ldr	r0, [pc, #368]	; (7efc <main+0x42c>)
    7d8a:	2305      	movs	r3, #5
    7d8c:	9301      	str	r3, [sp, #4]
    7d8e:	2330      	movs	r3, #48	; 0x30
    7d90:	9300      	str	r3, [sp, #0]
    7d92:	0013      	movs	r3, r2
    7d94:	2200      	movs	r2, #0
    7d96:	2100      	movs	r1, #0
    7d98:	f7f8 f9bb 	bl	112 <u8g2_DrawRFrame>
		u8g2_DrawStr(&u8g2, 60, 11, (char *)"ATMEL SAMD20 (48MHz)");
    7d9c:	4b5e      	ldr	r3, [pc, #376]	; (7f18 <main+0x448>)
    7d9e:	4857      	ldr	r0, [pc, #348]	; (7efc <main+0x42c>)
    7da0:	220b      	movs	r2, #11
    7da2:	213c      	movs	r1, #60	; 0x3c
    7da4:	f7f9 fcac 	bl	1700 <u8g2_DrawStr>
		u8g2_DrawLine(&u8g2, 3,12, 252,12);
    7da8:	4854      	ldr	r0, [pc, #336]	; (7efc <main+0x42c>)
    7daa:	230c      	movs	r3, #12
    7dac:	9300      	str	r3, [sp, #0]
    7dae:	23fc      	movs	r3, #252	; 0xfc
    7db0:	220c      	movs	r2, #12
    7db2:	2103      	movs	r1, #3
    7db4:	f7f9 ffd0 	bl	1d58 <u8g2_DrawLine>
		
		
		sprintf(debug_str, "INT:%04d; RSSI: %04d; tim:%03d:%02d:%02d; %01d " , rf_isReady(), lastRSSI(),  hour,mine,seco, get_io0());
    7db8:	f7ff f860 	bl	6e7c <rf_isReady>
    7dbc:	0003      	movs	r3, r0
    7dbe:	607b      	str	r3, [r7, #4]
    7dc0:	f7ff fe0e 	bl	79e0 <lastRSSI>
    7dc4:	0003      	movs	r3, r0
    7dc6:	603b      	str	r3, [r7, #0]
    7dc8:	4b54      	ldr	r3, [pc, #336]	; (7f1c <main+0x44c>)
    7dca:	881b      	ldrh	r3, [r3, #0]
    7dcc:	001c      	movs	r4, r3
    7dce:	4b54      	ldr	r3, [pc, #336]	; (7f20 <main+0x450>)
    7dd0:	881b      	ldrh	r3, [r3, #0]
    7dd2:	001d      	movs	r5, r3
    7dd4:	4b53      	ldr	r3, [pc, #332]	; (7f24 <main+0x454>)
    7dd6:	881b      	ldrh	r3, [r3, #0]
    7dd8:	001e      	movs	r6, r3
    7dda:	f7ff f8d9 	bl	6f90 <get_io0>
    7dde:	0003      	movs	r3, r0
    7de0:	4951      	ldr	r1, [pc, #324]	; (7f28 <main+0x458>)
    7de2:	207c      	movs	r0, #124	; 0x7c
    7de4:	2208      	movs	r2, #8
    7de6:	4694      	mov	ip, r2
    7de8:	44bc      	add	ip, r7
    7dea:	4460      	add	r0, ip
    7dec:	9303      	str	r3, [sp, #12]
    7dee:	9602      	str	r6, [sp, #8]
    7df0:	9501      	str	r5, [sp, #4]
    7df2:	9400      	str	r4, [sp, #0]
    7df4:	683b      	ldr	r3, [r7, #0]
    7df6:	687a      	ldr	r2, [r7, #4]
    7df8:	f000 f9a8 	bl	814c <siprintf>
		
		
		
		
		
		u8g2_DrawStr(&u8g2, 3, 23, (char *)debug_str);
    7dfc:	237c      	movs	r3, #124	; 0x7c
    7dfe:	2208      	movs	r2, #8
    7e00:	4694      	mov	ip, r2
    7e02:	44bc      	add	ip, r7
    7e04:	4463      	add	r3, ip
    7e06:	483d      	ldr	r0, [pc, #244]	; (7efc <main+0x42c>)
    7e08:	2217      	movs	r2, #23
    7e0a:	2103      	movs	r1, #3
    7e0c:	f7f9 fc78 	bl	1700 <u8g2_DrawStr>
		u8g2_DrawStr(&u8g2, 3, 34, (char *)rf_str);
    7e10:	2364      	movs	r3, #100	; 0x64
    7e12:	2208      	movs	r2, #8
    7e14:	4694      	mov	ip, r2
    7e16:	44bc      	add	ip, r7
    7e18:	4463      	add	r3, ip
    7e1a:	4838      	ldr	r0, [pc, #224]	; (7efc <main+0x42c>)
    7e1c:	2222      	movs	r2, #34	; 0x22
    7e1e:	2103      	movs	r1, #3
    7e20:	f7f9 fc6e 	bl	1700 <u8g2_DrawStr>
		u8g2_DrawStr(&u8g2, 3, 44, (char *)DATA);
    7e24:	4b41      	ldr	r3, [pc, #260]	; (7f2c <main+0x45c>)
    7e26:	4835      	ldr	r0, [pc, #212]	; (7efc <main+0x42c>)
    7e28:	222c      	movs	r2, #44	; 0x2c
    7e2a:	2103      	movs	r1, #3
    7e2c:	f7f9 fc68 	bl	1700 <u8g2_DrawStr>
		u8g2_SendBuffer(&u8g2);
    7e30:	4b32      	ldr	r3, [pc, #200]	; (7efc <main+0x42c>)
    7e32:	0018      	movs	r0, r3
    7e34:	f7f8 fb86 	bl	544 <u8g2_SendBuffer>
		
		//seco == 999 ? seco=0 : seco++;
		seco++;
    7e38:	4b3a      	ldr	r3, [pc, #232]	; (7f24 <main+0x454>)
    7e3a:	881b      	ldrh	r3, [r3, #0]
    7e3c:	3301      	adds	r3, #1
    7e3e:	b29a      	uxth	r2, r3
    7e40:	4b38      	ldr	r3, [pc, #224]	; (7f24 <main+0x454>)
    7e42:	801a      	strh	r2, [r3, #0]
		if(seco==60){
    7e44:	4b37      	ldr	r3, [pc, #220]	; (7f24 <main+0x454>)
    7e46:	881b      	ldrh	r3, [r3, #0]
    7e48:	2b3c      	cmp	r3, #60	; 0x3c
    7e4a:	d116      	bne.n	7e7a <main+0x3aa>
			u8g2_InitDisplay(&u8g2);
    7e4c:	4b2b      	ldr	r3, [pc, #172]	; (7efc <main+0x42c>)
    7e4e:	0018      	movs	r0, r3
    7e50:	f7fa fd31 	bl	28b6 <u8x8_InitDisplay>
			u8g2_SetPowerSave(&u8g2, 0);
    7e54:	4b29      	ldr	r3, [pc, #164]	; (7efc <main+0x42c>)
    7e56:	2100      	movs	r1, #0
    7e58:	0018      	movs	r0, r3
    7e5a:	f7fa fd3b 	bl	28d4 <u8x8_SetPowerSave>
			u8g2_SetContrast(&u8g2, 5);
    7e5e:	4b27      	ldr	r3, [pc, #156]	; (7efc <main+0x42c>)
    7e60:	2105      	movs	r1, #5
    7e62:	0018      	movs	r0, r3
    7e64:	f7fa fd49 	bl	28fa <u8x8_SetContrast>
			
			mine++;
    7e68:	4b2d      	ldr	r3, [pc, #180]	; (7f20 <main+0x450>)
    7e6a:	881b      	ldrh	r3, [r3, #0]
    7e6c:	3301      	adds	r3, #1
    7e6e:	b29a      	uxth	r2, r3
    7e70:	4b2b      	ldr	r3, [pc, #172]	; (7f20 <main+0x450>)
    7e72:	801a      	strh	r2, [r3, #0]
			seco=0;
    7e74:	4b2b      	ldr	r3, [pc, #172]	; (7f24 <main+0x454>)
    7e76:	2200      	movs	r2, #0
    7e78:	801a      	strh	r2, [r3, #0]
		}
		if(mine==60){
    7e7a:	4b29      	ldr	r3, [pc, #164]	; (7f20 <main+0x450>)
    7e7c:	881b      	ldrh	r3, [r3, #0]
    7e7e:	2b3c      	cmp	r3, #60	; 0x3c
    7e80:	d108      	bne.n	7e94 <main+0x3c4>
			hour++;
    7e82:	4b26      	ldr	r3, [pc, #152]	; (7f1c <main+0x44c>)
    7e84:	881b      	ldrh	r3, [r3, #0]
    7e86:	3301      	adds	r3, #1
    7e88:	b29a      	uxth	r2, r3
    7e8a:	4b24      	ldr	r3, [pc, #144]	; (7f1c <main+0x44c>)
    7e8c:	801a      	strh	r2, [r3, #0]
			mine=0;
    7e8e:	4b24      	ldr	r3, [pc, #144]	; (7f20 <main+0x450>)
    7e90:	2200      	movs	r2, #0
    7e92:	801a      	strh	r2, [r3, #0]
		}
		last_pkg_time++;
    7e94:	4b26      	ldr	r3, [pc, #152]	; (7f30 <main+0x460>)
    7e96:	681b      	ldr	r3, [r3, #0]
    7e98:	1c5a      	adds	r2, r3, #1
    7e9a:	4b25      	ldr	r3, [pc, #148]	; (7f30 <main+0x460>)
    7e9c:	601a      	str	r2, [r3, #0]
			//rfm69_init(868, NODEID, NETWORKID);
			//setHighPower(true);
		//}
		
		
		sprintf(rf_tx_str, "%03d:%02d:%02d test_ ; %010d\0",  hour,mine,seco, pack_counter);
    7e9e:	4b1f      	ldr	r3, [pc, #124]	; (7f1c <main+0x44c>)
    7ea0:	881b      	ldrh	r3, [r3, #0]
    7ea2:	001c      	movs	r4, r3
    7ea4:	4b1e      	ldr	r3, [pc, #120]	; (7f20 <main+0x450>)
    7ea6:	881b      	ldrh	r3, [r3, #0]
    7ea8:	001d      	movs	r5, r3
    7eaa:	4b1e      	ldr	r3, [pc, #120]	; (7f24 <main+0x454>)
    7eac:	881b      	ldrh	r3, [r3, #0]
    7eae:	001a      	movs	r2, r3
    7eb0:	4b20      	ldr	r3, [pc, #128]	; (7f34 <main+0x464>)
    7eb2:	681b      	ldr	r3, [r3, #0]
    7eb4:	4920      	ldr	r1, [pc, #128]	; (7f38 <main+0x468>)
    7eb6:	4821      	ldr	r0, [pc, #132]	; (7f3c <main+0x46c>)
    7eb8:	9301      	str	r3, [sp, #4]
    7eba:	9200      	str	r2, [sp, #0]
    7ebc:	002b      	movs	r3, r5
    7ebe:	0022      	movs	r2, r4
    7ec0:	f000 f944 	bl	814c <siprintf>
		gpio_set_pin_level(LED_R, true);
    7ec4:	2101      	movs	r1, #1
    7ec6:	203f      	movs	r0, #63	; 0x3f
    7ec8:	f7ff fde4 	bl	7a94 <gpio_set_pin_level>
		sendFrame(0, &rf_tx_str, sizeof(rf_tx_str));
    7ecc:	4b1b      	ldr	r3, [pc, #108]	; (7f3c <main+0x46c>)
    7ece:	2220      	movs	r2, #32
    7ed0:	0019      	movs	r1, r3
    7ed2:	e035      	b.n	7f40 <main+0x470>
    7ed4:	000090fc 	.word	0x000090fc
    7ed8:	00009114 	.word	0x00009114
    7edc:	00009118 	.word	0x00009118
    7ee0:	00009134 	.word	0x00009134
    7ee4:	00009148 	.word	0x00009148
    7ee8:	0000914c 	.word	0x0000914c
    7eec:	00009150 	.word	0x00009150
    7ef0:	0000710d 	.word	0x0000710d
    7ef4:	00007161 	.word	0x00007161
    7ef8:	00008e20 	.word	0x00008e20
    7efc:	200008cc 	.word	0x200008cc
    7f00:	0000898c 	.word	0x0000898c
    7f04:	40000c00 	.word	0x40000c00
    7f08:	00004301 	.word	0x00004301
    7f0c:	40001000 	.word	0x40001000
    7f10:	00009154 	.word	0x00009154
    7f14:	00009158 	.word	0x00009158
    7f18:	00009074 	.word	0x00009074
    7f1c:	20000960 	.word	0x20000960
    7f20:	200008c4 	.word	0x200008c4
    7f24:	20000962 	.word	0x20000962
    7f28:	0000908c 	.word	0x0000908c
    7f2c:	20000870 	.word	0x20000870
    7f30:	200008c8 	.word	0x200008c8
    7f34:	200007d4 	.word	0x200007d4
    7f38:	000090bc 	.word	0x000090bc
    7f3c:	200007d8 	.word	0x200007d8
    7f40:	2000      	movs	r0, #0
    7f42:	f7ff fc7f 	bl	7844 <sendFrame>
		gpio_set_pin_level(LED_R, false);
    7f46:	2100      	movs	r1, #0
    7f48:	203f      	movs	r0, #63	; 0x3f
    7f4a:	f7ff fda3 	bl	7a94 <gpio_set_pin_level>
		

		pack_counter++;
    7f4e:	4b18      	ldr	r3, [pc, #96]	; (7fb0 <main+0x4e0>)
    7f50:	681b      	ldr	r3, [r3, #0]
    7f52:	1c5a      	adds	r2, r3, #1
    7f54:	4b16      	ldr	r3, [pc, #88]	; (7fb0 <main+0x4e0>)
    7f56:	601a      	str	r2, [r3, #0]
		//delay_ms(100);
		
		if (rf_isReady()) {
    7f58:	f7fe ff90 	bl	6e7c <rf_isReady>
    7f5c:	1e03      	subs	r3, r0, #0
    7f5e:	d100      	bne.n	7f62 <main+0x492>
    7f60:	e701      	b.n	7d66 <main+0x296>
			
			sprintf((char *)rf_str , "%02d/%02d/%02d/%02d/%02d    ",  rx_header[0], rx_header[1], rx_header[2],  rx_header[3],  rx_header[4]);
    7f62:	4b14      	ldr	r3, [pc, #80]	; (7fb4 <main+0x4e4>)
    7f64:	781b      	ldrb	r3, [r3, #0]
    7f66:	b2db      	uxtb	r3, r3
    7f68:	001d      	movs	r5, r3
    7f6a:	4b12      	ldr	r3, [pc, #72]	; (7fb4 <main+0x4e4>)
    7f6c:	785b      	ldrb	r3, [r3, #1]
    7f6e:	b2db      	uxtb	r3, r3
    7f70:	001e      	movs	r6, r3
    7f72:	4b10      	ldr	r3, [pc, #64]	; (7fb4 <main+0x4e4>)
    7f74:	789b      	ldrb	r3, [r3, #2]
    7f76:	b2db      	uxtb	r3, r3
    7f78:	001a      	movs	r2, r3
    7f7a:	4b0e      	ldr	r3, [pc, #56]	; (7fb4 <main+0x4e4>)
    7f7c:	78db      	ldrb	r3, [r3, #3]
    7f7e:	b2db      	uxtb	r3, r3
    7f80:	001c      	movs	r4, r3
    7f82:	4b0c      	ldr	r3, [pc, #48]	; (7fb4 <main+0x4e4>)
    7f84:	791b      	ldrb	r3, [r3, #4]
    7f86:	b2db      	uxtb	r3, r3
    7f88:	4698      	mov	r8, r3
    7f8a:	490b      	ldr	r1, [pc, #44]	; (7fb8 <main+0x4e8>)
    7f8c:	2064      	movs	r0, #100	; 0x64
    7f8e:	2308      	movs	r3, #8
    7f90:	469c      	mov	ip, r3
    7f92:	44bc      	add	ip, r7
    7f94:	4460      	add	r0, ip
    7f96:	4643      	mov	r3, r8
    7f98:	9302      	str	r3, [sp, #8]
    7f9a:	9401      	str	r4, [sp, #4]
    7f9c:	9200      	str	r2, [sp, #0]
    7f9e:	0033      	movs	r3, r6
    7fa0:	002a      	movs	r2, r5
    7fa2:	f000 f8d3 	bl	814c <siprintf>
			//u8g2_DrawStr(&u8g2, 3, 34, (char *)debug_str);
			//u8g2_DrawStr(&u8g2, 3, 44, (char *)DATA);
			
			//u8g2_SendBuffer(&u8g2);
			//rx_ready = 0;
			last_pkg_time=0;
    7fa6:	4b05      	ldr	r3, [pc, #20]	; (7fbc <main+0x4ec>)
    7fa8:	2200      	movs	r2, #0
    7faa:	601a      	str	r2, [r3, #0]
		WDT->CLEAR.bit.CLEAR = 0xA5;
    7fac:	e6db      	b.n	7d66 <main+0x296>
    7fae:	46c0      	nop			; (mov r8, r8)
    7fb0:	200007d4 	.word	0x200007d4
    7fb4:	200008b8 	.word	0x200008b8
    7fb8:	000090dc 	.word	0x000090dc
    7fbc:	200008c8 	.word	0x200008c8

00007fc0 <__udivsi3>:
    7fc0:	2200      	movs	r2, #0
    7fc2:	0843      	lsrs	r3, r0, #1
    7fc4:	428b      	cmp	r3, r1
    7fc6:	d374      	bcc.n	80b2 <__udivsi3+0xf2>
    7fc8:	0903      	lsrs	r3, r0, #4
    7fca:	428b      	cmp	r3, r1
    7fcc:	d35f      	bcc.n	808e <__udivsi3+0xce>
    7fce:	0a03      	lsrs	r3, r0, #8
    7fd0:	428b      	cmp	r3, r1
    7fd2:	d344      	bcc.n	805e <__udivsi3+0x9e>
    7fd4:	0b03      	lsrs	r3, r0, #12
    7fd6:	428b      	cmp	r3, r1
    7fd8:	d328      	bcc.n	802c <__udivsi3+0x6c>
    7fda:	0c03      	lsrs	r3, r0, #16
    7fdc:	428b      	cmp	r3, r1
    7fde:	d30d      	bcc.n	7ffc <__udivsi3+0x3c>
    7fe0:	22ff      	movs	r2, #255	; 0xff
    7fe2:	0209      	lsls	r1, r1, #8
    7fe4:	ba12      	rev	r2, r2
    7fe6:	0c03      	lsrs	r3, r0, #16
    7fe8:	428b      	cmp	r3, r1
    7fea:	d302      	bcc.n	7ff2 <__udivsi3+0x32>
    7fec:	1212      	asrs	r2, r2, #8
    7fee:	0209      	lsls	r1, r1, #8
    7ff0:	d065      	beq.n	80be <__udivsi3+0xfe>
    7ff2:	0b03      	lsrs	r3, r0, #12
    7ff4:	428b      	cmp	r3, r1
    7ff6:	d319      	bcc.n	802c <__udivsi3+0x6c>
    7ff8:	e000      	b.n	7ffc <__udivsi3+0x3c>
    7ffa:	0a09      	lsrs	r1, r1, #8
    7ffc:	0bc3      	lsrs	r3, r0, #15
    7ffe:	428b      	cmp	r3, r1
    8000:	d301      	bcc.n	8006 <__udivsi3+0x46>
    8002:	03cb      	lsls	r3, r1, #15
    8004:	1ac0      	subs	r0, r0, r3
    8006:	4152      	adcs	r2, r2
    8008:	0b83      	lsrs	r3, r0, #14
    800a:	428b      	cmp	r3, r1
    800c:	d301      	bcc.n	8012 <__udivsi3+0x52>
    800e:	038b      	lsls	r3, r1, #14
    8010:	1ac0      	subs	r0, r0, r3
    8012:	4152      	adcs	r2, r2
    8014:	0b43      	lsrs	r3, r0, #13
    8016:	428b      	cmp	r3, r1
    8018:	d301      	bcc.n	801e <__udivsi3+0x5e>
    801a:	034b      	lsls	r3, r1, #13
    801c:	1ac0      	subs	r0, r0, r3
    801e:	4152      	adcs	r2, r2
    8020:	0b03      	lsrs	r3, r0, #12
    8022:	428b      	cmp	r3, r1
    8024:	d301      	bcc.n	802a <__udivsi3+0x6a>
    8026:	030b      	lsls	r3, r1, #12
    8028:	1ac0      	subs	r0, r0, r3
    802a:	4152      	adcs	r2, r2
    802c:	0ac3      	lsrs	r3, r0, #11
    802e:	428b      	cmp	r3, r1
    8030:	d301      	bcc.n	8036 <__udivsi3+0x76>
    8032:	02cb      	lsls	r3, r1, #11
    8034:	1ac0      	subs	r0, r0, r3
    8036:	4152      	adcs	r2, r2
    8038:	0a83      	lsrs	r3, r0, #10
    803a:	428b      	cmp	r3, r1
    803c:	d301      	bcc.n	8042 <__udivsi3+0x82>
    803e:	028b      	lsls	r3, r1, #10
    8040:	1ac0      	subs	r0, r0, r3
    8042:	4152      	adcs	r2, r2
    8044:	0a43      	lsrs	r3, r0, #9
    8046:	428b      	cmp	r3, r1
    8048:	d301      	bcc.n	804e <__udivsi3+0x8e>
    804a:	024b      	lsls	r3, r1, #9
    804c:	1ac0      	subs	r0, r0, r3
    804e:	4152      	adcs	r2, r2
    8050:	0a03      	lsrs	r3, r0, #8
    8052:	428b      	cmp	r3, r1
    8054:	d301      	bcc.n	805a <__udivsi3+0x9a>
    8056:	020b      	lsls	r3, r1, #8
    8058:	1ac0      	subs	r0, r0, r3
    805a:	4152      	adcs	r2, r2
    805c:	d2cd      	bcs.n	7ffa <__udivsi3+0x3a>
    805e:	09c3      	lsrs	r3, r0, #7
    8060:	428b      	cmp	r3, r1
    8062:	d301      	bcc.n	8068 <__udivsi3+0xa8>
    8064:	01cb      	lsls	r3, r1, #7
    8066:	1ac0      	subs	r0, r0, r3
    8068:	4152      	adcs	r2, r2
    806a:	0983      	lsrs	r3, r0, #6
    806c:	428b      	cmp	r3, r1
    806e:	d301      	bcc.n	8074 <__udivsi3+0xb4>
    8070:	018b      	lsls	r3, r1, #6
    8072:	1ac0      	subs	r0, r0, r3
    8074:	4152      	adcs	r2, r2
    8076:	0943      	lsrs	r3, r0, #5
    8078:	428b      	cmp	r3, r1
    807a:	d301      	bcc.n	8080 <__udivsi3+0xc0>
    807c:	014b      	lsls	r3, r1, #5
    807e:	1ac0      	subs	r0, r0, r3
    8080:	4152      	adcs	r2, r2
    8082:	0903      	lsrs	r3, r0, #4
    8084:	428b      	cmp	r3, r1
    8086:	d301      	bcc.n	808c <__udivsi3+0xcc>
    8088:	010b      	lsls	r3, r1, #4
    808a:	1ac0      	subs	r0, r0, r3
    808c:	4152      	adcs	r2, r2
    808e:	08c3      	lsrs	r3, r0, #3
    8090:	428b      	cmp	r3, r1
    8092:	d301      	bcc.n	8098 <__udivsi3+0xd8>
    8094:	00cb      	lsls	r3, r1, #3
    8096:	1ac0      	subs	r0, r0, r3
    8098:	4152      	adcs	r2, r2
    809a:	0883      	lsrs	r3, r0, #2
    809c:	428b      	cmp	r3, r1
    809e:	d301      	bcc.n	80a4 <__udivsi3+0xe4>
    80a0:	008b      	lsls	r3, r1, #2
    80a2:	1ac0      	subs	r0, r0, r3
    80a4:	4152      	adcs	r2, r2
    80a6:	0843      	lsrs	r3, r0, #1
    80a8:	428b      	cmp	r3, r1
    80aa:	d301      	bcc.n	80b0 <__udivsi3+0xf0>
    80ac:	004b      	lsls	r3, r1, #1
    80ae:	1ac0      	subs	r0, r0, r3
    80b0:	4152      	adcs	r2, r2
    80b2:	1a41      	subs	r1, r0, r1
    80b4:	d200      	bcs.n	80b8 <__udivsi3+0xf8>
    80b6:	4601      	mov	r1, r0
    80b8:	4152      	adcs	r2, r2
    80ba:	4610      	mov	r0, r2
    80bc:	4770      	bx	lr
    80be:	e7ff      	b.n	80c0 <__udivsi3+0x100>
    80c0:	b501      	push	{r0, lr}
    80c2:	2000      	movs	r0, #0
    80c4:	f000 f806 	bl	80d4 <__aeabi_idiv0>
    80c8:	bd02      	pop	{r1, pc}
    80ca:	46c0      	nop			; (mov r8, r8)

000080cc <__aeabi_uidivmod>:
    80cc:	2900      	cmp	r1, #0
    80ce:	d0f7      	beq.n	80c0 <__udivsi3+0x100>
    80d0:	e776      	b.n	7fc0 <__udivsi3>
    80d2:	4770      	bx	lr

000080d4 <__aeabi_idiv0>:
    80d4:	4770      	bx	lr
    80d6:	46c0      	nop			; (mov r8, r8)

000080d8 <ffs>:
    80d8:	2300      	movs	r3, #0
    80da:	b510      	push	{r4, lr}
    80dc:	4298      	cmp	r0, r3
    80de:	d007      	beq.n	80f0 <ffs+0x18>
    80e0:	001a      	movs	r2, r3
    80e2:	2101      	movs	r1, #1
    80e4:	0004      	movs	r4, r0
    80e6:	4114      	asrs	r4, r2
    80e8:	1c53      	adds	r3, r2, #1
    80ea:	001a      	movs	r2, r3
    80ec:	420c      	tst	r4, r1
    80ee:	d0f9      	beq.n	80e4 <ffs+0xc>
    80f0:	0018      	movs	r0, r3
    80f2:	bd10      	pop	{r4, pc}

000080f4 <__libc_init_array>:
    80f4:	b570      	push	{r4, r5, r6, lr}
    80f6:	2600      	movs	r6, #0
    80f8:	4d0c      	ldr	r5, [pc, #48]	; (812c <__libc_init_array+0x38>)
    80fa:	4c0d      	ldr	r4, [pc, #52]	; (8130 <__libc_init_array+0x3c>)
    80fc:	1b64      	subs	r4, r4, r5
    80fe:	10a4      	asrs	r4, r4, #2
    8100:	42a6      	cmp	r6, r4
    8102:	d109      	bne.n	8118 <__libc_init_array+0x24>
    8104:	2600      	movs	r6, #0
    8106:	f001 f873 	bl	91f0 <_init>
    810a:	4d0a      	ldr	r5, [pc, #40]	; (8134 <__libc_init_array+0x40>)
    810c:	4c0a      	ldr	r4, [pc, #40]	; (8138 <__libc_init_array+0x44>)
    810e:	1b64      	subs	r4, r4, r5
    8110:	10a4      	asrs	r4, r4, #2
    8112:	42a6      	cmp	r6, r4
    8114:	d105      	bne.n	8122 <__libc_init_array+0x2e>
    8116:	bd70      	pop	{r4, r5, r6, pc}
    8118:	00b3      	lsls	r3, r6, #2
    811a:	58eb      	ldr	r3, [r5, r3]
    811c:	4798      	blx	r3
    811e:	3601      	adds	r6, #1
    8120:	e7ee      	b.n	8100 <__libc_init_array+0xc>
    8122:	00b3      	lsls	r3, r6, #2
    8124:	58eb      	ldr	r3, [r5, r3]
    8126:	4798      	blx	r3
    8128:	3601      	adds	r6, #1
    812a:	e7f2      	b.n	8112 <__libc_init_array+0x1e>
    812c:	000091fc 	.word	0x000091fc
    8130:	000091fc 	.word	0x000091fc
    8134:	000091fc 	.word	0x000091fc
    8138:	00009200 	.word	0x00009200

0000813c <memset>:
    813c:	0003      	movs	r3, r0
    813e:	1882      	adds	r2, r0, r2
    8140:	4293      	cmp	r3, r2
    8142:	d100      	bne.n	8146 <memset+0xa>
    8144:	4770      	bx	lr
    8146:	7019      	strb	r1, [r3, #0]
    8148:	3301      	adds	r3, #1
    814a:	e7f9      	b.n	8140 <memset+0x4>

0000814c <siprintf>:
    814c:	b40e      	push	{r1, r2, r3}
    814e:	b510      	push	{r4, lr}
    8150:	b09d      	sub	sp, #116	; 0x74
    8152:	a902      	add	r1, sp, #8
    8154:	9002      	str	r0, [sp, #8]
    8156:	6108      	str	r0, [r1, #16]
    8158:	480b      	ldr	r0, [pc, #44]	; (8188 <siprintf+0x3c>)
    815a:	2482      	movs	r4, #130	; 0x82
    815c:	6088      	str	r0, [r1, #8]
    815e:	6148      	str	r0, [r1, #20]
    8160:	2001      	movs	r0, #1
    8162:	4240      	negs	r0, r0
    8164:	ab1f      	add	r3, sp, #124	; 0x7c
    8166:	81c8      	strh	r0, [r1, #14]
    8168:	4808      	ldr	r0, [pc, #32]	; (818c <siprintf+0x40>)
    816a:	cb04      	ldmia	r3!, {r2}
    816c:	00a4      	lsls	r4, r4, #2
    816e:	6800      	ldr	r0, [r0, #0]
    8170:	9301      	str	r3, [sp, #4]
    8172:	818c      	strh	r4, [r1, #12]
    8174:	f000 f8cc 	bl	8310 <_svfiprintf_r>
    8178:	2300      	movs	r3, #0
    817a:	9a02      	ldr	r2, [sp, #8]
    817c:	7013      	strb	r3, [r2, #0]
    817e:	b01d      	add	sp, #116	; 0x74
    8180:	bc10      	pop	{r4}
    8182:	bc08      	pop	{r3}
    8184:	b003      	add	sp, #12
    8186:	4718      	bx	r3
    8188:	7fffffff 	.word	0x7fffffff
    818c:	2000002c 	.word	0x2000002c

00008190 <_malloc_r>:
    8190:	2303      	movs	r3, #3
    8192:	b570      	push	{r4, r5, r6, lr}
    8194:	1ccd      	adds	r5, r1, #3
    8196:	439d      	bics	r5, r3
    8198:	3508      	adds	r5, #8
    819a:	0006      	movs	r6, r0
    819c:	2d0c      	cmp	r5, #12
    819e:	d21e      	bcs.n	81de <_malloc_r+0x4e>
    81a0:	250c      	movs	r5, #12
    81a2:	42a9      	cmp	r1, r5
    81a4:	d81d      	bhi.n	81e2 <_malloc_r+0x52>
    81a6:	0030      	movs	r0, r6
    81a8:	f000 fb76 	bl	8898 <__malloc_lock>
    81ac:	4a25      	ldr	r2, [pc, #148]	; (8244 <_malloc_r+0xb4>)
    81ae:	6814      	ldr	r4, [r2, #0]
    81b0:	0021      	movs	r1, r4
    81b2:	2900      	cmp	r1, #0
    81b4:	d119      	bne.n	81ea <_malloc_r+0x5a>
    81b6:	4c24      	ldr	r4, [pc, #144]	; (8248 <_malloc_r+0xb8>)
    81b8:	6823      	ldr	r3, [r4, #0]
    81ba:	2b00      	cmp	r3, #0
    81bc:	d103      	bne.n	81c6 <_malloc_r+0x36>
    81be:	0030      	movs	r0, r6
    81c0:	f000 fb32 	bl	8828 <_sbrk_r>
    81c4:	6020      	str	r0, [r4, #0]
    81c6:	0029      	movs	r1, r5
    81c8:	0030      	movs	r0, r6
    81ca:	f000 fb2d 	bl	8828 <_sbrk_r>
    81ce:	1c43      	adds	r3, r0, #1
    81d0:	d12c      	bne.n	822c <_malloc_r+0x9c>
    81d2:	230c      	movs	r3, #12
    81d4:	0030      	movs	r0, r6
    81d6:	6033      	str	r3, [r6, #0]
    81d8:	f000 fb5f 	bl	889a <__malloc_unlock>
    81dc:	e003      	b.n	81e6 <_malloc_r+0x56>
    81de:	2d00      	cmp	r5, #0
    81e0:	dadf      	bge.n	81a2 <_malloc_r+0x12>
    81e2:	230c      	movs	r3, #12
    81e4:	6033      	str	r3, [r6, #0]
    81e6:	2000      	movs	r0, #0
    81e8:	bd70      	pop	{r4, r5, r6, pc}
    81ea:	680b      	ldr	r3, [r1, #0]
    81ec:	1b5b      	subs	r3, r3, r5
    81ee:	d41a      	bmi.n	8226 <_malloc_r+0x96>
    81f0:	2b0b      	cmp	r3, #11
    81f2:	d903      	bls.n	81fc <_malloc_r+0x6c>
    81f4:	600b      	str	r3, [r1, #0]
    81f6:	18cc      	adds	r4, r1, r3
    81f8:	6025      	str	r5, [r4, #0]
    81fa:	e003      	b.n	8204 <_malloc_r+0x74>
    81fc:	428c      	cmp	r4, r1
    81fe:	d10e      	bne.n	821e <_malloc_r+0x8e>
    8200:	6863      	ldr	r3, [r4, #4]
    8202:	6013      	str	r3, [r2, #0]
    8204:	0030      	movs	r0, r6
    8206:	f000 fb48 	bl	889a <__malloc_unlock>
    820a:	0020      	movs	r0, r4
    820c:	2207      	movs	r2, #7
    820e:	300b      	adds	r0, #11
    8210:	1d23      	adds	r3, r4, #4
    8212:	4390      	bics	r0, r2
    8214:	1ac3      	subs	r3, r0, r3
    8216:	d0e7      	beq.n	81e8 <_malloc_r+0x58>
    8218:	425a      	negs	r2, r3
    821a:	50e2      	str	r2, [r4, r3]
    821c:	e7e4      	b.n	81e8 <_malloc_r+0x58>
    821e:	684b      	ldr	r3, [r1, #4]
    8220:	6063      	str	r3, [r4, #4]
    8222:	000c      	movs	r4, r1
    8224:	e7ee      	b.n	8204 <_malloc_r+0x74>
    8226:	000c      	movs	r4, r1
    8228:	6849      	ldr	r1, [r1, #4]
    822a:	e7c2      	b.n	81b2 <_malloc_r+0x22>
    822c:	2303      	movs	r3, #3
    822e:	1cc4      	adds	r4, r0, #3
    8230:	439c      	bics	r4, r3
    8232:	42a0      	cmp	r0, r4
    8234:	d0e0      	beq.n	81f8 <_malloc_r+0x68>
    8236:	1a21      	subs	r1, r4, r0
    8238:	0030      	movs	r0, r6
    823a:	f000 faf5 	bl	8828 <_sbrk_r>
    823e:	1c43      	adds	r3, r0, #1
    8240:	d1da      	bne.n	81f8 <_malloc_r+0x68>
    8242:	e7c6      	b.n	81d2 <_malloc_r+0x42>
    8244:	200007f8 	.word	0x200007f8
    8248:	200007fc 	.word	0x200007fc

0000824c <__ssputs_r>:
    824c:	b5f0      	push	{r4, r5, r6, r7, lr}
    824e:	688e      	ldr	r6, [r1, #8]
    8250:	b085      	sub	sp, #20
    8252:	0007      	movs	r7, r0
    8254:	000c      	movs	r4, r1
    8256:	9203      	str	r2, [sp, #12]
    8258:	9301      	str	r3, [sp, #4]
    825a:	429e      	cmp	r6, r3
    825c:	d839      	bhi.n	82d2 <__ssputs_r+0x86>
    825e:	2390      	movs	r3, #144	; 0x90
    8260:	898a      	ldrh	r2, [r1, #12]
    8262:	00db      	lsls	r3, r3, #3
    8264:	421a      	tst	r2, r3
    8266:	d034      	beq.n	82d2 <__ssputs_r+0x86>
    8268:	2503      	movs	r5, #3
    826a:	6909      	ldr	r1, [r1, #16]
    826c:	6823      	ldr	r3, [r4, #0]
    826e:	1a5b      	subs	r3, r3, r1
    8270:	9302      	str	r3, [sp, #8]
    8272:	6963      	ldr	r3, [r4, #20]
    8274:	9802      	ldr	r0, [sp, #8]
    8276:	435d      	muls	r5, r3
    8278:	0feb      	lsrs	r3, r5, #31
    827a:	195d      	adds	r5, r3, r5
    827c:	9b01      	ldr	r3, [sp, #4]
    827e:	106d      	asrs	r5, r5, #1
    8280:	3301      	adds	r3, #1
    8282:	181b      	adds	r3, r3, r0
    8284:	42ab      	cmp	r3, r5
    8286:	d900      	bls.n	828a <__ssputs_r+0x3e>
    8288:	001d      	movs	r5, r3
    828a:	0553      	lsls	r3, r2, #21
    828c:	d532      	bpl.n	82f4 <__ssputs_r+0xa8>
    828e:	0029      	movs	r1, r5
    8290:	0038      	movs	r0, r7
    8292:	f7ff ff7d 	bl	8190 <_malloc_r>
    8296:	1e06      	subs	r6, r0, #0
    8298:	d109      	bne.n	82ae <__ssputs_r+0x62>
    829a:	230c      	movs	r3, #12
    829c:	603b      	str	r3, [r7, #0]
    829e:	2340      	movs	r3, #64	; 0x40
    82a0:	2001      	movs	r0, #1
    82a2:	89a2      	ldrh	r2, [r4, #12]
    82a4:	4240      	negs	r0, r0
    82a6:	4313      	orrs	r3, r2
    82a8:	81a3      	strh	r3, [r4, #12]
    82aa:	b005      	add	sp, #20
    82ac:	bdf0      	pop	{r4, r5, r6, r7, pc}
    82ae:	9a02      	ldr	r2, [sp, #8]
    82b0:	6921      	ldr	r1, [r4, #16]
    82b2:	f000 fad6 	bl	8862 <memcpy>
    82b6:	89a3      	ldrh	r3, [r4, #12]
    82b8:	4a14      	ldr	r2, [pc, #80]	; (830c <__ssputs_r+0xc0>)
    82ba:	401a      	ands	r2, r3
    82bc:	2380      	movs	r3, #128	; 0x80
    82be:	4313      	orrs	r3, r2
    82c0:	81a3      	strh	r3, [r4, #12]
    82c2:	9b02      	ldr	r3, [sp, #8]
    82c4:	6126      	str	r6, [r4, #16]
    82c6:	18f6      	adds	r6, r6, r3
    82c8:	6026      	str	r6, [r4, #0]
    82ca:	6165      	str	r5, [r4, #20]
    82cc:	9e01      	ldr	r6, [sp, #4]
    82ce:	1aed      	subs	r5, r5, r3
    82d0:	60a5      	str	r5, [r4, #8]
    82d2:	9b01      	ldr	r3, [sp, #4]
    82d4:	42b3      	cmp	r3, r6
    82d6:	d200      	bcs.n	82da <__ssputs_r+0x8e>
    82d8:	001e      	movs	r6, r3
    82da:	0032      	movs	r2, r6
    82dc:	9903      	ldr	r1, [sp, #12]
    82de:	6820      	ldr	r0, [r4, #0]
    82e0:	f000 fac8 	bl	8874 <memmove>
    82e4:	68a3      	ldr	r3, [r4, #8]
    82e6:	2000      	movs	r0, #0
    82e8:	1b9b      	subs	r3, r3, r6
    82ea:	60a3      	str	r3, [r4, #8]
    82ec:	6823      	ldr	r3, [r4, #0]
    82ee:	199e      	adds	r6, r3, r6
    82f0:	6026      	str	r6, [r4, #0]
    82f2:	e7da      	b.n	82aa <__ssputs_r+0x5e>
    82f4:	002a      	movs	r2, r5
    82f6:	0038      	movs	r0, r7
    82f8:	f000 fb1a 	bl	8930 <_realloc_r>
    82fc:	1e06      	subs	r6, r0, #0
    82fe:	d1e0      	bne.n	82c2 <__ssputs_r+0x76>
    8300:	6921      	ldr	r1, [r4, #16]
    8302:	0038      	movs	r0, r7
    8304:	f000 faca 	bl	889c <_free_r>
    8308:	e7c7      	b.n	829a <__ssputs_r+0x4e>
    830a:	46c0      	nop			; (mov r8, r8)
    830c:	fffffb7f 	.word	0xfffffb7f

00008310 <_svfiprintf_r>:
    8310:	b5f0      	push	{r4, r5, r6, r7, lr}
    8312:	b09f      	sub	sp, #124	; 0x7c
    8314:	9002      	str	r0, [sp, #8]
    8316:	9305      	str	r3, [sp, #20]
    8318:	898b      	ldrh	r3, [r1, #12]
    831a:	000f      	movs	r7, r1
    831c:	0016      	movs	r6, r2
    831e:	061b      	lsls	r3, r3, #24
    8320:	d511      	bpl.n	8346 <_svfiprintf_r+0x36>
    8322:	690b      	ldr	r3, [r1, #16]
    8324:	2b00      	cmp	r3, #0
    8326:	d10e      	bne.n	8346 <_svfiprintf_r+0x36>
    8328:	2140      	movs	r1, #64	; 0x40
    832a:	f7ff ff31 	bl	8190 <_malloc_r>
    832e:	6038      	str	r0, [r7, #0]
    8330:	6138      	str	r0, [r7, #16]
    8332:	2800      	cmp	r0, #0
    8334:	d105      	bne.n	8342 <_svfiprintf_r+0x32>
    8336:	230c      	movs	r3, #12
    8338:	9a02      	ldr	r2, [sp, #8]
    833a:	3801      	subs	r0, #1
    833c:	6013      	str	r3, [r2, #0]
    833e:	b01f      	add	sp, #124	; 0x7c
    8340:	bdf0      	pop	{r4, r5, r6, r7, pc}
    8342:	2340      	movs	r3, #64	; 0x40
    8344:	617b      	str	r3, [r7, #20]
    8346:	2300      	movs	r3, #0
    8348:	ad06      	add	r5, sp, #24
    834a:	616b      	str	r3, [r5, #20]
    834c:	3320      	adds	r3, #32
    834e:	766b      	strb	r3, [r5, #25]
    8350:	3310      	adds	r3, #16
    8352:	76ab      	strb	r3, [r5, #26]
    8354:	0034      	movs	r4, r6
    8356:	7823      	ldrb	r3, [r4, #0]
    8358:	2b00      	cmp	r3, #0
    835a:	d147      	bne.n	83ec <_svfiprintf_r+0xdc>
    835c:	1ba3      	subs	r3, r4, r6
    835e:	9304      	str	r3, [sp, #16]
    8360:	d00d      	beq.n	837e <_svfiprintf_r+0x6e>
    8362:	1ba3      	subs	r3, r4, r6
    8364:	0032      	movs	r2, r6
    8366:	0039      	movs	r1, r7
    8368:	9802      	ldr	r0, [sp, #8]
    836a:	f7ff ff6f 	bl	824c <__ssputs_r>
    836e:	1c43      	adds	r3, r0, #1
    8370:	d100      	bne.n	8374 <_svfiprintf_r+0x64>
    8372:	e0b5      	b.n	84e0 <_svfiprintf_r+0x1d0>
    8374:	696a      	ldr	r2, [r5, #20]
    8376:	9b04      	ldr	r3, [sp, #16]
    8378:	4694      	mov	ip, r2
    837a:	4463      	add	r3, ip
    837c:	616b      	str	r3, [r5, #20]
    837e:	7823      	ldrb	r3, [r4, #0]
    8380:	2b00      	cmp	r3, #0
    8382:	d100      	bne.n	8386 <_svfiprintf_r+0x76>
    8384:	e0ac      	b.n	84e0 <_svfiprintf_r+0x1d0>
    8386:	2201      	movs	r2, #1
    8388:	2300      	movs	r3, #0
    838a:	4252      	negs	r2, r2
    838c:	606a      	str	r2, [r5, #4]
    838e:	a902      	add	r1, sp, #8
    8390:	3254      	adds	r2, #84	; 0x54
    8392:	1852      	adds	r2, r2, r1
    8394:	3401      	adds	r4, #1
    8396:	602b      	str	r3, [r5, #0]
    8398:	60eb      	str	r3, [r5, #12]
    839a:	60ab      	str	r3, [r5, #8]
    839c:	7013      	strb	r3, [r2, #0]
    839e:	65ab      	str	r3, [r5, #88]	; 0x58
    83a0:	4e58      	ldr	r6, [pc, #352]	; (8504 <_svfiprintf_r+0x1f4>)
    83a2:	2205      	movs	r2, #5
    83a4:	7821      	ldrb	r1, [r4, #0]
    83a6:	0030      	movs	r0, r6
    83a8:	f000 fa50 	bl	884c <memchr>
    83ac:	1c62      	adds	r2, r4, #1
    83ae:	2800      	cmp	r0, #0
    83b0:	d120      	bne.n	83f4 <_svfiprintf_r+0xe4>
    83b2:	6829      	ldr	r1, [r5, #0]
    83b4:	06cb      	lsls	r3, r1, #27
    83b6:	d504      	bpl.n	83c2 <_svfiprintf_r+0xb2>
    83b8:	2353      	movs	r3, #83	; 0x53
    83ba:	ae02      	add	r6, sp, #8
    83bc:	3020      	adds	r0, #32
    83be:	199b      	adds	r3, r3, r6
    83c0:	7018      	strb	r0, [r3, #0]
    83c2:	070b      	lsls	r3, r1, #28
    83c4:	d504      	bpl.n	83d0 <_svfiprintf_r+0xc0>
    83c6:	2353      	movs	r3, #83	; 0x53
    83c8:	202b      	movs	r0, #43	; 0x2b
    83ca:	ae02      	add	r6, sp, #8
    83cc:	199b      	adds	r3, r3, r6
    83ce:	7018      	strb	r0, [r3, #0]
    83d0:	7823      	ldrb	r3, [r4, #0]
    83d2:	2b2a      	cmp	r3, #42	; 0x2a
    83d4:	d016      	beq.n	8404 <_svfiprintf_r+0xf4>
    83d6:	2000      	movs	r0, #0
    83d8:	210a      	movs	r1, #10
    83da:	9b09      	ldr	r3, [sp, #36]	; 0x24
    83dc:	7822      	ldrb	r2, [r4, #0]
    83de:	3a30      	subs	r2, #48	; 0x30
    83e0:	2a09      	cmp	r2, #9
    83e2:	d955      	bls.n	8490 <_svfiprintf_r+0x180>
    83e4:	2800      	cmp	r0, #0
    83e6:	d015      	beq.n	8414 <_svfiprintf_r+0x104>
    83e8:	9309      	str	r3, [sp, #36]	; 0x24
    83ea:	e013      	b.n	8414 <_svfiprintf_r+0x104>
    83ec:	2b25      	cmp	r3, #37	; 0x25
    83ee:	d0b5      	beq.n	835c <_svfiprintf_r+0x4c>
    83f0:	3401      	adds	r4, #1
    83f2:	e7b0      	b.n	8356 <_svfiprintf_r+0x46>
    83f4:	2301      	movs	r3, #1
    83f6:	1b80      	subs	r0, r0, r6
    83f8:	4083      	lsls	r3, r0
    83fa:	6829      	ldr	r1, [r5, #0]
    83fc:	0014      	movs	r4, r2
    83fe:	430b      	orrs	r3, r1
    8400:	602b      	str	r3, [r5, #0]
    8402:	e7cd      	b.n	83a0 <_svfiprintf_r+0x90>
    8404:	9b05      	ldr	r3, [sp, #20]
    8406:	1d18      	adds	r0, r3, #4
    8408:	681b      	ldr	r3, [r3, #0]
    840a:	9005      	str	r0, [sp, #20]
    840c:	2b00      	cmp	r3, #0
    840e:	db39      	blt.n	8484 <_svfiprintf_r+0x174>
    8410:	9309      	str	r3, [sp, #36]	; 0x24
    8412:	0014      	movs	r4, r2
    8414:	7823      	ldrb	r3, [r4, #0]
    8416:	2b2e      	cmp	r3, #46	; 0x2e
    8418:	d10b      	bne.n	8432 <_svfiprintf_r+0x122>
    841a:	7863      	ldrb	r3, [r4, #1]
    841c:	1c62      	adds	r2, r4, #1
    841e:	2b2a      	cmp	r3, #42	; 0x2a
    8420:	d13e      	bne.n	84a0 <_svfiprintf_r+0x190>
    8422:	9b05      	ldr	r3, [sp, #20]
    8424:	3402      	adds	r4, #2
    8426:	1d1a      	adds	r2, r3, #4
    8428:	681b      	ldr	r3, [r3, #0]
    842a:	9205      	str	r2, [sp, #20]
    842c:	2b00      	cmp	r3, #0
    842e:	db34      	blt.n	849a <_svfiprintf_r+0x18a>
    8430:	9307      	str	r3, [sp, #28]
    8432:	4e35      	ldr	r6, [pc, #212]	; (8508 <_svfiprintf_r+0x1f8>)
    8434:	7821      	ldrb	r1, [r4, #0]
    8436:	2203      	movs	r2, #3
    8438:	0030      	movs	r0, r6
    843a:	f000 fa07 	bl	884c <memchr>
    843e:	2800      	cmp	r0, #0
    8440:	d006      	beq.n	8450 <_svfiprintf_r+0x140>
    8442:	2340      	movs	r3, #64	; 0x40
    8444:	1b80      	subs	r0, r0, r6
    8446:	4083      	lsls	r3, r0
    8448:	682a      	ldr	r2, [r5, #0]
    844a:	3401      	adds	r4, #1
    844c:	4313      	orrs	r3, r2
    844e:	602b      	str	r3, [r5, #0]
    8450:	7821      	ldrb	r1, [r4, #0]
    8452:	2206      	movs	r2, #6
    8454:	482d      	ldr	r0, [pc, #180]	; (850c <_svfiprintf_r+0x1fc>)
    8456:	1c66      	adds	r6, r4, #1
    8458:	7629      	strb	r1, [r5, #24]
    845a:	f000 f9f7 	bl	884c <memchr>
    845e:	2800      	cmp	r0, #0
    8460:	d046      	beq.n	84f0 <_svfiprintf_r+0x1e0>
    8462:	4b2b      	ldr	r3, [pc, #172]	; (8510 <_svfiprintf_r+0x200>)
    8464:	2b00      	cmp	r3, #0
    8466:	d12f      	bne.n	84c8 <_svfiprintf_r+0x1b8>
    8468:	6829      	ldr	r1, [r5, #0]
    846a:	9b05      	ldr	r3, [sp, #20]
    846c:	2207      	movs	r2, #7
    846e:	05c9      	lsls	r1, r1, #23
    8470:	d528      	bpl.n	84c4 <_svfiprintf_r+0x1b4>
    8472:	189b      	adds	r3, r3, r2
    8474:	4393      	bics	r3, r2
    8476:	3308      	adds	r3, #8
    8478:	9305      	str	r3, [sp, #20]
    847a:	696b      	ldr	r3, [r5, #20]
    847c:	9a03      	ldr	r2, [sp, #12]
    847e:	189b      	adds	r3, r3, r2
    8480:	616b      	str	r3, [r5, #20]
    8482:	e767      	b.n	8354 <_svfiprintf_r+0x44>
    8484:	425b      	negs	r3, r3
    8486:	60eb      	str	r3, [r5, #12]
    8488:	2302      	movs	r3, #2
    848a:	430b      	orrs	r3, r1
    848c:	602b      	str	r3, [r5, #0]
    848e:	e7c0      	b.n	8412 <_svfiprintf_r+0x102>
    8490:	434b      	muls	r3, r1
    8492:	3401      	adds	r4, #1
    8494:	189b      	adds	r3, r3, r2
    8496:	2001      	movs	r0, #1
    8498:	e7a0      	b.n	83dc <_svfiprintf_r+0xcc>
    849a:	2301      	movs	r3, #1
    849c:	425b      	negs	r3, r3
    849e:	e7c7      	b.n	8430 <_svfiprintf_r+0x120>
    84a0:	2300      	movs	r3, #0
    84a2:	0014      	movs	r4, r2
    84a4:	200a      	movs	r0, #10
    84a6:	001a      	movs	r2, r3
    84a8:	606b      	str	r3, [r5, #4]
    84aa:	7821      	ldrb	r1, [r4, #0]
    84ac:	3930      	subs	r1, #48	; 0x30
    84ae:	2909      	cmp	r1, #9
    84b0:	d903      	bls.n	84ba <_svfiprintf_r+0x1aa>
    84b2:	2b00      	cmp	r3, #0
    84b4:	d0bd      	beq.n	8432 <_svfiprintf_r+0x122>
    84b6:	9207      	str	r2, [sp, #28]
    84b8:	e7bb      	b.n	8432 <_svfiprintf_r+0x122>
    84ba:	4342      	muls	r2, r0
    84bc:	3401      	adds	r4, #1
    84be:	1852      	adds	r2, r2, r1
    84c0:	2301      	movs	r3, #1
    84c2:	e7f2      	b.n	84aa <_svfiprintf_r+0x19a>
    84c4:	3307      	adds	r3, #7
    84c6:	e7d5      	b.n	8474 <_svfiprintf_r+0x164>
    84c8:	ab05      	add	r3, sp, #20
    84ca:	9300      	str	r3, [sp, #0]
    84cc:	003a      	movs	r2, r7
    84ce:	4b11      	ldr	r3, [pc, #68]	; (8514 <_svfiprintf_r+0x204>)
    84d0:	0029      	movs	r1, r5
    84d2:	9802      	ldr	r0, [sp, #8]
    84d4:	e000      	b.n	84d8 <_svfiprintf_r+0x1c8>
    84d6:	bf00      	nop
    84d8:	9003      	str	r0, [sp, #12]
    84da:	9b03      	ldr	r3, [sp, #12]
    84dc:	3301      	adds	r3, #1
    84de:	d1cc      	bne.n	847a <_svfiprintf_r+0x16a>
    84e0:	89bb      	ldrh	r3, [r7, #12]
    84e2:	980b      	ldr	r0, [sp, #44]	; 0x2c
    84e4:	065b      	lsls	r3, r3, #25
    84e6:	d400      	bmi.n	84ea <_svfiprintf_r+0x1da>
    84e8:	e729      	b.n	833e <_svfiprintf_r+0x2e>
    84ea:	2001      	movs	r0, #1
    84ec:	4240      	negs	r0, r0
    84ee:	e726      	b.n	833e <_svfiprintf_r+0x2e>
    84f0:	ab05      	add	r3, sp, #20
    84f2:	9300      	str	r3, [sp, #0]
    84f4:	003a      	movs	r2, r7
    84f6:	4b07      	ldr	r3, [pc, #28]	; (8514 <_svfiprintf_r+0x204>)
    84f8:	0029      	movs	r1, r5
    84fa:	9802      	ldr	r0, [sp, #8]
    84fc:	f000 f87a 	bl	85f4 <_printf_i>
    8500:	e7ea      	b.n	84d8 <_svfiprintf_r+0x1c8>
    8502:	46c0      	nop			; (mov r8, r8)
    8504:	000091bc 	.word	0x000091bc
    8508:	000091c2 	.word	0x000091c2
    850c:	000091c6 	.word	0x000091c6
    8510:	00000000 	.word	0x00000000
    8514:	0000824d 	.word	0x0000824d

00008518 <_printf_common>:
    8518:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    851a:	0015      	movs	r5, r2
    851c:	9301      	str	r3, [sp, #4]
    851e:	688a      	ldr	r2, [r1, #8]
    8520:	690b      	ldr	r3, [r1, #16]
    8522:	9000      	str	r0, [sp, #0]
    8524:	000c      	movs	r4, r1
    8526:	4293      	cmp	r3, r2
    8528:	da00      	bge.n	852c <_printf_common+0x14>
    852a:	0013      	movs	r3, r2
    852c:	0022      	movs	r2, r4
    852e:	602b      	str	r3, [r5, #0]
    8530:	3243      	adds	r2, #67	; 0x43
    8532:	7812      	ldrb	r2, [r2, #0]
    8534:	2a00      	cmp	r2, #0
    8536:	d001      	beq.n	853c <_printf_common+0x24>
    8538:	3301      	adds	r3, #1
    853a:	602b      	str	r3, [r5, #0]
    853c:	6823      	ldr	r3, [r4, #0]
    853e:	069b      	lsls	r3, r3, #26
    8540:	d502      	bpl.n	8548 <_printf_common+0x30>
    8542:	682b      	ldr	r3, [r5, #0]
    8544:	3302      	adds	r3, #2
    8546:	602b      	str	r3, [r5, #0]
    8548:	2706      	movs	r7, #6
    854a:	6823      	ldr	r3, [r4, #0]
    854c:	401f      	ands	r7, r3
    854e:	d027      	beq.n	85a0 <_printf_common+0x88>
    8550:	0023      	movs	r3, r4
    8552:	3343      	adds	r3, #67	; 0x43
    8554:	781b      	ldrb	r3, [r3, #0]
    8556:	1e5a      	subs	r2, r3, #1
    8558:	4193      	sbcs	r3, r2
    855a:	6822      	ldr	r2, [r4, #0]
    855c:	0692      	lsls	r2, r2, #26
    855e:	d430      	bmi.n	85c2 <_printf_common+0xaa>
    8560:	0022      	movs	r2, r4
    8562:	9901      	ldr	r1, [sp, #4]
    8564:	3243      	adds	r2, #67	; 0x43
    8566:	9800      	ldr	r0, [sp, #0]
    8568:	9e08      	ldr	r6, [sp, #32]
    856a:	47b0      	blx	r6
    856c:	1c43      	adds	r3, r0, #1
    856e:	d025      	beq.n	85bc <_printf_common+0xa4>
    8570:	2306      	movs	r3, #6
    8572:	6820      	ldr	r0, [r4, #0]
    8574:	682a      	ldr	r2, [r5, #0]
    8576:	68e1      	ldr	r1, [r4, #12]
    8578:	4003      	ands	r3, r0
    857a:	2500      	movs	r5, #0
    857c:	2b04      	cmp	r3, #4
    857e:	d103      	bne.n	8588 <_printf_common+0x70>
    8580:	1a8d      	subs	r5, r1, r2
    8582:	43eb      	mvns	r3, r5
    8584:	17db      	asrs	r3, r3, #31
    8586:	401d      	ands	r5, r3
    8588:	68a3      	ldr	r3, [r4, #8]
    858a:	6922      	ldr	r2, [r4, #16]
    858c:	4293      	cmp	r3, r2
    858e:	dd01      	ble.n	8594 <_printf_common+0x7c>
    8590:	1a9b      	subs	r3, r3, r2
    8592:	18ed      	adds	r5, r5, r3
    8594:	2700      	movs	r7, #0
    8596:	42bd      	cmp	r5, r7
    8598:	d120      	bne.n	85dc <_printf_common+0xc4>
    859a:	2000      	movs	r0, #0
    859c:	e010      	b.n	85c0 <_printf_common+0xa8>
    859e:	3701      	adds	r7, #1
    85a0:	68e3      	ldr	r3, [r4, #12]
    85a2:	682a      	ldr	r2, [r5, #0]
    85a4:	1a9b      	subs	r3, r3, r2
    85a6:	429f      	cmp	r7, r3
    85a8:	dad2      	bge.n	8550 <_printf_common+0x38>
    85aa:	0022      	movs	r2, r4
    85ac:	2301      	movs	r3, #1
    85ae:	3219      	adds	r2, #25
    85b0:	9901      	ldr	r1, [sp, #4]
    85b2:	9800      	ldr	r0, [sp, #0]
    85b4:	9e08      	ldr	r6, [sp, #32]
    85b6:	47b0      	blx	r6
    85b8:	1c43      	adds	r3, r0, #1
    85ba:	d1f0      	bne.n	859e <_printf_common+0x86>
    85bc:	2001      	movs	r0, #1
    85be:	4240      	negs	r0, r0
    85c0:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    85c2:	2030      	movs	r0, #48	; 0x30
    85c4:	18e1      	adds	r1, r4, r3
    85c6:	3143      	adds	r1, #67	; 0x43
    85c8:	7008      	strb	r0, [r1, #0]
    85ca:	0021      	movs	r1, r4
    85cc:	1c5a      	adds	r2, r3, #1
    85ce:	3145      	adds	r1, #69	; 0x45
    85d0:	7809      	ldrb	r1, [r1, #0]
    85d2:	18a2      	adds	r2, r4, r2
    85d4:	3243      	adds	r2, #67	; 0x43
    85d6:	3302      	adds	r3, #2
    85d8:	7011      	strb	r1, [r2, #0]
    85da:	e7c1      	b.n	8560 <_printf_common+0x48>
    85dc:	0022      	movs	r2, r4
    85de:	2301      	movs	r3, #1
    85e0:	321a      	adds	r2, #26
    85e2:	9901      	ldr	r1, [sp, #4]
    85e4:	9800      	ldr	r0, [sp, #0]
    85e6:	9e08      	ldr	r6, [sp, #32]
    85e8:	47b0      	blx	r6
    85ea:	1c43      	adds	r3, r0, #1
    85ec:	d0e6      	beq.n	85bc <_printf_common+0xa4>
    85ee:	3701      	adds	r7, #1
    85f0:	e7d1      	b.n	8596 <_printf_common+0x7e>
	...

000085f4 <_printf_i>:
    85f4:	b5f0      	push	{r4, r5, r6, r7, lr}
    85f6:	b08b      	sub	sp, #44	; 0x2c
    85f8:	9206      	str	r2, [sp, #24]
    85fa:	000a      	movs	r2, r1
    85fc:	3243      	adds	r2, #67	; 0x43
    85fe:	9307      	str	r3, [sp, #28]
    8600:	9005      	str	r0, [sp, #20]
    8602:	9204      	str	r2, [sp, #16]
    8604:	7e0a      	ldrb	r2, [r1, #24]
    8606:	000c      	movs	r4, r1
    8608:	9b10      	ldr	r3, [sp, #64]	; 0x40
    860a:	2a6e      	cmp	r2, #110	; 0x6e
    860c:	d100      	bne.n	8610 <_printf_i+0x1c>
    860e:	e08f      	b.n	8730 <_printf_i+0x13c>
    8610:	d817      	bhi.n	8642 <_printf_i+0x4e>
    8612:	2a63      	cmp	r2, #99	; 0x63
    8614:	d02c      	beq.n	8670 <_printf_i+0x7c>
    8616:	d808      	bhi.n	862a <_printf_i+0x36>
    8618:	2a00      	cmp	r2, #0
    861a:	d100      	bne.n	861e <_printf_i+0x2a>
    861c:	e099      	b.n	8752 <_printf_i+0x15e>
    861e:	2a58      	cmp	r2, #88	; 0x58
    8620:	d054      	beq.n	86cc <_printf_i+0xd8>
    8622:	0026      	movs	r6, r4
    8624:	3642      	adds	r6, #66	; 0x42
    8626:	7032      	strb	r2, [r6, #0]
    8628:	e029      	b.n	867e <_printf_i+0x8a>
    862a:	2a64      	cmp	r2, #100	; 0x64
    862c:	d001      	beq.n	8632 <_printf_i+0x3e>
    862e:	2a69      	cmp	r2, #105	; 0x69
    8630:	d1f7      	bne.n	8622 <_printf_i+0x2e>
    8632:	6821      	ldr	r1, [r4, #0]
    8634:	681a      	ldr	r2, [r3, #0]
    8636:	0608      	lsls	r0, r1, #24
    8638:	d523      	bpl.n	8682 <_printf_i+0x8e>
    863a:	1d11      	adds	r1, r2, #4
    863c:	6019      	str	r1, [r3, #0]
    863e:	6815      	ldr	r5, [r2, #0]
    8640:	e025      	b.n	868e <_printf_i+0x9a>
    8642:	2a73      	cmp	r2, #115	; 0x73
    8644:	d100      	bne.n	8648 <_printf_i+0x54>
    8646:	e088      	b.n	875a <_printf_i+0x166>
    8648:	d808      	bhi.n	865c <_printf_i+0x68>
    864a:	2a6f      	cmp	r2, #111	; 0x6f
    864c:	d029      	beq.n	86a2 <_printf_i+0xae>
    864e:	2a70      	cmp	r2, #112	; 0x70
    8650:	d1e7      	bne.n	8622 <_printf_i+0x2e>
    8652:	2220      	movs	r2, #32
    8654:	6809      	ldr	r1, [r1, #0]
    8656:	430a      	orrs	r2, r1
    8658:	6022      	str	r2, [r4, #0]
    865a:	e003      	b.n	8664 <_printf_i+0x70>
    865c:	2a75      	cmp	r2, #117	; 0x75
    865e:	d020      	beq.n	86a2 <_printf_i+0xae>
    8660:	2a78      	cmp	r2, #120	; 0x78
    8662:	d1de      	bne.n	8622 <_printf_i+0x2e>
    8664:	0022      	movs	r2, r4
    8666:	2178      	movs	r1, #120	; 0x78
    8668:	3245      	adds	r2, #69	; 0x45
    866a:	7011      	strb	r1, [r2, #0]
    866c:	4a6c      	ldr	r2, [pc, #432]	; (8820 <_printf_i+0x22c>)
    866e:	e030      	b.n	86d2 <_printf_i+0xde>
    8670:	000e      	movs	r6, r1
    8672:	681a      	ldr	r2, [r3, #0]
    8674:	3642      	adds	r6, #66	; 0x42
    8676:	1d11      	adds	r1, r2, #4
    8678:	6019      	str	r1, [r3, #0]
    867a:	6813      	ldr	r3, [r2, #0]
    867c:	7033      	strb	r3, [r6, #0]
    867e:	2301      	movs	r3, #1
    8680:	e079      	b.n	8776 <_printf_i+0x182>
    8682:	0649      	lsls	r1, r1, #25
    8684:	d5d9      	bpl.n	863a <_printf_i+0x46>
    8686:	1d11      	adds	r1, r2, #4
    8688:	6019      	str	r1, [r3, #0]
    868a:	2300      	movs	r3, #0
    868c:	5ed5      	ldrsh	r5, [r2, r3]
    868e:	2d00      	cmp	r5, #0
    8690:	da03      	bge.n	869a <_printf_i+0xa6>
    8692:	232d      	movs	r3, #45	; 0x2d
    8694:	9a04      	ldr	r2, [sp, #16]
    8696:	426d      	negs	r5, r5
    8698:	7013      	strb	r3, [r2, #0]
    869a:	4b62      	ldr	r3, [pc, #392]	; (8824 <_printf_i+0x230>)
    869c:	270a      	movs	r7, #10
    869e:	9303      	str	r3, [sp, #12]
    86a0:	e02f      	b.n	8702 <_printf_i+0x10e>
    86a2:	6820      	ldr	r0, [r4, #0]
    86a4:	6819      	ldr	r1, [r3, #0]
    86a6:	0605      	lsls	r5, r0, #24
    86a8:	d503      	bpl.n	86b2 <_printf_i+0xbe>
    86aa:	1d08      	adds	r0, r1, #4
    86ac:	6018      	str	r0, [r3, #0]
    86ae:	680d      	ldr	r5, [r1, #0]
    86b0:	e005      	b.n	86be <_printf_i+0xca>
    86b2:	0640      	lsls	r0, r0, #25
    86b4:	d5f9      	bpl.n	86aa <_printf_i+0xb6>
    86b6:	680d      	ldr	r5, [r1, #0]
    86b8:	1d08      	adds	r0, r1, #4
    86ba:	6018      	str	r0, [r3, #0]
    86bc:	b2ad      	uxth	r5, r5
    86be:	4b59      	ldr	r3, [pc, #356]	; (8824 <_printf_i+0x230>)
    86c0:	2708      	movs	r7, #8
    86c2:	9303      	str	r3, [sp, #12]
    86c4:	2a6f      	cmp	r2, #111	; 0x6f
    86c6:	d018      	beq.n	86fa <_printf_i+0x106>
    86c8:	270a      	movs	r7, #10
    86ca:	e016      	b.n	86fa <_printf_i+0x106>
    86cc:	3145      	adds	r1, #69	; 0x45
    86ce:	700a      	strb	r2, [r1, #0]
    86d0:	4a54      	ldr	r2, [pc, #336]	; (8824 <_printf_i+0x230>)
    86d2:	9203      	str	r2, [sp, #12]
    86d4:	681a      	ldr	r2, [r3, #0]
    86d6:	6821      	ldr	r1, [r4, #0]
    86d8:	1d10      	adds	r0, r2, #4
    86da:	6018      	str	r0, [r3, #0]
    86dc:	6815      	ldr	r5, [r2, #0]
    86de:	0608      	lsls	r0, r1, #24
    86e0:	d522      	bpl.n	8728 <_printf_i+0x134>
    86e2:	07cb      	lsls	r3, r1, #31
    86e4:	d502      	bpl.n	86ec <_printf_i+0xf8>
    86e6:	2320      	movs	r3, #32
    86e8:	4319      	orrs	r1, r3
    86ea:	6021      	str	r1, [r4, #0]
    86ec:	2710      	movs	r7, #16
    86ee:	2d00      	cmp	r5, #0
    86f0:	d103      	bne.n	86fa <_printf_i+0x106>
    86f2:	2320      	movs	r3, #32
    86f4:	6822      	ldr	r2, [r4, #0]
    86f6:	439a      	bics	r2, r3
    86f8:	6022      	str	r2, [r4, #0]
    86fa:	0023      	movs	r3, r4
    86fc:	2200      	movs	r2, #0
    86fe:	3343      	adds	r3, #67	; 0x43
    8700:	701a      	strb	r2, [r3, #0]
    8702:	6863      	ldr	r3, [r4, #4]
    8704:	60a3      	str	r3, [r4, #8]
    8706:	2b00      	cmp	r3, #0
    8708:	db5c      	blt.n	87c4 <_printf_i+0x1d0>
    870a:	2204      	movs	r2, #4
    870c:	6821      	ldr	r1, [r4, #0]
    870e:	4391      	bics	r1, r2
    8710:	6021      	str	r1, [r4, #0]
    8712:	2d00      	cmp	r5, #0
    8714:	d158      	bne.n	87c8 <_printf_i+0x1d4>
    8716:	9e04      	ldr	r6, [sp, #16]
    8718:	2b00      	cmp	r3, #0
    871a:	d064      	beq.n	87e6 <_printf_i+0x1f2>
    871c:	0026      	movs	r6, r4
    871e:	9b03      	ldr	r3, [sp, #12]
    8720:	3642      	adds	r6, #66	; 0x42
    8722:	781b      	ldrb	r3, [r3, #0]
    8724:	7033      	strb	r3, [r6, #0]
    8726:	e05e      	b.n	87e6 <_printf_i+0x1f2>
    8728:	0648      	lsls	r0, r1, #25
    872a:	d5da      	bpl.n	86e2 <_printf_i+0xee>
    872c:	b2ad      	uxth	r5, r5
    872e:	e7d8      	b.n	86e2 <_printf_i+0xee>
    8730:	6809      	ldr	r1, [r1, #0]
    8732:	681a      	ldr	r2, [r3, #0]
    8734:	0608      	lsls	r0, r1, #24
    8736:	d505      	bpl.n	8744 <_printf_i+0x150>
    8738:	1d11      	adds	r1, r2, #4
    873a:	6019      	str	r1, [r3, #0]
    873c:	6813      	ldr	r3, [r2, #0]
    873e:	6962      	ldr	r2, [r4, #20]
    8740:	601a      	str	r2, [r3, #0]
    8742:	e006      	b.n	8752 <_printf_i+0x15e>
    8744:	0649      	lsls	r1, r1, #25
    8746:	d5f7      	bpl.n	8738 <_printf_i+0x144>
    8748:	1d11      	adds	r1, r2, #4
    874a:	6019      	str	r1, [r3, #0]
    874c:	6813      	ldr	r3, [r2, #0]
    874e:	8aa2      	ldrh	r2, [r4, #20]
    8750:	801a      	strh	r2, [r3, #0]
    8752:	2300      	movs	r3, #0
    8754:	9e04      	ldr	r6, [sp, #16]
    8756:	6123      	str	r3, [r4, #16]
    8758:	e054      	b.n	8804 <_printf_i+0x210>
    875a:	681a      	ldr	r2, [r3, #0]
    875c:	1d11      	adds	r1, r2, #4
    875e:	6019      	str	r1, [r3, #0]
    8760:	6816      	ldr	r6, [r2, #0]
    8762:	2100      	movs	r1, #0
    8764:	6862      	ldr	r2, [r4, #4]
    8766:	0030      	movs	r0, r6
    8768:	f000 f870 	bl	884c <memchr>
    876c:	2800      	cmp	r0, #0
    876e:	d001      	beq.n	8774 <_printf_i+0x180>
    8770:	1b80      	subs	r0, r0, r6
    8772:	6060      	str	r0, [r4, #4]
    8774:	6863      	ldr	r3, [r4, #4]
    8776:	6123      	str	r3, [r4, #16]
    8778:	2300      	movs	r3, #0
    877a:	9a04      	ldr	r2, [sp, #16]
    877c:	7013      	strb	r3, [r2, #0]
    877e:	e041      	b.n	8804 <_printf_i+0x210>
    8780:	6923      	ldr	r3, [r4, #16]
    8782:	0032      	movs	r2, r6
    8784:	9906      	ldr	r1, [sp, #24]
    8786:	9805      	ldr	r0, [sp, #20]
    8788:	9d07      	ldr	r5, [sp, #28]
    878a:	47a8      	blx	r5
    878c:	1c43      	adds	r3, r0, #1
    878e:	d043      	beq.n	8818 <_printf_i+0x224>
    8790:	6823      	ldr	r3, [r4, #0]
    8792:	2500      	movs	r5, #0
    8794:	079b      	lsls	r3, r3, #30
    8796:	d40f      	bmi.n	87b8 <_printf_i+0x1c4>
    8798:	9b09      	ldr	r3, [sp, #36]	; 0x24
    879a:	68e0      	ldr	r0, [r4, #12]
    879c:	4298      	cmp	r0, r3
    879e:	da3d      	bge.n	881c <_printf_i+0x228>
    87a0:	0018      	movs	r0, r3
    87a2:	e03b      	b.n	881c <_printf_i+0x228>
    87a4:	0022      	movs	r2, r4
    87a6:	2301      	movs	r3, #1
    87a8:	3219      	adds	r2, #25
    87aa:	9906      	ldr	r1, [sp, #24]
    87ac:	9805      	ldr	r0, [sp, #20]
    87ae:	9e07      	ldr	r6, [sp, #28]
    87b0:	47b0      	blx	r6
    87b2:	1c43      	adds	r3, r0, #1
    87b4:	d030      	beq.n	8818 <_printf_i+0x224>
    87b6:	3501      	adds	r5, #1
    87b8:	68e3      	ldr	r3, [r4, #12]
    87ba:	9a09      	ldr	r2, [sp, #36]	; 0x24
    87bc:	1a9b      	subs	r3, r3, r2
    87be:	429d      	cmp	r5, r3
    87c0:	dbf0      	blt.n	87a4 <_printf_i+0x1b0>
    87c2:	e7e9      	b.n	8798 <_printf_i+0x1a4>
    87c4:	2d00      	cmp	r5, #0
    87c6:	d0a9      	beq.n	871c <_printf_i+0x128>
    87c8:	9e04      	ldr	r6, [sp, #16]
    87ca:	0028      	movs	r0, r5
    87cc:	0039      	movs	r1, r7
    87ce:	f7ff fc7d 	bl	80cc <__aeabi_uidivmod>
    87d2:	9b03      	ldr	r3, [sp, #12]
    87d4:	3e01      	subs	r6, #1
    87d6:	5c5b      	ldrb	r3, [r3, r1]
    87d8:	0028      	movs	r0, r5
    87da:	7033      	strb	r3, [r6, #0]
    87dc:	0039      	movs	r1, r7
    87de:	f7ff fbef 	bl	7fc0 <__udivsi3>
    87e2:	1e05      	subs	r5, r0, #0
    87e4:	d1f1      	bne.n	87ca <_printf_i+0x1d6>
    87e6:	2f08      	cmp	r7, #8
    87e8:	d109      	bne.n	87fe <_printf_i+0x20a>
    87ea:	6823      	ldr	r3, [r4, #0]
    87ec:	07db      	lsls	r3, r3, #31
    87ee:	d506      	bpl.n	87fe <_printf_i+0x20a>
    87f0:	6863      	ldr	r3, [r4, #4]
    87f2:	6922      	ldr	r2, [r4, #16]
    87f4:	4293      	cmp	r3, r2
    87f6:	dc02      	bgt.n	87fe <_printf_i+0x20a>
    87f8:	2330      	movs	r3, #48	; 0x30
    87fa:	3e01      	subs	r6, #1
    87fc:	7033      	strb	r3, [r6, #0]
    87fe:	9b04      	ldr	r3, [sp, #16]
    8800:	1b9b      	subs	r3, r3, r6
    8802:	6123      	str	r3, [r4, #16]
    8804:	9b07      	ldr	r3, [sp, #28]
    8806:	aa09      	add	r2, sp, #36	; 0x24
    8808:	9300      	str	r3, [sp, #0]
    880a:	0021      	movs	r1, r4
    880c:	9b06      	ldr	r3, [sp, #24]
    880e:	9805      	ldr	r0, [sp, #20]
    8810:	f7ff fe82 	bl	8518 <_printf_common>
    8814:	1c43      	adds	r3, r0, #1
    8816:	d1b3      	bne.n	8780 <_printf_i+0x18c>
    8818:	2001      	movs	r0, #1
    881a:	4240      	negs	r0, r0
    881c:	b00b      	add	sp, #44	; 0x2c
    881e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    8820:	000091de 	.word	0x000091de
    8824:	000091cd 	.word	0x000091cd

00008828 <_sbrk_r>:
    8828:	2300      	movs	r3, #0
    882a:	b570      	push	{r4, r5, r6, lr}
    882c:	4c06      	ldr	r4, [pc, #24]	; (8848 <_sbrk_r+0x20>)
    882e:	0005      	movs	r5, r0
    8830:	0008      	movs	r0, r1
    8832:	6023      	str	r3, [r4, #0]
    8834:	f7fb fdaa 	bl	438c <_sbrk>
    8838:	1c43      	adds	r3, r0, #1
    883a:	d103      	bne.n	8844 <_sbrk_r+0x1c>
    883c:	6823      	ldr	r3, [r4, #0]
    883e:	2b00      	cmp	r3, #0
    8840:	d000      	beq.n	8844 <_sbrk_r+0x1c>
    8842:	602b      	str	r3, [r5, #0]
    8844:	bd70      	pop	{r4, r5, r6, pc}
    8846:	46c0      	nop			; (mov r8, r8)
    8848:	20000964 	.word	0x20000964

0000884c <memchr>:
    884c:	b2c9      	uxtb	r1, r1
    884e:	1882      	adds	r2, r0, r2
    8850:	4290      	cmp	r0, r2
    8852:	d101      	bne.n	8858 <memchr+0xc>
    8854:	2000      	movs	r0, #0
    8856:	4770      	bx	lr
    8858:	7803      	ldrb	r3, [r0, #0]
    885a:	428b      	cmp	r3, r1
    885c:	d0fb      	beq.n	8856 <memchr+0xa>
    885e:	3001      	adds	r0, #1
    8860:	e7f6      	b.n	8850 <memchr+0x4>

00008862 <memcpy>:
    8862:	2300      	movs	r3, #0
    8864:	b510      	push	{r4, lr}
    8866:	429a      	cmp	r2, r3
    8868:	d100      	bne.n	886c <memcpy+0xa>
    886a:	bd10      	pop	{r4, pc}
    886c:	5ccc      	ldrb	r4, [r1, r3]
    886e:	54c4      	strb	r4, [r0, r3]
    8870:	3301      	adds	r3, #1
    8872:	e7f8      	b.n	8866 <memcpy+0x4>

00008874 <memmove>:
    8874:	b510      	push	{r4, lr}
    8876:	4288      	cmp	r0, r1
    8878:	d902      	bls.n	8880 <memmove+0xc>
    887a:	188b      	adds	r3, r1, r2
    887c:	4298      	cmp	r0, r3
    887e:	d308      	bcc.n	8892 <memmove+0x1e>
    8880:	2300      	movs	r3, #0
    8882:	429a      	cmp	r2, r3
    8884:	d007      	beq.n	8896 <memmove+0x22>
    8886:	5ccc      	ldrb	r4, [r1, r3]
    8888:	54c4      	strb	r4, [r0, r3]
    888a:	3301      	adds	r3, #1
    888c:	e7f9      	b.n	8882 <memmove+0xe>
    888e:	5c8b      	ldrb	r3, [r1, r2]
    8890:	5483      	strb	r3, [r0, r2]
    8892:	3a01      	subs	r2, #1
    8894:	d2fb      	bcs.n	888e <memmove+0x1a>
    8896:	bd10      	pop	{r4, pc}

00008898 <__malloc_lock>:
    8898:	4770      	bx	lr

0000889a <__malloc_unlock>:
    889a:	4770      	bx	lr

0000889c <_free_r>:
    889c:	b570      	push	{r4, r5, r6, lr}
    889e:	0005      	movs	r5, r0
    88a0:	2900      	cmp	r1, #0
    88a2:	d010      	beq.n	88c6 <_free_r+0x2a>
    88a4:	1f0c      	subs	r4, r1, #4
    88a6:	6823      	ldr	r3, [r4, #0]
    88a8:	2b00      	cmp	r3, #0
    88aa:	da00      	bge.n	88ae <_free_r+0x12>
    88ac:	18e4      	adds	r4, r4, r3
    88ae:	0028      	movs	r0, r5
    88b0:	f7ff fff2 	bl	8898 <__malloc_lock>
    88b4:	4a1d      	ldr	r2, [pc, #116]	; (892c <_free_r+0x90>)
    88b6:	6813      	ldr	r3, [r2, #0]
    88b8:	2b00      	cmp	r3, #0
    88ba:	d105      	bne.n	88c8 <_free_r+0x2c>
    88bc:	6063      	str	r3, [r4, #4]
    88be:	6014      	str	r4, [r2, #0]
    88c0:	0028      	movs	r0, r5
    88c2:	f7ff ffea 	bl	889a <__malloc_unlock>
    88c6:	bd70      	pop	{r4, r5, r6, pc}
    88c8:	42a3      	cmp	r3, r4
    88ca:	d909      	bls.n	88e0 <_free_r+0x44>
    88cc:	6821      	ldr	r1, [r4, #0]
    88ce:	1860      	adds	r0, r4, r1
    88d0:	4283      	cmp	r3, r0
    88d2:	d1f3      	bne.n	88bc <_free_r+0x20>
    88d4:	6818      	ldr	r0, [r3, #0]
    88d6:	685b      	ldr	r3, [r3, #4]
    88d8:	1841      	adds	r1, r0, r1
    88da:	6021      	str	r1, [r4, #0]
    88dc:	e7ee      	b.n	88bc <_free_r+0x20>
    88de:	0013      	movs	r3, r2
    88e0:	685a      	ldr	r2, [r3, #4]
    88e2:	2a00      	cmp	r2, #0
    88e4:	d001      	beq.n	88ea <_free_r+0x4e>
    88e6:	42a2      	cmp	r2, r4
    88e8:	d9f9      	bls.n	88de <_free_r+0x42>
    88ea:	6819      	ldr	r1, [r3, #0]
    88ec:	1858      	adds	r0, r3, r1
    88ee:	42a0      	cmp	r0, r4
    88f0:	d10b      	bne.n	890a <_free_r+0x6e>
    88f2:	6820      	ldr	r0, [r4, #0]
    88f4:	1809      	adds	r1, r1, r0
    88f6:	1858      	adds	r0, r3, r1
    88f8:	6019      	str	r1, [r3, #0]
    88fa:	4282      	cmp	r2, r0
    88fc:	d1e0      	bne.n	88c0 <_free_r+0x24>
    88fe:	6810      	ldr	r0, [r2, #0]
    8900:	6852      	ldr	r2, [r2, #4]
    8902:	1841      	adds	r1, r0, r1
    8904:	6019      	str	r1, [r3, #0]
    8906:	605a      	str	r2, [r3, #4]
    8908:	e7da      	b.n	88c0 <_free_r+0x24>
    890a:	42a0      	cmp	r0, r4
    890c:	d902      	bls.n	8914 <_free_r+0x78>
    890e:	230c      	movs	r3, #12
    8910:	602b      	str	r3, [r5, #0]
    8912:	e7d5      	b.n	88c0 <_free_r+0x24>
    8914:	6821      	ldr	r1, [r4, #0]
    8916:	1860      	adds	r0, r4, r1
    8918:	4282      	cmp	r2, r0
    891a:	d103      	bne.n	8924 <_free_r+0x88>
    891c:	6810      	ldr	r0, [r2, #0]
    891e:	6852      	ldr	r2, [r2, #4]
    8920:	1841      	adds	r1, r0, r1
    8922:	6021      	str	r1, [r4, #0]
    8924:	6062      	str	r2, [r4, #4]
    8926:	605c      	str	r4, [r3, #4]
    8928:	e7ca      	b.n	88c0 <_free_r+0x24>
    892a:	46c0      	nop			; (mov r8, r8)
    892c:	200007f8 	.word	0x200007f8

00008930 <_realloc_r>:
    8930:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    8932:	0007      	movs	r7, r0
    8934:	000d      	movs	r5, r1
    8936:	0016      	movs	r6, r2
    8938:	2900      	cmp	r1, #0
    893a:	d105      	bne.n	8948 <_realloc_r+0x18>
    893c:	0011      	movs	r1, r2
    893e:	f7ff fc27 	bl	8190 <_malloc_r>
    8942:	0004      	movs	r4, r0
    8944:	0020      	movs	r0, r4
    8946:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    8948:	2a00      	cmp	r2, #0
    894a:	d103      	bne.n	8954 <_realloc_r+0x24>
    894c:	f7ff ffa6 	bl	889c <_free_r>
    8950:	0034      	movs	r4, r6
    8952:	e7f7      	b.n	8944 <_realloc_r+0x14>
    8954:	f000 f812 	bl	897c <_malloc_usable_size_r>
    8958:	002c      	movs	r4, r5
    895a:	4286      	cmp	r6, r0
    895c:	d9f2      	bls.n	8944 <_realloc_r+0x14>
    895e:	0031      	movs	r1, r6
    8960:	0038      	movs	r0, r7
    8962:	f7ff fc15 	bl	8190 <_malloc_r>
    8966:	1e04      	subs	r4, r0, #0
    8968:	d0ec      	beq.n	8944 <_realloc_r+0x14>
    896a:	0029      	movs	r1, r5
    896c:	0032      	movs	r2, r6
    896e:	f7ff ff78 	bl	8862 <memcpy>
    8972:	0029      	movs	r1, r5
    8974:	0038      	movs	r0, r7
    8976:	f7ff ff91 	bl	889c <_free_r>
    897a:	e7e3      	b.n	8944 <_realloc_r+0x14>

0000897c <_malloc_usable_size_r>:
    897c:	1f0b      	subs	r3, r1, #4
    897e:	681b      	ldr	r3, [r3, #0]
    8980:	1f18      	subs	r0, r3, #4
    8982:	2b00      	cmp	r3, #0
    8984:	da01      	bge.n	898a <_malloc_usable_size_r+0xe>
    8986:	580b      	ldr	r3, [r1, r0]
    8988:	18c0      	adds	r0, r0, r3
    898a:	4770      	bx	lr

0000898c <u8g2_font_Terminal_tr>:
    898c:	005f 0303 0404 0401 0c05 000c 09fe 09fe     _...............
    899c:	0100 036d 0402 2077 0005 02b1 0c21 b194     ..m...w ....!...
    89ac:	7246 4838 22c4 0009 0722 dd35 c242 2322     Fr8H."..".5.B."#
    89bc:	9b17 4391 32a4 8491 a12e 48c9 9222 248a     ...C.2.....H"..$
    89cc:	9076 241c 0107 0f24 efb6 464a b111 254e     v..$..$...JF..N%
    89dc:	9222 2684 2502 b813 272f a11c c485 b152     "..&.%../'....R.
    89ec:	2c54 8595 e12a 0008 0d26 b16c 1887 74d2     T,..*...&.l....t
    89fc:	8b38 11b4 2707 3206 c27d 2800 9409 4ab1     8....'.2}..(...J
    8a0c:	a4a2 029b 0a29 b194 a642 8ba4 0012 072a     ....)...B.....*.
    8a1c:	9d33 9222 2b03 560a 4af7 3228 4509 2c00     3."..+.V.J(2.E.,
    8a2c:	3407 66af 0252 062d fb16 00c2 062e 9123     .4.fR.-.......#.
    8a3c:	00c2 0c2f d185 494e 9226 6489 0032 0f30     ../...NI&..d2.0.
    8a4c:	1197 22a7 5523 112c 894b a926 3100 9609     ..."#U,.K.&..1..
    8a5c:	2ef1 d444 0327 0c32 f196 2286 0922 3a65     ..D.'.2...."".e:
    8a6c:	021d 0e33 f196 2286 2a12 854d 0924 0005     ..3....".*M.$...
    8a7c:	0e34 1197 3853 4923 2494 a947 0090 0d35     4...S8#I.$G...5.
    8a8c:	f196 10e2 ac54 490a 0a12 3600 960d 4af1     ....T..I...6...J
    8a9c:	28a6 88ac 2498 0014 0c37 1197 20e3 49a3     .(...$..7.... .I
    8aac:	5a85 00d5 0e38 f196 2286 9262 4450 124c     .Z..8...."b.PDL.
    8abc:	000a 0e39 f196 2286 9262 84d4 d932 0008     ..9...."b...2...
    8acc:	063a 9163 6cc2 093b af74 1d66 2934 3c01     :.c..l;.t.f.4).<
    8adc:	7409 2eb1 5124 0b53 073d f546 0ec2 3e35     .t..$QS.=.F...5>
    8aec:	7409 22b1 45a6 0629 0e3f f196 2286 ca12     .t.".E).?...."..
    8afc:	e514 a130 0008 0e40 b16c 1887 c916 260e     ..0...@.l......&
    8b0c:	4dbd 0344 0c41 f196 464a 3111 461d 024c     .MD.A...JF.1.FL.
    8b1c:	1142 1197 a4c3 9222 2488 1525 4491 8874     B....."..$%..Dt.
    8b2c:	4300 970e 8b11 a224 b551 4449 0a22 4400     .C....$.Q.ID"..D
    8b3c:	9713 c311 22a4 8892 2224 4889 9222 0e88     ....."..$".H"...
    8b4c:	0011 1245 1197 22e3 c892 9222 4d18 9312     ..E....".."..M..
    8b5c:	4445 0107 1146 1197 22e3 c892 9222 4d18     ED..F....".."..M
    8b6c:	9312 690a 4700 970e 8b11 a224 9551 126a     ...i.G....$.Q.j.
    8b7c:	a891 4800 960a 42f1 e9c4 e230 4924 9409     ...H...B..0.$I..
    8b8c:	82b1 d222 0217 0f4a 1197 288f 22d5 8892     .."...J....(."..
    8b9c:	2224 0911 4b00 9712 6311 1124 9449 2224     $"...K...c$.I.$"
    8bac:	449a 1124 4a89 4c02 970b 8311 d528 445b     .D$..J.L....(.[D
    8bbc:	1074 0d4d 1197 5643 1c39 112a 371a 4e01     t.M...CV9.*..7.N
    8bcc:	970d 4311 2b46 2859 1aa6 009b 0c4f 1197     ...CF+Y(....O...
    8bdc:	266b e351 a24d 0236 0f50 1197 a4c3 9222     k&Q.M.6.P.....".
    8bec:	2488 a925 0d22 5100 b70d 6b0d 5126 69e3     .$%."..Q...k&Q.i
    8bfc:	a352 090a 1052 1197 a4c3 9222 2488 8925     R...R....."..$%.
    8c0c:	4548 1254 0e53 f196 2286 9d62 444a 0924     HET.S...."b.JD$.
    8c1c:	0005 0b54 f196 22e2 0909 46f5 5501 960a     ..T...."...F.U..
    8c2c:	42f1 9fc4 1424 5600 960b 42f1 4fc4 9a12     .B..$..V...B.O..
    8c3c:	0008 0f57 1197 c643 844b d112 1124 2449     ..W...C.K...$.I$
    8c4c:	5800 970d 4311 26c6 9b51 d449 04d8 0c59     .X...C.&Q.I...Y.
    8c5c:	f196 c442 4249 aa13 0051 0e5a 1197 20e3     ..B.IB..Q.Z.... 
    8c6c:	4922 aa85 d9b2 0041 085b b194 a4c2 044f     "I....A.[.....O.
    8c7c:	0c5c d185 2642 0994 4265 0099 085d b194     \...B&..eB..]...
    8c8c:	a482 064f 095e 1b47 3a2f a893 5f09 1606     ..O.^.G./:..._..
    8c9c:	c2ed 6000 3206 c27d 6100 670d 8711 aa2c     ...`.2}..a.g..,.
    8cac:	2488 d122 0044 0f62 1197 aa63 525a 4911     .$".D.b...c.ZR.I
    8cbc:	1244 6511 6302 660b 86f1 2222 492a 0028     D..e.c.f..""*I(.
    8ccc:	1064 1197 aa6f 1154 4449 9112 2444 089a     d...o.T.ID..D$..
    8cdc:	0c65 f166 2286 0c3a 1245 000a 0d66 f196     e.f..":.E...f...
    8cec:	246a 9451 8495 246a 6700 8710 670d 9242     j$Q...j$.g...gB.
    8cfc:	2488 5122 2255 9112 6800 970f 6311 45aa     .$"QU"...h...c.E
    8d0c:	5134 8892 a224 0092 0969 b194 2446 e91d     4Q..$...i...F$..
    8d1c:	6a42 b60d 52ed 341d 48d4 4922 0028 0f6b     Bj...R.4.H"I(.k.
    8d2c:	1197 aa63 5124 49a2 2a44 92a2 6c00 9408     ..c.$Q.ID*...l..
    8d3c:	62b1 5fa4 6d08 670e c311 8922 2250 0894     .b._.m.g..".P"..
    8d4c:	4225 6e13 6609 a2f1 e222 0049 0a6f f166     %B.n.f..".I.o.f.
    8d5c:	2286 24e2 00a1 1070 0d87 3243 1152 4449     .".$..p...C2R.ID
    8d6c:	9112 24a4 01a4 0f71 0d87 4267 8892 2224     ...$..q...gB..$"
    8d7c:	4889 1554 7212 670c 6311 9222 a8ac 690a     .HT..r.g.c"....i
    8d8c:	7300 660d 86f1 9222 2588 0922 0005 0c74     .s.f.."..%"...t.
    8d9c:	f186 282a 08b3 88b5 0026 0f75 1167 2443     ..*(....&.u.g.C$
    8dac:	4911 1244 4491 9a24 7608 660a 42f1 49c4     .ID..D$..v.f.B.I
    8dbc:	1342 7701 670d 4311 12c6 44a1 4934 0024     B..w.g.C...D4I$.
    8dcc:	0c78 1167 2643 1b51 24ce 026a 0f79 0d87     x.g.C&Q..$j.y...
    8ddc:	2447 4911 1244 a891 44a8 7a03 6609 e2f1     G$.ID....D.z.f..
    8dec:	24a6 1d93 0b7b d195 a44e 1226 84ca 7c0a     .$..{...N.&....|
    8dfc:	9207 e271 0081 0c7d d195 a842 1426 44c9     ..q...}...B.&..D
    8e0c:	006a 0a7e 3738 4467 9091 0026 0000 0400     j.~.87gD..&.....
    8e1c:	ffff 0000                                   ....

00008e20 <u8g2_cb_r0>:
    8e20:	2443 0000 245b 0000 249f 0000 2764 0000     C$..[$...$..d'..
    8e30:	2740 0000 2752 0000 2764 0000 2764 0000     @'..R'..d'..d'..
    8e40:	2764 0000                                   d'..

00008e44 <u8x8_gp1287ai_display_info>:
    8e44:	0100 78f0 0101 783c 0900 003d 0403 783c     ...x..<x..=...<x
    8e54:	0720 0000 0100 0032                          .....2.

00008e5c <u8x8_d_gp1287ai_init_seq>:
    8e5c:	1518 1955 01fe 1518 161e 1910 1518 1633     ..U...........3.
    8e6c:	1640 1900 1518 1607 16ff 168c 1600 1604     @...............
    8e7c:	1600 1600 1901 1518 168d 1604 16fc 1600     ................
    8e8c:	1980 1518 1605 1600 1914 1518 19aa 0ffe     ................
    8e9c:	1518 1603 1600 1920 1518 160b 1600 193c     ...... .......<.
    8eac:	1518 1609 1900 1518 1610 1900 1518 1601     ................
    8ebc:	1900 1518 1986 00ff                         ........

00008ec4 <u8x8_d_gp1287ai_standby_seq>:
    8ec4:	1518 1986 00ff 0000                         ........

00008ecc <u8x8_d_gp1287ai_wakeup_seq>:
    8ecc:	1518 19b6 01fe 1518 1601 1900 00ff 0000     ................
    8edc:	2e2e 682f 6c70 702f 726f 2f74 7068 5f6c     ../hpl/port/hpl_
    8eec:	7067 6f69 625f 7361 2e65 0068 2e2e 682f     gpio_base.h.../h
    8efc:	6c70 702f 2f6d 7068 5f6c 6d70 625f 7361     pl/pm/hpl_pm_bas
    8f0c:	2e65 0068 2e2e 682f 6c61 732f 6372 682f     e.h.../hal/src/h
    8f1c:	6c61 695f 6332 6d5f 735f 6e79 2e63 0063     al_i2c_m_sync.c.
    8f2c:	2e2e 682f 6c61 732f 6372 682f 6c61 695f     ../hal/src/hal_i
    8f3c:	2e6f 0063 2e2e 682f 6c61 732f 6372 682f     o.c.../hal/src/h
    8f4c:	6c61 735f 6970 6d5f 735f 6e79 2e63 0063     al_spi_m_sync.c.
    8f5c:	2e2e 682f 6c61 732f 6372 682f 6c61 755f     ../hal/src/hal_u
    8f6c:	6173 7472 735f 6e79 2e63 0063 4460 0000     sart_sync.c.`D..
    8f7c:	443e 0000 4428 0000 440a 0000 43f2 0000     >D..(D...D...C..

00008f8c <_map>:
    8f8c:	0001 0000 0021 0000 000a 0000 000a 0000     ....!...........
    8f9c:	000e 0000 003e 0000 2e2e 682f 6c70 652f     ....>...../hpl/e
    8fac:	6369 682f 6c70 655f 6369 632e 0000 0000     ic/hpl_eic.c....
    8fbc:	2e2e 682f 6c70 732f 7265 6f63 2f6d 7068     ../hpl/sercom/hp
    8fcc:	5f6c 6573 6372 6d6f 632e 0000               l_sercom.c..

00008fd8 <sercomspi_regs>:
    8fd8:	000c 0020 0000 0002 0000 0000 0017 0000     .. .............
    8fe8:	000c 0020 0000 0002 0000 0000 00fe 0100     .. .............
    8ff8:	2e2e 682f 6c70 702f 726f 2f74 7068 5f6c     ../hpl/port/hpl_
    9008:	7067 6f69 625f 7361 2e65 0068 2e2e 682f     gpio_base.h.../h
    9018:	6c70 702f 2f6d 7068 5f6c 6d70 625f 7361     pl/pm/hpl_pm_bas
    9028:	2e65 0068 71a8 0000 71d2 0000 71d2 0000     e.h..q...q...q..
    9038:	7194 0000 71c2 0000 71ca 0000 71d2 0000     .q...q...q...q..
    9048:	71d2 0000 71d2 0000 71d2 0000 71d2 0000     .q...q...q...q..
    9058:	71d2 0000 71b0 0000 76c0 0000 769e 0000     .q...q...v...v..
    9068:	767c 0000 764c 0000 761c 0000 5441 454d     |v..Lv...v..ATME
    9078:	204c 4153 444d 3032 2820 3834 484d 297a     L SAMD20 (48MHz)
    9088:	0000 0000 4e49 3a54 3025 6434 203b 5352     ....INT:%04d; RS
    9098:	4953 203a 3025 6434 203b 6974 3a6d 3025     SI: %04d; tim:%0
    90a8:	6433 253a 3230 3a64 3025 6432 203b 3025     3d:%02d:%02d; %0
    90b8:	6431 0020 3025 6433 253a 3230 3a64 3025     1d .%03d:%02d:%0
    90c8:	6432 7420 7365 5f74 3b20 2520 3130 6430     2d test_ ; %010d
    90d8:	0000 0000 3025 6432 252f 3230 2f64 3025     ....%02d/%02d/%0
    90e8:	6432 252f 3230 2f64 3025 6432 2020 2020     2d/%02d/%02d    
    90f8:	0000 0000 2020 2020 2020 2020 2020 2020     ....            
    9108:	2020 2020 2020 2020 0d0a 0000 5aa5 0000             .....Z..
    9118:	0180 0000 0000 0000 0000 0000 0000 0000     ................
    9128:	0000 ff00 aa00 aaaa 00aa 0000 0fa2 0f0f     ................
    9138:	0f0f 0f0f 0f0f 0f0f 0f0f 0f0f 000f 0000     ................
    9148:	00ab 0019 00ae 0019 40b1 0000 0102 0000     .........@......
    9158:	0206 0000                                   ....

0000915c <__sf_fake_stderr>:
	...

0000917c <__sf_fake_stdin>:
	...

0000919c <__sf_fake_stdout>:
	...
    91bc:	2d23 2b30 0020 6c68 004c 6665 4567 4746     #-0+ .hlL.efgEFG
    91cc:	3000 3231 3433 3635 3837 4139 4342 4544     .0123456789ABCDE
    91dc:	0046 3130 3332 3534 3736 3938 6261 6463     F.0123456789abcd
    91ec:	6665 0000                                   ef..

000091f0 <_init>:
    91f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    91f2:	46c0      	nop			; (mov r8, r8)
    91f4:	bcf8      	pop	{r3, r4, r5, r6, r7}
    91f6:	bc08      	pop	{r3}
    91f8:	469e      	mov	lr, r3
    91fa:	4770      	bx	lr

000091fc <__init_array_start>:
    91fc:	000000cd 	.word	0x000000cd

00009200 <_fini>:
    9200:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    9202:	46c0      	nop			; (mov r8, r8)
    9204:	bcf8      	pop	{r3, r4, r5, r6, r7}
    9206:	bc08      	pop	{r3}
    9208:	469e      	mov	lr, r3
    920a:	4770      	bx	lr

0000920c <__fini_array_start>:
    920c:	000000a5 	.word	0x000000a5
