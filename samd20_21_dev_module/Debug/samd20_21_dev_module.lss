
samd20_21_dev_module.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00008d38  00000000  00000000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     00000090  20000000  00008d38  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000008a8  20000090  00008dc8  00020090  2**2
                  ALLOC
  3 .stack        00002000  20000938  00009670  00020090  2**0
                  ALLOC
  4 .ARM.attributes 00000028  00000000  00000000  00020090  2**0
                  CONTENTS, READONLY
  5 .comment      00000059  00000000  00000000  000200b8  2**0
                  CONTENTS, READONLY
  6 .debug_info   000bb1ce  00000000  00000000  00020111  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00004b28  00000000  00000000  000db2df  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    00018fd0  00000000  00000000  000dfe07  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_aranges 00003d40  00000000  00000000  000f8dd7  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00003ac0  00000000  00000000  000fcb17  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_macro  00014eec  00000000  00000000  001005d7  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   0001a416  00000000  00000000  001154c3  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    00076451  00000000  00000000  0012f8d9  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  0000ecb0  00000000  00000000  001a5d2c  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <exception_table>:
       0:	38 29 00 20 fd 2e 00 00 89 2f 00 00 89 2f 00 00     8). ...../.../..
	...
      2c:	89 2f 00 00 00 00 00 00 00 00 00 00 89 2f 00 00     ./.........../..
      3c:	89 2f 00 00 89 2f 00 00 89 2f 00 00 89 2f 00 00     ./.../.../.../..
      4c:	89 2f 00 00 b9 48 00 00 89 2f 00 00 89 2f 00 00     ./...H.../.../..
      5c:	89 2f 00 00 89 2f 00 00 89 2f 00 00 89 2f 00 00     ./.../.../.../..
      6c:	89 2f 00 00 89 2f 00 00 89 2f 00 00 89 2f 00 00     ./.../.../.../..
      7c:	89 2f 00 00 89 2f 00 00 89 2f 00 00 89 2f 00 00     ./.../.../.../..
      8c:	89 2f 00 00 89 2f 00 00 89 2f 00 00 89 2f 00 00     ./.../.../.../..
      9c:	89 2f 00 00 89 2f 00 00                             ./.../..

000000a4 <__do_global_dtors_aux>:
      a4:	b510      	push	{r4, lr}
      a6:	4c06      	ldr	r4, [pc, #24]	; (c0 <__do_global_dtors_aux+0x1c>)
      a8:	7823      	ldrb	r3, [r4, #0]
      aa:	2b00      	cmp	r3, #0
      ac:	d107      	bne.n	be <__do_global_dtors_aux+0x1a>
      ae:	4b05      	ldr	r3, [pc, #20]	; (c4 <__do_global_dtors_aux+0x20>)
      b0:	2b00      	cmp	r3, #0
      b2:	d002      	beq.n	ba <__do_global_dtors_aux+0x16>
      b4:	4804      	ldr	r0, [pc, #16]	; (c8 <__do_global_dtors_aux+0x24>)
      b6:	e000      	b.n	ba <__do_global_dtors_aux+0x16>
      b8:	bf00      	nop
      ba:	2301      	movs	r3, #1
      bc:	7023      	strb	r3, [r4, #0]
      be:	bd10      	pop	{r4, pc}
      c0:	20000090 	.word	0x20000090
      c4:	00000000 	.word	0x00000000
      c8:	00008d38 	.word	0x00008d38

000000cc <frame_dummy>:
      cc:	4b08      	ldr	r3, [pc, #32]	; (f0 <frame_dummy+0x24>)
      ce:	b510      	push	{r4, lr}
      d0:	2b00      	cmp	r3, #0
      d2:	d003      	beq.n	dc <frame_dummy+0x10>
      d4:	4907      	ldr	r1, [pc, #28]	; (f4 <frame_dummy+0x28>)
      d6:	4808      	ldr	r0, [pc, #32]	; (f8 <frame_dummy+0x2c>)
      d8:	e000      	b.n	dc <frame_dummy+0x10>
      da:	bf00      	nop
      dc:	4807      	ldr	r0, [pc, #28]	; (fc <frame_dummy+0x30>)
      de:	6803      	ldr	r3, [r0, #0]
      e0:	2b00      	cmp	r3, #0
      e2:	d100      	bne.n	e6 <frame_dummy+0x1a>
      e4:	bd10      	pop	{r4, pc}
      e6:	4b06      	ldr	r3, [pc, #24]	; (100 <frame_dummy+0x34>)
      e8:	2b00      	cmp	r3, #0
      ea:	d0fb      	beq.n	e4 <frame_dummy+0x18>
      ec:	4798      	blx	r3
      ee:	e7f9      	b.n	e4 <frame_dummy+0x18>
      f0:	00000000 	.word	0x00000000
      f4:	20000094 	.word	0x20000094
      f8:	00008d38 	.word	0x00008d38
      fc:	00008d38 	.word	0x00008d38
     100:	00000000 	.word	0x00000000

00000104 <atmel_start_init>:

/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
     104:	b580      	push	{r7, lr}
     106:	af00      	add	r7, sp, #0
	system_init();
     108:	f003 fc08 	bl	391c <system_init>
}
     10c:	46c0      	nop			; (mov r8, r8)
     10e:	46bd      	mov	sp, r7
     110:	bd80      	pop	{r7, pc}

00000112 <u8g2_DrawRFrame>:
  xr -= r;
  xr -= 1;
  
  yl = y;
  yl += h;
  yl -= r; 
     112:	b5b0      	push	{r4, r5, r7, lr}
  yl -= 1;
     114:	b08a      	sub	sp, #40	; 0x28
     116:	af02      	add	r7, sp, #8
     118:	60f8      	str	r0, [r7, #12]
     11a:	000c      	movs	r4, r1
     11c:	0010      	movs	r0, r2
     11e:	0019      	movs	r1, r3
     120:	230a      	movs	r3, #10

  u8g2_DrawDisc(u8g2, xl, yu, r, U8G2_DRAW_UPPER_LEFT);
     122:	18fb      	adds	r3, r7, r3
     124:	1c22      	adds	r2, r4, #0
     126:	801a      	strh	r2, [r3, #0]
     128:	2308      	movs	r3, #8
     12a:	18fb      	adds	r3, r7, r3
     12c:	1c02      	adds	r2, r0, #0
     12e:	801a      	strh	r2, [r3, #0]
     130:	1dbb      	adds	r3, r7, #6
     132:	1c0a      	adds	r2, r1, #0
     134:	801a      	strh	r2, [r3, #0]
     136:	230a      	movs	r3, #10
     138:	18fa      	adds	r2, r7, r3
     13a:	1dbb      	adds	r3, r7, #6
     13c:	8812      	ldrh	r2, [r2, #0]
     13e:	881b      	ldrh	r3, [r3, #0]
  u8g2_DrawDisc(u8g2, xr, yu, r, U8G2_DRAW_UPPER_RIGHT);
     140:	18d3      	adds	r3, r2, r3
     142:	b29d      	uxth	r5, r3
     144:	2308      	movs	r3, #8
     146:	18fb      	adds	r3, r7, r3
     148:	2230      	movs	r2, #48	; 0x30
     14a:	18b9      	adds	r1, r7, r2
     14c:	881a      	ldrh	r2, [r3, #0]
     14e:	880b      	ldrh	r3, [r1, #0]
     150:	18d3      	adds	r3, r2, r3
     152:	b29b      	uxth	r3, r3
     154:	2208      	movs	r2, #8
     156:	18ba      	adds	r2, r7, r2
     158:	8814      	ldrh	r4, [r2, #0]
     15a:	220a      	movs	r2, #10
     15c:	18ba      	adds	r2, r7, r2
  u8g2_DrawDisc(u8g2, xl, yl, r, U8G2_DRAW_LOWER_LEFT);
     15e:	8811      	ldrh	r1, [r2, #0]
     160:	68f8      	ldr	r0, [r7, #12]
     162:	9300      	str	r3, [sp, #0]
     164:	002b      	movs	r3, r5
     166:	0022      	movs	r2, r4
     168:	f001 fdbd 	bl	1ce6 <u8g2_IsIntersection>
     16c:	1e03      	subs	r3, r0, #0
     16e:	d100      	bne.n	172 <u8g2_DrawRFrame+0x60>
     170:	e13f      	b.n	3f2 <u8g2_DrawRFrame+0x2e0>
     172:	231e      	movs	r3, #30
     174:	18fb      	adds	r3, r7, r3
     176:	220a      	movs	r2, #10
     178:	18ba      	adds	r2, r7, r2
     17a:	8812      	ldrh	r2, [r2, #0]
  u8g2_DrawDisc(u8g2, xr, yl, r, U8G2_DRAW_LOWER_RIGHT);
     17c:	801a      	strh	r2, [r3, #0]
     17e:	231e      	movs	r3, #30
     180:	18fb      	adds	r3, r7, r3
     182:	221e      	movs	r2, #30
     184:	18b9      	adds	r1, r7, r2
     186:	2234      	movs	r2, #52	; 0x34
     188:	18ba      	adds	r2, r7, r2
     18a:	8809      	ldrh	r1, [r1, #0]
     18c:	8812      	ldrh	r2, [r2, #0]
     18e:	188a      	adds	r2, r1, r2
     190:	801a      	strh	r2, [r3, #0]
     192:	231c      	movs	r3, #28
     194:	18fb      	adds	r3, r7, r3
     196:	2208      	movs	r2, #8
     198:	18ba      	adds	r2, r7, r2

  {
    u8g2_uint_t ww, hh;

    ww = w;
     19a:	8812      	ldrh	r2, [r2, #0]
     19c:	801a      	strh	r2, [r3, #0]
     19e:	231c      	movs	r3, #28
     1a0:	18fb      	adds	r3, r7, r3
     1a2:	221c      	movs	r2, #28
    ww -= r;
     1a4:	18b9      	adds	r1, r7, r2
     1a6:	2234      	movs	r2, #52	; 0x34
     1a8:	18ba      	adds	r2, r7, r2
     1aa:	8809      	ldrh	r1, [r1, #0]
     1ac:	8812      	ldrh	r2, [r2, #0]
     1ae:	188a      	adds	r2, r1, r2
     1b0:	801a      	strh	r2, [r3, #0]
     1b2:	231a      	movs	r3, #26
     1b4:	18fb      	adds	r3, r7, r3
     1b6:	220a      	movs	r2, #10
    ww -= r;
     1b8:	18ba      	adds	r2, r7, r2
     1ba:	8812      	ldrh	r2, [r2, #0]
     1bc:	801a      	strh	r2, [r3, #0]
     1be:	231a      	movs	r3, #26
     1c0:	18fb      	adds	r3, r7, r3
     1c2:	221a      	movs	r2, #26
     1c4:	18b9      	adds	r1, r7, r2
     1c6:	1dba      	adds	r2, r7, #6
     1c8:	8809      	ldrh	r1, [r1, #0]
     1ca:	8812      	ldrh	r2, [r2, #0]
    xl++;
     1cc:	188a      	adds	r2, r1, r2
     1ce:	801a      	strh	r2, [r3, #0]
     1d0:	231a      	movs	r3, #26
     1d2:	18fb      	adds	r3, r7, r3
     1d4:	221a      	movs	r2, #26
     1d6:	18b9      	adds	r1, r7, r2
     1d8:	2234      	movs	r2, #52	; 0x34
    yu++;
     1da:	18ba      	adds	r2, r7, r2
     1dc:	8809      	ldrh	r1, [r1, #0]
     1de:	8812      	ldrh	r2, [r2, #0]
     1e0:	1a8a      	subs	r2, r1, r2
     1e2:	801a      	strh	r2, [r3, #0]
     1e4:	231a      	movs	r3, #26
     1e6:	18fb      	adds	r3, r7, r3
    
    if ( ww >= 3 )
     1e8:	221a      	movs	r2, #26
     1ea:	18ba      	adds	r2, r7, r2
     1ec:	8812      	ldrh	r2, [r2, #0]
     1ee:	3a01      	subs	r2, #1
     1f0:	801a      	strh	r2, [r3, #0]
    {
      ww -= 2;
     1f2:	2318      	movs	r3, #24
     1f4:	18fb      	adds	r3, r7, r3
     1f6:	2208      	movs	r2, #8
     1f8:	18ba      	adds	r2, r7, r2
     1fa:	8812      	ldrh	r2, [r2, #0]
     1fc:	801a      	strh	r2, [r3, #0]
     1fe:	2318      	movs	r3, #24
      u8g2_DrawBox(u8g2, xl, y, ww, r+1);
     200:	18fb      	adds	r3, r7, r3
     202:	2218      	movs	r2, #24
     204:	18ba      	adds	r2, r7, r2
     206:	2130      	movs	r1, #48	; 0x30
     208:	1878      	adds	r0, r7, r1
     20a:	8811      	ldrh	r1, [r2, #0]
     20c:	8802      	ldrh	r2, [r0, #0]
     20e:	188a      	adds	r2, r1, r2
     210:	801a      	strh	r2, [r3, #0]
     212:	2318      	movs	r3, #24
     214:	18fb      	adds	r3, r7, r3
     216:	2218      	movs	r2, #24
     218:	18b9      	adds	r1, r7, r2
     21a:	2234      	movs	r2, #52	; 0x34
     21c:	18ba      	adds	r2, r7, r2
     21e:	8809      	ldrh	r1, [r1, #0]
     220:	8812      	ldrh	r2, [r2, #0]
     222:	1a8a      	subs	r2, r1, r2
     224:	801a      	strh	r2, [r3, #0]
     226:	2318      	movs	r3, #24
      u8g2_DrawBox(u8g2, xl, yl, ww, r+1);
     228:	18fb      	adds	r3, r7, r3
     22a:	2218      	movs	r2, #24
     22c:	18ba      	adds	r2, r7, r2
     22e:	8812      	ldrh	r2, [r2, #0]
     230:	3a01      	subs	r2, #1
     232:	801a      	strh	r2, [r3, #0]
     234:	2334      	movs	r3, #52	; 0x34
     236:	18fb      	adds	r3, r7, r3
     238:	881c      	ldrh	r4, [r3, #0]
     23a:	231c      	movs	r3, #28
     23c:	18fb      	adds	r3, r7, r3
     23e:	881a      	ldrh	r2, [r3, #0]
     240:	231e      	movs	r3, #30
     242:	18fb      	adds	r3, r7, r3
     244:	8819      	ldrh	r1, [r3, #0]
     246:	68f8      	ldr	r0, [r7, #12]
     248:	2302      	movs	r3, #2
     24a:	9300      	str	r3, [sp, #0]
     24c:	0023      	movs	r3, r4
     24e:	f000 fb03 	bl	858 <u8g2_DrawCircle>
    }
    
    hh = h;
     252:	2334      	movs	r3, #52	; 0x34
     254:	18fb      	adds	r3, r7, r3
     256:	881c      	ldrh	r4, [r3, #0]
     258:	231c      	movs	r3, #28
     25a:	18fb      	adds	r3, r7, r3
    hh -= r;
     25c:	881a      	ldrh	r2, [r3, #0]
     25e:	231a      	movs	r3, #26
     260:	18fb      	adds	r3, r7, r3
     262:	8819      	ldrh	r1, [r3, #0]
     264:	68f8      	ldr	r0, [r7, #12]
     266:	2301      	movs	r3, #1
     268:	9300      	str	r3, [sp, #0]
     26a:	0023      	movs	r3, r4
     26c:	f000 faf4 	bl	858 <u8g2_DrawCircle>
    hh -= r;
     270:	2334      	movs	r3, #52	; 0x34
     272:	18fb      	adds	r3, r7, r3
     274:	881c      	ldrh	r4, [r3, #0]
     276:	2318      	movs	r3, #24
     278:	18fb      	adds	r3, r7, r3
     27a:	881a      	ldrh	r2, [r3, #0]
     27c:	231e      	movs	r3, #30
     27e:	18fb      	adds	r3, r7, r3
     280:	8819      	ldrh	r1, [r3, #0]
     282:	68f8      	ldr	r0, [r7, #12]
    //h--;
    if ( hh >= 3 )
     284:	2304      	movs	r3, #4
     286:	9300      	str	r3, [sp, #0]
     288:	0023      	movs	r3, r4
     28a:	f000 fae5 	bl	858 <u8g2_DrawCircle>
    {
      hh -= 2;
     28e:	2334      	movs	r3, #52	; 0x34
     290:	18fb      	adds	r3, r7, r3
     292:	881c      	ldrh	r4, [r3, #0]
     294:	2318      	movs	r3, #24
     296:	18fb      	adds	r3, r7, r3
     298:	881a      	ldrh	r2, [r3, #0]
     29a:	231a      	movs	r3, #26
      u8g2_DrawBox(u8g2, x, yu, w, hh);
     29c:	18fb      	adds	r3, r7, r3
     29e:	8819      	ldrh	r1, [r3, #0]
     2a0:	68f8      	ldr	r0, [r7, #12]
     2a2:	2308      	movs	r3, #8
     2a4:	9300      	str	r3, [sp, #0]
     2a6:	0023      	movs	r3, r4
     2a8:	f000 fad6 	bl	858 <u8g2_DrawCircle>
     2ac:	2316      	movs	r3, #22
     2ae:	18fb      	adds	r3, r7, r3
     2b0:	1dba      	adds	r2, r7, #6
     2b2:	8812      	ldrh	r2, [r2, #0]
     2b4:	801a      	strh	r2, [r3, #0]
     2b6:	2316      	movs	r3, #22
     2b8:	18fb      	adds	r3, r7, r3
     2ba:	2216      	movs	r2, #22
     2bc:	18b9      	adds	r1, r7, r2
    return;
     2be:	2234      	movs	r2, #52	; 0x34
    }
  }
}
     2c0:	18ba      	adds	r2, r7, r2
     2c2:	8809      	ldrh	r1, [r1, #0]
     2c4:	8812      	ldrh	r2, [r2, #0]

  {
    u8g2_uint_t ww, hh;

    ww = w;
    ww -= r;
     2c6:	1a8a      	subs	r2, r1, r2
     2c8:	801a      	strh	r2, [r3, #0]
    ww -= r;
     2ca:	2316      	movs	r3, #22
     2cc:	18fb      	adds	r3, r7, r3
     2ce:	2216      	movs	r2, #22
     2d0:	18b9      	adds	r1, r7, r2
     2d2:	2234      	movs	r2, #52	; 0x34
     2d4:	18ba      	adds	r2, r7, r2
     2d6:	8809      	ldrh	r1, [r1, #0]
     2d8:	8812      	ldrh	r2, [r2, #0]
     2da:	1a8a      	subs	r2, r1, r2
     2dc:	801a      	strh	r2, [r3, #0]
    hh = h;
     2de:	2314      	movs	r3, #20
     2e0:	18fb      	adds	r3, r7, r3
     2e2:	2230      	movs	r2, #48	; 0x30
     2e4:	18ba      	adds	r2, r7, r2
     2e6:	8812      	ldrh	r2, [r2, #0]
     2e8:	801a      	strh	r2, [r3, #0]
    hh -= r;
     2ea:	2314      	movs	r3, #20
     2ec:	18fb      	adds	r3, r7, r3
     2ee:	2214      	movs	r2, #20
     2f0:	18b9      	adds	r1, r7, r2
     2f2:	2234      	movs	r2, #52	; 0x34
     2f4:	18ba      	adds	r2, r7, r2
     2f6:	8809      	ldrh	r1, [r1, #0]
     2f8:	8812      	ldrh	r2, [r2, #0]
     2fa:	1a8a      	subs	r2, r1, r2
     2fc:	801a      	strh	r2, [r3, #0]
    hh -= r;
     2fe:	2314      	movs	r3, #20
     300:	18fb      	adds	r3, r7, r3
     302:	2214      	movs	r2, #20
     304:	18b9      	adds	r1, r7, r2
     306:	2234      	movs	r2, #52	; 0x34
     308:	18ba      	adds	r2, r7, r2
     30a:	8809      	ldrh	r1, [r1, #0]
     30c:	8812      	ldrh	r2, [r2, #0]
     30e:	1a8a      	subs	r2, r1, r2
     310:	801a      	strh	r2, [r3, #0]
    
    xl++;
     312:	231e      	movs	r3, #30
     314:	18fb      	adds	r3, r7, r3
     316:	881a      	ldrh	r2, [r3, #0]
     318:	231e      	movs	r3, #30
     31a:	18fb      	adds	r3, r7, r3
     31c:	3201      	adds	r2, #1
     31e:	801a      	strh	r2, [r3, #0]
    yu++;
     320:	231c      	movs	r3, #28
     322:	18fb      	adds	r3, r7, r3
     324:	881a      	ldrh	r2, [r3, #0]
     326:	231c      	movs	r3, #28
     328:	18fb      	adds	r3, r7, r3
     32a:	3201      	adds	r2, #1
     32c:	801a      	strh	r2, [r3, #0]
    
    if ( ww >= 3 )
     32e:	2316      	movs	r3, #22
     330:	18fb      	adds	r3, r7, r3
     332:	881b      	ldrh	r3, [r3, #0]
     334:	2b02      	cmp	r3, #2
     336:	d92c      	bls.n	392 <u8g2_DrawRFrame+0x280>
    {
      ww -= 2;
     338:	2316      	movs	r3, #22
     33a:	18fb      	adds	r3, r7, r3
     33c:	2216      	movs	r2, #22
     33e:	18ba      	adds	r2, r7, r2
     340:	8812      	ldrh	r2, [r2, #0]
     342:	3a02      	subs	r2, #2
     344:	801a      	strh	r2, [r3, #0]
      h--;
     346:	2330      	movs	r3, #48	; 0x30
     348:	18fb      	adds	r3, r7, r3
     34a:	881b      	ldrh	r3, [r3, #0]
     34c:	2230      	movs	r2, #48	; 0x30
     34e:	18ba      	adds	r2, r7, r2
     350:	3b01      	subs	r3, #1
     352:	8013      	strh	r3, [r2, #0]
      u8g2_DrawHLine(u8g2, xl, y, ww);
     354:	2316      	movs	r3, #22
     356:	18fb      	adds	r3, r7, r3
     358:	881c      	ldrh	r4, [r3, #0]
     35a:	2308      	movs	r3, #8
     35c:	18fb      	adds	r3, r7, r3
     35e:	881a      	ldrh	r2, [r3, #0]
     360:	231e      	movs	r3, #30
     362:	18fb      	adds	r3, r7, r3
     364:	8819      	ldrh	r1, [r3, #0]
     366:	68f8      	ldr	r0, [r7, #12]
     368:	0023      	movs	r3, r4
     36a:	f001 fbf7 	bl	1b5c <u8g2_DrawHLine>
      u8g2_DrawHLine(u8g2, xl, y+h, ww);
     36e:	2308      	movs	r3, #8
     370:	18fb      	adds	r3, r7, r3
     372:	2230      	movs	r2, #48	; 0x30
     374:	18b9      	adds	r1, r7, r2
     376:	881a      	ldrh	r2, [r3, #0]
     378:	880b      	ldrh	r3, [r1, #0]
     37a:	18d3      	adds	r3, r2, r3
     37c:	b29a      	uxth	r2, r3
     37e:	2316      	movs	r3, #22
     380:	18fb      	adds	r3, r7, r3
     382:	881c      	ldrh	r4, [r3, #0]
     384:	231e      	movs	r3, #30
     386:	18fb      	adds	r3, r7, r3
     388:	8819      	ldrh	r1, [r3, #0]
     38a:	68f8      	ldr	r0, [r7, #12]
     38c:	0023      	movs	r3, r4
     38e:	f001 fbe5 	bl	1b5c <u8g2_DrawHLine>
    }
    
    if ( hh >= 3 )
     392:	2314      	movs	r3, #20
     394:	18fb      	adds	r3, r7, r3
     396:	881b      	ldrh	r3, [r3, #0]
     398:	2b02      	cmp	r3, #2
     39a:	d92b      	bls.n	3f4 <u8g2_DrawRFrame+0x2e2>
    {
      hh -= 2;
     39c:	2314      	movs	r3, #20
     39e:	18fb      	adds	r3, r7, r3
     3a0:	2214      	movs	r2, #20
     3a2:	18ba      	adds	r2, r7, r2
     3a4:	8812      	ldrh	r2, [r2, #0]
     3a6:	3a02      	subs	r2, #2
     3a8:	801a      	strh	r2, [r3, #0]
      w--;
     3aa:	1dbb      	adds	r3, r7, #6
     3ac:	881a      	ldrh	r2, [r3, #0]
     3ae:	1dbb      	adds	r3, r7, #6
     3b0:	3a01      	subs	r2, #1
     3b2:	801a      	strh	r2, [r3, #0]
      u8g2_DrawVLine(u8g2, x, yu, hh);
     3b4:	2314      	movs	r3, #20
     3b6:	18fb      	adds	r3, r7, r3
     3b8:	881c      	ldrh	r4, [r3, #0]
     3ba:	231c      	movs	r3, #28
     3bc:	18fb      	adds	r3, r7, r3
     3be:	881a      	ldrh	r2, [r3, #0]
     3c0:	230a      	movs	r3, #10
     3c2:	18fb      	adds	r3, r7, r3
     3c4:	8819      	ldrh	r1, [r3, #0]
     3c6:	68f8      	ldr	r0, [r7, #12]
     3c8:	0023      	movs	r3, r4
     3ca:	f001 fbeb 	bl	1ba4 <u8g2_DrawVLine>
      u8g2_DrawVLine(u8g2, x+w, yu, hh);
     3ce:	230a      	movs	r3, #10
     3d0:	18fa      	adds	r2, r7, r3
     3d2:	1dbb      	adds	r3, r7, #6
     3d4:	8812      	ldrh	r2, [r2, #0]
     3d6:	881b      	ldrh	r3, [r3, #0]
     3d8:	18d3      	adds	r3, r2, r3
     3da:	b299      	uxth	r1, r3
     3dc:	2314      	movs	r3, #20
     3de:	18fb      	adds	r3, r7, r3
     3e0:	881c      	ldrh	r4, [r3, #0]
     3e2:	231c      	movs	r3, #28
     3e4:	18fb      	adds	r3, r7, r3
     3e6:	881a      	ldrh	r2, [r3, #0]
     3e8:	68f8      	ldr	r0, [r7, #12]
     3ea:	0023      	movs	r3, r4
     3ec:	f001 fbda 	bl	1ba4 <u8g2_DrawVLine>
     3f0:	e000      	b.n	3f4 <u8g2_DrawRFrame+0x2e2>
    return;
     3f2:	46c0      	nop			; (mov r8, r8)
    }
  }
}
     3f4:	46bd      	mov	sp, r7
     3f6:	b008      	add	sp, #32
     3f8:	bdb0      	pop	{r4, r5, r7, pc}

000003fa <u8g2_ClearBuffer>:
#include "u8g2.h"
#include <string.h>

/*============================================*/
void u8g2_ClearBuffer(u8g2_t *u8g2)
{
     3fa:	b580      	push	{r7, lr}
     3fc:	b084      	sub	sp, #16
     3fe:	af00      	add	r7, sp, #0
     400:	6078      	str	r0, [r7, #4]
  size_t cnt;
  cnt = u8g2_GetU8x8(u8g2)->display_info->tile_width;
     402:	687b      	ldr	r3, [r7, #4]
     404:	681b      	ldr	r3, [r3, #0]
     406:	7c1b      	ldrb	r3, [r3, #16]
     408:	60fb      	str	r3, [r7, #12]
  cnt *= u8g2->tile_buf_height;
     40a:	687b      	ldr	r3, [r7, #4]
     40c:	2238      	movs	r2, #56	; 0x38
     40e:	5c9b      	ldrb	r3, [r3, r2]
     410:	001a      	movs	r2, r3
     412:	68fb      	ldr	r3, [r7, #12]
     414:	4353      	muls	r3, r2
     416:	60fb      	str	r3, [r7, #12]
  cnt *= 8;
     418:	68fb      	ldr	r3, [r7, #12]
     41a:	00db      	lsls	r3, r3, #3
     41c:	60fb      	str	r3, [r7, #12]
  memset(u8g2->tile_buf_ptr, 0, cnt);
     41e:	687b      	ldr	r3, [r7, #4]
     420:	6b5b      	ldr	r3, [r3, #52]	; 0x34
     422:	68fa      	ldr	r2, [r7, #12]
     424:	2100      	movs	r1, #0
     426:	0018      	movs	r0, r3
     428:	f007 fc42 	bl	7cb0 <memset>
}
     42c:	46c0      	nop			; (mov r8, r8)
     42e:	46bd      	mov	sp, r7
     430:	b004      	add	sp, #16
     432:	bd80      	pop	{r7, pc}

00000434 <u8g2_send_tile_row>:

/*============================================*/

static void u8g2_send_tile_row(u8g2_t *u8g2, uint8_t src_tile_row, uint8_t dest_tile_row)
{
     434:	b580      	push	{r7, lr}
     436:	b086      	sub	sp, #24
     438:	af02      	add	r7, sp, #8
     43a:	6078      	str	r0, [r7, #4]
     43c:	0008      	movs	r0, r1
     43e:	0011      	movs	r1, r2
     440:	1cfb      	adds	r3, r7, #3
     442:	1c02      	adds	r2, r0, #0
     444:	701a      	strb	r2, [r3, #0]
     446:	1cbb      	adds	r3, r7, #2
     448:	1c0a      	adds	r2, r1, #0
     44a:	701a      	strb	r2, [r3, #0]
  uint8_t *ptr;
  uint16_t offset;
  uint8_t w;
  
  w = u8g2_GetU8x8(u8g2)->display_info->tile_width;
     44c:	687b      	ldr	r3, [r7, #4]
     44e:	681a      	ldr	r2, [r3, #0]
     450:	230f      	movs	r3, #15
     452:	18fb      	adds	r3, r7, r3
     454:	7c12      	ldrb	r2, [r2, #16]
     456:	701a      	strb	r2, [r3, #0]
  offset = src_tile_row;
     458:	230c      	movs	r3, #12
     45a:	18fb      	adds	r3, r7, r3
     45c:	1cfa      	adds	r2, r7, #3
     45e:	7812      	ldrb	r2, [r2, #0]
     460:	801a      	strh	r2, [r3, #0]
  ptr = u8g2->tile_buf_ptr;
     462:	687b      	ldr	r3, [r7, #4]
     464:	6b5b      	ldr	r3, [r3, #52]	; 0x34
     466:	60bb      	str	r3, [r7, #8]
  offset *= w;
     468:	230f      	movs	r3, #15
     46a:	18fb      	adds	r3, r7, r3
     46c:	781b      	ldrb	r3, [r3, #0]
     46e:	b29a      	uxth	r2, r3
     470:	230c      	movs	r3, #12
     472:	18fb      	adds	r3, r7, r3
     474:	210c      	movs	r1, #12
     476:	1879      	adds	r1, r7, r1
     478:	8809      	ldrh	r1, [r1, #0]
     47a:	434a      	muls	r2, r1
     47c:	801a      	strh	r2, [r3, #0]
  offset *= 8;
     47e:	230c      	movs	r3, #12
     480:	18fb      	adds	r3, r7, r3
     482:	220c      	movs	r2, #12
     484:	18ba      	adds	r2, r7, r2
     486:	8812      	ldrh	r2, [r2, #0]
     488:	00d2      	lsls	r2, r2, #3
     48a:	801a      	strh	r2, [r3, #0]
  ptr += offset;
     48c:	230c      	movs	r3, #12
     48e:	18fb      	adds	r3, r7, r3
     490:	881b      	ldrh	r3, [r3, #0]
     492:	68ba      	ldr	r2, [r7, #8]
     494:	18d3      	adds	r3, r2, r3
     496:	60bb      	str	r3, [r7, #8]
  u8x8_DrawTile(u8g2_GetU8x8(u8g2), 0, dest_tile_row, w, ptr);
     498:	230f      	movs	r3, #15
     49a:	18fb      	adds	r3, r7, r3
     49c:	7819      	ldrb	r1, [r3, #0]
     49e:	1cbb      	adds	r3, r7, #2
     4a0:	781a      	ldrb	r2, [r3, #0]
     4a2:	6878      	ldr	r0, [r7, #4]
     4a4:	68bb      	ldr	r3, [r7, #8]
     4a6:	9300      	str	r3, [sp, #0]
     4a8:	000b      	movs	r3, r1
     4aa:	2100      	movs	r1, #0
     4ac:	f002 f9c4 	bl	2838 <u8x8_DrawTile>
}
     4b0:	46c0      	nop			; (mov r8, r8)
     4b2:	46bd      	mov	sp, r7
     4b4:	b004      	add	sp, #16
     4b6:	bd80      	pop	{r7, pc}

000004b8 <u8g2_send_buffer>:
  For most displays, this will make the content visible to the user.
  Some displays (like the SSD1606) require a u8x8_RefreshDisplay()
*/
static void u8g2_send_buffer(u8g2_t *u8g2) U8X8_NOINLINE;
static void u8g2_send_buffer(u8g2_t *u8g2)
{
     4b8:	b580      	push	{r7, lr}
     4ba:	b084      	sub	sp, #16
     4bc:	af00      	add	r7, sp, #0
     4be:	6078      	str	r0, [r7, #4]
  uint8_t src_row;
  uint8_t src_max;
  uint8_t dest_row;
  uint8_t dest_max;

  src_row = 0;
     4c0:	230f      	movs	r3, #15
     4c2:	18fb      	adds	r3, r7, r3
     4c4:	2200      	movs	r2, #0
     4c6:	701a      	strb	r2, [r3, #0]
  src_max = u8g2->tile_buf_height;
     4c8:	230d      	movs	r3, #13
     4ca:	18fb      	adds	r3, r7, r3
     4cc:	687a      	ldr	r2, [r7, #4]
     4ce:	2138      	movs	r1, #56	; 0x38
     4d0:	5c52      	ldrb	r2, [r2, r1]
     4d2:	701a      	strb	r2, [r3, #0]
  dest_row = u8g2->tile_curr_row;
     4d4:	230e      	movs	r3, #14
     4d6:	18fb      	adds	r3, r7, r3
     4d8:	687a      	ldr	r2, [r7, #4]
     4da:	2139      	movs	r1, #57	; 0x39
     4dc:	5c52      	ldrb	r2, [r2, r1]
     4de:	701a      	strb	r2, [r3, #0]
  dest_max = u8g2_GetU8x8(u8g2)->display_info->tile_height;
     4e0:	687b      	ldr	r3, [r7, #4]
     4e2:	681a      	ldr	r2, [r3, #0]
     4e4:	230c      	movs	r3, #12
     4e6:	18fb      	adds	r3, r7, r3
     4e8:	7c52      	ldrb	r2, [r2, #17]
     4ea:	701a      	strb	r2, [r3, #0]
  
  do
  {
    u8g2_send_tile_row(u8g2, src_row, dest_row);
     4ec:	230e      	movs	r3, #14
     4ee:	18fb      	adds	r3, r7, r3
     4f0:	781a      	ldrb	r2, [r3, #0]
     4f2:	230f      	movs	r3, #15
     4f4:	18fb      	adds	r3, r7, r3
     4f6:	7819      	ldrb	r1, [r3, #0]
     4f8:	687b      	ldr	r3, [r7, #4]
     4fa:	0018      	movs	r0, r3
     4fc:	f7ff ff9a 	bl	434 <u8g2_send_tile_row>
    src_row++;
     500:	230f      	movs	r3, #15
     502:	18fb      	adds	r3, r7, r3
     504:	781a      	ldrb	r2, [r3, #0]
     506:	230f      	movs	r3, #15
     508:	18fb      	adds	r3, r7, r3
     50a:	3201      	adds	r2, #1
     50c:	701a      	strb	r2, [r3, #0]
    dest_row++;
     50e:	230e      	movs	r3, #14
     510:	18fb      	adds	r3, r7, r3
     512:	781a      	ldrb	r2, [r3, #0]
     514:	230e      	movs	r3, #14
     516:	18fb      	adds	r3, r7, r3
     518:	3201      	adds	r2, #1
     51a:	701a      	strb	r2, [r3, #0]
  } while( src_row < src_max && dest_row < dest_max );
     51c:	230f      	movs	r3, #15
     51e:	18fa      	adds	r2, r7, r3
     520:	230d      	movs	r3, #13
     522:	18fb      	adds	r3, r7, r3
     524:	7812      	ldrb	r2, [r2, #0]
     526:	781b      	ldrb	r3, [r3, #0]
     528:	429a      	cmp	r2, r3
     52a:	d207      	bcs.n	53c <u8g2_send_buffer+0x84>
     52c:	230e      	movs	r3, #14
     52e:	18fa      	adds	r2, r7, r3
     530:	230c      	movs	r3, #12
     532:	18fb      	adds	r3, r7, r3
     534:	7812      	ldrb	r2, [r2, #0]
     536:	781b      	ldrb	r3, [r3, #0]
     538:	429a      	cmp	r2, r3
     53a:	d3d7      	bcc.n	4ec <u8g2_send_buffer+0x34>
}
     53c:	46c0      	nop			; (mov r8, r8)
     53e:	46bd      	mov	sp, r7
     540:	b004      	add	sp, #16
     542:	bd80      	pop	{r7, pc}

00000544 <u8g2_SendBuffer>:

/* same as u8g2_send_buffer but also send the DISPLAY_REFRESH message (used by SSD1606) */
void u8g2_SendBuffer(u8g2_t *u8g2)
{
     544:	b580      	push	{r7, lr}
     546:	b082      	sub	sp, #8
     548:	af00      	add	r7, sp, #0
     54a:	6078      	str	r0, [r7, #4]
  u8g2_send_buffer(u8g2);
     54c:	687b      	ldr	r3, [r7, #4]
     54e:	0018      	movs	r0, r3
     550:	f7ff ffb2 	bl	4b8 <u8g2_send_buffer>
  u8x8_RefreshDisplay( u8g2_GetU8x8(u8g2) );  
     554:	687b      	ldr	r3, [r7, #4]
     556:	0018      	movs	r0, r3
     558:	f002 f9e2 	bl	2920 <u8x8_RefreshDisplay>
}
     55c:	46c0      	nop			; (mov r8, r8)
     55e:	46bd      	mov	sp, r7
     560:	b002      	add	sp, #8
     562:	bd80      	pop	{r7, pc}

00000564 <u8g2_draw_circle_section>:
/* Circle */

static void u8g2_draw_circle_section(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t x0, u8g2_uint_t y0, uint8_t option) U8G2_NOINLINE;

static void u8g2_draw_circle_section(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t x0, u8g2_uint_t y0, uint8_t option)
{
     564:	b590      	push	{r4, r7, lr}
     566:	b085      	sub	sp, #20
     568:	af00      	add	r7, sp, #0
     56a:	60f8      	str	r0, [r7, #12]
     56c:	000c      	movs	r4, r1
     56e:	0010      	movs	r0, r2
     570:	0019      	movs	r1, r3
     572:	230a      	movs	r3, #10
     574:	18fb      	adds	r3, r7, r3
     576:	1c22      	adds	r2, r4, #0
     578:	801a      	strh	r2, [r3, #0]
     57a:	2308      	movs	r3, #8
     57c:	18fb      	adds	r3, r7, r3
     57e:	1c02      	adds	r2, r0, #0
     580:	801a      	strh	r2, [r3, #0]
     582:	1dbb      	adds	r3, r7, #6
     584:	1c0a      	adds	r2, r1, #0
     586:	801a      	strh	r2, [r3, #0]
    /* upper right */
    if ( option & U8G2_DRAW_UPPER_RIGHT )
     588:	2324      	movs	r3, #36	; 0x24
     58a:	18fb      	adds	r3, r7, r3
     58c:	781b      	ldrb	r3, [r3, #0]
     58e:	2201      	movs	r2, #1
     590:	4013      	ands	r3, r2
     592:	d025      	beq.n	5e0 <u8g2_draw_circle_section+0x7c>
    {
      u8g2_DrawPixel(u8g2, x0 + x, y0 - y);
     594:	1dba      	adds	r2, r7, #6
     596:	230a      	movs	r3, #10
     598:	18fb      	adds	r3, r7, r3
     59a:	8812      	ldrh	r2, [r2, #0]
     59c:	881b      	ldrh	r3, [r3, #0]
     59e:	18d3      	adds	r3, r2, r3
     5a0:	b299      	uxth	r1, r3
     5a2:	2320      	movs	r3, #32
     5a4:	18fa      	adds	r2, r7, r3
     5a6:	2308      	movs	r3, #8
     5a8:	18fb      	adds	r3, r7, r3
     5aa:	8812      	ldrh	r2, [r2, #0]
     5ac:	881b      	ldrh	r3, [r3, #0]
     5ae:	1ad3      	subs	r3, r2, r3
     5b0:	b29a      	uxth	r2, r3
     5b2:	68fb      	ldr	r3, [r7, #12]
     5b4:	0018      	movs	r0, r3
     5b6:	f001 fb19 	bl	1bec <u8g2_DrawPixel>
      u8g2_DrawPixel(u8g2, x0 + y, y0 - x);
     5ba:	1dba      	adds	r2, r7, #6
     5bc:	2308      	movs	r3, #8
     5be:	18fb      	adds	r3, r7, r3
     5c0:	8812      	ldrh	r2, [r2, #0]
     5c2:	881b      	ldrh	r3, [r3, #0]
     5c4:	18d3      	adds	r3, r2, r3
     5c6:	b299      	uxth	r1, r3
     5c8:	2320      	movs	r3, #32
     5ca:	18fa      	adds	r2, r7, r3
     5cc:	230a      	movs	r3, #10
     5ce:	18fb      	adds	r3, r7, r3
     5d0:	8812      	ldrh	r2, [r2, #0]
     5d2:	881b      	ldrh	r3, [r3, #0]
     5d4:	1ad3      	subs	r3, r2, r3
     5d6:	b29a      	uxth	r2, r3
     5d8:	68fb      	ldr	r3, [r7, #12]
     5da:	0018      	movs	r0, r3
     5dc:	f001 fb06 	bl	1bec <u8g2_DrawPixel>
    }
    
    /* upper left */
    if ( option & U8G2_DRAW_UPPER_LEFT )
     5e0:	2324      	movs	r3, #36	; 0x24
     5e2:	18fb      	adds	r3, r7, r3
     5e4:	781b      	ldrb	r3, [r3, #0]
     5e6:	2202      	movs	r2, #2
     5e8:	4013      	ands	r3, r2
     5ea:	d025      	beq.n	638 <u8g2_draw_circle_section+0xd4>
    {
      u8g2_DrawPixel(u8g2, x0 - x, y0 - y);
     5ec:	1dba      	adds	r2, r7, #6
     5ee:	230a      	movs	r3, #10
     5f0:	18fb      	adds	r3, r7, r3
     5f2:	8812      	ldrh	r2, [r2, #0]
     5f4:	881b      	ldrh	r3, [r3, #0]
     5f6:	1ad3      	subs	r3, r2, r3
     5f8:	b299      	uxth	r1, r3
     5fa:	2320      	movs	r3, #32
     5fc:	18fa      	adds	r2, r7, r3
     5fe:	2308      	movs	r3, #8
     600:	18fb      	adds	r3, r7, r3
     602:	8812      	ldrh	r2, [r2, #0]
     604:	881b      	ldrh	r3, [r3, #0]
     606:	1ad3      	subs	r3, r2, r3
     608:	b29a      	uxth	r2, r3
     60a:	68fb      	ldr	r3, [r7, #12]
     60c:	0018      	movs	r0, r3
     60e:	f001 faed 	bl	1bec <u8g2_DrawPixel>
      u8g2_DrawPixel(u8g2, x0 - y, y0 - x);
     612:	1dba      	adds	r2, r7, #6
     614:	2308      	movs	r3, #8
     616:	18fb      	adds	r3, r7, r3
     618:	8812      	ldrh	r2, [r2, #0]
     61a:	881b      	ldrh	r3, [r3, #0]
     61c:	1ad3      	subs	r3, r2, r3
     61e:	b299      	uxth	r1, r3
     620:	2320      	movs	r3, #32
     622:	18fa      	adds	r2, r7, r3
     624:	230a      	movs	r3, #10
     626:	18fb      	adds	r3, r7, r3
     628:	8812      	ldrh	r2, [r2, #0]
     62a:	881b      	ldrh	r3, [r3, #0]
     62c:	1ad3      	subs	r3, r2, r3
     62e:	b29a      	uxth	r2, r3
     630:	68fb      	ldr	r3, [r7, #12]
     632:	0018      	movs	r0, r3
     634:	f001 fada 	bl	1bec <u8g2_DrawPixel>
    }
    
    /* lower right */
    if ( option & U8G2_DRAW_LOWER_RIGHT )
     638:	2324      	movs	r3, #36	; 0x24
     63a:	18fb      	adds	r3, r7, r3
     63c:	781b      	ldrb	r3, [r3, #0]
     63e:	2208      	movs	r2, #8
     640:	4013      	ands	r3, r2
     642:	d025      	beq.n	690 <u8g2_draw_circle_section+0x12c>
    {
      u8g2_DrawPixel(u8g2, x0 + x, y0 + y);
     644:	1dba      	adds	r2, r7, #6
     646:	230a      	movs	r3, #10
     648:	18fb      	adds	r3, r7, r3
     64a:	8812      	ldrh	r2, [r2, #0]
     64c:	881b      	ldrh	r3, [r3, #0]
     64e:	18d3      	adds	r3, r2, r3
     650:	b299      	uxth	r1, r3
     652:	2320      	movs	r3, #32
     654:	18fa      	adds	r2, r7, r3
     656:	2308      	movs	r3, #8
     658:	18fb      	adds	r3, r7, r3
     65a:	8812      	ldrh	r2, [r2, #0]
     65c:	881b      	ldrh	r3, [r3, #0]
     65e:	18d3      	adds	r3, r2, r3
     660:	b29a      	uxth	r2, r3
     662:	68fb      	ldr	r3, [r7, #12]
     664:	0018      	movs	r0, r3
     666:	f001 fac1 	bl	1bec <u8g2_DrawPixel>
      u8g2_DrawPixel(u8g2, x0 + y, y0 + x);
     66a:	1dba      	adds	r2, r7, #6
     66c:	2308      	movs	r3, #8
     66e:	18fb      	adds	r3, r7, r3
     670:	8812      	ldrh	r2, [r2, #0]
     672:	881b      	ldrh	r3, [r3, #0]
     674:	18d3      	adds	r3, r2, r3
     676:	b299      	uxth	r1, r3
     678:	2320      	movs	r3, #32
     67a:	18fa      	adds	r2, r7, r3
     67c:	230a      	movs	r3, #10
     67e:	18fb      	adds	r3, r7, r3
     680:	8812      	ldrh	r2, [r2, #0]
     682:	881b      	ldrh	r3, [r3, #0]
     684:	18d3      	adds	r3, r2, r3
     686:	b29a      	uxth	r2, r3
     688:	68fb      	ldr	r3, [r7, #12]
     68a:	0018      	movs	r0, r3
     68c:	f001 faae 	bl	1bec <u8g2_DrawPixel>
    }
    
    /* lower left */
    if ( option & U8G2_DRAW_LOWER_LEFT )
     690:	2324      	movs	r3, #36	; 0x24
     692:	18fb      	adds	r3, r7, r3
     694:	781b      	ldrb	r3, [r3, #0]
     696:	2204      	movs	r2, #4
     698:	4013      	ands	r3, r2
     69a:	d025      	beq.n	6e8 <u8g2_draw_circle_section+0x184>
    {
      u8g2_DrawPixel(u8g2, x0 - x, y0 + y);
     69c:	1dba      	adds	r2, r7, #6
     69e:	230a      	movs	r3, #10
     6a0:	18fb      	adds	r3, r7, r3
     6a2:	8812      	ldrh	r2, [r2, #0]
     6a4:	881b      	ldrh	r3, [r3, #0]
     6a6:	1ad3      	subs	r3, r2, r3
     6a8:	b299      	uxth	r1, r3
     6aa:	2320      	movs	r3, #32
     6ac:	18fa      	adds	r2, r7, r3
     6ae:	2308      	movs	r3, #8
     6b0:	18fb      	adds	r3, r7, r3
     6b2:	8812      	ldrh	r2, [r2, #0]
     6b4:	881b      	ldrh	r3, [r3, #0]
     6b6:	18d3      	adds	r3, r2, r3
     6b8:	b29a      	uxth	r2, r3
     6ba:	68fb      	ldr	r3, [r7, #12]
     6bc:	0018      	movs	r0, r3
     6be:	f001 fa95 	bl	1bec <u8g2_DrawPixel>
      u8g2_DrawPixel(u8g2, x0 - y, y0 + x);
     6c2:	1dba      	adds	r2, r7, #6
     6c4:	2308      	movs	r3, #8
     6c6:	18fb      	adds	r3, r7, r3
     6c8:	8812      	ldrh	r2, [r2, #0]
     6ca:	881b      	ldrh	r3, [r3, #0]
     6cc:	1ad3      	subs	r3, r2, r3
     6ce:	b299      	uxth	r1, r3
     6d0:	2320      	movs	r3, #32
     6d2:	18fa      	adds	r2, r7, r3
     6d4:	230a      	movs	r3, #10
     6d6:	18fb      	adds	r3, r7, r3
     6d8:	8812      	ldrh	r2, [r2, #0]
     6da:	881b      	ldrh	r3, [r3, #0]
     6dc:	18d3      	adds	r3, r2, r3
     6de:	b29a      	uxth	r2, r3
     6e0:	68fb      	ldr	r3, [r7, #12]
     6e2:	0018      	movs	r0, r3
     6e4:	f001 fa82 	bl	1bec <u8g2_DrawPixel>
    }
}
     6e8:	46c0      	nop			; (mov r8, r8)
     6ea:	46bd      	mov	sp, r7
     6ec:	b005      	add	sp, #20
     6ee:	bd90      	pop	{r4, r7, pc}

000006f0 <u8g2_draw_circle>:

static void u8g2_draw_circle(u8g2_t *u8g2, u8g2_uint_t x0, u8g2_uint_t y0, u8g2_uint_t rad, uint8_t option)
{
     6f0:	b590      	push	{r4, r7, lr}
     6f2:	b08b      	sub	sp, #44	; 0x2c
     6f4:	af02      	add	r7, sp, #8
     6f6:	60f8      	str	r0, [r7, #12]
     6f8:	000c      	movs	r4, r1
     6fa:	0010      	movs	r0, r2
     6fc:	0019      	movs	r1, r3
     6fe:	230a      	movs	r3, #10
     700:	18fb      	adds	r3, r7, r3
     702:	1c22      	adds	r2, r4, #0
     704:	801a      	strh	r2, [r3, #0]
     706:	2308      	movs	r3, #8
     708:	18fb      	adds	r3, r7, r3
     70a:	1c02      	adds	r2, r0, #0
     70c:	801a      	strh	r2, [r3, #0]
     70e:	1dbb      	adds	r3, r7, #6
     710:	1c0a      	adds	r2, r1, #0
     712:	801a      	strh	r2, [r3, #0]
    u8g2_int_t ddF_x;
    u8g2_int_t ddF_y;
    u8g2_uint_t x;
    u8g2_uint_t y;

    f = 1;
     714:	231e      	movs	r3, #30
     716:	18fb      	adds	r3, r7, r3
     718:	2201      	movs	r2, #1
     71a:	801a      	strh	r2, [r3, #0]
    f -= rad;
     71c:	231e      	movs	r3, #30
     71e:	18fb      	adds	r3, r7, r3
     720:	881a      	ldrh	r2, [r3, #0]
     722:	1dbb      	adds	r3, r7, #6
     724:	881b      	ldrh	r3, [r3, #0]
     726:	1ad3      	subs	r3, r2, r3
     728:	b29a      	uxth	r2, r3
     72a:	231e      	movs	r3, #30
     72c:	18fb      	adds	r3, r7, r3
     72e:	801a      	strh	r2, [r3, #0]
    ddF_x = 1;
     730:	231c      	movs	r3, #28
     732:	18fb      	adds	r3, r7, r3
     734:	2201      	movs	r2, #1
     736:	801a      	strh	r2, [r3, #0]
    ddF_y = 0;
     738:	231a      	movs	r3, #26
     73a:	18fb      	adds	r3, r7, r3
     73c:	2200      	movs	r2, #0
     73e:	801a      	strh	r2, [r3, #0]
    ddF_y -= rad;
     740:	231a      	movs	r3, #26
     742:	18fb      	adds	r3, r7, r3
     744:	881a      	ldrh	r2, [r3, #0]
     746:	1dbb      	adds	r3, r7, #6
     748:	881b      	ldrh	r3, [r3, #0]
     74a:	1ad3      	subs	r3, r2, r3
     74c:	b29a      	uxth	r2, r3
     74e:	231a      	movs	r3, #26
     750:	18fb      	adds	r3, r7, r3
     752:	801a      	strh	r2, [r3, #0]
    ddF_y *= 2;
     754:	231a      	movs	r3, #26
     756:	18fb      	adds	r3, r7, r3
     758:	881b      	ldrh	r3, [r3, #0]
     75a:	18db      	adds	r3, r3, r3
     75c:	b29a      	uxth	r2, r3
     75e:	231a      	movs	r3, #26
     760:	18fb      	adds	r3, r7, r3
     762:	801a      	strh	r2, [r3, #0]
    x = 0;
     764:	2318      	movs	r3, #24
     766:	18fb      	adds	r3, r7, r3
     768:	2200      	movs	r2, #0
     76a:	801a      	strh	r2, [r3, #0]
    y = rad;
     76c:	2316      	movs	r3, #22
     76e:	18fb      	adds	r3, r7, r3
     770:	1dba      	adds	r2, r7, #6
     772:	8812      	ldrh	r2, [r2, #0]
     774:	801a      	strh	r2, [r3, #0]

    u8g2_draw_circle_section(u8g2, x, y, x0, y0, option);
     776:	230a      	movs	r3, #10
     778:	18fb      	adds	r3, r7, r3
     77a:	881c      	ldrh	r4, [r3, #0]
     77c:	2316      	movs	r3, #22
     77e:	18fb      	adds	r3, r7, r3
     780:	881a      	ldrh	r2, [r3, #0]
     782:	2318      	movs	r3, #24
     784:	18fb      	adds	r3, r7, r3
     786:	8819      	ldrh	r1, [r3, #0]
     788:	68f8      	ldr	r0, [r7, #12]
     78a:	2330      	movs	r3, #48	; 0x30
     78c:	18fb      	adds	r3, r7, r3
     78e:	781b      	ldrb	r3, [r3, #0]
     790:	9301      	str	r3, [sp, #4]
     792:	2308      	movs	r3, #8
     794:	18fb      	adds	r3, r7, r3
     796:	881b      	ldrh	r3, [r3, #0]
     798:	9300      	str	r3, [sp, #0]
     79a:	0023      	movs	r3, r4
     79c:	f7ff fee2 	bl	564 <u8g2_draw_circle_section>
    
    while ( x < y )
     7a0:	e04e      	b.n	840 <u8g2_draw_circle+0x150>
    {
      if (f >= 0) 
     7a2:	231e      	movs	r3, #30
     7a4:	18fb      	adds	r3, r7, r3
     7a6:	2200      	movs	r2, #0
     7a8:	5e9b      	ldrsh	r3, [r3, r2]
     7aa:	2b00      	cmp	r3, #0
     7ac:	db19      	blt.n	7e2 <u8g2_draw_circle+0xf2>
      {
        y--;
     7ae:	2316      	movs	r3, #22
     7b0:	18fb      	adds	r3, r7, r3
     7b2:	881a      	ldrh	r2, [r3, #0]
     7b4:	2316      	movs	r3, #22
     7b6:	18fb      	adds	r3, r7, r3
     7b8:	3a01      	subs	r2, #1
     7ba:	801a      	strh	r2, [r3, #0]
        ddF_y += 2;
     7bc:	231a      	movs	r3, #26
     7be:	18fb      	adds	r3, r7, r3
     7c0:	881b      	ldrh	r3, [r3, #0]
     7c2:	3302      	adds	r3, #2
     7c4:	b29a      	uxth	r2, r3
     7c6:	231a      	movs	r3, #26
     7c8:	18fb      	adds	r3, r7, r3
     7ca:	801a      	strh	r2, [r3, #0]
        f += ddF_y;
     7cc:	231e      	movs	r3, #30
     7ce:	18fb      	adds	r3, r7, r3
     7d0:	881a      	ldrh	r2, [r3, #0]
     7d2:	231a      	movs	r3, #26
     7d4:	18fb      	adds	r3, r7, r3
     7d6:	881b      	ldrh	r3, [r3, #0]
     7d8:	18d3      	adds	r3, r2, r3
     7da:	b29a      	uxth	r2, r3
     7dc:	231e      	movs	r3, #30
     7de:	18fb      	adds	r3, r7, r3
     7e0:	801a      	strh	r2, [r3, #0]
      }
      x++;
     7e2:	2318      	movs	r3, #24
     7e4:	18fb      	adds	r3, r7, r3
     7e6:	881a      	ldrh	r2, [r3, #0]
     7e8:	2318      	movs	r3, #24
     7ea:	18fb      	adds	r3, r7, r3
     7ec:	3201      	adds	r2, #1
     7ee:	801a      	strh	r2, [r3, #0]
      ddF_x += 2;
     7f0:	231c      	movs	r3, #28
     7f2:	18fb      	adds	r3, r7, r3
     7f4:	881b      	ldrh	r3, [r3, #0]
     7f6:	3302      	adds	r3, #2
     7f8:	b29a      	uxth	r2, r3
     7fa:	231c      	movs	r3, #28
     7fc:	18fb      	adds	r3, r7, r3
     7fe:	801a      	strh	r2, [r3, #0]
      f += ddF_x;
     800:	231e      	movs	r3, #30
     802:	18fb      	adds	r3, r7, r3
     804:	881a      	ldrh	r2, [r3, #0]
     806:	231c      	movs	r3, #28
     808:	18fb      	adds	r3, r7, r3
     80a:	881b      	ldrh	r3, [r3, #0]
     80c:	18d3      	adds	r3, r2, r3
     80e:	b29a      	uxth	r2, r3
     810:	231e      	movs	r3, #30
     812:	18fb      	adds	r3, r7, r3
     814:	801a      	strh	r2, [r3, #0]

      u8g2_draw_circle_section(u8g2, x, y, x0, y0, option);    
     816:	230a      	movs	r3, #10
     818:	18fb      	adds	r3, r7, r3
     81a:	881c      	ldrh	r4, [r3, #0]
     81c:	2316      	movs	r3, #22
     81e:	18fb      	adds	r3, r7, r3
     820:	881a      	ldrh	r2, [r3, #0]
     822:	2318      	movs	r3, #24
     824:	18fb      	adds	r3, r7, r3
     826:	8819      	ldrh	r1, [r3, #0]
     828:	68f8      	ldr	r0, [r7, #12]
     82a:	2330      	movs	r3, #48	; 0x30
     82c:	18fb      	adds	r3, r7, r3
     82e:	781b      	ldrb	r3, [r3, #0]
     830:	9301      	str	r3, [sp, #4]
     832:	2308      	movs	r3, #8
     834:	18fb      	adds	r3, r7, r3
     836:	881b      	ldrh	r3, [r3, #0]
     838:	9300      	str	r3, [sp, #0]
     83a:	0023      	movs	r3, r4
     83c:	f7ff fe92 	bl	564 <u8g2_draw_circle_section>
    while ( x < y )
     840:	2318      	movs	r3, #24
     842:	18fa      	adds	r2, r7, r3
     844:	2316      	movs	r3, #22
     846:	18fb      	adds	r3, r7, r3
     848:	8812      	ldrh	r2, [r2, #0]
     84a:	881b      	ldrh	r3, [r3, #0]
     84c:	429a      	cmp	r2, r3
     84e:	d3a8      	bcc.n	7a2 <u8g2_draw_circle+0xb2>
    }
}
     850:	46c0      	nop			; (mov r8, r8)
     852:	46bd      	mov	sp, r7
     854:	b009      	add	sp, #36	; 0x24
     856:	bd90      	pop	{r4, r7, pc}

00000858 <u8g2_DrawCircle>:

void u8g2_DrawCircle(u8g2_t *u8g2, u8g2_uint_t x0, u8g2_uint_t y0, u8g2_uint_t rad, uint8_t option)
{
     858:	b5b0      	push	{r4, r5, r7, lr}
     85a:	b086      	sub	sp, #24
     85c:	af02      	add	r7, sp, #8
     85e:	60f8      	str	r0, [r7, #12]
     860:	000c      	movs	r4, r1
     862:	0010      	movs	r0, r2
     864:	0019      	movs	r1, r3
     866:	230a      	movs	r3, #10
     868:	18fb      	adds	r3, r7, r3
     86a:	1c22      	adds	r2, r4, #0
     86c:	801a      	strh	r2, [r3, #0]
     86e:	2308      	movs	r3, #8
     870:	18fb      	adds	r3, r7, r3
     872:	1c02      	adds	r2, r0, #0
     874:	801a      	strh	r2, [r3, #0]
     876:	1dbb      	adds	r3, r7, #6
     878:	1c0a      	adds	r2, r1, #0
     87a:	801a      	strh	r2, [r3, #0]
  /* check for bounding box */
#ifdef U8G2_WITH_INTERSECTION
  {
    if ( u8g2_IsIntersection(u8g2, x0-rad, y0-rad, x0+rad+1, y0+rad+1) == 0 ) 
     87c:	230a      	movs	r3, #10
     87e:	18fa      	adds	r2, r7, r3
     880:	1dbb      	adds	r3, r7, #6
     882:	8812      	ldrh	r2, [r2, #0]
     884:	881b      	ldrh	r3, [r3, #0]
     886:	1ad3      	subs	r3, r2, r3
     888:	b299      	uxth	r1, r3
     88a:	2308      	movs	r3, #8
     88c:	18fa      	adds	r2, r7, r3
     88e:	1dbb      	adds	r3, r7, #6
     890:	8812      	ldrh	r2, [r2, #0]
     892:	881b      	ldrh	r3, [r3, #0]
     894:	1ad3      	subs	r3, r2, r3
     896:	b29c      	uxth	r4, r3
     898:	230a      	movs	r3, #10
     89a:	18fa      	adds	r2, r7, r3
     89c:	1dbb      	adds	r3, r7, #6
     89e:	8812      	ldrh	r2, [r2, #0]
     8a0:	881b      	ldrh	r3, [r3, #0]
     8a2:	18d3      	adds	r3, r2, r3
     8a4:	b29b      	uxth	r3, r3
     8a6:	3301      	adds	r3, #1
     8a8:	b29d      	uxth	r5, r3
     8aa:	2308      	movs	r3, #8
     8ac:	18fa      	adds	r2, r7, r3
     8ae:	1dbb      	adds	r3, r7, #6
     8b0:	8812      	ldrh	r2, [r2, #0]
     8b2:	881b      	ldrh	r3, [r3, #0]
     8b4:	18d3      	adds	r3, r2, r3
     8b6:	b29b      	uxth	r3, r3
     8b8:	3301      	adds	r3, #1
     8ba:	b29b      	uxth	r3, r3
     8bc:	68f8      	ldr	r0, [r7, #12]
     8be:	9300      	str	r3, [sp, #0]
     8c0:	002b      	movs	r3, r5
     8c2:	0022      	movs	r2, r4
     8c4:	f001 fa0f 	bl	1ce6 <u8g2_IsIntersection>
     8c8:	1e03      	subs	r3, r0, #0
     8ca:	d010      	beq.n	8ee <u8g2_DrawCircle+0x96>
  }
#endif /* U8G2_WITH_INTERSECTION */
  
  
  /* draw circle */
  u8g2_draw_circle(u8g2, x0, y0, rad, option);
     8cc:	1dbb      	adds	r3, r7, #6
     8ce:	881c      	ldrh	r4, [r3, #0]
     8d0:	2308      	movs	r3, #8
     8d2:	18fb      	adds	r3, r7, r3
     8d4:	881a      	ldrh	r2, [r3, #0]
     8d6:	230a      	movs	r3, #10
     8d8:	18fb      	adds	r3, r7, r3
     8da:	8819      	ldrh	r1, [r3, #0]
     8dc:	68f8      	ldr	r0, [r7, #12]
     8de:	2320      	movs	r3, #32
     8e0:	18fb      	adds	r3, r7, r3
     8e2:	781b      	ldrb	r3, [r3, #0]
     8e4:	9300      	str	r3, [sp, #0]
     8e6:	0023      	movs	r3, r4
     8e8:	f7ff ff02 	bl	6f0 <u8g2_draw_circle>
     8ec:	e000      	b.n	8f0 <u8g2_DrawCircle+0x98>
      return;
     8ee:	46c0      	nop			; (mov r8, r8)
}
     8f0:	46bd      	mov	sp, r7
     8f2:	b004      	add	sp, #16
     8f4:	bdb0      	pop	{r4, r5, r7, pc}
	...

000008f8 <u8g2_m_32_7_f>:
  *page_cnt = 2;
  return buf;
  #endif
}
uint8_t *u8g2_m_32_7_f(uint8_t *page_cnt)
{
     8f8:	b580      	push	{r7, lr}
     8fa:	b082      	sub	sp, #8
     8fc:	af00      	add	r7, sp, #0
     8fe:	6078      	str	r0, [r7, #4]
  #ifdef U8G2_USE_DYNAMIC_ALLOC
  *page_cnt = 7;
  return 0;
  #else
  static uint8_t buf[1792];
  *page_cnt = 7;
     900:	687b      	ldr	r3, [r7, #4]
     902:	2207      	movs	r2, #7
     904:	701a      	strb	r2, [r3, #0]
  return buf;
     906:	4b02      	ldr	r3, [pc, #8]	; (910 <u8g2_m_32_7_f+0x18>)
  #endif
}
     908:	0018      	movs	r0, r3
     90a:	46bd      	mov	sp, r7
     90c:	b002      	add	sp, #8
     90e:	bd80      	pop	{r7, pc}
     910:	200000ac 	.word	0x200000ac

00000914 <u8g2_Setup_gp1287ai_256x50_f>:
  buf = u8g2_m_32_7_2(&tile_buf_height);
  u8g2_SetupBuffer(u8g2, buf, tile_buf_height, u8g2_ll_hvline_vertical_top_lsb, rotation);
}
/* gp1287ai f */
void u8g2_Setup_gp1287ai_256x50_f(u8g2_t *u8g2, const u8g2_cb_t *rotation, u8x8_msg_cb byte_cb, u8x8_msg_cb gpio_and_delay_cb)
{
     914:	b590      	push	{r4, r7, lr}
     916:	b089      	sub	sp, #36	; 0x24
     918:	af02      	add	r7, sp, #8
     91a:	60f8      	str	r0, [r7, #12]
     91c:	60b9      	str	r1, [r7, #8]
     91e:	607a      	str	r2, [r7, #4]
     920:	603b      	str	r3, [r7, #0]
  uint8_t tile_buf_height;
  uint8_t *buf;
  u8g2_SetupDisplay(u8g2, u8x8_d_gp1287ai_256x50, u8x8_cad_empty, byte_cb, gpio_and_delay_cb);
     922:	687c      	ldr	r4, [r7, #4]
     924:	4a0e      	ldr	r2, [pc, #56]	; (960 <u8g2_Setup_gp1287ai_256x50_f+0x4c>)
     926:	490f      	ldr	r1, [pc, #60]	; (964 <u8g2_Setup_gp1287ai_256x50_f+0x50>)
     928:	68f8      	ldr	r0, [r7, #12]
     92a:	683b      	ldr	r3, [r7, #0]
     92c:	9300      	str	r3, [sp, #0]
     92e:	0023      	movs	r3, r4
     930:	f002 fac4 	bl	2ebc <u8x8_Setup>
  buf = u8g2_m_32_7_f(&tile_buf_height);
     934:	2313      	movs	r3, #19
     936:	18fb      	adds	r3, r7, r3
     938:	0018      	movs	r0, r3
     93a:	f7ff ffdd 	bl	8f8 <u8g2_m_32_7_f>
     93e:	0003      	movs	r3, r0
     940:	617b      	str	r3, [r7, #20]
  u8g2_SetupBuffer(u8g2, buf, tile_buf_height, u8g2_ll_hvline_vertical_top_lsb, rotation);
     942:	2313      	movs	r3, #19
     944:	18fb      	adds	r3, r7, r3
     946:	781a      	ldrb	r2, [r3, #0]
     948:	4c07      	ldr	r4, [pc, #28]	; (968 <u8g2_Setup_gp1287ai_256x50_f+0x54>)
     94a:	6979      	ldr	r1, [r7, #20]
     94c:	68f8      	ldr	r0, [r7, #12]
     94e:	68bb      	ldr	r3, [r7, #8]
     950:	9300      	str	r3, [sp, #0]
     952:	0023      	movs	r3, r4
     954:	f001 fc4e 	bl	21f4 <u8g2_SetupBuffer>
}
     958:	46c0      	nop			; (mov r8, r8)
     95a:	46bd      	mov	sp, r7
     95c:	b007      	add	sp, #28
     95e:	bd90      	pop	{r4, r7, pc}
     960:	0000270d 	.word	0x0000270d
     964:	00002d89 	.word	0x00002d89
     968:	00001fd1 	.word	0x00001fd1

0000096c <u8g2_font_get_byte>:
/* low level byte and word access */

/* removed NOINLINE, because it leads to smaller code, might also be faster */
//static uint8_t u8g2_font_get_byte(const uint8_t *font, uint8_t offset) U8G2_NOINLINE;
static uint8_t u8g2_font_get_byte(const uint8_t *font, uint8_t offset)
{
     96c:	b580      	push	{r7, lr}
     96e:	b082      	sub	sp, #8
     970:	af00      	add	r7, sp, #0
     972:	6078      	str	r0, [r7, #4]
     974:	000a      	movs	r2, r1
     976:	1cfb      	adds	r3, r7, #3
     978:	701a      	strb	r2, [r3, #0]
  font += offset;
     97a:	1cfb      	adds	r3, r7, #3
     97c:	781b      	ldrb	r3, [r3, #0]
     97e:	687a      	ldr	r2, [r7, #4]
     980:	18d3      	adds	r3, r2, r3
     982:	607b      	str	r3, [r7, #4]
  return u8x8_pgm_read( font );  
     984:	687b      	ldr	r3, [r7, #4]
     986:	781b      	ldrb	r3, [r3, #0]
}
     988:	0018      	movs	r0, r3
     98a:	46bd      	mov	sp, r7
     98c:	b002      	add	sp, #8
     98e:	bd80      	pop	{r7, pc}

00000990 <u8g2_font_get_word>:

static uint16_t u8g2_font_get_word(const uint8_t *font, uint8_t offset) U8G2_NOINLINE; 
static uint16_t u8g2_font_get_word(const uint8_t *font, uint8_t offset)
{
     990:	b580      	push	{r7, lr}
     992:	b084      	sub	sp, #16
     994:	af00      	add	r7, sp, #0
     996:	6078      	str	r0, [r7, #4]
     998:	000a      	movs	r2, r1
     99a:	1cfb      	adds	r3, r7, #3
     99c:	701a      	strb	r2, [r3, #0]
    uint16_t pos;
    font += offset;
     99e:	1cfb      	adds	r3, r7, #3
     9a0:	781b      	ldrb	r3, [r3, #0]
     9a2:	687a      	ldr	r2, [r7, #4]
     9a4:	18d3      	adds	r3, r2, r3
     9a6:	607b      	str	r3, [r7, #4]
    pos = u8x8_pgm_read( font );
     9a8:	687b      	ldr	r3, [r7, #4]
     9aa:	781a      	ldrb	r2, [r3, #0]
     9ac:	230e      	movs	r3, #14
     9ae:	18fb      	adds	r3, r7, r3
     9b0:	801a      	strh	r2, [r3, #0]
    font++;
     9b2:	687b      	ldr	r3, [r7, #4]
     9b4:	3301      	adds	r3, #1
     9b6:	607b      	str	r3, [r7, #4]
    pos <<= 8;
     9b8:	230e      	movs	r3, #14
     9ba:	18fb      	adds	r3, r7, r3
     9bc:	220e      	movs	r2, #14
     9be:	18ba      	adds	r2, r7, r2
     9c0:	8812      	ldrh	r2, [r2, #0]
     9c2:	0212      	lsls	r2, r2, #8
     9c4:	801a      	strh	r2, [r3, #0]
    pos += u8x8_pgm_read( font);
     9c6:	687b      	ldr	r3, [r7, #4]
     9c8:	781b      	ldrb	r3, [r3, #0]
     9ca:	b299      	uxth	r1, r3
     9cc:	230e      	movs	r3, #14
     9ce:	18fb      	adds	r3, r7, r3
     9d0:	220e      	movs	r2, #14
     9d2:	18ba      	adds	r2, r7, r2
     9d4:	8812      	ldrh	r2, [r2, #0]
     9d6:	188a      	adds	r2, r1, r2
     9d8:	801a      	strh	r2, [r3, #0]
    return pos;
     9da:	230e      	movs	r3, #14
     9dc:	18fb      	adds	r3, r7, r3
     9de:	881b      	ldrh	r3, [r3, #0]
}
     9e0:	0018      	movs	r0, r3
     9e2:	46bd      	mov	sp, r7
     9e4:	b004      	add	sp, #16
     9e6:	bd80      	pop	{r7, pc}

000009e8 <u8g2_read_font_info>:

/*========================================================================*/
/* new font format */
void u8g2_read_font_info(u8g2_font_info_t *font_info, const uint8_t *font)
{
     9e8:	b580      	push	{r7, lr}
     9ea:	b082      	sub	sp, #8
     9ec:	af00      	add	r7, sp, #0
     9ee:	6078      	str	r0, [r7, #4]
     9f0:	6039      	str	r1, [r7, #0]
  /* offset 0 */
  font_info->glyph_cnt = u8g2_font_get_byte(font, 0);
     9f2:	683b      	ldr	r3, [r7, #0]
     9f4:	2100      	movs	r1, #0
     9f6:	0018      	movs	r0, r3
     9f8:	f7ff ffb8 	bl	96c <u8g2_font_get_byte>
     9fc:	0003      	movs	r3, r0
     9fe:	001a      	movs	r2, r3
     a00:	687b      	ldr	r3, [r7, #4]
     a02:	701a      	strb	r2, [r3, #0]
  font_info->bbx_mode = u8g2_font_get_byte(font, 1);
     a04:	683b      	ldr	r3, [r7, #0]
     a06:	2101      	movs	r1, #1
     a08:	0018      	movs	r0, r3
     a0a:	f7ff ffaf 	bl	96c <u8g2_font_get_byte>
     a0e:	0003      	movs	r3, r0
     a10:	001a      	movs	r2, r3
     a12:	687b      	ldr	r3, [r7, #4]
     a14:	705a      	strb	r2, [r3, #1]
  font_info->bits_per_0 = u8g2_font_get_byte(font, 2);
     a16:	683b      	ldr	r3, [r7, #0]
     a18:	2102      	movs	r1, #2
     a1a:	0018      	movs	r0, r3
     a1c:	f7ff ffa6 	bl	96c <u8g2_font_get_byte>
     a20:	0003      	movs	r3, r0
     a22:	001a      	movs	r2, r3
     a24:	687b      	ldr	r3, [r7, #4]
     a26:	709a      	strb	r2, [r3, #2]
  font_info->bits_per_1 = u8g2_font_get_byte(font, 3);
     a28:	683b      	ldr	r3, [r7, #0]
     a2a:	2103      	movs	r1, #3
     a2c:	0018      	movs	r0, r3
     a2e:	f7ff ff9d 	bl	96c <u8g2_font_get_byte>
     a32:	0003      	movs	r3, r0
     a34:	001a      	movs	r2, r3
     a36:	687b      	ldr	r3, [r7, #4]
     a38:	70da      	strb	r2, [r3, #3]
  
  /* offset 4 */
  font_info->bits_per_char_width = u8g2_font_get_byte(font, 4);
     a3a:	683b      	ldr	r3, [r7, #0]
     a3c:	2104      	movs	r1, #4
     a3e:	0018      	movs	r0, r3
     a40:	f7ff ff94 	bl	96c <u8g2_font_get_byte>
     a44:	0003      	movs	r3, r0
     a46:	001a      	movs	r2, r3
     a48:	687b      	ldr	r3, [r7, #4]
     a4a:	711a      	strb	r2, [r3, #4]
  font_info->bits_per_char_height = u8g2_font_get_byte(font, 5);
     a4c:	683b      	ldr	r3, [r7, #0]
     a4e:	2105      	movs	r1, #5
     a50:	0018      	movs	r0, r3
     a52:	f7ff ff8b 	bl	96c <u8g2_font_get_byte>
     a56:	0003      	movs	r3, r0
     a58:	001a      	movs	r2, r3
     a5a:	687b      	ldr	r3, [r7, #4]
     a5c:	715a      	strb	r2, [r3, #5]
  font_info->bits_per_char_x = u8g2_font_get_byte(font, 6);
     a5e:	683b      	ldr	r3, [r7, #0]
     a60:	2106      	movs	r1, #6
     a62:	0018      	movs	r0, r3
     a64:	f7ff ff82 	bl	96c <u8g2_font_get_byte>
     a68:	0003      	movs	r3, r0
     a6a:	001a      	movs	r2, r3
     a6c:	687b      	ldr	r3, [r7, #4]
     a6e:	719a      	strb	r2, [r3, #6]
  font_info->bits_per_char_y = u8g2_font_get_byte(font, 7);
     a70:	683b      	ldr	r3, [r7, #0]
     a72:	2107      	movs	r1, #7
     a74:	0018      	movs	r0, r3
     a76:	f7ff ff79 	bl	96c <u8g2_font_get_byte>
     a7a:	0003      	movs	r3, r0
     a7c:	001a      	movs	r2, r3
     a7e:	687b      	ldr	r3, [r7, #4]
     a80:	71da      	strb	r2, [r3, #7]
  font_info->bits_per_delta_x = u8g2_font_get_byte(font, 8);
     a82:	683b      	ldr	r3, [r7, #0]
     a84:	2108      	movs	r1, #8
     a86:	0018      	movs	r0, r3
     a88:	f7ff ff70 	bl	96c <u8g2_font_get_byte>
     a8c:	0003      	movs	r3, r0
     a8e:	001a      	movs	r2, r3
     a90:	687b      	ldr	r3, [r7, #4]
     a92:	721a      	strb	r2, [r3, #8]
  
  /* offset 9 */
  font_info->max_char_width = u8g2_font_get_byte(font, 9);
     a94:	683b      	ldr	r3, [r7, #0]
     a96:	2109      	movs	r1, #9
     a98:	0018      	movs	r0, r3
     a9a:	f7ff ff67 	bl	96c <u8g2_font_get_byte>
     a9e:	0003      	movs	r3, r0
     aa0:	b25a      	sxtb	r2, r3
     aa2:	687b      	ldr	r3, [r7, #4]
     aa4:	725a      	strb	r2, [r3, #9]
  font_info->max_char_height = u8g2_font_get_byte(font, 10);
     aa6:	683b      	ldr	r3, [r7, #0]
     aa8:	210a      	movs	r1, #10
     aaa:	0018      	movs	r0, r3
     aac:	f7ff ff5e 	bl	96c <u8g2_font_get_byte>
     ab0:	0003      	movs	r3, r0
     ab2:	b25a      	sxtb	r2, r3
     ab4:	687b      	ldr	r3, [r7, #4]
     ab6:	729a      	strb	r2, [r3, #10]
  font_info->x_offset = u8g2_font_get_byte(font, 11);
     ab8:	683b      	ldr	r3, [r7, #0]
     aba:	210b      	movs	r1, #11
     abc:	0018      	movs	r0, r3
     abe:	f7ff ff55 	bl	96c <u8g2_font_get_byte>
     ac2:	0003      	movs	r3, r0
     ac4:	b25a      	sxtb	r2, r3
     ac6:	687b      	ldr	r3, [r7, #4]
     ac8:	72da      	strb	r2, [r3, #11]
  font_info->y_offset = u8g2_font_get_byte(font, 12);
     aca:	683b      	ldr	r3, [r7, #0]
     acc:	210c      	movs	r1, #12
     ace:	0018      	movs	r0, r3
     ad0:	f7ff ff4c 	bl	96c <u8g2_font_get_byte>
     ad4:	0003      	movs	r3, r0
     ad6:	b25a      	sxtb	r2, r3
     ad8:	687b      	ldr	r3, [r7, #4]
     ada:	731a      	strb	r2, [r3, #12]
  
  /* offset 13 */
  font_info->ascent_A = u8g2_font_get_byte(font, 13);
     adc:	683b      	ldr	r3, [r7, #0]
     ade:	210d      	movs	r1, #13
     ae0:	0018      	movs	r0, r3
     ae2:	f7ff ff43 	bl	96c <u8g2_font_get_byte>
     ae6:	0003      	movs	r3, r0
     ae8:	b25a      	sxtb	r2, r3
     aea:	687b      	ldr	r3, [r7, #4]
     aec:	735a      	strb	r2, [r3, #13]
  font_info->descent_g = u8g2_font_get_byte(font, 14);
     aee:	683b      	ldr	r3, [r7, #0]
     af0:	210e      	movs	r1, #14
     af2:	0018      	movs	r0, r3
     af4:	f7ff ff3a 	bl	96c <u8g2_font_get_byte>
     af8:	0003      	movs	r3, r0
     afa:	b25a      	sxtb	r2, r3
     afc:	687b      	ldr	r3, [r7, #4]
     afe:	739a      	strb	r2, [r3, #14]
  font_info->ascent_para = u8g2_font_get_byte(font, 15);
     b00:	683b      	ldr	r3, [r7, #0]
     b02:	210f      	movs	r1, #15
     b04:	0018      	movs	r0, r3
     b06:	f7ff ff31 	bl	96c <u8g2_font_get_byte>
     b0a:	0003      	movs	r3, r0
     b0c:	b25a      	sxtb	r2, r3
     b0e:	687b      	ldr	r3, [r7, #4]
     b10:	73da      	strb	r2, [r3, #15]
  font_info->descent_para = u8g2_font_get_byte(font, 16);
     b12:	683b      	ldr	r3, [r7, #0]
     b14:	2110      	movs	r1, #16
     b16:	0018      	movs	r0, r3
     b18:	f7ff ff28 	bl	96c <u8g2_font_get_byte>
     b1c:	0003      	movs	r3, r0
     b1e:	b25a      	sxtb	r2, r3
     b20:	687b      	ldr	r3, [r7, #4]
     b22:	741a      	strb	r2, [r3, #16]
  
  /* offset 17 */
  font_info->start_pos_upper_A = u8g2_font_get_word(font, 17);
     b24:	683b      	ldr	r3, [r7, #0]
     b26:	2111      	movs	r1, #17
     b28:	0018      	movs	r0, r3
     b2a:	f7ff ff31 	bl	990 <u8g2_font_get_word>
     b2e:	0003      	movs	r3, r0
     b30:	001a      	movs	r2, r3
     b32:	687b      	ldr	r3, [r7, #4]
     b34:	825a      	strh	r2, [r3, #18]
  font_info->start_pos_lower_a = u8g2_font_get_word(font, 19); 
     b36:	683b      	ldr	r3, [r7, #0]
     b38:	2113      	movs	r1, #19
     b3a:	0018      	movs	r0, r3
     b3c:	f7ff ff28 	bl	990 <u8g2_font_get_word>
     b40:	0003      	movs	r3, r0
     b42:	001a      	movs	r2, r3
     b44:	687b      	ldr	r3, [r7, #4]
     b46:	829a      	strh	r2, [r3, #20]
  
  /* offset 21 */
#ifdef U8G2_WITH_UNICODE
  font_info->start_pos_unicode = u8g2_font_get_word(font, 21); 
     b48:	683b      	ldr	r3, [r7, #0]
     b4a:	2115      	movs	r1, #21
     b4c:	0018      	movs	r0, r3
     b4e:	f7ff ff1f 	bl	990 <u8g2_font_get_word>
     b52:	0003      	movs	r3, r0
     b54:	001a      	movs	r2, r3
     b56:	687b      	ldr	r3, [r7, #4]
     b58:	82da      	strh	r2, [r3, #22]
#endif
}
     b5a:	46c0      	nop			; (mov r8, r8)
     b5c:	46bd      	mov	sp, r7
     b5e:	b002      	add	sp, #8
     b60:	bd80      	pop	{r7, pc}

00000b62 <u8g2_font_decode_get_unsigned_bits>:
/*========================================================================*/
/* glyph handling */

/* optimized */
uint8_t u8g2_font_decode_get_unsigned_bits(u8g2_font_decode_t *f, uint8_t cnt) 
{
     b62:	b580      	push	{r7, lr}
     b64:	b084      	sub	sp, #16
     b66:	af00      	add	r7, sp, #0
     b68:	6078      	str	r0, [r7, #4]
     b6a:	000a      	movs	r2, r1
     b6c:	1cfb      	adds	r3, r7, #3
     b6e:	701a      	strb	r2, [r3, #0]
  uint8_t val;
  uint8_t bit_pos = f->decode_bit_pos;
     b70:	230d      	movs	r3, #13
     b72:	18fb      	adds	r3, r7, r3
     b74:	687a      	ldr	r2, [r7, #4]
     b76:	7b12      	ldrb	r2, [r2, #12]
     b78:	701a      	strb	r2, [r3, #0]
  uint8_t bit_pos_plus_cnt;
  
  //val = *(f->decode_ptr);
  val = u8x8_pgm_read( f->decode_ptr );  
     b7a:	687b      	ldr	r3, [r7, #4]
     b7c:	681a      	ldr	r2, [r3, #0]
     b7e:	230f      	movs	r3, #15
     b80:	18fb      	adds	r3, r7, r3
     b82:	7812      	ldrb	r2, [r2, #0]
     b84:	701a      	strb	r2, [r3, #0]
  
  val >>= bit_pos;
     b86:	230f      	movs	r3, #15
     b88:	18fb      	adds	r3, r7, r3
     b8a:	781a      	ldrb	r2, [r3, #0]
     b8c:	230d      	movs	r3, #13
     b8e:	18fb      	adds	r3, r7, r3
     b90:	781b      	ldrb	r3, [r3, #0]
     b92:	411a      	asrs	r2, r3
     b94:	230f      	movs	r3, #15
     b96:	18fb      	adds	r3, r7, r3
     b98:	701a      	strb	r2, [r3, #0]
  bit_pos_plus_cnt = bit_pos;
     b9a:	230e      	movs	r3, #14
     b9c:	18fb      	adds	r3, r7, r3
     b9e:	220d      	movs	r2, #13
     ba0:	18ba      	adds	r2, r7, r2
     ba2:	7812      	ldrb	r2, [r2, #0]
     ba4:	701a      	strb	r2, [r3, #0]
  bit_pos_plus_cnt += cnt;
     ba6:	230e      	movs	r3, #14
     ba8:	18fb      	adds	r3, r7, r3
     baa:	220e      	movs	r2, #14
     bac:	18b9      	adds	r1, r7, r2
     bae:	1cfa      	adds	r2, r7, #3
     bb0:	7809      	ldrb	r1, [r1, #0]
     bb2:	7812      	ldrb	r2, [r2, #0]
     bb4:	188a      	adds	r2, r1, r2
     bb6:	701a      	strb	r2, [r3, #0]
  if ( bit_pos_plus_cnt >= 8 )
     bb8:	230e      	movs	r3, #14
     bba:	18fb      	adds	r3, r7, r3
     bbc:	781b      	ldrb	r3, [r3, #0]
     bbe:	2b07      	cmp	r3, #7
     bc0:	d92c      	bls.n	c1c <u8g2_font_decode_get_unsigned_bits+0xba>
  {
    uint8_t s = 8;
     bc2:	230c      	movs	r3, #12
     bc4:	18fb      	adds	r3, r7, r3
     bc6:	2208      	movs	r2, #8
     bc8:	701a      	strb	r2, [r3, #0]
    s -= bit_pos;
     bca:	230c      	movs	r3, #12
     bcc:	18fb      	adds	r3, r7, r3
     bce:	220c      	movs	r2, #12
     bd0:	18b9      	adds	r1, r7, r2
     bd2:	220d      	movs	r2, #13
     bd4:	18ba      	adds	r2, r7, r2
     bd6:	7809      	ldrb	r1, [r1, #0]
     bd8:	7812      	ldrb	r2, [r2, #0]
     bda:	1a8a      	subs	r2, r1, r2
     bdc:	701a      	strb	r2, [r3, #0]
    f->decode_ptr++;
     bde:	687b      	ldr	r3, [r7, #4]
     be0:	681b      	ldr	r3, [r3, #0]
     be2:	1c5a      	adds	r2, r3, #1
     be4:	687b      	ldr	r3, [r7, #4]
     be6:	601a      	str	r2, [r3, #0]
    //val |= *(f->decode_ptr) << (8-bit_pos);
    val |= u8x8_pgm_read( f->decode_ptr ) << (s);
     be8:	687b      	ldr	r3, [r7, #4]
     bea:	681b      	ldr	r3, [r3, #0]
     bec:	781b      	ldrb	r3, [r3, #0]
     bee:	001a      	movs	r2, r3
     bf0:	230c      	movs	r3, #12
     bf2:	18fb      	adds	r3, r7, r3
     bf4:	781b      	ldrb	r3, [r3, #0]
     bf6:	409a      	lsls	r2, r3
     bf8:	0013      	movs	r3, r2
     bfa:	b25a      	sxtb	r2, r3
     bfc:	230f      	movs	r3, #15
     bfe:	18fb      	adds	r3, r7, r3
     c00:	781b      	ldrb	r3, [r3, #0]
     c02:	b25b      	sxtb	r3, r3
     c04:	4313      	orrs	r3, r2
     c06:	b25a      	sxtb	r2, r3
     c08:	230f      	movs	r3, #15
     c0a:	18fb      	adds	r3, r7, r3
     c0c:	701a      	strb	r2, [r3, #0]
    //bit_pos -= 8;
    bit_pos_plus_cnt -= 8;
     c0e:	230e      	movs	r3, #14
     c10:	18fb      	adds	r3, r7, r3
     c12:	220e      	movs	r2, #14
     c14:	18ba      	adds	r2, r7, r2
     c16:	7812      	ldrb	r2, [r2, #0]
     c18:	3a08      	subs	r2, #8
     c1a:	701a      	strb	r2, [r3, #0]
  }
  val &= (1U<<cnt)-1;
     c1c:	1cfb      	adds	r3, r7, #3
     c1e:	781b      	ldrb	r3, [r3, #0]
     c20:	2201      	movs	r2, #1
     c22:	409a      	lsls	r2, r3
     c24:	0013      	movs	r3, r2
     c26:	b2db      	uxtb	r3, r3
     c28:	3b01      	subs	r3, #1
     c2a:	b2da      	uxtb	r2, r3
     c2c:	230f      	movs	r3, #15
     c2e:	18fb      	adds	r3, r7, r3
     c30:	210f      	movs	r1, #15
     c32:	1879      	adds	r1, r7, r1
     c34:	7809      	ldrb	r1, [r1, #0]
     c36:	400a      	ands	r2, r1
     c38:	701a      	strb	r2, [r3, #0]
  //bit_pos += cnt;
  
  f->decode_bit_pos = bit_pos_plus_cnt;
     c3a:	687b      	ldr	r3, [r7, #4]
     c3c:	220e      	movs	r2, #14
     c3e:	18ba      	adds	r2, r7, r2
     c40:	7812      	ldrb	r2, [r2, #0]
     c42:	731a      	strb	r2, [r3, #12]
  return val;
     c44:	230f      	movs	r3, #15
     c46:	18fb      	adds	r3, r7, r3
     c48:	781b      	ldrb	r3, [r3, #0]
}
     c4a:	0018      	movs	r0, r3
     c4c:	46bd      	mov	sp, r7
     c4e:	b004      	add	sp, #16
     c50:	bd80      	pop	{r7, pc}

00000c52 <u8g2_font_decode_get_signed_bits>:
	r = bits(x)+1;

*/
/* optimized */
int8_t u8g2_font_decode_get_signed_bits(u8g2_font_decode_t *f, uint8_t cnt)
{
     c52:	b580      	push	{r7, lr}
     c54:	b084      	sub	sp, #16
     c56:	af00      	add	r7, sp, #0
     c58:	6078      	str	r0, [r7, #4]
     c5a:	000a      	movs	r2, r1
     c5c:	1cfb      	adds	r3, r7, #3
     c5e:	701a      	strb	r2, [r3, #0]
  int8_t v, d;
  v = (int8_t)u8g2_font_decode_get_unsigned_bits(f, cnt);
     c60:	1cfb      	adds	r3, r7, #3
     c62:	781a      	ldrb	r2, [r3, #0]
     c64:	687b      	ldr	r3, [r7, #4]
     c66:	0011      	movs	r1, r2
     c68:	0018      	movs	r0, r3
     c6a:	f7ff ff7a 	bl	b62 <u8g2_font_decode_get_unsigned_bits>
     c6e:	0003      	movs	r3, r0
     c70:	001a      	movs	r2, r3
     c72:	230f      	movs	r3, #15
     c74:	18fb      	adds	r3, r7, r3
     c76:	701a      	strb	r2, [r3, #0]
  d = 1;
     c78:	230e      	movs	r3, #14
     c7a:	18fb      	adds	r3, r7, r3
     c7c:	2201      	movs	r2, #1
     c7e:	701a      	strb	r2, [r3, #0]
  cnt--;
     c80:	1cfb      	adds	r3, r7, #3
     c82:	781a      	ldrb	r2, [r3, #0]
     c84:	1cfb      	adds	r3, r7, #3
     c86:	3a01      	subs	r2, #1
     c88:	701a      	strb	r2, [r3, #0]
  d <<= cnt;
     c8a:	230e      	movs	r3, #14
     c8c:	18fb      	adds	r3, r7, r3
     c8e:	2200      	movs	r2, #0
     c90:	569a      	ldrsb	r2, [r3, r2]
     c92:	1cfb      	adds	r3, r7, #3
     c94:	781b      	ldrb	r3, [r3, #0]
     c96:	409a      	lsls	r2, r3
     c98:	230e      	movs	r3, #14
     c9a:	18fb      	adds	r3, r7, r3
     c9c:	701a      	strb	r2, [r3, #0]
  v -= d;
     c9e:	230f      	movs	r3, #15
     ca0:	18fb      	adds	r3, r7, r3
     ca2:	781a      	ldrb	r2, [r3, #0]
     ca4:	230e      	movs	r3, #14
     ca6:	18fb      	adds	r3, r7, r3
     ca8:	781b      	ldrb	r3, [r3, #0]
     caa:	1ad3      	subs	r3, r2, r3
     cac:	b2da      	uxtb	r2, r3
     cae:	230f      	movs	r3, #15
     cb0:	18fb      	adds	r3, r7, r3
     cb2:	701a      	strb	r2, [r3, #0]
  return v;
     cb4:	230f      	movs	r3, #15
     cb6:	18fb      	adds	r3, r7, r3
     cb8:	781b      	ldrb	r3, [r3, #0]
     cba:	b25b      	sxtb	r3, r3
  //return (int8_t)u8g2_font_decode_get_unsigned_bits(f, cnt) - ((1<<cnt)>>1);
}
     cbc:	0018      	movs	r0, r3
     cbe:	46bd      	mov	sp, r7
     cc0:	b004      	add	sp, #16
     cc2:	bd80      	pop	{r7, pc}

00000cc4 <u8g2_add_vector_y>:


#ifdef U8G2_WITH_FONT_ROTATION
u8g2_uint_t u8g2_add_vector_y(u8g2_uint_t dy, int8_t x, int8_t y, uint8_t dir)
{
     cc4:	b5b0      	push	{r4, r5, r7, lr}
     cc6:	b082      	sub	sp, #8
     cc8:	af00      	add	r7, sp, #0
     cca:	0005      	movs	r5, r0
     ccc:	000c      	movs	r4, r1
     cce:	0010      	movs	r0, r2
     cd0:	0019      	movs	r1, r3
     cd2:	1dbb      	adds	r3, r7, #6
     cd4:	1c2a      	adds	r2, r5, #0
     cd6:	801a      	strh	r2, [r3, #0]
     cd8:	1d7b      	adds	r3, r7, #5
     cda:	1c22      	adds	r2, r4, #0
     cdc:	701a      	strb	r2, [r3, #0]
     cde:	1d3b      	adds	r3, r7, #4
     ce0:	1c02      	adds	r2, r0, #0
     ce2:	701a      	strb	r2, [r3, #0]
     ce4:	1cfb      	adds	r3, r7, #3
     ce6:	1c0a      	adds	r2, r1, #0
     ce8:	701a      	strb	r2, [r3, #0]
  switch(dir)
     cea:	1cfb      	adds	r3, r7, #3
     cec:	781b      	ldrb	r3, [r3, #0]
     cee:	2b01      	cmp	r3, #1
     cf0:	d00d      	beq.n	d0e <u8g2_add_vector_y+0x4a>
     cf2:	2b02      	cmp	r3, #2
     cf4:	d015      	beq.n	d22 <u8g2_add_vector_y+0x5e>
     cf6:	2b00      	cmp	r3, #0
     cf8:	d11d      	bne.n	d36 <u8g2_add_vector_y+0x72>
  {
    case 0:
      dy += y;
     cfa:	1d3b      	adds	r3, r7, #4
     cfc:	781b      	ldrb	r3, [r3, #0]
     cfe:	b25b      	sxtb	r3, r3
     d00:	b299      	uxth	r1, r3
     d02:	1dbb      	adds	r3, r7, #6
     d04:	1dba      	adds	r2, r7, #6
     d06:	8812      	ldrh	r2, [r2, #0]
     d08:	188a      	adds	r2, r1, r2
     d0a:	801a      	strh	r2, [r3, #0]
      break;
     d0c:	e01d      	b.n	d4a <u8g2_add_vector_y+0x86>
    case 1:
      dy += x;
     d0e:	1d7b      	adds	r3, r7, #5
     d10:	781b      	ldrb	r3, [r3, #0]
     d12:	b25b      	sxtb	r3, r3
     d14:	b299      	uxth	r1, r3
     d16:	1dbb      	adds	r3, r7, #6
     d18:	1dba      	adds	r2, r7, #6
     d1a:	8812      	ldrh	r2, [r2, #0]
     d1c:	188a      	adds	r2, r1, r2
     d1e:	801a      	strh	r2, [r3, #0]
      break;
     d20:	e013      	b.n	d4a <u8g2_add_vector_y+0x86>
    case 2:
      dy -= y;
     d22:	1d3b      	adds	r3, r7, #4
     d24:	781b      	ldrb	r3, [r3, #0]
     d26:	b25b      	sxtb	r3, r3
     d28:	b29a      	uxth	r2, r3
     d2a:	1dbb      	adds	r3, r7, #6
     d2c:	1db9      	adds	r1, r7, #6
     d2e:	8809      	ldrh	r1, [r1, #0]
     d30:	1a8a      	subs	r2, r1, r2
     d32:	801a      	strh	r2, [r3, #0]
      break;
     d34:	e009      	b.n	d4a <u8g2_add_vector_y+0x86>
    default:
      dy -= x;
     d36:	1d7b      	adds	r3, r7, #5
     d38:	781b      	ldrb	r3, [r3, #0]
     d3a:	b25b      	sxtb	r3, r3
     d3c:	b29a      	uxth	r2, r3
     d3e:	1dbb      	adds	r3, r7, #6
     d40:	1db9      	adds	r1, r7, #6
     d42:	8809      	ldrh	r1, [r1, #0]
     d44:	1a8a      	subs	r2, r1, r2
     d46:	801a      	strh	r2, [r3, #0]
      break;      
     d48:	46c0      	nop			; (mov r8, r8)
  }
  return dy;
     d4a:	1dbb      	adds	r3, r7, #6
     d4c:	881b      	ldrh	r3, [r3, #0]
}
     d4e:	0018      	movs	r0, r3
     d50:	46bd      	mov	sp, r7
     d52:	b002      	add	sp, #8
     d54:	bdb0      	pop	{r4, r5, r7, pc}

00000d56 <u8g2_add_vector_x>:

u8g2_uint_t u8g2_add_vector_x(u8g2_uint_t dx, int8_t x, int8_t y, uint8_t dir)
{
     d56:	b5b0      	push	{r4, r5, r7, lr}
     d58:	b082      	sub	sp, #8
     d5a:	af00      	add	r7, sp, #0
     d5c:	0005      	movs	r5, r0
     d5e:	000c      	movs	r4, r1
     d60:	0010      	movs	r0, r2
     d62:	0019      	movs	r1, r3
     d64:	1dbb      	adds	r3, r7, #6
     d66:	1c2a      	adds	r2, r5, #0
     d68:	801a      	strh	r2, [r3, #0]
     d6a:	1d7b      	adds	r3, r7, #5
     d6c:	1c22      	adds	r2, r4, #0
     d6e:	701a      	strb	r2, [r3, #0]
     d70:	1d3b      	adds	r3, r7, #4
     d72:	1c02      	adds	r2, r0, #0
     d74:	701a      	strb	r2, [r3, #0]
     d76:	1cfb      	adds	r3, r7, #3
     d78:	1c0a      	adds	r2, r1, #0
     d7a:	701a      	strb	r2, [r3, #0]
  switch(dir)
     d7c:	1cfb      	adds	r3, r7, #3
     d7e:	781b      	ldrb	r3, [r3, #0]
     d80:	2b01      	cmp	r3, #1
     d82:	d00d      	beq.n	da0 <u8g2_add_vector_x+0x4a>
     d84:	2b02      	cmp	r3, #2
     d86:	d015      	beq.n	db4 <u8g2_add_vector_x+0x5e>
     d88:	2b00      	cmp	r3, #0
     d8a:	d11d      	bne.n	dc8 <u8g2_add_vector_x+0x72>
  {
    case 0:
      dx += x;
     d8c:	1d7b      	adds	r3, r7, #5
     d8e:	781b      	ldrb	r3, [r3, #0]
     d90:	b25b      	sxtb	r3, r3
     d92:	b299      	uxth	r1, r3
     d94:	1dbb      	adds	r3, r7, #6
     d96:	1dba      	adds	r2, r7, #6
     d98:	8812      	ldrh	r2, [r2, #0]
     d9a:	188a      	adds	r2, r1, r2
     d9c:	801a      	strh	r2, [r3, #0]
      break;
     d9e:	e01d      	b.n	ddc <u8g2_add_vector_x+0x86>
    case 1:
      dx -= y;
     da0:	1d3b      	adds	r3, r7, #4
     da2:	781b      	ldrb	r3, [r3, #0]
     da4:	b25b      	sxtb	r3, r3
     da6:	b29a      	uxth	r2, r3
     da8:	1dbb      	adds	r3, r7, #6
     daa:	1db9      	adds	r1, r7, #6
     dac:	8809      	ldrh	r1, [r1, #0]
     dae:	1a8a      	subs	r2, r1, r2
     db0:	801a      	strh	r2, [r3, #0]
      break;
     db2:	e013      	b.n	ddc <u8g2_add_vector_x+0x86>
    case 2:
      dx -= x;
     db4:	1d7b      	adds	r3, r7, #5
     db6:	781b      	ldrb	r3, [r3, #0]
     db8:	b25b      	sxtb	r3, r3
     dba:	b29a      	uxth	r2, r3
     dbc:	1dbb      	adds	r3, r7, #6
     dbe:	1db9      	adds	r1, r7, #6
     dc0:	8809      	ldrh	r1, [r1, #0]
     dc2:	1a8a      	subs	r2, r1, r2
     dc4:	801a      	strh	r2, [r3, #0]
      break;
     dc6:	e009      	b.n	ddc <u8g2_add_vector_x+0x86>
    default:
      dx += y;
     dc8:	1d3b      	adds	r3, r7, #4
     dca:	781b      	ldrb	r3, [r3, #0]
     dcc:	b25b      	sxtb	r3, r3
     dce:	b299      	uxth	r1, r3
     dd0:	1dbb      	adds	r3, r7, #6
     dd2:	1dba      	adds	r2, r7, #6
     dd4:	8812      	ldrh	r2, [r2, #0]
     dd6:	188a      	adds	r2, r1, r2
     dd8:	801a      	strh	r2, [r3, #0]
      break;      
     dda:	46c0      	nop			; (mov r8, r8)
  }
  return dx;
     ddc:	1dbb      	adds	r3, r7, #6
     dde:	881b      	ldrh	r3, [r3, #0]
}
     de0:	0018      	movs	r0, r3
     de2:	46bd      	mov	sp, r7
     de4:	b002      	add	sp, #8
     de6:	bdb0      	pop	{r4, r5, r7, pc}

00000de8 <u8g2_font_decode_len>:
  Called by:
    u8g2_font_decode_glyph()
*/
/* optimized */
void u8g2_font_decode_len(u8g2_t *u8g2, uint8_t len, uint8_t is_foreground)
{
     de8:	b5b0      	push	{r4, r5, r7, lr}
     dea:	b088      	sub	sp, #32
     dec:	af02      	add	r7, sp, #8
     dee:	6078      	str	r0, [r7, #4]
     df0:	0008      	movs	r0, r1
     df2:	0011      	movs	r1, r2
     df4:	1cfb      	adds	r3, r7, #3
     df6:	1c02      	adds	r2, r0, #0
     df8:	701a      	strb	r2, [r3, #0]
     dfa:	1cbb      	adds	r3, r7, #2
     dfc:	1c0a      	adds	r2, r1, #0
     dfe:	701a      	strb	r2, [r3, #0]
  uint8_t lx,ly;
  
  /* target position on the screen */
  u8g2_uint_t x, y;
  
  u8g2_font_decode_t *decode = &(u8g2->font_decode);
     e00:	687b      	ldr	r3, [r7, #4]
     e02:	3360      	adds	r3, #96	; 0x60
     e04:	613b      	str	r3, [r7, #16]
  
  cnt = len;
     e06:	2317      	movs	r3, #23
     e08:	18fb      	adds	r3, r7, r3
     e0a:	1cfa      	adds	r2, r7, #3
     e0c:	7812      	ldrb	r2, [r2, #0]
     e0e:	701a      	strb	r2, [r3, #0]
  
  /* get the local position */
  lx = decode->x;
     e10:	693b      	ldr	r3, [r7, #16]
     e12:	2208      	movs	r2, #8
     e14:	569a      	ldrsb	r2, [r3, r2]
     e16:	2315      	movs	r3, #21
     e18:	18fb      	adds	r3, r7, r3
     e1a:	701a      	strb	r2, [r3, #0]
  ly = decode->y;
     e1c:	693b      	ldr	r3, [r7, #16]
     e1e:	2209      	movs	r2, #9
     e20:	569a      	ldrsb	r2, [r3, r2]
     e22:	2314      	movs	r3, #20
     e24:	18fb      	adds	r3, r7, r3
     e26:	701a      	strb	r2, [r3, #0]
  
  for(;;)
  {
    /* calculate the number of pixel to the right edge of the glyph */
    rem = decode->glyph_width;
     e28:	693b      	ldr	r3, [r7, #16]
     e2a:	220a      	movs	r2, #10
     e2c:	569a      	ldrsb	r2, [r3, r2]
     e2e:	230f      	movs	r3, #15
     e30:	18fb      	adds	r3, r7, r3
     e32:	701a      	strb	r2, [r3, #0]
    rem -= lx;
     e34:	230f      	movs	r3, #15
     e36:	18fb      	adds	r3, r7, r3
     e38:	220f      	movs	r2, #15
     e3a:	18b9      	adds	r1, r7, r2
     e3c:	2215      	movs	r2, #21
     e3e:	18ba      	adds	r2, r7, r2
     e40:	7809      	ldrb	r1, [r1, #0]
     e42:	7812      	ldrb	r2, [r2, #0]
     e44:	1a8a      	subs	r2, r1, r2
     e46:	701a      	strb	r2, [r3, #0]
    
    /* calculate how many pixel to draw. This is either to the right edge */
    /* or lesser, if not enough pixel are left */
    current = rem;
     e48:	2316      	movs	r3, #22
     e4a:	18fb      	adds	r3, r7, r3
     e4c:	220f      	movs	r2, #15
     e4e:	18ba      	adds	r2, r7, r2
     e50:	7812      	ldrb	r2, [r2, #0]
     e52:	701a      	strb	r2, [r3, #0]
    if ( cnt < rem )
     e54:	2317      	movs	r3, #23
     e56:	18fa      	adds	r2, r7, r3
     e58:	230f      	movs	r3, #15
     e5a:	18fb      	adds	r3, r7, r3
     e5c:	7812      	ldrb	r2, [r2, #0]
     e5e:	781b      	ldrb	r3, [r3, #0]
     e60:	429a      	cmp	r2, r3
     e62:	d205      	bcs.n	e70 <u8g2_font_decode_len+0x88>
      current = cnt;
     e64:	2316      	movs	r3, #22
     e66:	18fb      	adds	r3, r7, r3
     e68:	2217      	movs	r2, #23
     e6a:	18ba      	adds	r2, r7, r2
     e6c:	7812      	ldrb	r2, [r2, #0]
     e6e:	701a      	strb	r2, [r3, #0]
    
    /* now draw the line, but apply the rotation around the glyph target position */
    //u8g2_font_decode_draw_pixel(u8g2, lx,ly,current, is_foreground);

    /* get target position */
    x = decode->target_x;
     e70:	230c      	movs	r3, #12
     e72:	18fb      	adds	r3, r7, r3
     e74:	693a      	ldr	r2, [r7, #16]
     e76:	8892      	ldrh	r2, [r2, #4]
     e78:	801a      	strh	r2, [r3, #0]
    y = decode->target_y;
     e7a:	230a      	movs	r3, #10
     e7c:	18fb      	adds	r3, r7, r3
     e7e:	693a      	ldr	r2, [r7, #16]
     e80:	88d2      	ldrh	r2, [r2, #6]
     e82:	801a      	strh	r2, [r3, #0]

    /* apply rotation */
#ifdef U8G2_WITH_FONT_ROTATION
    
    x = u8g2_add_vector_x(x, lx, ly, decode->dir);
     e84:	2315      	movs	r3, #21
     e86:	18fb      	adds	r3, r7, r3
     e88:	2100      	movs	r1, #0
     e8a:	5659      	ldrsb	r1, [r3, r1]
     e8c:	2314      	movs	r3, #20
     e8e:	18fb      	adds	r3, r7, r3
     e90:	2200      	movs	r2, #0
     e92:	569a      	ldrsb	r2, [r3, r2]
     e94:	693b      	ldr	r3, [r7, #16]
     e96:	7c1d      	ldrb	r5, [r3, #16]
     e98:	230c      	movs	r3, #12
     e9a:	18fc      	adds	r4, r7, r3
     e9c:	230c      	movs	r3, #12
     e9e:	18fb      	adds	r3, r7, r3
     ea0:	8818      	ldrh	r0, [r3, #0]
     ea2:	002b      	movs	r3, r5
     ea4:	f7ff ff57 	bl	d56 <u8g2_add_vector_x>
     ea8:	0003      	movs	r3, r0
     eaa:	8023      	strh	r3, [r4, #0]
    y = u8g2_add_vector_y(y, lx, ly, decode->dir);
     eac:	2315      	movs	r3, #21
     eae:	18fb      	adds	r3, r7, r3
     eb0:	2100      	movs	r1, #0
     eb2:	5659      	ldrsb	r1, [r3, r1]
     eb4:	2314      	movs	r3, #20
     eb6:	18fb      	adds	r3, r7, r3
     eb8:	2200      	movs	r2, #0
     eba:	569a      	ldrsb	r2, [r3, r2]
     ebc:	693b      	ldr	r3, [r7, #16]
     ebe:	7c1d      	ldrb	r5, [r3, #16]
     ec0:	230a      	movs	r3, #10
     ec2:	18fc      	adds	r4, r7, r3
     ec4:	230a      	movs	r3, #10
     ec6:	18fb      	adds	r3, r7, r3
     ec8:	8818      	ldrh	r0, [r3, #0]
     eca:	002b      	movs	r3, r5
     ecc:	f7ff fefa 	bl	cc4 <u8g2_add_vector_y>
     ed0:	0003      	movs	r3, r0
     ed2:	8023      	strh	r3, [r4, #0]
    x += lx;
    y += ly;
#endif
    
    /* draw foreground and background (if required) */
    if ( is_foreground )
     ed4:	1cbb      	adds	r3, r7, #2
     ed6:	781b      	ldrb	r3, [r3, #0]
     ed8:	2b00      	cmp	r3, #0
     eda:	d017      	beq.n	f0c <u8g2_font_decode_len+0x124>
    {
      u8g2->draw_color = decode->fg_color;			/* draw_color will be restored later */
     edc:	693b      	ldr	r3, [r7, #16]
     ede:	7b99      	ldrb	r1, [r3, #14]
     ee0:	687b      	ldr	r3, [r7, #4]
     ee2:	2292      	movs	r2, #146	; 0x92
     ee4:	5499      	strb	r1, [r3, r2]
      u8g2_DrawHVLine(u8g2, 
     ee6:	2316      	movs	r3, #22
     ee8:	18fb      	adds	r3, r7, r3
     eea:	781b      	ldrb	r3, [r3, #0]
     eec:	b29d      	uxth	r5, r3
     eee:	693b      	ldr	r3, [r7, #16]
     ef0:	7c1b      	ldrb	r3, [r3, #16]
     ef2:	220a      	movs	r2, #10
     ef4:	18ba      	adds	r2, r7, r2
     ef6:	8814      	ldrh	r4, [r2, #0]
     ef8:	220c      	movs	r2, #12
     efa:	18ba      	adds	r2, r7, r2
     efc:	8811      	ldrh	r1, [r2, #0]
     efe:	6878      	ldr	r0, [r7, #4]
     f00:	9300      	str	r3, [sp, #0]
     f02:	002b      	movs	r3, r5
     f04:	0022      	movs	r2, r4
     f06:	f000 fd70 	bl	19ea <u8g2_DrawHVLine>
     f0a:	e01a      	b.n	f42 <u8g2_font_decode_len+0x15a>
#else
	0
#endif
      );
    }
    else if ( decode->is_transparent == 0 )    
     f0c:	693b      	ldr	r3, [r7, #16]
     f0e:	7b5b      	ldrb	r3, [r3, #13]
     f10:	2b00      	cmp	r3, #0
     f12:	d116      	bne.n	f42 <u8g2_font_decode_len+0x15a>
    {
      u8g2->draw_color = decode->bg_color;			/* draw_color will be restored later */
     f14:	693b      	ldr	r3, [r7, #16]
     f16:	7bd9      	ldrb	r1, [r3, #15]
     f18:	687b      	ldr	r3, [r7, #4]
     f1a:	2292      	movs	r2, #146	; 0x92
     f1c:	5499      	strb	r1, [r3, r2]
      u8g2_DrawHVLine(u8g2, 
     f1e:	2316      	movs	r3, #22
     f20:	18fb      	adds	r3, r7, r3
     f22:	781b      	ldrb	r3, [r3, #0]
     f24:	b29d      	uxth	r5, r3
     f26:	693b      	ldr	r3, [r7, #16]
     f28:	7c1b      	ldrb	r3, [r3, #16]
     f2a:	220a      	movs	r2, #10
     f2c:	18ba      	adds	r2, r7, r2
     f2e:	8814      	ldrh	r4, [r2, #0]
     f30:	220c      	movs	r2, #12
     f32:	18ba      	adds	r2, r7, r2
     f34:	8811      	ldrh	r1, [r2, #0]
     f36:	6878      	ldr	r0, [r7, #4]
     f38:	9300      	str	r3, [sp, #0]
     f3a:	002b      	movs	r3, r5
     f3c:	0022      	movs	r2, r4
     f3e:	f000 fd54 	bl	19ea <u8g2_DrawHVLine>
#endif
      );   
    }
    
    /* check, whether the end of the run length code has been reached */
    if ( cnt < rem )
     f42:	2317      	movs	r3, #23
     f44:	18fa      	adds	r2, r7, r3
     f46:	230f      	movs	r3, #15
     f48:	18fb      	adds	r3, r7, r3
     f4a:	7812      	ldrb	r2, [r2, #0]
     f4c:	781b      	ldrb	r3, [r3, #0]
     f4e:	429a      	cmp	r2, r3
     f50:	d315      	bcc.n	f7e <u8g2_font_decode_len+0x196>
      break;
    cnt -= rem;
     f52:	2317      	movs	r3, #23
     f54:	18fb      	adds	r3, r7, r3
     f56:	2217      	movs	r2, #23
     f58:	18b9      	adds	r1, r7, r2
     f5a:	220f      	movs	r2, #15
     f5c:	18ba      	adds	r2, r7, r2
     f5e:	7809      	ldrb	r1, [r1, #0]
     f60:	7812      	ldrb	r2, [r2, #0]
     f62:	1a8a      	subs	r2, r1, r2
     f64:	701a      	strb	r2, [r3, #0]
    lx = 0;
     f66:	2315      	movs	r3, #21
     f68:	18fb      	adds	r3, r7, r3
     f6a:	2200      	movs	r2, #0
     f6c:	701a      	strb	r2, [r3, #0]
    ly++;
     f6e:	2314      	movs	r3, #20
     f70:	18fb      	adds	r3, r7, r3
     f72:	781a      	ldrb	r2, [r3, #0]
     f74:	2314      	movs	r3, #20
     f76:	18fb      	adds	r3, r7, r3
     f78:	3201      	adds	r2, #1
     f7a:	701a      	strb	r2, [r3, #0]
    rem = decode->glyph_width;
     f7c:	e754      	b.n	e28 <u8g2_font_decode_len+0x40>
      break;
     f7e:	46c0      	nop			; (mov r8, r8)
  }
  lx += cnt;
     f80:	2315      	movs	r3, #21
     f82:	18fb      	adds	r3, r7, r3
     f84:	2215      	movs	r2, #21
     f86:	18b9      	adds	r1, r7, r2
     f88:	2217      	movs	r2, #23
     f8a:	18ba      	adds	r2, r7, r2
     f8c:	7809      	ldrb	r1, [r1, #0]
     f8e:	7812      	ldrb	r2, [r2, #0]
     f90:	188a      	adds	r2, r1, r2
     f92:	701a      	strb	r2, [r3, #0]
  
  decode->x = lx;
     f94:	2315      	movs	r3, #21
     f96:	18fb      	adds	r3, r7, r3
     f98:	2200      	movs	r2, #0
     f9a:	569a      	ldrsb	r2, [r3, r2]
     f9c:	693b      	ldr	r3, [r7, #16]
     f9e:	721a      	strb	r2, [r3, #8]
  decode->y = ly;  
     fa0:	2314      	movs	r3, #20
     fa2:	18fb      	adds	r3, r7, r3
     fa4:	2200      	movs	r2, #0
     fa6:	569a      	ldrsb	r2, [r3, r2]
     fa8:	693b      	ldr	r3, [r7, #16]
     faa:	725a      	strb	r2, [r3, #9]
}
     fac:	46c0      	nop			; (mov r8, r8)
     fae:	46bd      	mov	sp, r7
     fb0:	b006      	add	sp, #24
     fb2:	bdb0      	pop	{r4, r5, r7, pc}

00000fb4 <u8g2_font_setup_decode>:
  
}


static void u8g2_font_setup_decode(u8g2_t *u8g2, const uint8_t *glyph_data)
{
     fb4:	b580      	push	{r7, lr}
     fb6:	b084      	sub	sp, #16
     fb8:	af00      	add	r7, sp, #0
     fba:	6078      	str	r0, [r7, #4]
     fbc:	6039      	str	r1, [r7, #0]
  u8g2_font_decode_t *decode = &(u8g2->font_decode);
     fbe:	687b      	ldr	r3, [r7, #4]
     fc0:	3360      	adds	r3, #96	; 0x60
     fc2:	60fb      	str	r3, [r7, #12]
  decode->decode_ptr = glyph_data;
     fc4:	68fb      	ldr	r3, [r7, #12]
     fc6:	683a      	ldr	r2, [r7, #0]
     fc8:	601a      	str	r2, [r3, #0]
  decode->decode_bit_pos = 0;
     fca:	68fb      	ldr	r3, [r7, #12]
     fcc:	2200      	movs	r2, #0
     fce:	731a      	strb	r2, [r3, #12]
  /*
  decode->decode_ptr += 1;
  decode->decode_ptr += 1;
  */
  
  decode->glyph_width = u8g2_font_decode_get_unsigned_bits(decode, u8g2->font_info.bits_per_char_width);
     fd0:	687b      	ldr	r3, [r7, #4]
     fd2:	2278      	movs	r2, #120	; 0x78
     fd4:	5c9a      	ldrb	r2, [r3, r2]
     fd6:	68fb      	ldr	r3, [r7, #12]
     fd8:	0011      	movs	r1, r2
     fda:	0018      	movs	r0, r3
     fdc:	f7ff fdc1 	bl	b62 <u8g2_font_decode_get_unsigned_bits>
     fe0:	0003      	movs	r3, r0
     fe2:	b25a      	sxtb	r2, r3
     fe4:	68fb      	ldr	r3, [r7, #12]
     fe6:	729a      	strb	r2, [r3, #10]
  decode->glyph_height = u8g2_font_decode_get_unsigned_bits(decode,u8g2->font_info.bits_per_char_height);
     fe8:	687b      	ldr	r3, [r7, #4]
     fea:	2279      	movs	r2, #121	; 0x79
     fec:	5c9a      	ldrb	r2, [r3, r2]
     fee:	68fb      	ldr	r3, [r7, #12]
     ff0:	0011      	movs	r1, r2
     ff2:	0018      	movs	r0, r3
     ff4:	f7ff fdb5 	bl	b62 <u8g2_font_decode_get_unsigned_bits>
     ff8:	0003      	movs	r3, r0
     ffa:	b25a      	sxtb	r2, r3
     ffc:	68fb      	ldr	r3, [r7, #12]
     ffe:	72da      	strb	r2, [r3, #11]
  
  decode->fg_color = u8g2->draw_color;
    1000:	687b      	ldr	r3, [r7, #4]
    1002:	2292      	movs	r2, #146	; 0x92
    1004:	5c9a      	ldrb	r2, [r3, r2]
    1006:	68fb      	ldr	r3, [r7, #12]
    1008:	739a      	strb	r2, [r3, #14]
  decode->bg_color = (decode->fg_color == 0 ? 1 : 0);
    100a:	68fb      	ldr	r3, [r7, #12]
    100c:	7b9b      	ldrb	r3, [r3, #14]
    100e:	425a      	negs	r2, r3
    1010:	4153      	adcs	r3, r2
    1012:	b2db      	uxtb	r3, r3
    1014:	001a      	movs	r2, r3
    1016:	68fb      	ldr	r3, [r7, #12]
    1018:	73da      	strb	r2, [r3, #15]
}
    101a:	46c0      	nop			; (mov r8, r8)
    101c:	46bd      	mov	sp, r7
    101e:	b004      	add	sp, #16
    1020:	bd80      	pop	{r7, pc}

00001022 <u8g2_font_decode_glyph>:
  Calls:
    u8g2_font_decode_len()
*/
/* optimized */
int8_t u8g2_font_decode_glyph(u8g2_t *u8g2, const uint8_t *glyph_data)
{
    1022:	b590      	push	{r4, r7, lr}
    1024:	b08b      	sub	sp, #44	; 0x2c
    1026:	af02      	add	r7, sp, #8
    1028:	6078      	str	r0, [r7, #4]
    102a:	6039      	str	r1, [r7, #0]
  uint8_t a, b;
  int8_t x, y;
  int8_t d;
  int8_t h;
  u8g2_font_decode_t *decode = &(u8g2->font_decode);
    102c:	687b      	ldr	r3, [r7, #4]
    102e:	3360      	adds	r3, #96	; 0x60
    1030:	617b      	str	r3, [r7, #20]
    
  u8g2_font_setup_decode(u8g2, glyph_data);     /* set values in u8g2->font_decode data structure */
    1032:	683a      	ldr	r2, [r7, #0]
    1034:	687b      	ldr	r3, [r7, #4]
    1036:	0011      	movs	r1, r2
    1038:	0018      	movs	r0, r3
    103a:	f7ff ffbb 	bl	fb4 <u8g2_font_setup_decode>
  h = u8g2->font_decode.glyph_height;
    103e:	2313      	movs	r3, #19
    1040:	18fb      	adds	r3, r7, r3
    1042:	687a      	ldr	r2, [r7, #4]
    1044:	216b      	movs	r1, #107	; 0x6b
    1046:	5c52      	ldrb	r2, [r2, r1]
    1048:	701a      	strb	r2, [r3, #0]
  
  x = u8g2_font_decode_get_signed_bits(decode, u8g2->font_info.bits_per_char_x);
    104a:	687b      	ldr	r3, [r7, #4]
    104c:	227a      	movs	r2, #122	; 0x7a
    104e:	5c9a      	ldrb	r2, [r3, r2]
    1050:	2312      	movs	r3, #18
    1052:	18fc      	adds	r4, r7, r3
    1054:	697b      	ldr	r3, [r7, #20]
    1056:	0011      	movs	r1, r2
    1058:	0018      	movs	r0, r3
    105a:	f7ff fdfa 	bl	c52 <u8g2_font_decode_get_signed_bits>
    105e:	0003      	movs	r3, r0
    1060:	7023      	strb	r3, [r4, #0]
  y = u8g2_font_decode_get_signed_bits(decode, u8g2->font_info.bits_per_char_y);
    1062:	687b      	ldr	r3, [r7, #4]
    1064:	227b      	movs	r2, #123	; 0x7b
    1066:	5c9a      	ldrb	r2, [r3, r2]
    1068:	2311      	movs	r3, #17
    106a:	18fc      	adds	r4, r7, r3
    106c:	697b      	ldr	r3, [r7, #20]
    106e:	0011      	movs	r1, r2
    1070:	0018      	movs	r0, r3
    1072:	f7ff fdee 	bl	c52 <u8g2_font_decode_get_signed_bits>
    1076:	0003      	movs	r3, r0
    1078:	7023      	strb	r3, [r4, #0]
  d = u8g2_font_decode_get_signed_bits(decode, u8g2->font_info.bits_per_delta_x);
    107a:	687b      	ldr	r3, [r7, #4]
    107c:	227c      	movs	r2, #124	; 0x7c
    107e:	5c9a      	ldrb	r2, [r3, r2]
    1080:	2310      	movs	r3, #16
    1082:	18fc      	adds	r4, r7, r3
    1084:	697b      	ldr	r3, [r7, #20]
    1086:	0011      	movs	r1, r2
    1088:	0018      	movs	r0, r3
    108a:	f7ff fde2 	bl	c52 <u8g2_font_decode_get_signed_bits>
    108e:	0003      	movs	r3, r0
    1090:	7023      	strb	r3, [r4, #0]
  
  if ( decode->glyph_width > 0 )
    1092:	697b      	ldr	r3, [r7, #20]
    1094:	7a9b      	ldrb	r3, [r3, #10]
    1096:	b25b      	sxtb	r3, r3
    1098:	2b00      	cmp	r3, #0
    109a:	dc00      	bgt.n	109e <u8g2_font_decode_glyph+0x7c>
    109c:	e14c      	b.n	1338 <u8g2_font_decode_glyph+0x316>
  {
#ifdef U8G2_WITH_FONT_ROTATION
    decode->target_x = u8g2_add_vector_x(decode->target_x, x, -(h+y), decode->dir);
    109e:	697b      	ldr	r3, [r7, #20]
    10a0:	8898      	ldrh	r0, [r3, #4]
    10a2:	2313      	movs	r3, #19
    10a4:	18fb      	adds	r3, r7, r3
    10a6:	781a      	ldrb	r2, [r3, #0]
    10a8:	2311      	movs	r3, #17
    10aa:	18fb      	adds	r3, r7, r3
    10ac:	781b      	ldrb	r3, [r3, #0]
    10ae:	18d3      	adds	r3, r2, r3
    10b0:	b2db      	uxtb	r3, r3
    10b2:	425b      	negs	r3, r3
    10b4:	b2db      	uxtb	r3, r3
    10b6:	b25a      	sxtb	r2, r3
    10b8:	697b      	ldr	r3, [r7, #20]
    10ba:	7c1c      	ldrb	r4, [r3, #16]
    10bc:	2312      	movs	r3, #18
    10be:	18fb      	adds	r3, r7, r3
    10c0:	2100      	movs	r1, #0
    10c2:	5659      	ldrsb	r1, [r3, r1]
    10c4:	0023      	movs	r3, r4
    10c6:	f7ff fe46 	bl	d56 <u8g2_add_vector_x>
    10ca:	0003      	movs	r3, r0
    10cc:	001a      	movs	r2, r3
    10ce:	697b      	ldr	r3, [r7, #20]
    10d0:	809a      	strh	r2, [r3, #4]
    decode->target_y = u8g2_add_vector_y(decode->target_y, x, -(h+y), decode->dir);
    10d2:	697b      	ldr	r3, [r7, #20]
    10d4:	88d8      	ldrh	r0, [r3, #6]
    10d6:	2313      	movs	r3, #19
    10d8:	18fb      	adds	r3, r7, r3
    10da:	781a      	ldrb	r2, [r3, #0]
    10dc:	2311      	movs	r3, #17
    10de:	18fb      	adds	r3, r7, r3
    10e0:	781b      	ldrb	r3, [r3, #0]
    10e2:	18d3      	adds	r3, r2, r3
    10e4:	b2db      	uxtb	r3, r3
    10e6:	425b      	negs	r3, r3
    10e8:	b2db      	uxtb	r3, r3
    10ea:	b25a      	sxtb	r2, r3
    10ec:	697b      	ldr	r3, [r7, #20]
    10ee:	7c1c      	ldrb	r4, [r3, #16]
    10f0:	2312      	movs	r3, #18
    10f2:	18fb      	adds	r3, r7, r3
    10f4:	2100      	movs	r1, #0
    10f6:	5659      	ldrsb	r1, [r3, r1]
    10f8:	0023      	movs	r3, r4
    10fa:	f7ff fde3 	bl	cc4 <u8g2_add_vector_y>
    10fe:	0003      	movs	r3, r0
    1100:	001a      	movs	r2, r3
    1102:	697b      	ldr	r3, [r7, #20]
    1104:	80da      	strh	r2, [r3, #6]
    //u8g2_add_vector(&(decode->target_x), &(decode->target_y), x, -(h+y), decode->dir);

#ifdef U8G2_WITH_INTERSECTION
    {
      u8g2_uint_t x0, x1, y0, y1;
      x0 = decode->target_x;
    1106:	231e      	movs	r3, #30
    1108:	18fb      	adds	r3, r7, r3
    110a:	697a      	ldr	r2, [r7, #20]
    110c:	8892      	ldrh	r2, [r2, #4]
    110e:	801a      	strh	r2, [r3, #0]
      y0 = decode->target_y;
    1110:	231a      	movs	r3, #26
    1112:	18fb      	adds	r3, r7, r3
    1114:	697a      	ldr	r2, [r7, #20]
    1116:	88d2      	ldrh	r2, [r2, #6]
    1118:	801a      	strh	r2, [r3, #0]
      x1 = x0;
    111a:	231c      	movs	r3, #28
    111c:	18fb      	adds	r3, r7, r3
    111e:	221e      	movs	r2, #30
    1120:	18ba      	adds	r2, r7, r2
    1122:	8812      	ldrh	r2, [r2, #0]
    1124:	801a      	strh	r2, [r3, #0]
      y1 = y0;
    1126:	2318      	movs	r3, #24
    1128:	18fb      	adds	r3, r7, r3
    112a:	221a      	movs	r2, #26
    112c:	18ba      	adds	r2, r7, r2
    112e:	8812      	ldrh	r2, [r2, #0]
    1130:	801a      	strh	r2, [r3, #0]
      
#ifdef U8G2_WITH_FONT_ROTATION
      switch(decode->dir)
    1132:	697b      	ldr	r3, [r7, #20]
    1134:	7c1b      	ldrb	r3, [r3, #16]
    1136:	2b01      	cmp	r3, #1
    1138:	d021      	beq.n	117e <u8g2_font_decode_glyph+0x15c>
    113a:	dc02      	bgt.n	1142 <u8g2_font_decode_glyph+0x120>
    113c:	2b00      	cmp	r3, #0
    113e:	d006      	beq.n	114e <u8g2_font_decode_glyph+0x12c>
    1140:	e09d      	b.n	127e <u8g2_font_decode_glyph+0x25c>
    1142:	2b02      	cmp	r3, #2
    1144:	d041      	beq.n	11ca <u8g2_font_decode_glyph+0x1a8>
    1146:	2b03      	cmp	r3, #3
    1148:	d100      	bne.n	114c <u8g2_font_decode_glyph+0x12a>
    114a:	e072      	b.n	1232 <u8g2_font_decode_glyph+0x210>
    114c:	e097      	b.n	127e <u8g2_font_decode_glyph+0x25c>
      {
	case 0:
	    x1 += decode->glyph_width;
    114e:	697b      	ldr	r3, [r7, #20]
    1150:	7a9b      	ldrb	r3, [r3, #10]
    1152:	b25b      	sxtb	r3, r3
    1154:	b299      	uxth	r1, r3
    1156:	231c      	movs	r3, #28
    1158:	18fb      	adds	r3, r7, r3
    115a:	221c      	movs	r2, #28
    115c:	18ba      	adds	r2, r7, r2
    115e:	8812      	ldrh	r2, [r2, #0]
    1160:	188a      	adds	r2, r1, r2
    1162:	801a      	strh	r2, [r3, #0]
	    y1 += h;
    1164:	2313      	movs	r3, #19
    1166:	18fb      	adds	r3, r7, r3
    1168:	781b      	ldrb	r3, [r3, #0]
    116a:	b25b      	sxtb	r3, r3
    116c:	b299      	uxth	r1, r3
    116e:	2318      	movs	r3, #24
    1170:	18fb      	adds	r3, r7, r3
    1172:	2218      	movs	r2, #24
    1174:	18ba      	adds	r2, r7, r2
    1176:	8812      	ldrh	r2, [r2, #0]
    1178:	188a      	adds	r2, r1, r2
    117a:	801a      	strh	r2, [r3, #0]
	    break;
    117c:	e07f      	b.n	127e <u8g2_font_decode_glyph+0x25c>
	case 1:
	    x0 -= h;
    117e:	2313      	movs	r3, #19
    1180:	18fb      	adds	r3, r7, r3
    1182:	781b      	ldrb	r3, [r3, #0]
    1184:	b25b      	sxtb	r3, r3
    1186:	b29a      	uxth	r2, r3
    1188:	231e      	movs	r3, #30
    118a:	18fb      	adds	r3, r7, r3
    118c:	211e      	movs	r1, #30
    118e:	1879      	adds	r1, r7, r1
    1190:	8809      	ldrh	r1, [r1, #0]
    1192:	1a8a      	subs	r2, r1, r2
    1194:	801a      	strh	r2, [r3, #0]
	    x0++;	/* shift down, because of assymetric boundaries for the interseciton test */
    1196:	231e      	movs	r3, #30
    1198:	18fb      	adds	r3, r7, r3
    119a:	881a      	ldrh	r2, [r3, #0]
    119c:	231e      	movs	r3, #30
    119e:	18fb      	adds	r3, r7, r3
    11a0:	3201      	adds	r2, #1
    11a2:	801a      	strh	r2, [r3, #0]
	    x1++;
    11a4:	231c      	movs	r3, #28
    11a6:	18fb      	adds	r3, r7, r3
    11a8:	881a      	ldrh	r2, [r3, #0]
    11aa:	231c      	movs	r3, #28
    11ac:	18fb      	adds	r3, r7, r3
    11ae:	3201      	adds	r2, #1
    11b0:	801a      	strh	r2, [r3, #0]
	    y1 += decode->glyph_width;
    11b2:	697b      	ldr	r3, [r7, #20]
    11b4:	7a9b      	ldrb	r3, [r3, #10]
    11b6:	b25b      	sxtb	r3, r3
    11b8:	b299      	uxth	r1, r3
    11ba:	2318      	movs	r3, #24
    11bc:	18fb      	adds	r3, r7, r3
    11be:	2218      	movs	r2, #24
    11c0:	18ba      	adds	r2, r7, r2
    11c2:	8812      	ldrh	r2, [r2, #0]
    11c4:	188a      	adds	r2, r1, r2
    11c6:	801a      	strh	r2, [r3, #0]
	    break;
    11c8:	e059      	b.n	127e <u8g2_font_decode_glyph+0x25c>
	case 2:
	    x0 -= decode->glyph_width;
    11ca:	697b      	ldr	r3, [r7, #20]
    11cc:	7a9b      	ldrb	r3, [r3, #10]
    11ce:	b25b      	sxtb	r3, r3
    11d0:	b29a      	uxth	r2, r3
    11d2:	231e      	movs	r3, #30
    11d4:	18fb      	adds	r3, r7, r3
    11d6:	211e      	movs	r1, #30
    11d8:	1879      	adds	r1, r7, r1
    11da:	8809      	ldrh	r1, [r1, #0]
    11dc:	1a8a      	subs	r2, r1, r2
    11de:	801a      	strh	r2, [r3, #0]
	    x0++;	/* shift down, because of assymetric boundaries for the interseciton test */
    11e0:	231e      	movs	r3, #30
    11e2:	18fb      	adds	r3, r7, r3
    11e4:	881a      	ldrh	r2, [r3, #0]
    11e6:	231e      	movs	r3, #30
    11e8:	18fb      	adds	r3, r7, r3
    11ea:	3201      	adds	r2, #1
    11ec:	801a      	strh	r2, [r3, #0]
	    x1++;
    11ee:	231c      	movs	r3, #28
    11f0:	18fb      	adds	r3, r7, r3
    11f2:	881a      	ldrh	r2, [r3, #0]
    11f4:	231c      	movs	r3, #28
    11f6:	18fb      	adds	r3, r7, r3
    11f8:	3201      	adds	r2, #1
    11fa:	801a      	strh	r2, [r3, #0]
	    y0 -= h;
    11fc:	2313      	movs	r3, #19
    11fe:	18fb      	adds	r3, r7, r3
    1200:	781b      	ldrb	r3, [r3, #0]
    1202:	b25b      	sxtb	r3, r3
    1204:	b29a      	uxth	r2, r3
    1206:	231a      	movs	r3, #26
    1208:	18fb      	adds	r3, r7, r3
    120a:	211a      	movs	r1, #26
    120c:	1879      	adds	r1, r7, r1
    120e:	8809      	ldrh	r1, [r1, #0]
    1210:	1a8a      	subs	r2, r1, r2
    1212:	801a      	strh	r2, [r3, #0]
	    y0++;	/* shift down, because of assymetric boundaries for the interseciton test */
    1214:	231a      	movs	r3, #26
    1216:	18fb      	adds	r3, r7, r3
    1218:	881a      	ldrh	r2, [r3, #0]
    121a:	231a      	movs	r3, #26
    121c:	18fb      	adds	r3, r7, r3
    121e:	3201      	adds	r2, #1
    1220:	801a      	strh	r2, [r3, #0]
	    y1++;
    1222:	2318      	movs	r3, #24
    1224:	18fb      	adds	r3, r7, r3
    1226:	881a      	ldrh	r2, [r3, #0]
    1228:	2318      	movs	r3, #24
    122a:	18fb      	adds	r3, r7, r3
    122c:	3201      	adds	r2, #1
    122e:	801a      	strh	r2, [r3, #0]
	    break;	  
    1230:	e025      	b.n	127e <u8g2_font_decode_glyph+0x25c>
	case 3:
	    x1 += h;
    1232:	2313      	movs	r3, #19
    1234:	18fb      	adds	r3, r7, r3
    1236:	781b      	ldrb	r3, [r3, #0]
    1238:	b25b      	sxtb	r3, r3
    123a:	b299      	uxth	r1, r3
    123c:	231c      	movs	r3, #28
    123e:	18fb      	adds	r3, r7, r3
    1240:	221c      	movs	r2, #28
    1242:	18ba      	adds	r2, r7, r2
    1244:	8812      	ldrh	r2, [r2, #0]
    1246:	188a      	adds	r2, r1, r2
    1248:	801a      	strh	r2, [r3, #0]
	    y0 -= decode->glyph_width;
    124a:	697b      	ldr	r3, [r7, #20]
    124c:	7a9b      	ldrb	r3, [r3, #10]
    124e:	b25b      	sxtb	r3, r3
    1250:	b29a      	uxth	r2, r3
    1252:	231a      	movs	r3, #26
    1254:	18fb      	adds	r3, r7, r3
    1256:	211a      	movs	r1, #26
    1258:	1879      	adds	r1, r7, r1
    125a:	8809      	ldrh	r1, [r1, #0]
    125c:	1a8a      	subs	r2, r1, r2
    125e:	801a      	strh	r2, [r3, #0]
	    y0++;	/* shift down, because of assymetric boundaries for the interseciton test */
    1260:	231a      	movs	r3, #26
    1262:	18fb      	adds	r3, r7, r3
    1264:	881a      	ldrh	r2, [r3, #0]
    1266:	231a      	movs	r3, #26
    1268:	18fb      	adds	r3, r7, r3
    126a:	3201      	adds	r2, #1
    126c:	801a      	strh	r2, [r3, #0]
	    y1++;
    126e:	2318      	movs	r3, #24
    1270:	18fb      	adds	r3, r7, r3
    1272:	881a      	ldrh	r2, [r3, #0]
    1274:	2318      	movs	r3, #24
    1276:	18fb      	adds	r3, r7, r3
    1278:	3201      	adds	r2, #1
    127a:	801a      	strh	r2, [r3, #0]
	    break;	  
    127c:	46c0      	nop			; (mov r8, r8)
#else /* U8G2_WITH_FONT_ROTATION */
      x1 += decode->glyph_width;
      y1 += h;      
#endif
      
      if ( u8g2_IsIntersection(u8g2, x0, y0, x1, y1) == 0 ) 
    127e:	231c      	movs	r3, #28
    1280:	18fb      	adds	r3, r7, r3
    1282:	881c      	ldrh	r4, [r3, #0]
    1284:	231a      	movs	r3, #26
    1286:	18fb      	adds	r3, r7, r3
    1288:	881a      	ldrh	r2, [r3, #0]
    128a:	231e      	movs	r3, #30
    128c:	18fb      	adds	r3, r7, r3
    128e:	8819      	ldrh	r1, [r3, #0]
    1290:	6878      	ldr	r0, [r7, #4]
    1292:	2318      	movs	r3, #24
    1294:	18fb      	adds	r3, r7, r3
    1296:	881b      	ldrh	r3, [r3, #0]
    1298:	9300      	str	r3, [sp, #0]
    129a:	0023      	movs	r3, r4
    129c:	f000 fd23 	bl	1ce6 <u8g2_IsIntersection>
    12a0:	1e03      	subs	r3, r0, #0
    12a2:	d104      	bne.n	12ae <u8g2_font_decode_glyph+0x28c>
	return d;
    12a4:	2310      	movs	r3, #16
    12a6:	18fb      	adds	r3, r7, r3
    12a8:	781b      	ldrb	r3, [r3, #0]
    12aa:	b25b      	sxtb	r3, r3
    12ac:	e048      	b.n	1340 <u8g2_font_decode_glyph+0x31e>
    }
#endif /* U8G2_WITH_INTERSECTION */
   
    /* reset local x/y position */
    decode->x = 0;
    12ae:	697b      	ldr	r3, [r7, #20]
    12b0:	2200      	movs	r2, #0
    12b2:	721a      	strb	r2, [r3, #8]
    decode->y = 0;
    12b4:	697b      	ldr	r3, [r7, #20]
    12b6:	2200      	movs	r2, #0
    12b8:	725a      	strb	r2, [r3, #9]
    
    /* decode glyph */
    for(;;)
    {
      a = u8g2_font_decode_get_unsigned_bits(decode, u8g2->font_info.bits_per_0);
    12ba:	687b      	ldr	r3, [r7, #4]
    12bc:	2276      	movs	r2, #118	; 0x76
    12be:	5c9a      	ldrb	r2, [r3, r2]
    12c0:	230f      	movs	r3, #15
    12c2:	18fc      	adds	r4, r7, r3
    12c4:	697b      	ldr	r3, [r7, #20]
    12c6:	0011      	movs	r1, r2
    12c8:	0018      	movs	r0, r3
    12ca:	f7ff fc4a 	bl	b62 <u8g2_font_decode_get_unsigned_bits>
    12ce:	0003      	movs	r3, r0
    12d0:	7023      	strb	r3, [r4, #0]
      b = u8g2_font_decode_get_unsigned_bits(decode, u8g2->font_info.bits_per_1);
    12d2:	687b      	ldr	r3, [r7, #4]
    12d4:	2277      	movs	r2, #119	; 0x77
    12d6:	5c9a      	ldrb	r2, [r3, r2]
    12d8:	230e      	movs	r3, #14
    12da:	18fc      	adds	r4, r7, r3
    12dc:	697b      	ldr	r3, [r7, #20]
    12de:	0011      	movs	r1, r2
    12e0:	0018      	movs	r0, r3
    12e2:	f7ff fc3e 	bl	b62 <u8g2_font_decode_get_unsigned_bits>
    12e6:	0003      	movs	r3, r0
    12e8:	7023      	strb	r3, [r4, #0]
      do
      {
	u8g2_font_decode_len(u8g2, a, 0);
    12ea:	230f      	movs	r3, #15
    12ec:	18fb      	adds	r3, r7, r3
    12ee:	7819      	ldrb	r1, [r3, #0]
    12f0:	687b      	ldr	r3, [r7, #4]
    12f2:	2200      	movs	r2, #0
    12f4:	0018      	movs	r0, r3
    12f6:	f7ff fd77 	bl	de8 <u8g2_font_decode_len>
	u8g2_font_decode_len(u8g2, b, 1);
    12fa:	230e      	movs	r3, #14
    12fc:	18fb      	adds	r3, r7, r3
    12fe:	7819      	ldrb	r1, [r3, #0]
    1300:	687b      	ldr	r3, [r7, #4]
    1302:	2201      	movs	r2, #1
    1304:	0018      	movs	r0, r3
    1306:	f7ff fd6f 	bl	de8 <u8g2_font_decode_len>
      } while( u8g2_font_decode_get_unsigned_bits(decode, 1) != 0 );
    130a:	697b      	ldr	r3, [r7, #20]
    130c:	2101      	movs	r1, #1
    130e:	0018      	movs	r0, r3
    1310:	f7ff fc27 	bl	b62 <u8g2_font_decode_get_unsigned_bits>
    1314:	1e03      	subs	r3, r0, #0
    1316:	d1e8      	bne.n	12ea <u8g2_font_decode_glyph+0x2c8>

      if ( decode->y >= h )
    1318:	697b      	ldr	r3, [r7, #20]
    131a:	7a5b      	ldrb	r3, [r3, #9]
    131c:	b25b      	sxtb	r3, r3
    131e:	2213      	movs	r2, #19
    1320:	18ba      	adds	r2, r7, r2
    1322:	7812      	ldrb	r2, [r2, #0]
    1324:	b252      	sxtb	r2, r2
    1326:	429a      	cmp	r2, r3
    1328:	dd00      	ble.n	132c <u8g2_font_decode_glyph+0x30a>
      a = u8g2_font_decode_get_unsigned_bits(decode, u8g2->font_info.bits_per_0);
    132a:	e7c6      	b.n	12ba <u8g2_font_decode_glyph+0x298>
	break;
    132c:	46c0      	nop			; (mov r8, r8)
    }
    
    /* restore the u8g2 draw color, because this is modified by the decode algo */
    u8g2->draw_color = decode->fg_color;
    132e:	697b      	ldr	r3, [r7, #20]
    1330:	7b99      	ldrb	r1, [r3, #14]
    1332:	687b      	ldr	r3, [r7, #4]
    1334:	2292      	movs	r2, #146	; 0x92
    1336:	5499      	strb	r1, [r3, r2]
  }
  return d;
    1338:	2310      	movs	r3, #16
    133a:	18fb      	adds	r3, r7, r3
    133c:	781b      	ldrb	r3, [r3, #0]
    133e:	b25b      	sxtb	r3, r3
}
    1340:	0018      	movs	r0, r3
    1342:	46bd      	mov	sp, r7
    1344:	b009      	add	sp, #36	; 0x24
    1346:	bd90      	pop	{r4, r7, pc}

00001348 <u8g2_font_get_glyph_data>:
    encoding: Encoding (ASCII or Unicode) of the glyph
  Return:
    Address of the glyph data or NULL, if the encoding is not avialable in the font.
*/
const uint8_t *u8g2_font_get_glyph_data(u8g2_t *u8g2, uint16_t encoding)
{
    1348:	b590      	push	{r4, r7, lr}
    134a:	b087      	sub	sp, #28
    134c:	af00      	add	r7, sp, #0
    134e:	6078      	str	r0, [r7, #4]
    1350:	000a      	movs	r2, r1
    1352:	1cbb      	adds	r3, r7, #2
    1354:	801a      	strh	r2, [r3, #0]
  const uint8_t *font = u8g2->font;
    1356:	687b      	ldr	r3, [r7, #4]
    1358:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    135a:	617b      	str	r3, [r7, #20]
  font += U8G2_FONT_DATA_STRUCT_SIZE;
    135c:	697b      	ldr	r3, [r7, #20]
    135e:	3317      	adds	r3, #23
    1360:	617b      	str	r3, [r7, #20]

  
  if ( encoding <= 255 )
    1362:	1cbb      	adds	r3, r7, #2
    1364:	881b      	ldrh	r3, [r3, #0]
    1366:	2bff      	cmp	r3, #255	; 0xff
    1368:	d82d      	bhi.n	13c6 <u8g2_font_get_glyph_data+0x7e>
  {
    if ( encoding >= 'a' )
    136a:	1cbb      	adds	r3, r7, #2
    136c:	881b      	ldrh	r3, [r3, #0]
    136e:	2b60      	cmp	r3, #96	; 0x60
    1370:	d907      	bls.n	1382 <u8g2_font_get_glyph_data+0x3a>
    {
      font += u8g2->font_info.start_pos_lower_a;
    1372:	687b      	ldr	r3, [r7, #4]
    1374:	2288      	movs	r2, #136	; 0x88
    1376:	5a9b      	ldrh	r3, [r3, r2]
    1378:	001a      	movs	r2, r3
    137a:	697b      	ldr	r3, [r7, #20]
    137c:	189b      	adds	r3, r3, r2
    137e:	617b      	str	r3, [r7, #20]
    1380:	e00a      	b.n	1398 <u8g2_font_get_glyph_data+0x50>
    }
    else if ( encoding >= 'A' )
    1382:	1cbb      	adds	r3, r7, #2
    1384:	881b      	ldrh	r3, [r3, #0]
    1386:	2b40      	cmp	r3, #64	; 0x40
    1388:	d906      	bls.n	1398 <u8g2_font_get_glyph_data+0x50>
    {
      font += u8g2->font_info.start_pos_upper_A;
    138a:	687b      	ldr	r3, [r7, #4]
    138c:	2286      	movs	r2, #134	; 0x86
    138e:	5a9b      	ldrh	r3, [r3, r2]
    1390:	001a      	movs	r2, r3
    1392:	697b      	ldr	r3, [r7, #20]
    1394:	189b      	adds	r3, r3, r2
    1396:	617b      	str	r3, [r7, #20]
    }
    
    for(;;)
    {
      if ( u8x8_pgm_read( font + 1 ) == 0 )
    1398:	697b      	ldr	r3, [r7, #20]
    139a:	3301      	adds	r3, #1
    139c:	781b      	ldrb	r3, [r3, #0]
    139e:	2b00      	cmp	r3, #0
    13a0:	d065      	beq.n	146e <u8g2_font_get_glyph_data+0x126>
	break;
      if ( u8x8_pgm_read( font ) == encoding )
    13a2:	697b      	ldr	r3, [r7, #20]
    13a4:	781b      	ldrb	r3, [r3, #0]
    13a6:	b29b      	uxth	r3, r3
    13a8:	1cba      	adds	r2, r7, #2
    13aa:	8812      	ldrh	r2, [r2, #0]
    13ac:	429a      	cmp	r2, r3
    13ae:	d102      	bne.n	13b6 <u8g2_font_get_glyph_data+0x6e>
      {
	return font+2;	/* skip encoding and glyph size */
    13b0:	697b      	ldr	r3, [r7, #20]
    13b2:	3302      	adds	r3, #2
    13b4:	e05f      	b.n	1476 <u8g2_font_get_glyph_data+0x12e>
      }
      font += u8x8_pgm_read( font + 1 );
    13b6:	697b      	ldr	r3, [r7, #20]
    13b8:	3301      	adds	r3, #1
    13ba:	781b      	ldrb	r3, [r3, #0]
    13bc:	001a      	movs	r2, r3
    13be:	697b      	ldr	r3, [r7, #20]
    13c0:	189b      	adds	r3, r3, r2
    13c2:	617b      	str	r3, [r7, #20]
      if ( u8x8_pgm_read( font + 1 ) == 0 )
    13c4:	e7e8      	b.n	1398 <u8g2_font_get_glyph_data+0x50>
//	font = u8g2->last_font_data;
//    }
//    else
//#endif 

    font += u8g2->font_info.start_pos_unicode;
    13c6:	687b      	ldr	r3, [r7, #4]
    13c8:	228a      	movs	r2, #138	; 0x8a
    13ca:	5a9b      	ldrh	r3, [r3, r2]
    13cc:	001a      	movs	r2, r3
    13ce:	697b      	ldr	r3, [r7, #20]
    13d0:	189b      	adds	r3, r3, r2
    13d2:	617b      	str	r3, [r7, #20]
    unicode_lookup_table = font; 
    13d4:	697b      	ldr	r3, [r7, #20]
    13d6:	613b      	str	r3, [r7, #16]
  
    /* issue 596: search for the glyph start in the unicode lookup table */
    do
    {
      font += u8g2_font_get_word(unicode_lookup_table, 0);
    13d8:	693b      	ldr	r3, [r7, #16]
    13da:	2100      	movs	r1, #0
    13dc:	0018      	movs	r0, r3
    13de:	f7ff fad7 	bl	990 <u8g2_font_get_word>
    13e2:	0003      	movs	r3, r0
    13e4:	001a      	movs	r2, r3
    13e6:	697b      	ldr	r3, [r7, #20]
    13e8:	189b      	adds	r3, r3, r2
    13ea:	617b      	str	r3, [r7, #20]
      e = u8g2_font_get_word(unicode_lookup_table, 2);
    13ec:	230e      	movs	r3, #14
    13ee:	18fc      	adds	r4, r7, r3
    13f0:	693b      	ldr	r3, [r7, #16]
    13f2:	2102      	movs	r1, #2
    13f4:	0018      	movs	r0, r3
    13f6:	f7ff facb 	bl	990 <u8g2_font_get_word>
    13fa:	0003      	movs	r3, r0
    13fc:	8023      	strh	r3, [r4, #0]
      unicode_lookup_table+=4;
    13fe:	693b      	ldr	r3, [r7, #16]
    1400:	3304      	adds	r3, #4
    1402:	613b      	str	r3, [r7, #16]
    } while( e < encoding );
    1404:	230e      	movs	r3, #14
    1406:	18fa      	adds	r2, r7, r3
    1408:	1cbb      	adds	r3, r7, #2
    140a:	8812      	ldrh	r2, [r2, #0]
    140c:	881b      	ldrh	r3, [r3, #0]
    140e:	429a      	cmp	r2, r3
    1410:	d3e2      	bcc.n	13d8 <u8g2_font_get_glyph_data+0x90>
    
  
    for(;;)
    {
      e = u8x8_pgm_read( font );
    1412:	697b      	ldr	r3, [r7, #20]
    1414:	781a      	ldrb	r2, [r3, #0]
    1416:	230e      	movs	r3, #14
    1418:	18fb      	adds	r3, r7, r3
    141a:	801a      	strh	r2, [r3, #0]
      e <<= 8;
    141c:	230e      	movs	r3, #14
    141e:	18fb      	adds	r3, r7, r3
    1420:	220e      	movs	r2, #14
    1422:	18ba      	adds	r2, r7, r2
    1424:	8812      	ldrh	r2, [r2, #0]
    1426:	0212      	lsls	r2, r2, #8
    1428:	801a      	strh	r2, [r3, #0]
      e |= u8x8_pgm_read( font + 1 );
    142a:	697b      	ldr	r3, [r7, #20]
    142c:	3301      	adds	r3, #1
    142e:	781b      	ldrb	r3, [r3, #0]
    1430:	b299      	uxth	r1, r3
    1432:	230e      	movs	r3, #14
    1434:	18fb      	adds	r3, r7, r3
    1436:	220e      	movs	r2, #14
    1438:	18ba      	adds	r2, r7, r2
    143a:	8812      	ldrh	r2, [r2, #0]
    143c:	430a      	orrs	r2, r1
    143e:	801a      	strh	r2, [r3, #0]
//#ifdef  __unix__
//      if ( encoding < e )
//        break;
//#endif 

      if ( e == 0 )
    1440:	230e      	movs	r3, #14
    1442:	18fb      	adds	r3, r7, r3
    1444:	881b      	ldrh	r3, [r3, #0]
    1446:	2b00      	cmp	r3, #0
    1448:	d013      	beq.n	1472 <u8g2_font_get_glyph_data+0x12a>
	break;
  
      if ( e == encoding )
    144a:	230e      	movs	r3, #14
    144c:	18fa      	adds	r2, r7, r3
    144e:	1cbb      	adds	r3, r7, #2
    1450:	8812      	ldrh	r2, [r2, #0]
    1452:	881b      	ldrh	r3, [r3, #0]
    1454:	429a      	cmp	r2, r3
    1456:	d102      	bne.n	145e <u8g2_font_get_glyph_data+0x116>
// removed, there is now the new index table
//#ifdef  __unix__
//	u8g2->last_font_data = font;
//	u8g2->last_unicode = encoding;
//#endif 
	return font+3;	/* skip encoding and glyph size */
    1458:	697b      	ldr	r3, [r7, #20]
    145a:	3303      	adds	r3, #3
    145c:	e00b      	b.n	1476 <u8g2_font_get_glyph_data+0x12e>
      }
      font += u8x8_pgm_read( font + 2 );
    145e:	697b      	ldr	r3, [r7, #20]
    1460:	3302      	adds	r3, #2
    1462:	781b      	ldrb	r3, [r3, #0]
    1464:	001a      	movs	r2, r3
    1466:	697b      	ldr	r3, [r7, #20]
    1468:	189b      	adds	r3, r3, r2
    146a:	617b      	str	r3, [r7, #20]
      e = u8x8_pgm_read( font );
    146c:	e7d1      	b.n	1412 <u8g2_font_get_glyph_data+0xca>
	break;
    146e:	46c0      	nop			; (mov r8, r8)
    1470:	e000      	b.n	1474 <u8g2_font_get_glyph_data+0x12c>
	break;
    1472:	46c0      	nop			; (mov r8, r8)
    }  
  }
#endif
  
  return NULL;
    1474:	2300      	movs	r3, #0
}
    1476:	0018      	movs	r0, r3
    1478:	46bd      	mov	sp, r7
    147a:	b007      	add	sp, #28
    147c:	bd90      	pop	{r4, r7, pc}

0000147e <u8g2_font_draw_glyph>:

static u8g2_uint_t u8g2_font_draw_glyph(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, uint16_t encoding)
{
    147e:	b590      	push	{r4, r7, lr}
    1480:	b087      	sub	sp, #28
    1482:	af00      	add	r7, sp, #0
    1484:	60f8      	str	r0, [r7, #12]
    1486:	000c      	movs	r4, r1
    1488:	0010      	movs	r0, r2
    148a:	0019      	movs	r1, r3
    148c:	230a      	movs	r3, #10
    148e:	18fb      	adds	r3, r7, r3
    1490:	1c22      	adds	r2, r4, #0
    1492:	801a      	strh	r2, [r3, #0]
    1494:	2308      	movs	r3, #8
    1496:	18fb      	adds	r3, r7, r3
    1498:	1c02      	adds	r2, r0, #0
    149a:	801a      	strh	r2, [r3, #0]
    149c:	1dbb      	adds	r3, r7, #6
    149e:	1c0a      	adds	r2, r1, #0
    14a0:	801a      	strh	r2, [r3, #0]
  u8g2_uint_t dx = 0;
    14a2:	2316      	movs	r3, #22
    14a4:	18fb      	adds	r3, r7, r3
    14a6:	2200      	movs	r2, #0
    14a8:	801a      	strh	r2, [r3, #0]
  u8g2->font_decode.target_x = x;
    14aa:	68fb      	ldr	r3, [r7, #12]
    14ac:	220a      	movs	r2, #10
    14ae:	18ba      	adds	r2, r7, r2
    14b0:	2164      	movs	r1, #100	; 0x64
    14b2:	8812      	ldrh	r2, [r2, #0]
    14b4:	525a      	strh	r2, [r3, r1]
  u8g2->font_decode.target_y = y;
    14b6:	68fb      	ldr	r3, [r7, #12]
    14b8:	2208      	movs	r2, #8
    14ba:	18ba      	adds	r2, r7, r2
    14bc:	2166      	movs	r1, #102	; 0x66
    14be:	8812      	ldrh	r2, [r2, #0]
    14c0:	525a      	strh	r2, [r3, r1]
  //u8g2->font_decode.is_transparent = is_transparent; this is already set
  //u8g2->font_decode.dir = dir;
  const uint8_t *glyph_data = u8g2_font_get_glyph_data(u8g2, encoding);
    14c2:	1dbb      	adds	r3, r7, #6
    14c4:	881a      	ldrh	r2, [r3, #0]
    14c6:	68fb      	ldr	r3, [r7, #12]
    14c8:	0011      	movs	r1, r2
    14ca:	0018      	movs	r0, r3
    14cc:	f7ff ff3c 	bl	1348 <u8g2_font_get_glyph_data>
    14d0:	0003      	movs	r3, r0
    14d2:	613b      	str	r3, [r7, #16]
  if ( glyph_data != NULL )
    14d4:	693b      	ldr	r3, [r7, #16]
    14d6:	2b00      	cmp	r3, #0
    14d8:	d00a      	beq.n	14f0 <u8g2_font_draw_glyph+0x72>
  {
    dx = u8g2_font_decode_glyph(u8g2, glyph_data);
    14da:	693a      	ldr	r2, [r7, #16]
    14dc:	68fb      	ldr	r3, [r7, #12]
    14de:	0011      	movs	r1, r2
    14e0:	0018      	movs	r0, r3
    14e2:	f7ff fd9e 	bl	1022 <u8g2_font_decode_glyph>
    14e6:	0003      	movs	r3, r0
    14e8:	001a      	movs	r2, r3
    14ea:	2316      	movs	r3, #22
    14ec:	18fb      	adds	r3, r7, r3
    14ee:	801a      	strh	r2, [r3, #0]
  }
  return dx;
    14f0:	2316      	movs	r3, #22
    14f2:	18fb      	adds	r3, r7, r3
    14f4:	881b      	ldrh	r3, [r3, #0]
}
    14f6:	0018      	movs	r0, r3
    14f8:	46bd      	mov	sp, r7
    14fa:	b007      	add	sp, #28
    14fc:	bd90      	pop	{r4, r7, pc}

000014fe <u8g2_DrawGlyph>:
{
  u8g2->font_decode.is_transparent = is_transparent;		// new font procedures
}

u8g2_uint_t u8g2_DrawGlyph(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, uint16_t encoding)
{
    14fe:	b590      	push	{r4, r7, lr}
    1500:	b085      	sub	sp, #20
    1502:	af00      	add	r7, sp, #0
    1504:	60f8      	str	r0, [r7, #12]
    1506:	000c      	movs	r4, r1
    1508:	0010      	movs	r0, r2
    150a:	0019      	movs	r1, r3
    150c:	230a      	movs	r3, #10
    150e:	18fb      	adds	r3, r7, r3
    1510:	1c22      	adds	r2, r4, #0
    1512:	801a      	strh	r2, [r3, #0]
    1514:	2308      	movs	r3, #8
    1516:	18fb      	adds	r3, r7, r3
    1518:	1c02      	adds	r2, r0, #0
    151a:	801a      	strh	r2, [r3, #0]
    151c:	1dbb      	adds	r3, r7, #6
    151e:	1c0a      	adds	r2, r1, #0
    1520:	801a      	strh	r2, [r3, #0]
#ifdef U8G2_WITH_FONT_ROTATION
  switch(u8g2->font_decode.dir)
    1522:	68fb      	ldr	r3, [r7, #12]
    1524:	2270      	movs	r2, #112	; 0x70
    1526:	5c9b      	ldrb	r3, [r3, r2]
    1528:	2b01      	cmp	r3, #1
    152a:	d017      	beq.n	155c <u8g2_DrawGlyph+0x5e>
    152c:	dc02      	bgt.n	1534 <u8g2_DrawGlyph+0x36>
    152e:	2b00      	cmp	r3, #0
    1530:	d005      	beq.n	153e <u8g2_DrawGlyph+0x40>
    1532:	e040      	b.n	15b6 <u8g2_DrawGlyph+0xb8>
    1534:	2b02      	cmp	r3, #2
    1536:	d020      	beq.n	157a <u8g2_DrawGlyph+0x7c>
    1538:	2b03      	cmp	r3, #3
    153a:	d02d      	beq.n	1598 <u8g2_DrawGlyph+0x9a>
    153c:	e03b      	b.n	15b6 <u8g2_DrawGlyph+0xb8>
  {
    case 0:
      y += u8g2->font_calc_vref(u8g2);
    153e:	68fb      	ldr	r3, [r7, #12]
    1540:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
    1542:	68fa      	ldr	r2, [r7, #12]
    1544:	0010      	movs	r0, r2
    1546:	4798      	blx	r3
    1548:	0003      	movs	r3, r0
    154a:	0019      	movs	r1, r3
    154c:	2308      	movs	r3, #8
    154e:	18fb      	adds	r3, r7, r3
    1550:	2208      	movs	r2, #8
    1552:	18ba      	adds	r2, r7, r2
    1554:	8812      	ldrh	r2, [r2, #0]
    1556:	188a      	adds	r2, r1, r2
    1558:	801a      	strh	r2, [r3, #0]
      break;
    155a:	e02c      	b.n	15b6 <u8g2_DrawGlyph+0xb8>
    case 1:
      x -= u8g2->font_calc_vref(u8g2);
    155c:	68fb      	ldr	r3, [r7, #12]
    155e:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
    1560:	68fa      	ldr	r2, [r7, #12]
    1562:	0010      	movs	r0, r2
    1564:	4798      	blx	r3
    1566:	0003      	movs	r3, r0
    1568:	0019      	movs	r1, r3
    156a:	230a      	movs	r3, #10
    156c:	18fb      	adds	r3, r7, r3
    156e:	220a      	movs	r2, #10
    1570:	18ba      	adds	r2, r7, r2
    1572:	8812      	ldrh	r2, [r2, #0]
    1574:	1a52      	subs	r2, r2, r1
    1576:	801a      	strh	r2, [r3, #0]
      break;
    1578:	e01d      	b.n	15b6 <u8g2_DrawGlyph+0xb8>
    case 2:
      y -= u8g2->font_calc_vref(u8g2);
    157a:	68fb      	ldr	r3, [r7, #12]
    157c:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
    157e:	68fa      	ldr	r2, [r7, #12]
    1580:	0010      	movs	r0, r2
    1582:	4798      	blx	r3
    1584:	0003      	movs	r3, r0
    1586:	0019      	movs	r1, r3
    1588:	2308      	movs	r3, #8
    158a:	18fb      	adds	r3, r7, r3
    158c:	2208      	movs	r2, #8
    158e:	18ba      	adds	r2, r7, r2
    1590:	8812      	ldrh	r2, [r2, #0]
    1592:	1a52      	subs	r2, r2, r1
    1594:	801a      	strh	r2, [r3, #0]
      break;
    1596:	e00e      	b.n	15b6 <u8g2_DrawGlyph+0xb8>
    case 3:
      x += u8g2->font_calc_vref(u8g2);
    1598:	68fb      	ldr	r3, [r7, #12]
    159a:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
    159c:	68fa      	ldr	r2, [r7, #12]
    159e:	0010      	movs	r0, r2
    15a0:	4798      	blx	r3
    15a2:	0003      	movs	r3, r0
    15a4:	0019      	movs	r1, r3
    15a6:	230a      	movs	r3, #10
    15a8:	18fb      	adds	r3, r7, r3
    15aa:	220a      	movs	r2, #10
    15ac:	18ba      	adds	r2, r7, r2
    15ae:	8812      	ldrh	r2, [r2, #0]
    15b0:	188a      	adds	r2, r1, r2
    15b2:	801a      	strh	r2, [r3, #0]
      break;
    15b4:	46c0      	nop			; (mov r8, r8)
  }
#else
  y += u8g2->font_calc_vref(u8g2);
#endif
  return u8g2_font_draw_glyph(u8g2, x, y, encoding);
    15b6:	1dbb      	adds	r3, r7, #6
    15b8:	881c      	ldrh	r4, [r3, #0]
    15ba:	2308      	movs	r3, #8
    15bc:	18fb      	adds	r3, r7, r3
    15be:	881a      	ldrh	r2, [r3, #0]
    15c0:	230a      	movs	r3, #10
    15c2:	18fb      	adds	r3, r7, r3
    15c4:	8819      	ldrh	r1, [r3, #0]
    15c6:	68f8      	ldr	r0, [r7, #12]
    15c8:	0023      	movs	r3, r4
    15ca:	f7ff ff58 	bl	147e <u8g2_font_draw_glyph>
    15ce:	0003      	movs	r3, r0
}
    15d0:	0018      	movs	r0, r3
    15d2:	46bd      	mov	sp, r7
    15d4:	b005      	add	sp, #20
    15d6:	bd90      	pop	{r4, r7, pc}

000015d8 <u8g2_draw_string>:
  return u8g2_font_2x_draw_glyph(u8g2, x, y, encoding);
}

static u8g2_uint_t u8g2_draw_string(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, const char *str) U8G2_NOINLINE;
static u8g2_uint_t u8g2_draw_string(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, const char *str)
{
    15d8:	b5b0      	push	{r4, r5, r7, lr}
    15da:	b086      	sub	sp, #24
    15dc:	af00      	add	r7, sp, #0
    15de:	60f8      	str	r0, [r7, #12]
    15e0:	0008      	movs	r0, r1
    15e2:	0011      	movs	r1, r2
    15e4:	607b      	str	r3, [r7, #4]
    15e6:	230a      	movs	r3, #10
    15e8:	18fb      	adds	r3, r7, r3
    15ea:	1c02      	adds	r2, r0, #0
    15ec:	801a      	strh	r2, [r3, #0]
    15ee:	2308      	movs	r3, #8
    15f0:	18fb      	adds	r3, r7, r3
    15f2:	1c0a      	adds	r2, r1, #0
    15f4:	801a      	strh	r2, [r3, #0]
  uint16_t e;
  u8g2_uint_t delta, sum;
  u8x8_utf8_init(u8g2_GetU8x8(u8g2));
    15f6:	68fb      	ldr	r3, [r7, #12]
    15f8:	0018      	movs	r0, r3
    15fa:	f000 ff76 	bl	24ea <u8x8_utf8_init>
  sum = 0;
    15fe:	2316      	movs	r3, #22
    1600:	18fb      	adds	r3, r7, r3
    1602:	2200      	movs	r2, #0
    1604:	801a      	strh	r2, [r3, #0]
  for(;;)
  {
    e = u8g2->u8x8.next_cb(u8g2_GetU8x8(u8g2), (uint8_t)*str);
    1606:	68fb      	ldr	r3, [r7, #12]
    1608:	685b      	ldr	r3, [r3, #4]
    160a:	687a      	ldr	r2, [r7, #4]
    160c:	7811      	ldrb	r1, [r2, #0]
    160e:	2214      	movs	r2, #20
    1610:	18bc      	adds	r4, r7, r2
    1612:	68fa      	ldr	r2, [r7, #12]
    1614:	0010      	movs	r0, r2
    1616:	4798      	blx	r3
    1618:	0003      	movs	r3, r0
    161a:	8023      	strh	r3, [r4, #0]
    if ( e == 0x0ffff )
    161c:	2314      	movs	r3, #20
    161e:	18fb      	adds	r3, r7, r3
    1620:	881b      	ldrh	r3, [r3, #0]
    1622:	4a35      	ldr	r2, [pc, #212]	; (16f8 <u8g2_draw_string+0x120>)
    1624:	4293      	cmp	r3, r2
    1626:	d05e      	beq.n	16e6 <u8g2_draw_string+0x10e>
      break;
    str++;
    1628:	687b      	ldr	r3, [r7, #4]
    162a:	3301      	adds	r3, #1
    162c:	607b      	str	r3, [r7, #4]
    if ( e != 0x0fffe )
    162e:	2314      	movs	r3, #20
    1630:	18fb      	adds	r3, r7, r3
    1632:	881b      	ldrh	r3, [r3, #0]
    1634:	4a31      	ldr	r2, [pc, #196]	; (16fc <u8g2_draw_string+0x124>)
    1636:	4293      	cmp	r3, r2
    1638:	d0e5      	beq.n	1606 <u8g2_draw_string+0x2e>
    {
      delta = u8g2_DrawGlyph(u8g2, x, y, e);
    163a:	2312      	movs	r3, #18
    163c:	18fc      	adds	r4, r7, r3
    163e:	2314      	movs	r3, #20
    1640:	18fb      	adds	r3, r7, r3
    1642:	881d      	ldrh	r5, [r3, #0]
    1644:	2308      	movs	r3, #8
    1646:	18fb      	adds	r3, r7, r3
    1648:	881a      	ldrh	r2, [r3, #0]
    164a:	230a      	movs	r3, #10
    164c:	18fb      	adds	r3, r7, r3
    164e:	8819      	ldrh	r1, [r3, #0]
    1650:	68f8      	ldr	r0, [r7, #12]
    1652:	002b      	movs	r3, r5
    1654:	f7ff ff53 	bl	14fe <u8g2_DrawGlyph>
    1658:	0003      	movs	r3, r0
    165a:	8023      	strh	r3, [r4, #0]
    
#ifdef U8G2_WITH_FONT_ROTATION
      switch(u8g2->font_decode.dir)
    165c:	68fb      	ldr	r3, [r7, #12]
    165e:	2270      	movs	r2, #112	; 0x70
    1660:	5c9b      	ldrb	r3, [r3, r2]
    1662:	2b01      	cmp	r3, #1
    1664:	d013      	beq.n	168e <u8g2_draw_string+0xb6>
    1666:	dc02      	bgt.n	166e <u8g2_draw_string+0x96>
    1668:	2b00      	cmp	r3, #0
    166a:	d005      	beq.n	1678 <u8g2_draw_string+0xa0>
    166c:	e030      	b.n	16d0 <u8g2_draw_string+0xf8>
    166e:	2b02      	cmp	r3, #2
    1670:	d018      	beq.n	16a4 <u8g2_draw_string+0xcc>
    1672:	2b03      	cmp	r3, #3
    1674:	d021      	beq.n	16ba <u8g2_draw_string+0xe2>
    1676:	e02b      	b.n	16d0 <u8g2_draw_string+0xf8>
      {
	case 0:
	  x += delta;
    1678:	230a      	movs	r3, #10
    167a:	18fb      	adds	r3, r7, r3
    167c:	220a      	movs	r2, #10
    167e:	18b9      	adds	r1, r7, r2
    1680:	2212      	movs	r2, #18
    1682:	18ba      	adds	r2, r7, r2
    1684:	8809      	ldrh	r1, [r1, #0]
    1686:	8812      	ldrh	r2, [r2, #0]
    1688:	188a      	adds	r2, r1, r2
    168a:	801a      	strh	r2, [r3, #0]
	  break;
    168c:	e020      	b.n	16d0 <u8g2_draw_string+0xf8>
	case 1:
	  y += delta;
    168e:	2308      	movs	r3, #8
    1690:	18fb      	adds	r3, r7, r3
    1692:	2208      	movs	r2, #8
    1694:	18b9      	adds	r1, r7, r2
    1696:	2212      	movs	r2, #18
    1698:	18ba      	adds	r2, r7, r2
    169a:	8809      	ldrh	r1, [r1, #0]
    169c:	8812      	ldrh	r2, [r2, #0]
    169e:	188a      	adds	r2, r1, r2
    16a0:	801a      	strh	r2, [r3, #0]
	  break;
    16a2:	e015      	b.n	16d0 <u8g2_draw_string+0xf8>
	case 2:
	  x -= delta;
    16a4:	230a      	movs	r3, #10
    16a6:	18fb      	adds	r3, r7, r3
    16a8:	220a      	movs	r2, #10
    16aa:	18b9      	adds	r1, r7, r2
    16ac:	2212      	movs	r2, #18
    16ae:	18ba      	adds	r2, r7, r2
    16b0:	8809      	ldrh	r1, [r1, #0]
    16b2:	8812      	ldrh	r2, [r2, #0]
    16b4:	1a8a      	subs	r2, r1, r2
    16b6:	801a      	strh	r2, [r3, #0]
	  break;
    16b8:	e00a      	b.n	16d0 <u8g2_draw_string+0xf8>
	case 3:
	  y -= delta;
    16ba:	2308      	movs	r3, #8
    16bc:	18fb      	adds	r3, r7, r3
    16be:	2208      	movs	r2, #8
    16c0:	18b9      	adds	r1, r7, r2
    16c2:	2212      	movs	r2, #18
    16c4:	18ba      	adds	r2, r7, r2
    16c6:	8809      	ldrh	r1, [r1, #0]
    16c8:	8812      	ldrh	r2, [r2, #0]
    16ca:	1a8a      	subs	r2, r1, r2
    16cc:	801a      	strh	r2, [r3, #0]
	  break;
    16ce:	46c0      	nop			; (mov r8, r8)

#else
      x += delta;
#endif

      sum += delta;    
    16d0:	2316      	movs	r3, #22
    16d2:	18fb      	adds	r3, r7, r3
    16d4:	2216      	movs	r2, #22
    16d6:	18b9      	adds	r1, r7, r2
    16d8:	2212      	movs	r2, #18
    16da:	18ba      	adds	r2, r7, r2
    16dc:	8809      	ldrh	r1, [r1, #0]
    16de:	8812      	ldrh	r2, [r2, #0]
    16e0:	188a      	adds	r2, r1, r2
    16e2:	801a      	strh	r2, [r3, #0]
    e = u8g2->u8x8.next_cb(u8g2_GetU8x8(u8g2), (uint8_t)*str);
    16e4:	e78f      	b.n	1606 <u8g2_draw_string+0x2e>
      break;
    16e6:	46c0      	nop			; (mov r8, r8)
    }
  }
  return sum;
    16e8:	2316      	movs	r3, #22
    16ea:	18fb      	adds	r3, r7, r3
    16ec:	881b      	ldrh	r3, [r3, #0]
}
    16ee:	0018      	movs	r0, r3
    16f0:	46bd      	mov	sp, r7
    16f2:	b006      	add	sp, #24
    16f4:	bdb0      	pop	{r4, r5, r7, pc}
    16f6:	46c0      	nop			; (mov r8, r8)
    16f8:	0000ffff 	.word	0x0000ffff
    16fc:	0000fffe 	.word	0x0000fffe

00001700 <u8g2_DrawStr>:
  }
  return sum;
}

u8g2_uint_t u8g2_DrawStr(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, const char *str)
{
    1700:	b590      	push	{r4, r7, lr}
    1702:	b085      	sub	sp, #20
    1704:	af00      	add	r7, sp, #0
    1706:	60f8      	str	r0, [r7, #12]
    1708:	0008      	movs	r0, r1
    170a:	0011      	movs	r1, r2
    170c:	607b      	str	r3, [r7, #4]
    170e:	230a      	movs	r3, #10
    1710:	18fb      	adds	r3, r7, r3
    1712:	1c02      	adds	r2, r0, #0
    1714:	801a      	strh	r2, [r3, #0]
    1716:	2308      	movs	r3, #8
    1718:	18fb      	adds	r3, r7, r3
    171a:	1c0a      	adds	r2, r1, #0
    171c:	801a      	strh	r2, [r3, #0]
  u8g2->u8x8.next_cb = u8x8_ascii_next;
    171e:	68fb      	ldr	r3, [r7, #12]
    1720:	4a08      	ldr	r2, [pc, #32]	; (1744 <u8g2_DrawStr+0x44>)
    1722:	605a      	str	r2, [r3, #4]
  return u8g2_draw_string(u8g2, x, y, str);
    1724:	687c      	ldr	r4, [r7, #4]
    1726:	2308      	movs	r3, #8
    1728:	18fb      	adds	r3, r7, r3
    172a:	881a      	ldrh	r2, [r3, #0]
    172c:	230a      	movs	r3, #10
    172e:	18fb      	adds	r3, r7, r3
    1730:	8819      	ldrh	r1, [r3, #0]
    1732:	68f8      	ldr	r0, [r7, #12]
    1734:	0023      	movs	r3, r4
    1736:	f7ff ff4f 	bl	15d8 <u8g2_draw_string>
    173a:	0003      	movs	r3, r0
}
    173c:	0018      	movs	r0, r3
    173e:	46bd      	mov	sp, r7
    1740:	b005      	add	sp, #20
    1742:	bd90      	pop	{r4, r7, pc}
    1744:	00002505 	.word	0x00002505

00001748 <u8g2_UpdateRefHeight>:
/*===============================================*/

/* set ascent/descent for reference point calculation */

void u8g2_UpdateRefHeight(u8g2_t *u8g2)
{
    1748:	b580      	push	{r7, lr}
    174a:	b082      	sub	sp, #8
    174c:	af00      	add	r7, sp, #0
    174e:	6078      	str	r0, [r7, #4]
  if ( u8g2->font == NULL )
    1750:	687b      	ldr	r3, [r7, #4]
    1752:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    1754:	2b00      	cmp	r3, #0
    1756:	d05d      	beq.n	1814 <u8g2_UpdateRefHeight+0xcc>
    return;
  u8g2->font_ref_ascent = u8g2->font_info.ascent_A;
    1758:	687b      	ldr	r3, [r7, #4]
    175a:	2281      	movs	r2, #129	; 0x81
    175c:	5699      	ldrsb	r1, [r3, r2]
    175e:	687b      	ldr	r3, [r7, #4]
    1760:	228e      	movs	r2, #142	; 0x8e
    1762:	5499      	strb	r1, [r3, r2]
  u8g2->font_ref_descent = u8g2->font_info.descent_g;
    1764:	687b      	ldr	r3, [r7, #4]
    1766:	2282      	movs	r2, #130	; 0x82
    1768:	5699      	ldrsb	r1, [r3, r2]
    176a:	687b      	ldr	r3, [r7, #4]
    176c:	228f      	movs	r2, #143	; 0x8f
    176e:	5499      	strb	r1, [r3, r2]
  if ( u8g2->font_height_mode == U8G2_FONT_HEIGHT_MODE_TEXT )
    1770:	687b      	ldr	r3, [r7, #4]
    1772:	228d      	movs	r2, #141	; 0x8d
    1774:	5c9b      	ldrb	r3, [r3, r2]
    1776:	2b00      	cmp	r3, #0
    1778:	d04d      	beq.n	1816 <u8g2_UpdateRefHeight+0xce>
  {
  }
  else if ( u8g2->font_height_mode == U8G2_FONT_HEIGHT_MODE_XTEXT )
    177a:	687b      	ldr	r3, [r7, #4]
    177c:	228d      	movs	r2, #141	; 0x8d
    177e:	5c9b      	ldrb	r3, [r3, r2]
    1780:	2b01      	cmp	r3, #1
    1782:	d11c      	bne.n	17be <u8g2_UpdateRefHeight+0x76>
  {
    if ( u8g2->font_ref_ascent < u8g2->font_info.ascent_para )
    1784:	687b      	ldr	r3, [r7, #4]
    1786:	228e      	movs	r2, #142	; 0x8e
    1788:	569a      	ldrsb	r2, [r3, r2]
    178a:	687b      	ldr	r3, [r7, #4]
    178c:	2183      	movs	r1, #131	; 0x83
    178e:	565b      	ldrsb	r3, [r3, r1]
    1790:	429a      	cmp	r2, r3
    1792:	da05      	bge.n	17a0 <u8g2_UpdateRefHeight+0x58>
      u8g2->font_ref_ascent = u8g2->font_info.ascent_para;
    1794:	687b      	ldr	r3, [r7, #4]
    1796:	2283      	movs	r2, #131	; 0x83
    1798:	5699      	ldrsb	r1, [r3, r2]
    179a:	687b      	ldr	r3, [r7, #4]
    179c:	228e      	movs	r2, #142	; 0x8e
    179e:	5499      	strb	r1, [r3, r2]
    if ( u8g2->font_ref_descent > u8g2->font_info.descent_para )
    17a0:	687b      	ldr	r3, [r7, #4]
    17a2:	228f      	movs	r2, #143	; 0x8f
    17a4:	569a      	ldrsb	r2, [r3, r2]
    17a6:	687b      	ldr	r3, [r7, #4]
    17a8:	2184      	movs	r1, #132	; 0x84
    17aa:	565b      	ldrsb	r3, [r3, r1]
    17ac:	429a      	cmp	r2, r3
    17ae:	dd32      	ble.n	1816 <u8g2_UpdateRefHeight+0xce>
      u8g2->font_ref_descent = u8g2->font_info.descent_para;
    17b0:	687b      	ldr	r3, [r7, #4]
    17b2:	2284      	movs	r2, #132	; 0x84
    17b4:	5699      	ldrsb	r1, [r3, r2]
    17b6:	687b      	ldr	r3, [r7, #4]
    17b8:	228f      	movs	r2, #143	; 0x8f
    17ba:	5499      	strb	r1, [r3, r2]
    17bc:	e02b      	b.n	1816 <u8g2_UpdateRefHeight+0xce>
  }
  else
  {
    if ( u8g2->font_ref_ascent < u8g2->font_info.max_char_height+u8g2->font_info.y_offset )
    17be:	687b      	ldr	r3, [r7, #4]
    17c0:	228e      	movs	r2, #142	; 0x8e
    17c2:	569b      	ldrsb	r3, [r3, r2]
    17c4:	0019      	movs	r1, r3
    17c6:	687b      	ldr	r3, [r7, #4]
    17c8:	227e      	movs	r2, #126	; 0x7e
    17ca:	569b      	ldrsb	r3, [r3, r2]
    17cc:	0018      	movs	r0, r3
    17ce:	687b      	ldr	r3, [r7, #4]
    17d0:	2280      	movs	r2, #128	; 0x80
    17d2:	569b      	ldrsb	r3, [r3, r2]
    17d4:	18c3      	adds	r3, r0, r3
    17d6:	4299      	cmp	r1, r3
    17d8:	da0d      	bge.n	17f6 <u8g2_UpdateRefHeight+0xae>
      u8g2->font_ref_ascent = u8g2->font_info.max_char_height+u8g2->font_info.y_offset;
    17da:	687b      	ldr	r3, [r7, #4]
    17dc:	227e      	movs	r2, #126	; 0x7e
    17de:	569b      	ldrsb	r3, [r3, r2]
    17e0:	b2da      	uxtb	r2, r3
    17e2:	687b      	ldr	r3, [r7, #4]
    17e4:	2180      	movs	r1, #128	; 0x80
    17e6:	565b      	ldrsb	r3, [r3, r1]
    17e8:	b2db      	uxtb	r3, r3
    17ea:	18d3      	adds	r3, r2, r3
    17ec:	b2db      	uxtb	r3, r3
    17ee:	b259      	sxtb	r1, r3
    17f0:	687b      	ldr	r3, [r7, #4]
    17f2:	228e      	movs	r2, #142	; 0x8e
    17f4:	5499      	strb	r1, [r3, r2]
    if ( u8g2->font_ref_descent > u8g2->font_info.y_offset )
    17f6:	687b      	ldr	r3, [r7, #4]
    17f8:	228f      	movs	r2, #143	; 0x8f
    17fa:	569a      	ldrsb	r2, [r3, r2]
    17fc:	687b      	ldr	r3, [r7, #4]
    17fe:	2180      	movs	r1, #128	; 0x80
    1800:	565b      	ldrsb	r3, [r3, r1]
    1802:	429a      	cmp	r2, r3
    1804:	dd07      	ble.n	1816 <u8g2_UpdateRefHeight+0xce>
      u8g2->font_ref_descent = u8g2->font_info.y_offset;
    1806:	687b      	ldr	r3, [r7, #4]
    1808:	2280      	movs	r2, #128	; 0x80
    180a:	5699      	ldrsb	r1, [r3, r2]
    180c:	687b      	ldr	r3, [r7, #4]
    180e:	228f      	movs	r2, #143	; 0x8f
    1810:	5499      	strb	r1, [r3, r2]
    1812:	e000      	b.n	1816 <u8g2_UpdateRefHeight+0xce>
    return;
    1814:	46c0      	nop			; (mov r8, r8)
  }  
}
    1816:	46bd      	mov	sp, r7
    1818:	b002      	add	sp, #8
    181a:	bd80      	pop	{r7, pc}

0000181c <u8g2_font_calc_vref_font>:

/*===============================================*/
/* callback procedures to correct the y position */

u8g2_uint_t u8g2_font_calc_vref_font(U8X8_UNUSED u8g2_t *u8g2)
{
    181c:	b580      	push	{r7, lr}
    181e:	b082      	sub	sp, #8
    1820:	af00      	add	r7, sp, #0
    1822:	6078      	str	r0, [r7, #4]
  return 0;
    1824:	2300      	movs	r3, #0
}
    1826:	0018      	movs	r0, r3
    1828:	46bd      	mov	sp, r7
    182a:	b002      	add	sp, #8
    182c:	bd80      	pop	{r7, pc}
	...

00001830 <u8g2_SetFontPosBaseline>:

void u8g2_SetFontPosBaseline(u8g2_t *u8g2)
{
    1830:	b580      	push	{r7, lr}
    1832:	b082      	sub	sp, #8
    1834:	af00      	add	r7, sp, #0
    1836:	6078      	str	r0, [r7, #4]
  u8g2->font_calc_vref = u8g2_font_calc_vref_font;
    1838:	687b      	ldr	r3, [r7, #4]
    183a:	4a03      	ldr	r2, [pc, #12]	; (1848 <u8g2_SetFontPosBaseline+0x18>)
    183c:	65da      	str	r2, [r3, #92]	; 0x5c
}
    183e:	46c0      	nop			; (mov r8, r8)
    1840:	46bd      	mov	sp, r7
    1842:	b002      	add	sp, #8
    1844:	bd80      	pop	{r7, pc}
    1846:	46c0      	nop			; (mov r8, r8)
    1848:	0000181d 	.word	0x0000181d

0000184c <u8g2_SetFont>:
}

/*===============================================*/

void u8g2_SetFont(u8g2_t *u8g2, const uint8_t  *font)
{
    184c:	b580      	push	{r7, lr}
    184e:	b082      	sub	sp, #8
    1850:	af00      	add	r7, sp, #0
    1852:	6078      	str	r0, [r7, #4]
    1854:	6039      	str	r1, [r7, #0]
  if ( u8g2->font != font )
    1856:	687b      	ldr	r3, [r7, #4]
    1858:	6d9a      	ldr	r2, [r3, #88]	; 0x58
    185a:	683b      	ldr	r3, [r7, #0]
    185c:	429a      	cmp	r2, r3
    185e:	d00d      	beq.n	187c <u8g2_SetFont+0x30>
  {
//#ifdef  __unix__
//	u8g2->last_font_data = NULL;
//	u8g2->last_unicode = 0x0ffff;
//#endif 
    u8g2->font = font;
    1860:	687b      	ldr	r3, [r7, #4]
    1862:	683a      	ldr	r2, [r7, #0]
    1864:	659a      	str	r2, [r3, #88]	; 0x58
    u8g2_read_font_info(&(u8g2->font_info), font);
    1866:	687b      	ldr	r3, [r7, #4]
    1868:	3374      	adds	r3, #116	; 0x74
    186a:	683a      	ldr	r2, [r7, #0]
    186c:	0011      	movs	r1, r2
    186e:	0018      	movs	r0, r3
    1870:	f7ff f8ba 	bl	9e8 <u8g2_read_font_info>
    u8g2_UpdateRefHeight(u8g2);
    1874:	687b      	ldr	r3, [r7, #4]
    1876:	0018      	movs	r0, r3
    1878:	f7ff ff66 	bl	1748 <u8g2_UpdateRefHeight>
    /* u8g2_SetFontPosBaseline(u8g2); */ /* removed with issue 195 */
  }
}
    187c:	46c0      	nop			; (mov r8, r8)
    187e:	46bd      	mov	sp, r7
    1880:	b002      	add	sp, #8
    1882:	bd80      	pop	{r7, pc}

00001884 <u8g2_clip_intersection2>:
  will return 0 if there is no intersection and if a > b

*/

static uint8_t u8g2_clip_intersection2(u8g2_uint_t *ap, u8g2_uint_t *len, u8g2_uint_t c, u8g2_uint_t d)
{
    1884:	b580      	push	{r7, lr}
    1886:	b086      	sub	sp, #24
    1888:	af00      	add	r7, sp, #0
    188a:	60f8      	str	r0, [r7, #12]
    188c:	60b9      	str	r1, [r7, #8]
    188e:	0019      	movs	r1, r3
    1890:	1dbb      	adds	r3, r7, #6
    1892:	801a      	strh	r2, [r3, #0]
    1894:	1d3b      	adds	r3, r7, #4
    1896:	1c0a      	adds	r2, r1, #0
    1898:	801a      	strh	r2, [r3, #0]
  u8g2_uint_t a = *ap;
    189a:	2316      	movs	r3, #22
    189c:	18fb      	adds	r3, r7, r3
    189e:	68fa      	ldr	r2, [r7, #12]
    18a0:	8812      	ldrh	r2, [r2, #0]
    18a2:	801a      	strh	r2, [r3, #0]
  u8g2_uint_t b;
  b  = a;
    18a4:	2314      	movs	r3, #20
    18a6:	18fb      	adds	r3, r7, r3
    18a8:	2216      	movs	r2, #22
    18aa:	18ba      	adds	r2, r7, r2
    18ac:	8812      	ldrh	r2, [r2, #0]
    18ae:	801a      	strh	r2, [r3, #0]
  b += *len;
    18b0:	68bb      	ldr	r3, [r7, #8]
    18b2:	8819      	ldrh	r1, [r3, #0]
    18b4:	2314      	movs	r3, #20
    18b6:	18fb      	adds	r3, r7, r3
    18b8:	2214      	movs	r2, #20
    18ba:	18ba      	adds	r2, r7, r2
    18bc:	8812      	ldrh	r2, [r2, #0]
    18be:	188a      	adds	r2, r1, r2
    18c0:	801a      	strh	r2, [r3, #0]
  /* be removed completly (be aware about memory curruption for wrong */
  /* arguments) or return 0 for a>b (will lead to skipped lines for wrong */
  /* arguments) */  
  
  /* removing the following if clause completly may lead to memory corruption of a>b */
  if ( a > b )
    18c2:	2316      	movs	r3, #22
    18c4:	18fa      	adds	r2, r7, r3
    18c6:	2314      	movs	r3, #20
    18c8:	18fb      	adds	r3, r7, r3
    18ca:	8812      	ldrh	r2, [r2, #0]
    18cc:	881b      	ldrh	r3, [r3, #0]
    18ce:	429a      	cmp	r2, r3
    18d0:	d918      	bls.n	1904 <u8g2_clip_intersection2+0x80>
  {    
    /* replacing this if with a simple "return 0;" will not handle the case with negative a */    
    if ( a < d )
    18d2:	2316      	movs	r3, #22
    18d4:	18fa      	adds	r2, r7, r3
    18d6:	1d3b      	adds	r3, r7, #4
    18d8:	8812      	ldrh	r2, [r2, #0]
    18da:	881b      	ldrh	r3, [r3, #0]
    18dc:	429a      	cmp	r2, r3
    18de:	d20c      	bcs.n	18fa <u8g2_clip_intersection2+0x76>
    {
      b = d;
    18e0:	2314      	movs	r3, #20
    18e2:	18fb      	adds	r3, r7, r3
    18e4:	1d3a      	adds	r2, r7, #4
    18e6:	8812      	ldrh	r2, [r2, #0]
    18e8:	801a      	strh	r2, [r3, #0]
      b--;
    18ea:	2314      	movs	r3, #20
    18ec:	18fb      	adds	r3, r7, r3
    18ee:	881a      	ldrh	r2, [r3, #0]
    18f0:	2314      	movs	r3, #20
    18f2:	18fb      	adds	r3, r7, r3
    18f4:	3a01      	subs	r2, #1
    18f6:	801a      	strh	r2, [r3, #0]
    18f8:	e004      	b.n	1904 <u8g2_clip_intersection2+0x80>
    }
    else
    {
      a = c;
    18fa:	2316      	movs	r3, #22
    18fc:	18fb      	adds	r3, r7, r3
    18fe:	1dba      	adds	r2, r7, #6
    1900:	8812      	ldrh	r2, [r2, #0]
    1902:	801a      	strh	r2, [r3, #0]
    }
  }
  
  /* from now on, the asumption a <= b is ok */
  
  if ( a >= d )
    1904:	2316      	movs	r3, #22
    1906:	18fa      	adds	r2, r7, r3
    1908:	1d3b      	adds	r3, r7, #4
    190a:	8812      	ldrh	r2, [r2, #0]
    190c:	881b      	ldrh	r3, [r3, #0]
    190e:	429a      	cmp	r2, r3
    1910:	d301      	bcc.n	1916 <u8g2_clip_intersection2+0x92>
    return 0;
    1912:	2300      	movs	r3, #0
    1914:	e035      	b.n	1982 <u8g2_clip_intersection2+0xfe>
  if ( b <= c )
    1916:	2314      	movs	r3, #20
    1918:	18fa      	adds	r2, r7, r3
    191a:	1dbb      	adds	r3, r7, #6
    191c:	8812      	ldrh	r2, [r2, #0]
    191e:	881b      	ldrh	r3, [r3, #0]
    1920:	429a      	cmp	r2, r3
    1922:	d801      	bhi.n	1928 <u8g2_clip_intersection2+0xa4>
    return 0;
    1924:	2300      	movs	r3, #0
    1926:	e02c      	b.n	1982 <u8g2_clip_intersection2+0xfe>
  if ( a < c )		
    1928:	2316      	movs	r3, #22
    192a:	18fa      	adds	r2, r7, r3
    192c:	1dbb      	adds	r3, r7, #6
    192e:	8812      	ldrh	r2, [r2, #0]
    1930:	881b      	ldrh	r3, [r3, #0]
    1932:	429a      	cmp	r2, r3
    1934:	d204      	bcs.n	1940 <u8g2_clip_intersection2+0xbc>
    a = c;
    1936:	2316      	movs	r3, #22
    1938:	18fb      	adds	r3, r7, r3
    193a:	1dba      	adds	r2, r7, #6
    193c:	8812      	ldrh	r2, [r2, #0]
    193e:	801a      	strh	r2, [r3, #0]
  if ( b > d )
    1940:	2314      	movs	r3, #20
    1942:	18fa      	adds	r2, r7, r3
    1944:	1d3b      	adds	r3, r7, #4
    1946:	8812      	ldrh	r2, [r2, #0]
    1948:	881b      	ldrh	r3, [r3, #0]
    194a:	429a      	cmp	r2, r3
    194c:	d904      	bls.n	1958 <u8g2_clip_intersection2+0xd4>
    b = d;
    194e:	2314      	movs	r3, #20
    1950:	18fb      	adds	r3, r7, r3
    1952:	1d3a      	adds	r2, r7, #4
    1954:	8812      	ldrh	r2, [r2, #0]
    1956:	801a      	strh	r2, [r3, #0]
  
  *ap = a;
    1958:	68fb      	ldr	r3, [r7, #12]
    195a:	2216      	movs	r2, #22
    195c:	18ba      	adds	r2, r7, r2
    195e:	8812      	ldrh	r2, [r2, #0]
    1960:	801a      	strh	r2, [r3, #0]
  b -= a;
    1962:	2314      	movs	r3, #20
    1964:	18fb      	adds	r3, r7, r3
    1966:	2214      	movs	r2, #20
    1968:	18b9      	adds	r1, r7, r2
    196a:	2216      	movs	r2, #22
    196c:	18ba      	adds	r2, r7, r2
    196e:	8809      	ldrh	r1, [r1, #0]
    1970:	8812      	ldrh	r2, [r2, #0]
    1972:	1a8a      	subs	r2, r1, r2
    1974:	801a      	strh	r2, [r3, #0]
  *len = b;
    1976:	68bb      	ldr	r3, [r7, #8]
    1978:	2214      	movs	r2, #20
    197a:	18ba      	adds	r2, r7, r2
    197c:	8812      	ldrh	r2, [r2, #0]
    197e:	801a      	strh	r2, [r3, #0]
  return 1;
    1980:	2301      	movs	r3, #1
}
    1982:	0018      	movs	r0, r3
    1984:	46bd      	mov	sp, r7
    1986:	b006      	add	sp, #24
    1988:	bd80      	pop	{r7, pc}

0000198a <u8g2_draw_hv_line_2dir>:
  This function first adjusts the y position to the local buffer. Then it
  will clip the line and call u8g2_draw_low_level_hv_line()

*/
void u8g2_draw_hv_line_2dir(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t len, uint8_t dir)
{
    198a:	b5b0      	push	{r4, r5, r7, lr}
    198c:	b086      	sub	sp, #24
    198e:	af02      	add	r7, sp, #8
    1990:	60f8      	str	r0, [r7, #12]
    1992:	000c      	movs	r4, r1
    1994:	0010      	movs	r0, r2
    1996:	0019      	movs	r1, r3
    1998:	230a      	movs	r3, #10
    199a:	18fb      	adds	r3, r7, r3
    199c:	1c22      	adds	r2, r4, #0
    199e:	801a      	strh	r2, [r3, #0]
    19a0:	2308      	movs	r3, #8
    19a2:	18fb      	adds	r3, r7, r3
    19a4:	1c02      	adds	r2, r0, #0
    19a6:	801a      	strh	r2, [r3, #0]
    19a8:	1dbb      	adds	r3, r7, #6
    19aa:	1c0a      	adds	r2, r1, #0
    19ac:	801a      	strh	r2, [r3, #0]

  /* clipping happens before the display rotation */

  /* transform to pixel buffer coordinates */
  y -= u8g2->pixel_curr_row;
    19ae:	68fb      	ldr	r3, [r7, #12]
    19b0:	8fda      	ldrh	r2, [r3, #62]	; 0x3e
    19b2:	2308      	movs	r3, #8
    19b4:	18fb      	adds	r3, r7, r3
    19b6:	2108      	movs	r1, #8
    19b8:	1879      	adds	r1, r7, r1
    19ba:	8809      	ldrh	r1, [r1, #0]
    19bc:	1a8a      	subs	r2, r1, r2
    19be:	801a      	strh	r2, [r3, #0]
  
  u8g2->ll_hvline(u8g2, x, y, len, dir);
    19c0:	68fb      	ldr	r3, [r7, #12]
    19c2:	6adc      	ldr	r4, [r3, #44]	; 0x2c
    19c4:	1dbb      	adds	r3, r7, #6
    19c6:	881d      	ldrh	r5, [r3, #0]
    19c8:	2308      	movs	r3, #8
    19ca:	18fb      	adds	r3, r7, r3
    19cc:	881a      	ldrh	r2, [r3, #0]
    19ce:	230a      	movs	r3, #10
    19d0:	18fb      	adds	r3, r7, r3
    19d2:	8819      	ldrh	r1, [r3, #0]
    19d4:	68f8      	ldr	r0, [r7, #12]
    19d6:	2320      	movs	r3, #32
    19d8:	18fb      	adds	r3, r7, r3
    19da:	781b      	ldrb	r3, [r3, #0]
    19dc:	9300      	str	r3, [sp, #0]
    19de:	002b      	movs	r3, r5
    19e0:	47a0      	blx	r4
}
    19e2:	46c0      	nop			; (mov r8, r8)
    19e4:	46bd      	mov	sp, r7
    19e6:	b004      	add	sp, #16
    19e8:	bdb0      	pop	{r4, r5, r7, pc}

000019ea <u8g2_DrawHVLine>:
  This function should be called by the user.
  
  "dir" may have 4 directions: 0 (left to right), 1, 2, 3 (down up)
*/
void u8g2_DrawHVLine(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t len, uint8_t dir)
{
    19ea:	b5b0      	push	{r4, r5, r7, lr}
    19ec:	b086      	sub	sp, #24
    19ee:	af02      	add	r7, sp, #8
    19f0:	60f8      	str	r0, [r7, #12]
    19f2:	000c      	movs	r4, r1
    19f4:	0010      	movs	r0, r2
    19f6:	0019      	movs	r1, r3
    19f8:	230a      	movs	r3, #10
    19fa:	18fb      	adds	r3, r7, r3
    19fc:	1c22      	adds	r2, r4, #0
    19fe:	801a      	strh	r2, [r3, #0]
    1a00:	2308      	movs	r3, #8
    1a02:	18fb      	adds	r3, r7, r3
    1a04:	1c02      	adds	r2, r0, #0
    1a06:	801a      	strh	r2, [r3, #0]
    1a08:	1dbb      	adds	r3, r7, #6
    1a0a:	1c0a      	adds	r2, r1, #0
    1a0c:	801a      	strh	r2, [r3, #0]
  /* Make a call to the callback function (e.g. u8g2_draw_l90_r0). */
  /* The callback may rotate the hv line */
  /* after rotation this will call u8g2_draw_hv_line_4dir() */
  
#ifdef U8G2_WITH_CLIP_WINDOW_SUPPORT
  if ( u8g2->is_page_clip_window_intersection != 0 )
    1a0e:	68fb      	ldr	r3, [r7, #12]
    1a10:	228c      	movs	r2, #140	; 0x8c
    1a12:	5c9b      	ldrb	r3, [r3, r2]
    1a14:	2b00      	cmp	r3, #0
    1a16:	d100      	bne.n	1a1a <u8g2_DrawHVLine+0x30>
    1a18:	e09d      	b.n	1b56 <u8g2_DrawHVLine+0x16c>
#endif /* U8G2_WITH_CLIP_WINDOW_SUPPORT */
    if ( len != 0 )
    1a1a:	1dbb      	adds	r3, r7, #6
    1a1c:	881b      	ldrh	r3, [r3, #0]
    1a1e:	2b00      	cmp	r3, #0
    1a20:	d100      	bne.n	1a24 <u8g2_DrawHVLine+0x3a>
    1a22:	e098      	b.n	1b56 <u8g2_DrawHVLine+0x16c>
    {
    
      /* convert to two directions */    
      if ( len > 1 )
    1a24:	1dbb      	adds	r3, r7, #6
    1a26:	881b      	ldrh	r3, [r3, #0]
    1a28:	2b01      	cmp	r3, #1
    1a2a:	d92e      	bls.n	1a8a <u8g2_DrawHVLine+0xa0>
      {
	if ( dir == 2 )
    1a2c:	2320      	movs	r3, #32
    1a2e:	18fb      	adds	r3, r7, r3
    1a30:	781b      	ldrb	r3, [r3, #0]
    1a32:	2b02      	cmp	r3, #2
    1a34:	d112      	bne.n	1a5c <u8g2_DrawHVLine+0x72>
	{
	  x -= len;
    1a36:	230a      	movs	r3, #10
    1a38:	18fb      	adds	r3, r7, r3
    1a3a:	881a      	ldrh	r2, [r3, #0]
    1a3c:	1dbb      	adds	r3, r7, #6
    1a3e:	881b      	ldrh	r3, [r3, #0]
    1a40:	1ad3      	subs	r3, r2, r3
    1a42:	b29a      	uxth	r2, r3
    1a44:	230a      	movs	r3, #10
    1a46:	18fb      	adds	r3, r7, r3
    1a48:	801a      	strh	r2, [r3, #0]
	  x++;
    1a4a:	230a      	movs	r3, #10
    1a4c:	18fb      	adds	r3, r7, r3
    1a4e:	881b      	ldrh	r3, [r3, #0]
    1a50:	3301      	adds	r3, #1
    1a52:	b29a      	uxth	r2, r3
    1a54:	230a      	movs	r3, #10
    1a56:	18fb      	adds	r3, r7, r3
    1a58:	801a      	strh	r2, [r3, #0]
    1a5a:	e016      	b.n	1a8a <u8g2_DrawHVLine+0xa0>
	}
	else if ( dir == 3 )
    1a5c:	2320      	movs	r3, #32
    1a5e:	18fb      	adds	r3, r7, r3
    1a60:	781b      	ldrb	r3, [r3, #0]
    1a62:	2b03      	cmp	r3, #3
    1a64:	d111      	bne.n	1a8a <u8g2_DrawHVLine+0xa0>
	{
	  y -= len;
    1a66:	2308      	movs	r3, #8
    1a68:	18fb      	adds	r3, r7, r3
    1a6a:	881a      	ldrh	r2, [r3, #0]
    1a6c:	1dbb      	adds	r3, r7, #6
    1a6e:	881b      	ldrh	r3, [r3, #0]
    1a70:	1ad3      	subs	r3, r2, r3
    1a72:	b29a      	uxth	r2, r3
    1a74:	2308      	movs	r3, #8
    1a76:	18fb      	adds	r3, r7, r3
    1a78:	801a      	strh	r2, [r3, #0]
	  y++;
    1a7a:	2308      	movs	r3, #8
    1a7c:	18fb      	adds	r3, r7, r3
    1a7e:	881b      	ldrh	r3, [r3, #0]
    1a80:	3301      	adds	r3, #1
    1a82:	b29a      	uxth	r2, r3
    1a84:	2308      	movs	r3, #8
    1a86:	18fb      	adds	r3, r7, r3
    1a88:	801a      	strh	r2, [r3, #0]
	}
      }
      dir &= 1;  
    1a8a:	2320      	movs	r3, #32
    1a8c:	18f9      	adds	r1, r7, r3
    1a8e:	2320      	movs	r3, #32
    1a90:	18fb      	adds	r3, r7, r3
    1a92:	781b      	ldrb	r3, [r3, #0]
    1a94:	2201      	movs	r2, #1
    1a96:	4013      	ands	r3, r2
    1a98:	700b      	strb	r3, [r1, #0]
      
      /* clip against the user window */
      if ( dir == 0 )
    1a9a:	2320      	movs	r3, #32
    1a9c:	18fb      	adds	r3, r7, r3
    1a9e:	781b      	ldrb	r3, [r3, #0]
    1aa0:	2b00      	cmp	r3, #0
    1aa2:	d11e      	bne.n	1ae2 <u8g2_DrawHVLine+0xf8>
      {
	if ( y < u8g2->user_y0 )
    1aa4:	68fb      	ldr	r3, [r7, #12]
    1aa6:	224c      	movs	r2, #76	; 0x4c
    1aa8:	5a9a      	ldrh	r2, [r3, r2]
    1aaa:	2308      	movs	r3, #8
    1aac:	18fb      	adds	r3, r7, r3
    1aae:	881b      	ldrh	r3, [r3, #0]
    1ab0:	429a      	cmp	r2, r3
    1ab2:	d847      	bhi.n	1b44 <u8g2_DrawHVLine+0x15a>
	  return;
	if ( y >= u8g2->user_y1 )
    1ab4:	68fb      	ldr	r3, [r7, #12]
    1ab6:	224e      	movs	r2, #78	; 0x4e
    1ab8:	5a9a      	ldrh	r2, [r3, r2]
    1aba:	2308      	movs	r3, #8
    1abc:	18fb      	adds	r3, r7, r3
    1abe:	881b      	ldrh	r3, [r3, #0]
    1ac0:	429a      	cmp	r2, r3
    1ac2:	d941      	bls.n	1b48 <u8g2_DrawHVLine+0x15e>
	  return;
	if ( u8g2_clip_intersection2(&x, &len, u8g2->user_x0, u8g2->user_x1) == 0 )
    1ac4:	68fb      	ldr	r3, [r7, #12]
    1ac6:	2248      	movs	r2, #72	; 0x48
    1ac8:	5a9c      	ldrh	r4, [r3, r2]
    1aca:	68fb      	ldr	r3, [r7, #12]
    1acc:	224a      	movs	r2, #74	; 0x4a
    1ace:	5a9b      	ldrh	r3, [r3, r2]
    1ad0:	1db9      	adds	r1, r7, #6
    1ad2:	220a      	movs	r2, #10
    1ad4:	18b8      	adds	r0, r7, r2
    1ad6:	0022      	movs	r2, r4
    1ad8:	f7ff fed4 	bl	1884 <u8g2_clip_intersection2>
    1adc:	1e03      	subs	r3, r0, #0
    1ade:	d11e      	bne.n	1b1e <u8g2_DrawHVLine+0x134>
	  return;
    1ae0:	e039      	b.n	1b56 <u8g2_DrawHVLine+0x16c>
      }
      else
      {
	if ( x < u8g2->user_x0 )
    1ae2:	68fb      	ldr	r3, [r7, #12]
    1ae4:	2248      	movs	r2, #72	; 0x48
    1ae6:	5a9a      	ldrh	r2, [r3, r2]
    1ae8:	230a      	movs	r3, #10
    1aea:	18fb      	adds	r3, r7, r3
    1aec:	881b      	ldrh	r3, [r3, #0]
    1aee:	429a      	cmp	r2, r3
    1af0:	d82c      	bhi.n	1b4c <u8g2_DrawHVLine+0x162>
	  return;
	if ( x >= u8g2->user_x1 )
    1af2:	68fb      	ldr	r3, [r7, #12]
    1af4:	224a      	movs	r2, #74	; 0x4a
    1af6:	5a9a      	ldrh	r2, [r3, r2]
    1af8:	230a      	movs	r3, #10
    1afa:	18fb      	adds	r3, r7, r3
    1afc:	881b      	ldrh	r3, [r3, #0]
    1afe:	429a      	cmp	r2, r3
    1b00:	d926      	bls.n	1b50 <u8g2_DrawHVLine+0x166>
	  return;
	if ( u8g2_clip_intersection2(&y, &len, u8g2->user_y0, u8g2->user_y1) == 0 )
    1b02:	68fb      	ldr	r3, [r7, #12]
    1b04:	224c      	movs	r2, #76	; 0x4c
    1b06:	5a9c      	ldrh	r4, [r3, r2]
    1b08:	68fb      	ldr	r3, [r7, #12]
    1b0a:	224e      	movs	r2, #78	; 0x4e
    1b0c:	5a9b      	ldrh	r3, [r3, r2]
    1b0e:	1db9      	adds	r1, r7, #6
    1b10:	2208      	movs	r2, #8
    1b12:	18b8      	adds	r0, r7, r2
    1b14:	0022      	movs	r2, r4
    1b16:	f7ff feb5 	bl	1884 <u8g2_clip_intersection2>
    1b1a:	1e03      	subs	r3, r0, #0
    1b1c:	d01a      	beq.n	1b54 <u8g2_DrawHVLine+0x16a>
	  return;
      }
      
      
      u8g2->cb->draw_l90(u8g2, x, y, len, dir);
    1b1e:	68fb      	ldr	r3, [r7, #12]
    1b20:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    1b22:	689c      	ldr	r4, [r3, #8]
    1b24:	230a      	movs	r3, #10
    1b26:	18fb      	adds	r3, r7, r3
    1b28:	8819      	ldrh	r1, [r3, #0]
    1b2a:	2308      	movs	r3, #8
    1b2c:	18fb      	adds	r3, r7, r3
    1b2e:	881a      	ldrh	r2, [r3, #0]
    1b30:	1dbb      	adds	r3, r7, #6
    1b32:	881d      	ldrh	r5, [r3, #0]
    1b34:	68f8      	ldr	r0, [r7, #12]
    1b36:	2320      	movs	r3, #32
    1b38:	18fb      	adds	r3, r7, r3
    1b3a:	781b      	ldrb	r3, [r3, #0]
    1b3c:	9300      	str	r3, [sp, #0]
    1b3e:	002b      	movs	r3, r5
    1b40:	47a0      	blx	r4
    1b42:	e008      	b.n	1b56 <u8g2_DrawHVLine+0x16c>
	  return;
    1b44:	46c0      	nop			; (mov r8, r8)
    1b46:	e006      	b.n	1b56 <u8g2_DrawHVLine+0x16c>
	  return;
    1b48:	46c0      	nop			; (mov r8, r8)
    1b4a:	e004      	b.n	1b56 <u8g2_DrawHVLine+0x16c>
	  return;
    1b4c:	46c0      	nop			; (mov r8, r8)
    1b4e:	e002      	b.n	1b56 <u8g2_DrawHVLine+0x16c>
	  return;
    1b50:	46c0      	nop			; (mov r8, r8)
    1b52:	e000      	b.n	1b56 <u8g2_DrawHVLine+0x16c>
	  return;
    1b54:	46c0      	nop			; (mov r8, r8)
    }
}
    1b56:	46bd      	mov	sp, r7
    1b58:	b004      	add	sp, #16
    1b5a:	bdb0      	pop	{r4, r5, r7, pc}

00001b5c <u8g2_DrawHLine>:

void u8g2_DrawHLine(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t len)
{
    1b5c:	b590      	push	{r4, r7, lr}
    1b5e:	b087      	sub	sp, #28
    1b60:	af02      	add	r7, sp, #8
    1b62:	60f8      	str	r0, [r7, #12]
    1b64:	000c      	movs	r4, r1
    1b66:	0010      	movs	r0, r2
    1b68:	0019      	movs	r1, r3
    1b6a:	230a      	movs	r3, #10
    1b6c:	18fb      	adds	r3, r7, r3
    1b6e:	1c22      	adds	r2, r4, #0
    1b70:	801a      	strh	r2, [r3, #0]
    1b72:	2308      	movs	r3, #8
    1b74:	18fb      	adds	r3, r7, r3
    1b76:	1c02      	adds	r2, r0, #0
    1b78:	801a      	strh	r2, [r3, #0]
    1b7a:	1dbb      	adds	r3, r7, #6
    1b7c:	1c0a      	adds	r2, r1, #0
    1b7e:	801a      	strh	r2, [r3, #0]
// #ifdef U8G2_WITH_INTERSECTION
//   if ( u8g2_IsIntersection(u8g2, x, y, x+len, y+1) == 0 ) 
//     return;
// #endif /* U8G2_WITH_INTERSECTION */
  u8g2_DrawHVLine(u8g2, x, y, len, 0);
    1b80:	1dbb      	adds	r3, r7, #6
    1b82:	881c      	ldrh	r4, [r3, #0]
    1b84:	2308      	movs	r3, #8
    1b86:	18fb      	adds	r3, r7, r3
    1b88:	881a      	ldrh	r2, [r3, #0]
    1b8a:	230a      	movs	r3, #10
    1b8c:	18fb      	adds	r3, r7, r3
    1b8e:	8819      	ldrh	r1, [r3, #0]
    1b90:	68f8      	ldr	r0, [r7, #12]
    1b92:	2300      	movs	r3, #0
    1b94:	9300      	str	r3, [sp, #0]
    1b96:	0023      	movs	r3, r4
    1b98:	f7ff ff27 	bl	19ea <u8g2_DrawHVLine>
}
    1b9c:	46c0      	nop			; (mov r8, r8)
    1b9e:	46bd      	mov	sp, r7
    1ba0:	b005      	add	sp, #20
    1ba2:	bd90      	pop	{r4, r7, pc}

00001ba4 <u8g2_DrawVLine>:

void u8g2_DrawVLine(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t len)
{
    1ba4:	b590      	push	{r4, r7, lr}
    1ba6:	b087      	sub	sp, #28
    1ba8:	af02      	add	r7, sp, #8
    1baa:	60f8      	str	r0, [r7, #12]
    1bac:	000c      	movs	r4, r1
    1bae:	0010      	movs	r0, r2
    1bb0:	0019      	movs	r1, r3
    1bb2:	230a      	movs	r3, #10
    1bb4:	18fb      	adds	r3, r7, r3
    1bb6:	1c22      	adds	r2, r4, #0
    1bb8:	801a      	strh	r2, [r3, #0]
    1bba:	2308      	movs	r3, #8
    1bbc:	18fb      	adds	r3, r7, r3
    1bbe:	1c02      	adds	r2, r0, #0
    1bc0:	801a      	strh	r2, [r3, #0]
    1bc2:	1dbb      	adds	r3, r7, #6
    1bc4:	1c0a      	adds	r2, r1, #0
    1bc6:	801a      	strh	r2, [r3, #0]
// #ifdef U8G2_WITH_INTERSECTION
//   if ( u8g2_IsIntersection(u8g2, x, y, x+1, y+len) == 0 ) 
//     return;
// #endif /* U8G2_WITH_INTERSECTION */
  u8g2_DrawHVLine(u8g2, x, y, len, 1);
    1bc8:	1dbb      	adds	r3, r7, #6
    1bca:	881c      	ldrh	r4, [r3, #0]
    1bcc:	2308      	movs	r3, #8
    1bce:	18fb      	adds	r3, r7, r3
    1bd0:	881a      	ldrh	r2, [r3, #0]
    1bd2:	230a      	movs	r3, #10
    1bd4:	18fb      	adds	r3, r7, r3
    1bd6:	8819      	ldrh	r1, [r3, #0]
    1bd8:	68f8      	ldr	r0, [r7, #12]
    1bda:	2301      	movs	r3, #1
    1bdc:	9300      	str	r3, [sp, #0]
    1bde:	0023      	movs	r3, r4
    1be0:	f7ff ff03 	bl	19ea <u8g2_DrawHVLine>
}
    1be4:	46c0      	nop			; (mov r8, r8)
    1be6:	46bd      	mov	sp, r7
    1be8:	b005      	add	sp, #20
    1bea:	bd90      	pop	{r4, r7, pc}

00001bec <u8g2_DrawPixel>:

void u8g2_DrawPixel(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y)
{
    1bec:	b580      	push	{r7, lr}
    1bee:	b084      	sub	sp, #16
    1bf0:	af02      	add	r7, sp, #8
    1bf2:	6078      	str	r0, [r7, #4]
    1bf4:	0008      	movs	r0, r1
    1bf6:	0011      	movs	r1, r2
    1bf8:	1cbb      	adds	r3, r7, #2
    1bfa:	1c02      	adds	r2, r0, #0
    1bfc:	801a      	strh	r2, [r3, #0]
    1bfe:	003b      	movs	r3, r7
    1c00:	1c0a      	adds	r2, r1, #0
    1c02:	801a      	strh	r2, [r3, #0]
#ifdef U8G2_WITH_INTERSECTION
  if ( y < u8g2->user_y0 )
    1c04:	687b      	ldr	r3, [r7, #4]
    1c06:	224c      	movs	r2, #76	; 0x4c
    1c08:	5a9b      	ldrh	r3, [r3, r2]
    1c0a:	003a      	movs	r2, r7
    1c0c:	8812      	ldrh	r2, [r2, #0]
    1c0e:	429a      	cmp	r2, r3
    1c10:	d31f      	bcc.n	1c52 <u8g2_DrawPixel+0x66>
    return;
  if ( y >= u8g2->user_y1 )
    1c12:	687b      	ldr	r3, [r7, #4]
    1c14:	224e      	movs	r2, #78	; 0x4e
    1c16:	5a9b      	ldrh	r3, [r3, r2]
    1c18:	003a      	movs	r2, r7
    1c1a:	8812      	ldrh	r2, [r2, #0]
    1c1c:	429a      	cmp	r2, r3
    1c1e:	d21a      	bcs.n	1c56 <u8g2_DrawPixel+0x6a>
    return;
  if ( x < u8g2->user_x0 )
    1c20:	687b      	ldr	r3, [r7, #4]
    1c22:	2248      	movs	r2, #72	; 0x48
    1c24:	5a9b      	ldrh	r3, [r3, r2]
    1c26:	1cba      	adds	r2, r7, #2
    1c28:	8812      	ldrh	r2, [r2, #0]
    1c2a:	429a      	cmp	r2, r3
    1c2c:	d315      	bcc.n	1c5a <u8g2_DrawPixel+0x6e>
    return;
  if ( x >= u8g2->user_x1 )
    1c2e:	687b      	ldr	r3, [r7, #4]
    1c30:	224a      	movs	r2, #74	; 0x4a
    1c32:	5a9b      	ldrh	r3, [r3, r2]
    1c34:	1cba      	adds	r2, r7, #2
    1c36:	8812      	ldrh	r2, [r2, #0]
    1c38:	429a      	cmp	r2, r3
    1c3a:	d210      	bcs.n	1c5e <u8g2_DrawPixel+0x72>
    return;
#endif /* U8G2_WITH_INTERSECTION */
  u8g2_DrawHVLine(u8g2, x, y, 1, 0);
    1c3c:	003b      	movs	r3, r7
    1c3e:	881a      	ldrh	r2, [r3, #0]
    1c40:	1cbb      	adds	r3, r7, #2
    1c42:	8819      	ldrh	r1, [r3, #0]
    1c44:	6878      	ldr	r0, [r7, #4]
    1c46:	2300      	movs	r3, #0
    1c48:	9300      	str	r3, [sp, #0]
    1c4a:	2301      	movs	r3, #1
    1c4c:	f7ff fecd 	bl	19ea <u8g2_DrawHVLine>
    1c50:	e006      	b.n	1c60 <u8g2_DrawPixel+0x74>
    return;
    1c52:	46c0      	nop			; (mov r8, r8)
    1c54:	e004      	b.n	1c60 <u8g2_DrawPixel+0x74>
    return;
    1c56:	46c0      	nop			; (mov r8, r8)
    1c58:	e002      	b.n	1c60 <u8g2_DrawPixel+0x74>
    return;
    1c5a:	46c0      	nop			; (mov r8, r8)
    1c5c:	e000      	b.n	1c60 <u8g2_DrawPixel+0x74>
    return;
    1c5e:	46c0      	nop			; (mov r8, r8)
}
    1c60:	46bd      	mov	sp, r7
    1c62:	b002      	add	sp, #8
    1c64:	bd80      	pop	{r7, pc}

00001c66 <u8g2_is_intersection_decision_tree>:
  version with asymetric boundaries.
  a1 and v1 are excluded
  v0 == v1 is not support end return 1
*/
uint8_t u8g2_is_intersection_decision_tree(u8g2_uint_t a0, u8g2_uint_t a1, u8g2_uint_t v0, u8g2_uint_t v1)
{
    1c66:	b5b0      	push	{r4, r5, r7, lr}
    1c68:	b082      	sub	sp, #8
    1c6a:	af00      	add	r7, sp, #0
    1c6c:	0005      	movs	r5, r0
    1c6e:	000c      	movs	r4, r1
    1c70:	0010      	movs	r0, r2
    1c72:	0019      	movs	r1, r3
    1c74:	1dbb      	adds	r3, r7, #6
    1c76:	1c2a      	adds	r2, r5, #0
    1c78:	801a      	strh	r2, [r3, #0]
    1c7a:	1d3b      	adds	r3, r7, #4
    1c7c:	1c22      	adds	r2, r4, #0
    1c7e:	801a      	strh	r2, [r3, #0]
    1c80:	1cbb      	adds	r3, r7, #2
    1c82:	1c02      	adds	r2, r0, #0
    1c84:	801a      	strh	r2, [r3, #0]
    1c86:	003b      	movs	r3, r7
    1c88:	1c0a      	adds	r2, r1, #0
    1c8a:	801a      	strh	r2, [r3, #0]
  if ( v0 < a1 )		// v0 <= a1
    1c8c:	1cba      	adds	r2, r7, #2
    1c8e:	1d3b      	adds	r3, r7, #4
    1c90:	8812      	ldrh	r2, [r2, #0]
    1c92:	881b      	ldrh	r3, [r3, #0]
    1c94:	429a      	cmp	r2, r3
    1c96:	d211      	bcs.n	1cbc <u8g2_is_intersection_decision_tree+0x56>
  {
    if ( v1 > a0 )	// v1 >= a0
    1c98:	003a      	movs	r2, r7
    1c9a:	1dbb      	adds	r3, r7, #6
    1c9c:	8812      	ldrh	r2, [r2, #0]
    1c9e:	881b      	ldrh	r3, [r3, #0]
    1ca0:	429a      	cmp	r2, r3
    1ca2:	d901      	bls.n	1ca8 <u8g2_is_intersection_decision_tree+0x42>
    {
      return 1;
    1ca4:	2301      	movs	r3, #1
    1ca6:	e01a      	b.n	1cde <u8g2_is_intersection_decision_tree+0x78>
    }
    else
    {
      if ( v0 > v1 )	// v0 > v1
    1ca8:	1cba      	adds	r2, r7, #2
    1caa:	003b      	movs	r3, r7
    1cac:	8812      	ldrh	r2, [r2, #0]
    1cae:	881b      	ldrh	r3, [r3, #0]
    1cb0:	429a      	cmp	r2, r3
    1cb2:	d901      	bls.n	1cb8 <u8g2_is_intersection_decision_tree+0x52>
      {
	return 1;
    1cb4:	2301      	movs	r3, #1
    1cb6:	e012      	b.n	1cde <u8g2_is_intersection_decision_tree+0x78>
      }
      else
      {
	return 0;
    1cb8:	2300      	movs	r3, #0
    1cba:	e010      	b.n	1cde <u8g2_is_intersection_decision_tree+0x78>
      }
    }
  }
  else
  {
    if ( v1 > a0 )	// v1 >= a0
    1cbc:	003a      	movs	r2, r7
    1cbe:	1dbb      	adds	r3, r7, #6
    1cc0:	8812      	ldrh	r2, [r2, #0]
    1cc2:	881b      	ldrh	r3, [r3, #0]
    1cc4:	429a      	cmp	r2, r3
    1cc6:	d909      	bls.n	1cdc <u8g2_is_intersection_decision_tree+0x76>
    {
      if ( v0 > v1 )	// v0 > v1
    1cc8:	1cba      	adds	r2, r7, #2
    1cca:	003b      	movs	r3, r7
    1ccc:	8812      	ldrh	r2, [r2, #0]
    1cce:	881b      	ldrh	r3, [r3, #0]
    1cd0:	429a      	cmp	r2, r3
    1cd2:	d901      	bls.n	1cd8 <u8g2_is_intersection_decision_tree+0x72>
      {
	return 1;
    1cd4:	2301      	movs	r3, #1
    1cd6:	e002      	b.n	1cde <u8g2_is_intersection_decision_tree+0x78>
      }
      else
      {
	return 0;
    1cd8:	2300      	movs	r3, #0
    1cda:	e000      	b.n	1cde <u8g2_is_intersection_decision_tree+0x78>
      }
    }
    else
    {
      return 0;
    1cdc:	2300      	movs	r3, #0
    }
  }
}
    1cde:	0018      	movs	r0, r3
    1ce0:	46bd      	mov	sp, r7
    1ce2:	b002      	add	sp, #8
    1ce4:	bdb0      	pop	{r4, r5, r7, pc}

00001ce6 <u8g2_IsIntersection>:



/* upper limits are not included (asymetric boundaries) */
uint8_t u8g2_IsIntersection(u8g2_t *u8g2, u8g2_uint_t x0, u8g2_uint_t y0, u8g2_uint_t x1, u8g2_uint_t y1)
{
    1ce6:	b590      	push	{r4, r7, lr}
    1ce8:	b085      	sub	sp, #20
    1cea:	af00      	add	r7, sp, #0
    1cec:	60f8      	str	r0, [r7, #12]
    1cee:	000c      	movs	r4, r1
    1cf0:	0010      	movs	r0, r2
    1cf2:	0019      	movs	r1, r3
    1cf4:	230a      	movs	r3, #10
    1cf6:	18fb      	adds	r3, r7, r3
    1cf8:	1c22      	adds	r2, r4, #0
    1cfa:	801a      	strh	r2, [r3, #0]
    1cfc:	2308      	movs	r3, #8
    1cfe:	18fb      	adds	r3, r7, r3
    1d00:	1c02      	adds	r2, r0, #0
    1d02:	801a      	strh	r2, [r3, #0]
    1d04:	1dbb      	adds	r3, r7, #6
    1d06:	1c0a      	adds	r2, r1, #0
    1d08:	801a      	strh	r2, [r3, #0]
  if ( u8g2_is_intersection_decision_tree(u8g2->user_y0, u8g2->user_y1, y0, y1) == 0 )
    1d0a:	68fb      	ldr	r3, [r7, #12]
    1d0c:	224c      	movs	r2, #76	; 0x4c
    1d0e:	5a98      	ldrh	r0, [r3, r2]
    1d10:	68fb      	ldr	r3, [r7, #12]
    1d12:	224e      	movs	r2, #78	; 0x4e
    1d14:	5a99      	ldrh	r1, [r3, r2]
    1d16:	2320      	movs	r3, #32
    1d18:	18fb      	adds	r3, r7, r3
    1d1a:	881c      	ldrh	r4, [r3, #0]
    1d1c:	2308      	movs	r3, #8
    1d1e:	18fb      	adds	r3, r7, r3
    1d20:	881a      	ldrh	r2, [r3, #0]
    1d22:	0023      	movs	r3, r4
    1d24:	f7ff ff9f 	bl	1c66 <u8g2_is_intersection_decision_tree>
    1d28:	1e03      	subs	r3, r0, #0
    1d2a:	d101      	bne.n	1d30 <u8g2_IsIntersection+0x4a>
    return 0; 
    1d2c:	2300      	movs	r3, #0
    1d2e:	e00e      	b.n	1d4e <u8g2_IsIntersection+0x68>
  
  return u8g2_is_intersection_decision_tree(u8g2->user_x0, u8g2->user_x1, x0, x1);
    1d30:	68fb      	ldr	r3, [r7, #12]
    1d32:	2248      	movs	r2, #72	; 0x48
    1d34:	5a98      	ldrh	r0, [r3, r2]
    1d36:	68fb      	ldr	r3, [r7, #12]
    1d38:	224a      	movs	r2, #74	; 0x4a
    1d3a:	5a99      	ldrh	r1, [r3, r2]
    1d3c:	1dbb      	adds	r3, r7, #6
    1d3e:	881c      	ldrh	r4, [r3, #0]
    1d40:	230a      	movs	r3, #10
    1d42:	18fb      	adds	r3, r7, r3
    1d44:	881a      	ldrh	r2, [r3, #0]
    1d46:	0023      	movs	r3, r4
    1d48:	f7ff ff8d 	bl	1c66 <u8g2_is_intersection_decision_tree>
    1d4c:	0003      	movs	r3, r0
}
    1d4e:	0018      	movs	r0, r3
    1d50:	46bd      	mov	sp, r7
    1d52:	b005      	add	sp, #20
    1d54:	bd90      	pop	{r4, r7, pc}
	...

00001d58 <u8g2_DrawLine>:

#include "u8g2.h"


void u8g2_DrawLine(u8g2_t *u8g2, u8g2_uint_t x1, u8g2_uint_t y1, u8g2_uint_t x2, u8g2_uint_t y2)
{
    1d58:	b590      	push	{r4, r7, lr}
    1d5a:	b089      	sub	sp, #36	; 0x24
    1d5c:	af00      	add	r7, sp, #0
    1d5e:	60f8      	str	r0, [r7, #12]
    1d60:	000c      	movs	r4, r1
    1d62:	0010      	movs	r0, r2
    1d64:	0019      	movs	r1, r3
    1d66:	230a      	movs	r3, #10
    1d68:	18fb      	adds	r3, r7, r3
    1d6a:	1c22      	adds	r2, r4, #0
    1d6c:	801a      	strh	r2, [r3, #0]
    1d6e:	2308      	movs	r3, #8
    1d70:	18fb      	adds	r3, r7, r3
    1d72:	1c02      	adds	r2, r0, #0
    1d74:	801a      	strh	r2, [r3, #0]
    1d76:	1dbb      	adds	r3, r7, #6
    1d78:	1c0a      	adds	r2, r1, #0
    1d7a:	801a      	strh	r2, [r3, #0]
  u8g2_uint_t x,y;
  u8g2_uint_t dx, dy;
  u8g2_int_t err;
  u8g2_int_t ystep;

  uint8_t swapxy = 0;
    1d7c:	2313      	movs	r3, #19
    1d7e:	18fb      	adds	r3, r7, r3
    1d80:	2200      	movs	r2, #0
    1d82:	701a      	strb	r2, [r3, #0]
  
  /* no intersection check at the moment, should be added... */

  if ( x1 > x2 ) dx = x1-x2; else dx = x2-x1;
    1d84:	230a      	movs	r3, #10
    1d86:	18fa      	adds	r2, r7, r3
    1d88:	1dbb      	adds	r3, r7, #6
    1d8a:	8812      	ldrh	r2, [r2, #0]
    1d8c:	881b      	ldrh	r3, [r3, #0]
    1d8e:	429a      	cmp	r2, r3
    1d90:	d909      	bls.n	1da6 <u8g2_DrawLine+0x4e>
    1d92:	231a      	movs	r3, #26
    1d94:	18fb      	adds	r3, r7, r3
    1d96:	220a      	movs	r2, #10
    1d98:	18b9      	adds	r1, r7, r2
    1d9a:	1dba      	adds	r2, r7, #6
    1d9c:	8809      	ldrh	r1, [r1, #0]
    1d9e:	8812      	ldrh	r2, [r2, #0]
    1da0:	1a8a      	subs	r2, r1, r2
    1da2:	801a      	strh	r2, [r3, #0]
    1da4:	e008      	b.n	1db8 <u8g2_DrawLine+0x60>
    1da6:	231a      	movs	r3, #26
    1da8:	18fb      	adds	r3, r7, r3
    1daa:	1db9      	adds	r1, r7, #6
    1dac:	220a      	movs	r2, #10
    1dae:	18ba      	adds	r2, r7, r2
    1db0:	8809      	ldrh	r1, [r1, #0]
    1db2:	8812      	ldrh	r2, [r2, #0]
    1db4:	1a8a      	subs	r2, r1, r2
    1db6:	801a      	strh	r2, [r3, #0]
  if ( y1 > y2 ) dy = y1-y2; else dy = y2-y1;
    1db8:	2308      	movs	r3, #8
    1dba:	18fb      	adds	r3, r7, r3
    1dbc:	2230      	movs	r2, #48	; 0x30
    1dbe:	18b9      	adds	r1, r7, r2
    1dc0:	881a      	ldrh	r2, [r3, #0]
    1dc2:	880b      	ldrh	r3, [r1, #0]
    1dc4:	429a      	cmp	r2, r3
    1dc6:	d90a      	bls.n	1dde <u8g2_DrawLine+0x86>
    1dc8:	2318      	movs	r3, #24
    1dca:	18fb      	adds	r3, r7, r3
    1dcc:	2208      	movs	r2, #8
    1dce:	18ba      	adds	r2, r7, r2
    1dd0:	2130      	movs	r1, #48	; 0x30
    1dd2:	1878      	adds	r0, r7, r1
    1dd4:	8811      	ldrh	r1, [r2, #0]
    1dd6:	8802      	ldrh	r2, [r0, #0]
    1dd8:	1a8a      	subs	r2, r1, r2
    1dda:	801a      	strh	r2, [r3, #0]
    1ddc:	e009      	b.n	1df2 <u8g2_DrawLine+0x9a>
    1dde:	2318      	movs	r3, #24
    1de0:	18fb      	adds	r3, r7, r3
    1de2:	2230      	movs	r2, #48	; 0x30
    1de4:	18b9      	adds	r1, r7, r2
    1de6:	2208      	movs	r2, #8
    1de8:	18ba      	adds	r2, r7, r2
    1dea:	8809      	ldrh	r1, [r1, #0]
    1dec:	8812      	ldrh	r2, [r2, #0]
    1dee:	1a8a      	subs	r2, r1, r2
    1df0:	801a      	strh	r2, [r3, #0]

  if ( dy > dx ) 
    1df2:	2318      	movs	r3, #24
    1df4:	18fa      	adds	r2, r7, r3
    1df6:	231a      	movs	r3, #26
    1df8:	18fb      	adds	r3, r7, r3
    1dfa:	8812      	ldrh	r2, [r2, #0]
    1dfc:	881b      	ldrh	r3, [r3, #0]
    1dfe:	429a      	cmp	r2, r3
    1e00:	d937      	bls.n	1e72 <u8g2_DrawLine+0x11a>
  {
    swapxy = 1;
    1e02:	2313      	movs	r3, #19
    1e04:	18fb      	adds	r3, r7, r3
    1e06:	2201      	movs	r2, #1
    1e08:	701a      	strb	r2, [r3, #0]
    tmp = dx; dx =dy; dy = tmp;
    1e0a:	2310      	movs	r3, #16
    1e0c:	18fb      	adds	r3, r7, r3
    1e0e:	221a      	movs	r2, #26
    1e10:	18ba      	adds	r2, r7, r2
    1e12:	8812      	ldrh	r2, [r2, #0]
    1e14:	801a      	strh	r2, [r3, #0]
    1e16:	231a      	movs	r3, #26
    1e18:	18fb      	adds	r3, r7, r3
    1e1a:	2218      	movs	r2, #24
    1e1c:	18ba      	adds	r2, r7, r2
    1e1e:	8812      	ldrh	r2, [r2, #0]
    1e20:	801a      	strh	r2, [r3, #0]
    1e22:	2318      	movs	r3, #24
    1e24:	18fb      	adds	r3, r7, r3
    1e26:	2210      	movs	r2, #16
    1e28:	18ba      	adds	r2, r7, r2
    1e2a:	8812      	ldrh	r2, [r2, #0]
    1e2c:	801a      	strh	r2, [r3, #0]
    tmp = x1; x1 =y1; y1 = tmp;
    1e2e:	2310      	movs	r3, #16
    1e30:	18fb      	adds	r3, r7, r3
    1e32:	220a      	movs	r2, #10
    1e34:	18ba      	adds	r2, r7, r2
    1e36:	8812      	ldrh	r2, [r2, #0]
    1e38:	801a      	strh	r2, [r3, #0]
    1e3a:	230a      	movs	r3, #10
    1e3c:	18fb      	adds	r3, r7, r3
    1e3e:	2208      	movs	r2, #8
    1e40:	18ba      	adds	r2, r7, r2
    1e42:	8812      	ldrh	r2, [r2, #0]
    1e44:	801a      	strh	r2, [r3, #0]
    1e46:	2308      	movs	r3, #8
    1e48:	18fb      	adds	r3, r7, r3
    1e4a:	2210      	movs	r2, #16
    1e4c:	18ba      	adds	r2, r7, r2
    1e4e:	8812      	ldrh	r2, [r2, #0]
    1e50:	801a      	strh	r2, [r3, #0]
    tmp = x2; x2 =y2; y2 = tmp;
    1e52:	2310      	movs	r3, #16
    1e54:	18fb      	adds	r3, r7, r3
    1e56:	1dba      	adds	r2, r7, #6
    1e58:	8812      	ldrh	r2, [r2, #0]
    1e5a:	801a      	strh	r2, [r3, #0]
    1e5c:	1dbb      	adds	r3, r7, #6
    1e5e:	2230      	movs	r2, #48	; 0x30
    1e60:	18ba      	adds	r2, r7, r2
    1e62:	8812      	ldrh	r2, [r2, #0]
    1e64:	801a      	strh	r2, [r3, #0]
    1e66:	2330      	movs	r3, #48	; 0x30
    1e68:	18fa      	adds	r2, r7, r3
    1e6a:	2310      	movs	r3, #16
    1e6c:	18fb      	adds	r3, r7, r3
    1e6e:	881b      	ldrh	r3, [r3, #0]
    1e70:	8013      	strh	r3, [r2, #0]
  }
  if ( x1 > x2 ) 
    1e72:	230a      	movs	r3, #10
    1e74:	18fa      	adds	r2, r7, r3
    1e76:	1dbb      	adds	r3, r7, #6
    1e78:	8812      	ldrh	r2, [r2, #0]
    1e7a:	881b      	ldrh	r3, [r3, #0]
    1e7c:	429a      	cmp	r2, r3
    1e7e:	d921      	bls.n	1ec4 <u8g2_DrawLine+0x16c>
  {
    tmp = x1; x1 =x2; x2 = tmp;
    1e80:	2310      	movs	r3, #16
    1e82:	18fb      	adds	r3, r7, r3
    1e84:	220a      	movs	r2, #10
    1e86:	18ba      	adds	r2, r7, r2
    1e88:	8812      	ldrh	r2, [r2, #0]
    1e8a:	801a      	strh	r2, [r3, #0]
    1e8c:	230a      	movs	r3, #10
    1e8e:	18fb      	adds	r3, r7, r3
    1e90:	1dba      	adds	r2, r7, #6
    1e92:	8812      	ldrh	r2, [r2, #0]
    1e94:	801a      	strh	r2, [r3, #0]
    1e96:	1dbb      	adds	r3, r7, #6
    1e98:	2210      	movs	r2, #16
    1e9a:	18ba      	adds	r2, r7, r2
    1e9c:	8812      	ldrh	r2, [r2, #0]
    1e9e:	801a      	strh	r2, [r3, #0]
    tmp = y1; y1 =y2; y2 = tmp;
    1ea0:	2310      	movs	r3, #16
    1ea2:	18fb      	adds	r3, r7, r3
    1ea4:	2208      	movs	r2, #8
    1ea6:	18ba      	adds	r2, r7, r2
    1ea8:	8812      	ldrh	r2, [r2, #0]
    1eaa:	801a      	strh	r2, [r3, #0]
    1eac:	2308      	movs	r3, #8
    1eae:	18fb      	adds	r3, r7, r3
    1eb0:	2230      	movs	r2, #48	; 0x30
    1eb2:	18ba      	adds	r2, r7, r2
    1eb4:	8812      	ldrh	r2, [r2, #0]
    1eb6:	801a      	strh	r2, [r3, #0]
    1eb8:	2330      	movs	r3, #48	; 0x30
    1eba:	18fa      	adds	r2, r7, r3
    1ebc:	2310      	movs	r3, #16
    1ebe:	18fb      	adds	r3, r7, r3
    1ec0:	881b      	ldrh	r3, [r3, #0]
    1ec2:	8013      	strh	r3, [r2, #0]
  }
  err = dx >> 1;
    1ec4:	231a      	movs	r3, #26
    1ec6:	18fb      	adds	r3, r7, r3
    1ec8:	881b      	ldrh	r3, [r3, #0]
    1eca:	085b      	lsrs	r3, r3, #1
    1ecc:	b29a      	uxth	r2, r3
    1ece:	2316      	movs	r3, #22
    1ed0:	18fb      	adds	r3, r7, r3
    1ed2:	801a      	strh	r2, [r3, #0]
  if ( y2 > y1 ) ystep = 1; else ystep = -1;
    1ed4:	2330      	movs	r3, #48	; 0x30
    1ed6:	18fa      	adds	r2, r7, r3
    1ed8:	2308      	movs	r3, #8
    1eda:	18fb      	adds	r3, r7, r3
    1edc:	8812      	ldrh	r2, [r2, #0]
    1ede:	881b      	ldrh	r3, [r3, #0]
    1ee0:	429a      	cmp	r2, r3
    1ee2:	d904      	bls.n	1eee <u8g2_DrawLine+0x196>
    1ee4:	2314      	movs	r3, #20
    1ee6:	18fb      	adds	r3, r7, r3
    1ee8:	2201      	movs	r2, #1
    1eea:	801a      	strh	r2, [r3, #0]
    1eec:	e004      	b.n	1ef8 <u8g2_DrawLine+0x1a0>
    1eee:	2314      	movs	r3, #20
    1ef0:	18fb      	adds	r3, r7, r3
    1ef2:	2201      	movs	r2, #1
    1ef4:	4252      	negs	r2, r2
    1ef6:	801a      	strh	r2, [r3, #0]
  y = y1;
    1ef8:	231c      	movs	r3, #28
    1efa:	18fb      	adds	r3, r7, r3
    1efc:	2208      	movs	r2, #8
    1efe:	18ba      	adds	r2, r7, r2
    1f00:	8812      	ldrh	r2, [r2, #0]
    1f02:	801a      	strh	r2, [r3, #0]

#ifndef  U8G2_16BIT
  if ( x2 == 255 )
    x2--;
#else
  if ( x2 == 0xffff )
    1f04:	1dbb      	adds	r3, r7, #6
    1f06:	881b      	ldrh	r3, [r3, #0]
    1f08:	4a30      	ldr	r2, [pc, #192]	; (1fcc <u8g2_DrawLine+0x274>)
    1f0a:	4293      	cmp	r3, r2
    1f0c:	d104      	bne.n	1f18 <u8g2_DrawLine+0x1c0>
    x2--;
    1f0e:	1dbb      	adds	r3, r7, #6
    1f10:	881a      	ldrh	r2, [r3, #0]
    1f12:	1dbb      	adds	r3, r7, #6
    1f14:	3a01      	subs	r2, #1
    1f16:	801a      	strh	r2, [r3, #0]
#endif

  for( x = x1; x <= x2; x++ )
    1f18:	231e      	movs	r3, #30
    1f1a:	18fb      	adds	r3, r7, r3
    1f1c:	220a      	movs	r2, #10
    1f1e:	18ba      	adds	r2, r7, r2
    1f20:	8812      	ldrh	r2, [r2, #0]
    1f22:	801a      	strh	r2, [r3, #0]
    1f24:	e046      	b.n	1fb4 <u8g2_DrawLine+0x25c>
  {
    if ( swapxy == 0 ) 
    1f26:	2313      	movs	r3, #19
    1f28:	18fb      	adds	r3, r7, r3
    1f2a:	781b      	ldrb	r3, [r3, #0]
    1f2c:	2b00      	cmp	r3, #0
    1f2e:	d10a      	bne.n	1f46 <u8g2_DrawLine+0x1ee>
      u8g2_DrawPixel(u8g2, x, y); 
    1f30:	231c      	movs	r3, #28
    1f32:	18fb      	adds	r3, r7, r3
    1f34:	881a      	ldrh	r2, [r3, #0]
    1f36:	231e      	movs	r3, #30
    1f38:	18fb      	adds	r3, r7, r3
    1f3a:	8819      	ldrh	r1, [r3, #0]
    1f3c:	68fb      	ldr	r3, [r7, #12]
    1f3e:	0018      	movs	r0, r3
    1f40:	f7ff fe54 	bl	1bec <u8g2_DrawPixel>
    1f44:	e009      	b.n	1f5a <u8g2_DrawLine+0x202>
    else 
      u8g2_DrawPixel(u8g2, y, x); 
    1f46:	231e      	movs	r3, #30
    1f48:	18fb      	adds	r3, r7, r3
    1f4a:	881a      	ldrh	r2, [r3, #0]
    1f4c:	231c      	movs	r3, #28
    1f4e:	18fb      	adds	r3, r7, r3
    1f50:	8819      	ldrh	r1, [r3, #0]
    1f52:	68fb      	ldr	r3, [r7, #12]
    1f54:	0018      	movs	r0, r3
    1f56:	f7ff fe49 	bl	1bec <u8g2_DrawPixel>
    err -= (u8g2_uint_t)dy;
    1f5a:	2316      	movs	r3, #22
    1f5c:	18fb      	adds	r3, r7, r3
    1f5e:	881a      	ldrh	r2, [r3, #0]
    1f60:	2318      	movs	r3, #24
    1f62:	18fb      	adds	r3, r7, r3
    1f64:	881b      	ldrh	r3, [r3, #0]
    1f66:	1ad3      	subs	r3, r2, r3
    1f68:	b29a      	uxth	r2, r3
    1f6a:	2316      	movs	r3, #22
    1f6c:	18fb      	adds	r3, r7, r3
    1f6e:	801a      	strh	r2, [r3, #0]
    if ( err < 0 ) 
    1f70:	2316      	movs	r3, #22
    1f72:	18fb      	adds	r3, r7, r3
    1f74:	2200      	movs	r2, #0
    1f76:	5e9b      	ldrsh	r3, [r3, r2]
    1f78:	2b00      	cmp	r3, #0
    1f7a:	da14      	bge.n	1fa6 <u8g2_DrawLine+0x24e>
    {
      y += (u8g2_uint_t)ystep;
    1f7c:	2314      	movs	r3, #20
    1f7e:	18fb      	adds	r3, r7, r3
    1f80:	8819      	ldrh	r1, [r3, #0]
    1f82:	231c      	movs	r3, #28
    1f84:	18fb      	adds	r3, r7, r3
    1f86:	221c      	movs	r2, #28
    1f88:	18ba      	adds	r2, r7, r2
    1f8a:	8812      	ldrh	r2, [r2, #0]
    1f8c:	188a      	adds	r2, r1, r2
    1f8e:	801a      	strh	r2, [r3, #0]
      err += (u8g2_uint_t)dx;
    1f90:	2316      	movs	r3, #22
    1f92:	18fb      	adds	r3, r7, r3
    1f94:	881a      	ldrh	r2, [r3, #0]
    1f96:	231a      	movs	r3, #26
    1f98:	18fb      	adds	r3, r7, r3
    1f9a:	881b      	ldrh	r3, [r3, #0]
    1f9c:	18d3      	adds	r3, r2, r3
    1f9e:	b29a      	uxth	r2, r3
    1fa0:	2316      	movs	r3, #22
    1fa2:	18fb      	adds	r3, r7, r3
    1fa4:	801a      	strh	r2, [r3, #0]
  for( x = x1; x <= x2; x++ )
    1fa6:	231e      	movs	r3, #30
    1fa8:	18fb      	adds	r3, r7, r3
    1faa:	881a      	ldrh	r2, [r3, #0]
    1fac:	231e      	movs	r3, #30
    1fae:	18fb      	adds	r3, r7, r3
    1fb0:	3201      	adds	r2, #1
    1fb2:	801a      	strh	r2, [r3, #0]
    1fb4:	231e      	movs	r3, #30
    1fb6:	18fa      	adds	r2, r7, r3
    1fb8:	1dbb      	adds	r3, r7, #6
    1fba:	8812      	ldrh	r2, [r2, #0]
    1fbc:	881b      	ldrh	r3, [r3, #0]
    1fbe:	429a      	cmp	r2, r3
    1fc0:	d9b1      	bls.n	1f26 <u8g2_DrawLine+0x1ce>
    }
  }
}
    1fc2:	46c0      	nop			; (mov r8, r8)
    1fc4:	46bd      	mov	sp, r7
    1fc6:	b009      	add	sp, #36	; 0x24
    1fc8:	bd90      	pop	{r4, r7, pc}
    1fca:	46c0      	nop			; (mov r8, r8)
    1fcc:	0000ffff 	.word	0x0000ffff

00001fd0 <u8g2_ll_hvline_vertical_top_lsb>:
		1: vertical line (top to bottom)
  asumption: 
    all clipping done
*/
void u8g2_ll_hvline_vertical_top_lsb(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t len, uint8_t dir)
{
    1fd0:	b590      	push	{r4, r7, lr}
    1fd2:	b089      	sub	sp, #36	; 0x24
    1fd4:	af00      	add	r7, sp, #0
    1fd6:	60f8      	str	r0, [r7, #12]
    1fd8:	000c      	movs	r4, r1
    1fda:	0010      	movs	r0, r2
    1fdc:	0019      	movs	r1, r3
    1fde:	230a      	movs	r3, #10
    1fe0:	18fb      	adds	r3, r7, r3
    1fe2:	1c22      	adds	r2, r4, #0
    1fe4:	801a      	strh	r2, [r3, #0]
    1fe6:	2308      	movs	r3, #8
    1fe8:	18fb      	adds	r3, r7, r3
    1fea:	1c02      	adds	r2, r0, #0
    1fec:	801a      	strh	r2, [r3, #0]
    1fee:	1dbb      	adds	r3, r7, #6
    1ff0:	1c0a      	adds	r2, r1, #0
    1ff2:	801a      	strh	r2, [r3, #0]
  //assert(x < u8g2_GetU8x8(u8g2)->display_info->tile_width*8);
  //assert(y >= u8g2->buf_y0);
  //assert(y < u8g2_GetU8x8(u8g2)->display_info->tile_height*8);
  
  /* bytes are vertical, lsb on top (y=0), msb at bottom (y=7) */
  bit_pos = y;		/* overflow truncate is ok here... */
    1ff4:	231b      	movs	r3, #27
    1ff6:	18fb      	adds	r3, r7, r3
    1ff8:	2208      	movs	r2, #8
    1ffa:	18ba      	adds	r2, r7, r2
    1ffc:	8812      	ldrh	r2, [r2, #0]
    1ffe:	701a      	strb	r2, [r3, #0]
  bit_pos &= 7; 	/* ... because only the lowest 3 bits are needed */
    2000:	231b      	movs	r3, #27
    2002:	18fb      	adds	r3, r7, r3
    2004:	221b      	movs	r2, #27
    2006:	18ba      	adds	r2, r7, r2
    2008:	7812      	ldrb	r2, [r2, #0]
    200a:	2107      	movs	r1, #7
    200c:	400a      	ands	r2, r1
    200e:	701a      	strb	r2, [r3, #0]
  mask = 1;
    2010:	2318      	movs	r3, #24
    2012:	18fb      	adds	r3, r7, r3
    2014:	2201      	movs	r2, #1
    2016:	701a      	strb	r2, [r3, #0]
  mask <<= bit_pos;
    2018:	2318      	movs	r3, #24
    201a:	18fb      	adds	r3, r7, r3
    201c:	781a      	ldrb	r2, [r3, #0]
    201e:	231b      	movs	r3, #27
    2020:	18fb      	adds	r3, r7, r3
    2022:	781b      	ldrb	r3, [r3, #0]
    2024:	409a      	lsls	r2, r3
    2026:	2318      	movs	r3, #24
    2028:	18fb      	adds	r3, r7, r3
    202a:	701a      	strb	r2, [r3, #0]

  or_mask = 0;
    202c:	231a      	movs	r3, #26
    202e:	18fb      	adds	r3, r7, r3
    2030:	2200      	movs	r2, #0
    2032:	701a      	strb	r2, [r3, #0]
  xor_mask = 0;
    2034:	2319      	movs	r3, #25
    2036:	18fb      	adds	r3, r7, r3
    2038:	2200      	movs	r2, #0
    203a:	701a      	strb	r2, [r3, #0]
  if ( u8g2->draw_color <= 1 )
    203c:	68fb      	ldr	r3, [r7, #12]
    203e:	2292      	movs	r2, #146	; 0x92
    2040:	5c9b      	ldrb	r3, [r3, r2]
    2042:	2b01      	cmp	r3, #1
    2044:	d805      	bhi.n	2052 <STACK_SIZE+0x52>
    or_mask  = mask;
    2046:	231a      	movs	r3, #26
    2048:	18fb      	adds	r3, r7, r3
    204a:	2218      	movs	r2, #24
    204c:	18ba      	adds	r2, r7, r2
    204e:	7812      	ldrb	r2, [r2, #0]
    2050:	701a      	strb	r2, [r3, #0]
  if ( u8g2->draw_color != 1 )
    2052:	68fb      	ldr	r3, [r7, #12]
    2054:	2292      	movs	r2, #146	; 0x92
    2056:	5c9b      	ldrb	r3, [r3, r2]
    2058:	2b01      	cmp	r3, #1
    205a:	d005      	beq.n	2068 <STACK_SIZE+0x68>
    xor_mask = mask;
    205c:	2319      	movs	r3, #25
    205e:	18fb      	adds	r3, r7, r3
    2060:	2218      	movs	r2, #24
    2062:	18ba      	adds	r2, r7, r2
    2064:	7812      	ldrb	r2, [r2, #0]
    2066:	701a      	strb	r2, [r3, #0]


  offset = y;		/* y might be 8 or 16 bit, but we need 16 bit, so use a 16 bit variable */
    2068:	2316      	movs	r3, #22
    206a:	18fb      	adds	r3, r7, r3
    206c:	2208      	movs	r2, #8
    206e:	18ba      	adds	r2, r7, r2
    2070:	8812      	ldrh	r2, [r2, #0]
    2072:	801a      	strh	r2, [r3, #0]
  offset &= ~7;
    2074:	2316      	movs	r3, #22
    2076:	18fb      	adds	r3, r7, r3
    2078:	2216      	movs	r2, #22
    207a:	18ba      	adds	r2, r7, r2
    207c:	8812      	ldrh	r2, [r2, #0]
    207e:	2107      	movs	r1, #7
    2080:	438a      	bics	r2, r1
    2082:	801a      	strh	r2, [r3, #0]
  offset *= u8g2_GetU8x8(u8g2)->display_info->tile_width;
    2084:	68fb      	ldr	r3, [r7, #12]
    2086:	681b      	ldr	r3, [r3, #0]
    2088:	7c1b      	ldrb	r3, [r3, #16]
    208a:	b29a      	uxth	r2, r3
    208c:	2316      	movs	r3, #22
    208e:	18fb      	adds	r3, r7, r3
    2090:	2116      	movs	r1, #22
    2092:	1879      	adds	r1, r7, r1
    2094:	8809      	ldrh	r1, [r1, #0]
    2096:	434a      	muls	r2, r1
    2098:	801a      	strh	r2, [r3, #0]
  ptr = u8g2->tile_buf_ptr;
    209a:	68fb      	ldr	r3, [r7, #12]
    209c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    209e:	61fb      	str	r3, [r7, #28]
  ptr += offset;
    20a0:	2316      	movs	r3, #22
    20a2:	18fb      	adds	r3, r7, r3
    20a4:	881b      	ldrh	r3, [r3, #0]
    20a6:	69fa      	ldr	r2, [r7, #28]
    20a8:	18d3      	adds	r3, r2, r3
    20aa:	61fb      	str	r3, [r7, #28]
  ptr += x;
    20ac:	230a      	movs	r3, #10
    20ae:	18fb      	adds	r3, r7, r3
    20b0:	881b      	ldrh	r3, [r3, #0]
    20b2:	69fa      	ldr	r2, [r7, #28]
    20b4:	18d3      	adds	r3, r2, r3
    20b6:	61fb      	str	r3, [r7, #28]
  
  if ( dir == 0 )
    20b8:	2330      	movs	r3, #48	; 0x30
    20ba:	18fb      	adds	r3, r7, r3
    20bc:	781b      	ldrb	r3, [r3, #0]
    20be:	2b00      	cmp	r3, #0
    20c0:	d11e      	bne.n	2100 <STACK_SIZE+0x100>
      do
      {
#ifdef __unix
	assert(ptr < max_ptr);
#endif
	*ptr |= or_mask;
    20c2:	69fb      	ldr	r3, [r7, #28]
    20c4:	781a      	ldrb	r2, [r3, #0]
    20c6:	231a      	movs	r3, #26
    20c8:	18fb      	adds	r3, r7, r3
    20ca:	781b      	ldrb	r3, [r3, #0]
    20cc:	4313      	orrs	r3, r2
    20ce:	b2da      	uxtb	r2, r3
    20d0:	69fb      	ldr	r3, [r7, #28]
    20d2:	701a      	strb	r2, [r3, #0]
	*ptr ^= xor_mask;
    20d4:	69fb      	ldr	r3, [r7, #28]
    20d6:	781a      	ldrb	r2, [r3, #0]
    20d8:	2319      	movs	r3, #25
    20da:	18fb      	adds	r3, r7, r3
    20dc:	781b      	ldrb	r3, [r3, #0]
    20de:	4053      	eors	r3, r2
    20e0:	b2da      	uxtb	r2, r3
    20e2:	69fb      	ldr	r3, [r7, #28]
    20e4:	701a      	strb	r2, [r3, #0]
	ptr++;
    20e6:	69fb      	ldr	r3, [r7, #28]
    20e8:	3301      	adds	r3, #1
    20ea:	61fb      	str	r3, [r7, #28]
	len--;
    20ec:	1dbb      	adds	r3, r7, #6
    20ee:	881a      	ldrh	r2, [r3, #0]
    20f0:	1dbb      	adds	r3, r7, #6
    20f2:	3a01      	subs	r2, #1
    20f4:	801a      	strh	r2, [r3, #0]
      } while( len != 0 );
    20f6:	1dbb      	adds	r3, r7, #6
    20f8:	881b      	ldrh	r3, [r3, #0]
    20fa:	2b00      	cmp	r3, #0
    20fc:	d1e1      	bne.n	20c2 <STACK_SIZE+0xc2>
	or_mask <<= 1;
	xor_mask <<= 1;
      }
    } while( len != 0 );
  }
}
    20fe:	e055      	b.n	21ac <STACK_SIZE+0x1ac>
      *ptr |= or_mask;
    2100:	69fb      	ldr	r3, [r7, #28]
    2102:	781a      	ldrb	r2, [r3, #0]
    2104:	231a      	movs	r3, #26
    2106:	18fb      	adds	r3, r7, r3
    2108:	781b      	ldrb	r3, [r3, #0]
    210a:	4313      	orrs	r3, r2
    210c:	b2da      	uxtb	r2, r3
    210e:	69fb      	ldr	r3, [r7, #28]
    2110:	701a      	strb	r2, [r3, #0]
      *ptr ^= xor_mask;
    2112:	69fb      	ldr	r3, [r7, #28]
    2114:	781a      	ldrb	r2, [r3, #0]
    2116:	2319      	movs	r3, #25
    2118:	18fb      	adds	r3, r7, r3
    211a:	781b      	ldrb	r3, [r3, #0]
    211c:	4053      	eors	r3, r2
    211e:	b2da      	uxtb	r2, r3
    2120:	69fb      	ldr	r3, [r7, #28]
    2122:	701a      	strb	r2, [r3, #0]
      bit_pos++;
    2124:	231b      	movs	r3, #27
    2126:	18fb      	adds	r3, r7, r3
    2128:	781a      	ldrb	r2, [r3, #0]
    212a:	231b      	movs	r3, #27
    212c:	18fb      	adds	r3, r7, r3
    212e:	3201      	adds	r2, #1
    2130:	701a      	strb	r2, [r3, #0]
      bit_pos &= 7;
    2132:	231b      	movs	r3, #27
    2134:	18fb      	adds	r3, r7, r3
    2136:	221b      	movs	r2, #27
    2138:	18ba      	adds	r2, r7, r2
    213a:	7812      	ldrb	r2, [r2, #0]
    213c:	2107      	movs	r1, #7
    213e:	400a      	ands	r2, r1
    2140:	701a      	strb	r2, [r3, #0]
      len--;
    2142:	1dbb      	adds	r3, r7, #6
    2144:	881a      	ldrh	r2, [r3, #0]
    2146:	1dbb      	adds	r3, r7, #6
    2148:	3a01      	subs	r2, #1
    214a:	801a      	strh	r2, [r3, #0]
      if ( bit_pos == 0 )
    214c:	231b      	movs	r3, #27
    214e:	18fb      	adds	r3, r7, r3
    2150:	781b      	ldrb	r3, [r3, #0]
    2152:	2b00      	cmp	r3, #0
    2154:	d118      	bne.n	2188 <STACK_SIZE+0x188>
	ptr+=u8g2->pixel_buf_width;	/* 6 Jan 17: Changed u8g2->width to u8g2->pixel_buf_width, issue #148 */
    2156:	68fb      	ldr	r3, [r7, #12]
    2158:	8f5b      	ldrh	r3, [r3, #58]	; 0x3a
    215a:	001a      	movs	r2, r3
    215c:	69fb      	ldr	r3, [r7, #28]
    215e:	189b      	adds	r3, r3, r2
    2160:	61fb      	str	r3, [r7, #28]
	if ( u8g2->draw_color <= 1 )
    2162:	68fb      	ldr	r3, [r7, #12]
    2164:	2292      	movs	r2, #146	; 0x92
    2166:	5c9b      	ldrb	r3, [r3, r2]
    2168:	2b01      	cmp	r3, #1
    216a:	d803      	bhi.n	2174 <STACK_SIZE+0x174>
	  or_mask  = 1;
    216c:	231a      	movs	r3, #26
    216e:	18fb      	adds	r3, r7, r3
    2170:	2201      	movs	r2, #1
    2172:	701a      	strb	r2, [r3, #0]
	if ( u8g2->draw_color != 1 )
    2174:	68fb      	ldr	r3, [r7, #12]
    2176:	2292      	movs	r2, #146	; 0x92
    2178:	5c9b      	ldrb	r3, [r3, r2]
    217a:	2b01      	cmp	r3, #1
    217c:	d012      	beq.n	21a4 <STACK_SIZE+0x1a4>
	  xor_mask = 1;
    217e:	2319      	movs	r3, #25
    2180:	18fb      	adds	r3, r7, r3
    2182:	2201      	movs	r2, #1
    2184:	701a      	strb	r2, [r3, #0]
    2186:	e00d      	b.n	21a4 <STACK_SIZE+0x1a4>
	or_mask <<= 1;
    2188:	231a      	movs	r3, #26
    218a:	18fa      	adds	r2, r7, r3
    218c:	231a      	movs	r3, #26
    218e:	18fb      	adds	r3, r7, r3
    2190:	781b      	ldrb	r3, [r3, #0]
    2192:	18db      	adds	r3, r3, r3
    2194:	7013      	strb	r3, [r2, #0]
	xor_mask <<= 1;
    2196:	2319      	movs	r3, #25
    2198:	18fa      	adds	r2, r7, r3
    219a:	2319      	movs	r3, #25
    219c:	18fb      	adds	r3, r7, r3
    219e:	781b      	ldrb	r3, [r3, #0]
    21a0:	18db      	adds	r3, r3, r3
    21a2:	7013      	strb	r3, [r2, #0]
    } while( len != 0 );
    21a4:	1dbb      	adds	r3, r7, #6
    21a6:	881b      	ldrh	r3, [r3, #0]
    21a8:	2b00      	cmp	r3, #0
    21aa:	d1a9      	bne.n	2100 <STACK_SIZE+0x100>
}
    21ac:	46c0      	nop			; (mov r8, r8)
    21ae:	46bd      	mov	sp, r7
    21b0:	b009      	add	sp, #36	; 0x24
    21b2:	bd90      	pop	{r4, r7, pc}

000021b4 <u8g2_SetMaxClipWindow>:


#ifdef U8G2_WITH_CLIP_WINDOW_SUPPORT

void u8g2_SetMaxClipWindow(u8g2_t *u8g2)
{
    21b4:	b580      	push	{r7, lr}
    21b6:	b082      	sub	sp, #8
    21b8:	af00      	add	r7, sp, #0
    21ba:	6078      	str	r0, [r7, #4]
  u8g2->clip_x0 = 0;
    21bc:	687b      	ldr	r3, [r7, #4]
    21be:	2250      	movs	r2, #80	; 0x50
    21c0:	2100      	movs	r1, #0
    21c2:	5299      	strh	r1, [r3, r2]
  u8g2->clip_y0 = 0;
    21c4:	687b      	ldr	r3, [r7, #4]
    21c6:	2254      	movs	r2, #84	; 0x54
    21c8:	2100      	movs	r1, #0
    21ca:	5299      	strh	r1, [r3, r2]
  u8g2->clip_x1 = (u8g2_uint_t)~(u8g2_uint_t)0;
    21cc:	687b      	ldr	r3, [r7, #4]
    21ce:	2252      	movs	r2, #82	; 0x52
    21d0:	2101      	movs	r1, #1
    21d2:	4249      	negs	r1, r1
    21d4:	5299      	strh	r1, [r3, r2]
  u8g2->clip_y1 = (u8g2_uint_t)~(u8g2_uint_t)0;
    21d6:	687b      	ldr	r3, [r7, #4]
    21d8:	2256      	movs	r2, #86	; 0x56
    21da:	2101      	movs	r1, #1
    21dc:	4249      	negs	r1, r1
    21de:	5299      	strh	r1, [r3, r2]
  
  u8g2->cb->update_page_win(u8g2);
    21e0:	687b      	ldr	r3, [r7, #4]
    21e2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    21e4:	685b      	ldr	r3, [r3, #4]
    21e6:	687a      	ldr	r2, [r7, #4]
    21e8:	0010      	movs	r0, r2
    21ea:	4798      	blx	r3
}
    21ec:	46c0      	nop			; (mov r8, r8)
    21ee:	46bd      	mov	sp, r7
    21f0:	b002      	add	sp, #8
    21f2:	bd80      	pop	{r7, pc}

000021f4 <u8g2_SetupBuffer>:
/*
  This procedure is called after setting up the display (u8x8 structure).
  --> This is the central init procedure for u8g2 object
*/
void u8g2_SetupBuffer(u8g2_t *u8g2, uint8_t *buf, uint8_t tile_buf_height, u8g2_draw_ll_hvline_cb ll_hvline_cb, const u8g2_cb_t *u8g2_cb)
{
    21f4:	b580      	push	{r7, lr}
    21f6:	b084      	sub	sp, #16
    21f8:	af00      	add	r7, sp, #0
    21fa:	60f8      	str	r0, [r7, #12]
    21fc:	60b9      	str	r1, [r7, #8]
    21fe:	603b      	str	r3, [r7, #0]
    2200:	1dfb      	adds	r3, r7, #7
    2202:	701a      	strb	r2, [r3, #0]
  u8g2->font = NULL;
    2204:	68fb      	ldr	r3, [r7, #12]
    2206:	2200      	movs	r2, #0
    2208:	659a      	str	r2, [r3, #88]	; 0x58
  //u8g2->kerning = NULL;
  //u8g2->get_kerning_cb = u8g2_GetNullKerning;
  
  //u8g2->ll_hvline = u8g2_ll_hvline_vertical_top_lsb;
  u8g2->ll_hvline = ll_hvline_cb;
    220a:	68fb      	ldr	r3, [r7, #12]
    220c:	683a      	ldr	r2, [r7, #0]
    220e:	62da      	str	r2, [r3, #44]	; 0x2c
  
  u8g2->tile_buf_ptr = buf;
    2210:	68fb      	ldr	r3, [r7, #12]
    2212:	68ba      	ldr	r2, [r7, #8]
    2214:	635a      	str	r2, [r3, #52]	; 0x34
  u8g2->tile_buf_height = tile_buf_height;
    2216:	68fb      	ldr	r3, [r7, #12]
    2218:	1dfa      	adds	r2, r7, #7
    221a:	2138      	movs	r1, #56	; 0x38
    221c:	7812      	ldrb	r2, [r2, #0]
    221e:	545a      	strb	r2, [r3, r1]
  
  u8g2->tile_curr_row = 0;
    2220:	68fb      	ldr	r3, [r7, #12]
    2222:	2239      	movs	r2, #57	; 0x39
    2224:	2100      	movs	r1, #0
    2226:	5499      	strb	r1, [r3, r2]
  
  u8g2->font_decode.is_transparent = 0; /* issue 443 */
    2228:	68fb      	ldr	r3, [r7, #12]
    222a:	226d      	movs	r2, #109	; 0x6d
    222c:	2100      	movs	r1, #0
    222e:	5499      	strb	r1, [r3, r2]
  u8g2->bitmap_transparency = 0;
    2230:	68fb      	ldr	r3, [r7, #12]
    2232:	2291      	movs	r2, #145	; 0x91
    2234:	2100      	movs	r1, #0
    2236:	5499      	strb	r1, [r3, r2]
  
  u8g2->font_height_mode = 0; /* issue 2046 */
    2238:	68fb      	ldr	r3, [r7, #12]
    223a:	228d      	movs	r2, #141	; 0x8d
    223c:	2100      	movs	r1, #0
    223e:	5499      	strb	r1, [r3, r2]
  u8g2->draw_color = 1;
    2240:	68fb      	ldr	r3, [r7, #12]
    2242:	2292      	movs	r2, #146	; 0x92
    2244:	2101      	movs	r1, #1
    2246:	5499      	strb	r1, [r3, r2]
  u8g2->is_auto_page_clear = 1;
    2248:	68fb      	ldr	r3, [r7, #12]
    224a:	2293      	movs	r2, #147	; 0x93
    224c:	2101      	movs	r1, #1
    224e:	5499      	strb	r1, [r3, r2]
  
  u8g2->cb = u8g2_cb;
    2250:	68fb      	ldr	r3, [r7, #12]
    2252:	69ba      	ldr	r2, [r7, #24]
    2254:	631a      	str	r2, [r3, #48]	; 0x30
  u8g2->cb->update_dimension(u8g2);
    2256:	68fb      	ldr	r3, [r7, #12]
    2258:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    225a:	681b      	ldr	r3, [r3, #0]
    225c:	68fa      	ldr	r2, [r7, #12]
    225e:	0010      	movs	r0, r2
    2260:	4798      	blx	r3
#ifdef U8G2_WITH_CLIP_WINDOW_SUPPORT
  u8g2_SetMaxClipWindow(u8g2);		/* assign a clip window and call the update() procedure */
    2262:	68fb      	ldr	r3, [r7, #12]
    2264:	0018      	movs	r0, r3
    2266:	f7ff ffa5 	bl	21b4 <u8g2_SetMaxClipWindow>
#else
  u8g2->cb->update_page_win(u8g2);
#endif

  u8g2_SetFontPosBaseline(u8g2);  /* issue 195 */
    226a:	68fb      	ldr	r3, [r7, #12]
    226c:	0018      	movs	r0, r3
    226e:	f7ff fadf 	bl	1830 <u8g2_SetFontPosBaseline>
  
#ifdef U8G2_WITH_FONT_ROTATION  
  u8g2->font_decode.dir = 0;
    2272:	68fb      	ldr	r3, [r7, #12]
    2274:	2270      	movs	r2, #112	; 0x70
    2276:	2100      	movs	r1, #0
    2278:	5499      	strb	r1, [r3, r2]
#endif
}
    227a:	46c0      	nop			; (mov r8, r8)
    227c:	46bd      	mov	sp, r7
    227e:	b004      	add	sp, #16
    2280:	bd80      	pop	{r7, pc}

00002282 <u8g2_update_dimension_common>:
    u8g2_uint_t buf_y0;
    u8g2_uint_t buf_y1; 	
*/

static void u8g2_update_dimension_common(u8g2_t *u8g2)
{
    2282:	b580      	push	{r7, lr}
    2284:	b084      	sub	sp, #16
    2286:	af00      	add	r7, sp, #0
    2288:	6078      	str	r0, [r7, #4]
  const u8x8_display_info_t *display_info = u8g2_GetU8x8(u8g2)->display_info;
    228a:	687b      	ldr	r3, [r7, #4]
    228c:	681b      	ldr	r3, [r3, #0]
    228e:	60bb      	str	r3, [r7, #8]
  u8g2_uint_t t;
  
  t = u8g2->tile_buf_height;
    2290:	687b      	ldr	r3, [r7, #4]
    2292:	2238      	movs	r2, #56	; 0x38
    2294:	5c9a      	ldrb	r2, [r3, r2]
    2296:	230e      	movs	r3, #14
    2298:	18fb      	adds	r3, r7, r3
    229a:	801a      	strh	r2, [r3, #0]
  t *= 8;
    229c:	230e      	movs	r3, #14
    229e:	18fb      	adds	r3, r7, r3
    22a0:	220e      	movs	r2, #14
    22a2:	18ba      	adds	r2, r7, r2
    22a4:	8812      	ldrh	r2, [r2, #0]
    22a6:	00d2      	lsls	r2, r2, #3
    22a8:	801a      	strh	r2, [r3, #0]
  u8g2->pixel_buf_height = t;
    22aa:	687b      	ldr	r3, [r7, #4]
    22ac:	220e      	movs	r2, #14
    22ae:	18ba      	adds	r2, r7, r2
    22b0:	8812      	ldrh	r2, [r2, #0]
    22b2:	879a      	strh	r2, [r3, #60]	; 0x3c
  
  t = display_info->tile_width;
    22b4:	68bb      	ldr	r3, [r7, #8]
    22b6:	7c1a      	ldrb	r2, [r3, #16]
    22b8:	230e      	movs	r3, #14
    22ba:	18fb      	adds	r3, r7, r3
    22bc:	801a      	strh	r2, [r3, #0]
#ifndef U8G2_16BIT
  if ( t >= 32 )
    t = 31;
#endif
  t *= 8;
    22be:	230e      	movs	r3, #14
    22c0:	18fb      	adds	r3, r7, r3
    22c2:	220e      	movs	r2, #14
    22c4:	18ba      	adds	r2, r7, r2
    22c6:	8812      	ldrh	r2, [r2, #0]
    22c8:	00d2      	lsls	r2, r2, #3
    22ca:	801a      	strh	r2, [r3, #0]
  u8g2->pixel_buf_width = t;
    22cc:	687b      	ldr	r3, [r7, #4]
    22ce:	220e      	movs	r2, #14
    22d0:	18ba      	adds	r2, r7, r2
    22d2:	8812      	ldrh	r2, [r2, #0]
    22d4:	875a      	strh	r2, [r3, #58]	; 0x3a
  
  t = u8g2->tile_curr_row;
    22d6:	687b      	ldr	r3, [r7, #4]
    22d8:	2239      	movs	r2, #57	; 0x39
    22da:	5c9a      	ldrb	r2, [r3, r2]
    22dc:	230e      	movs	r3, #14
    22de:	18fb      	adds	r3, r7, r3
    22e0:	801a      	strh	r2, [r3, #0]
  t *= 8;
    22e2:	230e      	movs	r3, #14
    22e4:	18fb      	adds	r3, r7, r3
    22e6:	220e      	movs	r2, #14
    22e8:	18ba      	adds	r2, r7, r2
    22ea:	8812      	ldrh	r2, [r2, #0]
    22ec:	00d2      	lsls	r2, r2, #3
    22ee:	801a      	strh	r2, [r3, #0]
  u8g2->pixel_curr_row = t;
    22f0:	687b      	ldr	r3, [r7, #4]
    22f2:	220e      	movs	r2, #14
    22f4:	18ba      	adds	r2, r7, r2
    22f6:	8812      	ldrh	r2, [r2, #0]
    22f8:	87da      	strh	r2, [r3, #62]	; 0x3e
  
  t = u8g2->tile_buf_height;
    22fa:	687b      	ldr	r3, [r7, #4]
    22fc:	2238      	movs	r2, #56	; 0x38
    22fe:	5c9a      	ldrb	r2, [r3, r2]
    2300:	230e      	movs	r3, #14
    2302:	18fb      	adds	r3, r7, r3
    2304:	801a      	strh	r2, [r3, #0]
  /* handle the case, where the buffer is larger than the (remaining) part of the display */
  if ( t + u8g2->tile_curr_row > display_info->tile_height )
    2306:	230e      	movs	r3, #14
    2308:	18fb      	adds	r3, r7, r3
    230a:	881b      	ldrh	r3, [r3, #0]
    230c:	687a      	ldr	r2, [r7, #4]
    230e:	2139      	movs	r1, #57	; 0x39
    2310:	5c52      	ldrb	r2, [r2, r1]
    2312:	189b      	adds	r3, r3, r2
    2314:	68ba      	ldr	r2, [r7, #8]
    2316:	7c52      	ldrb	r2, [r2, #17]
    2318:	4293      	cmp	r3, r2
    231a:	dd0a      	ble.n	2332 <u8g2_update_dimension_common+0xb0>
    t = display_info->tile_height - u8g2->tile_curr_row;
    231c:	68bb      	ldr	r3, [r7, #8]
    231e:	7c5b      	ldrb	r3, [r3, #17]
    2320:	b299      	uxth	r1, r3
    2322:	687b      	ldr	r3, [r7, #4]
    2324:	2239      	movs	r2, #57	; 0x39
    2326:	5c9b      	ldrb	r3, [r3, r2]
    2328:	b29a      	uxth	r2, r3
    232a:	230e      	movs	r3, #14
    232c:	18fb      	adds	r3, r7, r3
    232e:	1a8a      	subs	r2, r1, r2
    2330:	801a      	strh	r2, [r3, #0]
  t *= 8;
    2332:	230e      	movs	r3, #14
    2334:	18fb      	adds	r3, r7, r3
    2336:	220e      	movs	r2, #14
    2338:	18ba      	adds	r2, r7, r2
    233a:	8812      	ldrh	r2, [r2, #0]
    233c:	00d2      	lsls	r2, r2, #3
    233e:	801a      	strh	r2, [r3, #0]
  
  u8g2->buf_y0 = u8g2->pixel_curr_row;   
    2340:	687b      	ldr	r3, [r7, #4]
    2342:	8fd9      	ldrh	r1, [r3, #62]	; 0x3e
    2344:	687b      	ldr	r3, [r7, #4]
    2346:	2240      	movs	r2, #64	; 0x40
    2348:	5299      	strh	r1, [r3, r2]
  u8g2->buf_y1 = u8g2->buf_y0;
    234a:	687b      	ldr	r3, [r7, #4]
    234c:	2240      	movs	r2, #64	; 0x40
    234e:	5a99      	ldrh	r1, [r3, r2]
    2350:	687b      	ldr	r3, [r7, #4]
    2352:	2242      	movs	r2, #66	; 0x42
    2354:	5299      	strh	r1, [r3, r2]
  u8g2->buf_y1 += t;
    2356:	687b      	ldr	r3, [r7, #4]
    2358:	2242      	movs	r2, #66	; 0x42
    235a:	5a9a      	ldrh	r2, [r3, r2]
    235c:	230e      	movs	r3, #14
    235e:	18fb      	adds	r3, r7, r3
    2360:	881b      	ldrh	r3, [r3, #0]
    2362:	18d3      	adds	r3, r2, r3
    2364:	b299      	uxth	r1, r3
    2366:	687b      	ldr	r3, [r7, #4]
    2368:	2242      	movs	r2, #66	; 0x42
    236a:	5299      	strh	r1, [r3, r2]

  
#ifdef U8G2_16BIT
  u8g2->width = display_info->pixel_width;
    236c:	68bb      	ldr	r3, [r7, #8]
    236e:	8a99      	ldrh	r1, [r3, #20]
    2370:	687b      	ldr	r3, [r7, #4]
    2372:	2244      	movs	r2, #68	; 0x44
    2374:	5299      	strh	r1, [r3, r2]
  u8g2->height = display_info->pixel_height;
    2376:	68bb      	ldr	r3, [r7, #8]
    2378:	8ad9      	ldrh	r1, [r3, #22]
    237a:	687b      	ldr	r3, [r7, #4]
    237c:	2246      	movs	r2, #70	; 0x46
    237e:	5299      	strh	r1, [r3, r2]
  if ( display_info->pixel_width <= 240 )
    u8g2->width = display_info->pixel_width;
  u8g2->height = display_info->pixel_height;
#endif

}
    2380:	46c0      	nop			; (mov r8, r8)
    2382:	46bd      	mov	sp, r7
    2384:	b004      	add	sp, #16
    2386:	bd80      	pop	{r7, pc}

00002388 <u8g2_apply_clip_window>:
/*==========================================================*/
/* apply clip window */

#ifdef U8G2_WITH_CLIP_WINDOW_SUPPORT
static void u8g2_apply_clip_window(u8g2_t *u8g2)
{
    2388:	b5b0      	push	{r4, r5, r7, lr}
    238a:	b084      	sub	sp, #16
    238c:	af02      	add	r7, sp, #8
    238e:	6078      	str	r0, [r7, #4]
  /* check aganst the current user_??? window */
  if ( u8g2_IsIntersection(u8g2, u8g2->clip_x0, u8g2->clip_y0, u8g2->clip_x1, u8g2->clip_y1) == 0 ) 
    2390:	687b      	ldr	r3, [r7, #4]
    2392:	2250      	movs	r2, #80	; 0x50
    2394:	5a99      	ldrh	r1, [r3, r2]
    2396:	687b      	ldr	r3, [r7, #4]
    2398:	2254      	movs	r2, #84	; 0x54
    239a:	5a9c      	ldrh	r4, [r3, r2]
    239c:	687b      	ldr	r3, [r7, #4]
    239e:	2252      	movs	r2, #82	; 0x52
    23a0:	5a9d      	ldrh	r5, [r3, r2]
    23a2:	687b      	ldr	r3, [r7, #4]
    23a4:	2256      	movs	r2, #86	; 0x56
    23a6:	5a9b      	ldrh	r3, [r3, r2]
    23a8:	6878      	ldr	r0, [r7, #4]
    23aa:	9300      	str	r3, [sp, #0]
    23ac:	002b      	movs	r3, r5
    23ae:	0022      	movs	r2, r4
    23b0:	f7ff fc99 	bl	1ce6 <u8g2_IsIntersection>
    23b4:	1e03      	subs	r3, r0, #0
    23b6:	d104      	bne.n	23c2 <u8g2_apply_clip_window+0x3a>
  {
    u8g2->is_page_clip_window_intersection = 0;
    23b8:	687b      	ldr	r3, [r7, #4]
    23ba:	228c      	movs	r2, #140	; 0x8c
    23bc:	2100      	movs	r1, #0
    23be:	5499      	strb	r1, [r3, r2]
    if ( u8g2->user_y0 < u8g2->clip_y0 )
      u8g2->user_y0 = u8g2->clip_y0;
    if ( u8g2->user_y1 > u8g2->clip_y1 )
      u8g2->user_y1 = u8g2->clip_y1;
  }
}
    23c0:	e03b      	b.n	243a <u8g2_apply_clip_window+0xb2>
    u8g2->is_page_clip_window_intersection = 1;
    23c2:	687b      	ldr	r3, [r7, #4]
    23c4:	228c      	movs	r2, #140	; 0x8c
    23c6:	2101      	movs	r1, #1
    23c8:	5499      	strb	r1, [r3, r2]
    if ( u8g2->user_x0 < u8g2->clip_x0 )
    23ca:	687b      	ldr	r3, [r7, #4]
    23cc:	2248      	movs	r2, #72	; 0x48
    23ce:	5a9a      	ldrh	r2, [r3, r2]
    23d0:	687b      	ldr	r3, [r7, #4]
    23d2:	2150      	movs	r1, #80	; 0x50
    23d4:	5a5b      	ldrh	r3, [r3, r1]
    23d6:	429a      	cmp	r2, r3
    23d8:	d205      	bcs.n	23e6 <u8g2_apply_clip_window+0x5e>
      u8g2->user_x0 = u8g2->clip_x0;
    23da:	687b      	ldr	r3, [r7, #4]
    23dc:	2250      	movs	r2, #80	; 0x50
    23de:	5a99      	ldrh	r1, [r3, r2]
    23e0:	687b      	ldr	r3, [r7, #4]
    23e2:	2248      	movs	r2, #72	; 0x48
    23e4:	5299      	strh	r1, [r3, r2]
    if ( u8g2->user_x1 > u8g2->clip_x1 )
    23e6:	687b      	ldr	r3, [r7, #4]
    23e8:	224a      	movs	r2, #74	; 0x4a
    23ea:	5a9a      	ldrh	r2, [r3, r2]
    23ec:	687b      	ldr	r3, [r7, #4]
    23ee:	2152      	movs	r1, #82	; 0x52
    23f0:	5a5b      	ldrh	r3, [r3, r1]
    23f2:	429a      	cmp	r2, r3
    23f4:	d905      	bls.n	2402 <u8g2_apply_clip_window+0x7a>
      u8g2->user_x1 = u8g2->clip_x1;
    23f6:	687b      	ldr	r3, [r7, #4]
    23f8:	2252      	movs	r2, #82	; 0x52
    23fa:	5a99      	ldrh	r1, [r3, r2]
    23fc:	687b      	ldr	r3, [r7, #4]
    23fe:	224a      	movs	r2, #74	; 0x4a
    2400:	5299      	strh	r1, [r3, r2]
    if ( u8g2->user_y0 < u8g2->clip_y0 )
    2402:	687b      	ldr	r3, [r7, #4]
    2404:	224c      	movs	r2, #76	; 0x4c
    2406:	5a9a      	ldrh	r2, [r3, r2]
    2408:	687b      	ldr	r3, [r7, #4]
    240a:	2154      	movs	r1, #84	; 0x54
    240c:	5a5b      	ldrh	r3, [r3, r1]
    240e:	429a      	cmp	r2, r3
    2410:	d205      	bcs.n	241e <u8g2_apply_clip_window+0x96>
      u8g2->user_y0 = u8g2->clip_y0;
    2412:	687b      	ldr	r3, [r7, #4]
    2414:	2254      	movs	r2, #84	; 0x54
    2416:	5a99      	ldrh	r1, [r3, r2]
    2418:	687b      	ldr	r3, [r7, #4]
    241a:	224c      	movs	r2, #76	; 0x4c
    241c:	5299      	strh	r1, [r3, r2]
    if ( u8g2->user_y1 > u8g2->clip_y1 )
    241e:	687b      	ldr	r3, [r7, #4]
    2420:	224e      	movs	r2, #78	; 0x4e
    2422:	5a9a      	ldrh	r2, [r3, r2]
    2424:	687b      	ldr	r3, [r7, #4]
    2426:	2156      	movs	r1, #86	; 0x56
    2428:	5a5b      	ldrh	r3, [r3, r1]
    242a:	429a      	cmp	r2, r3
    242c:	d905      	bls.n	243a <u8g2_apply_clip_window+0xb2>
      u8g2->user_y1 = u8g2->clip_y1;
    242e:	687b      	ldr	r3, [r7, #4]
    2430:	2256      	movs	r2, #86	; 0x56
    2432:	5a99      	ldrh	r1, [r3, r2]
    2434:	687b      	ldr	r3, [r7, #4]
    2436:	224e      	movs	r2, #78	; 0x4e
    2438:	5299      	strh	r1, [r3, r2]
}
    243a:	46c0      	nop			; (mov r8, r8)
    243c:	46bd      	mov	sp, r7
    243e:	b002      	add	sp, #8
    2440:	bdb0      	pop	{r4, r5, r7, pc}

00002442 <u8g2_update_dimension_r0>:

/*==========================================================*/


void u8g2_update_dimension_r0(u8g2_t *u8g2)
{
    2442:	b580      	push	{r7, lr}
    2444:	b082      	sub	sp, #8
    2446:	af00      	add	r7, sp, #0
    2448:	6078      	str	r0, [r7, #4]
  u8g2_update_dimension_common(u8g2);  
    244a:	687b      	ldr	r3, [r7, #4]
    244c:	0018      	movs	r0, r3
    244e:	f7ff ff18 	bl	2282 <u8g2_update_dimension_common>
}
    2452:	46c0      	nop			; (mov r8, r8)
    2454:	46bd      	mov	sp, r7
    2456:	b002      	add	sp, #8
    2458:	bd80      	pop	{r7, pc}

0000245a <u8g2_update_page_win_r0>:

void u8g2_update_page_win_r0(u8g2_t *u8g2)
{
    245a:	b580      	push	{r7, lr}
    245c:	b082      	sub	sp, #8
    245e:	af00      	add	r7, sp, #0
    2460:	6078      	str	r0, [r7, #4]
  u8g2->user_x0 = 0;
    2462:	687b      	ldr	r3, [r7, #4]
    2464:	2248      	movs	r2, #72	; 0x48
    2466:	2100      	movs	r1, #0
    2468:	5299      	strh	r1, [r3, r2]
  u8g2->user_x1 = u8g2->width;			/* pixel_buf_width replaced with width */
    246a:	687b      	ldr	r3, [r7, #4]
    246c:	2244      	movs	r2, #68	; 0x44
    246e:	5a99      	ldrh	r1, [r3, r2]
    2470:	687b      	ldr	r3, [r7, #4]
    2472:	224a      	movs	r2, #74	; 0x4a
    2474:	5299      	strh	r1, [r3, r2]
  
  u8g2->user_y0 = u8g2->buf_y0;
    2476:	687b      	ldr	r3, [r7, #4]
    2478:	2240      	movs	r2, #64	; 0x40
    247a:	5a99      	ldrh	r1, [r3, r2]
    247c:	687b      	ldr	r3, [r7, #4]
    247e:	224c      	movs	r2, #76	; 0x4c
    2480:	5299      	strh	r1, [r3, r2]
  u8g2->user_y1 = u8g2->buf_y1;
    2482:	687b      	ldr	r3, [r7, #4]
    2484:	2242      	movs	r2, #66	; 0x42
    2486:	5a99      	ldrh	r1, [r3, r2]
    2488:	687b      	ldr	r3, [r7, #4]
    248a:	224e      	movs	r2, #78	; 0x4e
    248c:	5299      	strh	r1, [r3, r2]
  
#ifdef U8G2_WITH_CLIP_WINDOW_SUPPORT
  u8g2_apply_clip_window(u8g2);
    248e:	687b      	ldr	r3, [r7, #4]
    2490:	0018      	movs	r0, r3
    2492:	f7ff ff79 	bl	2388 <u8g2_apply_clip_window>
#endif /* U8G2_WITH_CLIP_WINDOW_SUPPORT */
}
    2496:	46c0      	nop			; (mov r8, r8)
    2498:	46bd      	mov	sp, r7
    249a:	b002      	add	sp, #8
    249c:	bd80      	pop	{r7, pc}

0000249e <u8g2_draw_l90_r0>:
/*============================================*/
extern void u8g2_draw_hv_line_2dir(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t len, uint8_t dir);


void u8g2_draw_l90_r0(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t len, uint8_t dir)
{
    249e:	b590      	push	{r4, r7, lr}
    24a0:	b087      	sub	sp, #28
    24a2:	af02      	add	r7, sp, #8
    24a4:	60f8      	str	r0, [r7, #12]
    24a6:	000c      	movs	r4, r1
    24a8:	0010      	movs	r0, r2
    24aa:	0019      	movs	r1, r3
    24ac:	230a      	movs	r3, #10
    24ae:	18fb      	adds	r3, r7, r3
    24b0:	1c22      	adds	r2, r4, #0
    24b2:	801a      	strh	r2, [r3, #0]
    24b4:	2308      	movs	r3, #8
    24b6:	18fb      	adds	r3, r7, r3
    24b8:	1c02      	adds	r2, r0, #0
    24ba:	801a      	strh	r2, [r3, #0]
    24bc:	1dbb      	adds	r3, r7, #6
    24be:	1c0a      	adds	r2, r1, #0
    24c0:	801a      	strh	r2, [r3, #0]
#ifdef __unix
  assert( dir <= 1 );
#endif
  u8g2_draw_hv_line_2dir(u8g2, x, y, len, dir);
    24c2:	1dbb      	adds	r3, r7, #6
    24c4:	881c      	ldrh	r4, [r3, #0]
    24c6:	2308      	movs	r3, #8
    24c8:	18fb      	adds	r3, r7, r3
    24ca:	881a      	ldrh	r2, [r3, #0]
    24cc:	230a      	movs	r3, #10
    24ce:	18fb      	adds	r3, r7, r3
    24d0:	8819      	ldrh	r1, [r3, #0]
    24d2:	68f8      	ldr	r0, [r7, #12]
    24d4:	2320      	movs	r3, #32
    24d6:	18fb      	adds	r3, r7, r3
    24d8:	781b      	ldrb	r3, [r3, #0]
    24da:	9300      	str	r3, [sp, #0]
    24dc:	0023      	movs	r3, r4
    24de:	f7ff fa54 	bl	198a <u8g2_draw_hv_line_2dir>
}
    24e2:	46c0      	nop			; (mov r8, r8)
    24e4:	46bd      	mov	sp, r7
    24e6:	b005      	add	sp, #20
    24e8:	bd90      	pop	{r4, r7, pc}

000024ea <u8x8_utf8_init>:

*/

/* reset the internal state machine */
void u8x8_utf8_init(u8x8_t *u8x8)
{
    24ea:	b580      	push	{r7, lr}
    24ec:	b082      	sub	sp, #8
    24ee:	af00      	add	r7, sp, #0
    24f0:	6078      	str	r0, [r7, #4]
  u8x8->utf8_state = 0;	/* also reset during u8x8_SetupDefaults() */
    24f2:	687b      	ldr	r3, [r7, #4]
    24f4:	2226      	movs	r2, #38	; 0x26
    24f6:	2100      	movs	r1, #0
    24f8:	5499      	strb	r1, [r3, r2]
}
    24fa:	46c0      	nop			; (mov r8, r8)
    24fc:	46bd      	mov	sp, r7
    24fe:	b002      	add	sp, #8
    2500:	bd80      	pop	{r7, pc}
	...

00002504 <u8x8_ascii_next>:

uint16_t u8x8_ascii_next(U8X8_UNUSED u8x8_t *u8x8, uint8_t b)
{
    2504:	b580      	push	{r7, lr}
    2506:	b082      	sub	sp, #8
    2508:	af00      	add	r7, sp, #0
    250a:	6078      	str	r0, [r7, #4]
    250c:	000a      	movs	r2, r1
    250e:	1cfb      	adds	r3, r7, #3
    2510:	701a      	strb	r2, [r3, #0]
  if ( b == 0 || b == '\n' ) /* '\n' terminates the string to support the string list procedures */
    2512:	1cfb      	adds	r3, r7, #3
    2514:	781b      	ldrb	r3, [r3, #0]
    2516:	2b00      	cmp	r3, #0
    2518:	d003      	beq.n	2522 <u8x8_ascii_next+0x1e>
    251a:	1cfb      	adds	r3, r7, #3
    251c:	781b      	ldrb	r3, [r3, #0]
    251e:	2b0a      	cmp	r3, #10
    2520:	d101      	bne.n	2526 <u8x8_ascii_next+0x22>
    return 0x0ffff;	/* end of string detected*/
    2522:	4b04      	ldr	r3, [pc, #16]	; (2534 <u8x8_ascii_next+0x30>)
    2524:	e002      	b.n	252c <u8x8_ascii_next+0x28>
  return b;
    2526:	1cfb      	adds	r3, r7, #3
    2528:	781b      	ldrb	r3, [r3, #0]
    252a:	b29b      	uxth	r3, r3
}
    252c:	0018      	movs	r0, r3
    252e:	46bd      	mov	sp, r7
    2530:	b002      	add	sp, #8
    2532:	bd80      	pop	{r7, pc}
    2534:	0000ffff 	.word	0x0000ffff

00002538 <u8x8_byte_SendBytes>:
{
  return u8x8->byte_cb(u8x8, U8X8_MSG_BYTE_SET_DC, dc, NULL);
}

uint8_t u8x8_byte_SendBytes(u8x8_t *u8x8, uint8_t cnt, uint8_t *data)
{
    2538:	b590      	push	{r4, r7, lr}
    253a:	b085      	sub	sp, #20
    253c:	af00      	add	r7, sp, #0
    253e:	60f8      	str	r0, [r7, #12]
    2540:	607a      	str	r2, [r7, #4]
    2542:	230b      	movs	r3, #11
    2544:	18fb      	adds	r3, r7, r3
    2546:	1c0a      	adds	r2, r1, #0
    2548:	701a      	strb	r2, [r3, #0]
  return u8x8->byte_cb(u8x8, U8X8_MSG_BYTE_SEND, cnt, (void *)data);
    254a:	68fb      	ldr	r3, [r7, #12]
    254c:	691c      	ldr	r4, [r3, #16]
    254e:	6879      	ldr	r1, [r7, #4]
    2550:	230b      	movs	r3, #11
    2552:	18fb      	adds	r3, r7, r3
    2554:	781a      	ldrb	r2, [r3, #0]
    2556:	68f8      	ldr	r0, [r7, #12]
    2558:	000b      	movs	r3, r1
    255a:	2117      	movs	r1, #23
    255c:	47a0      	blx	r4
    255e:	0003      	movs	r3, r0
}
    2560:	0018      	movs	r0, r3
    2562:	46bd      	mov	sp, r7
    2564:	b005      	add	sp, #20
    2566:	bd90      	pop	{r4, r7, pc}

00002568 <u8x8_byte_SendByte>:

uint8_t u8x8_byte_SendByte(u8x8_t *u8x8, uint8_t byte)
{
    2568:	b580      	push	{r7, lr}
    256a:	b082      	sub	sp, #8
    256c:	af00      	add	r7, sp, #0
    256e:	6078      	str	r0, [r7, #4]
    2570:	000a      	movs	r2, r1
    2572:	1cfb      	adds	r3, r7, #3
    2574:	701a      	strb	r2, [r3, #0]
  return u8x8_byte_SendBytes(u8x8, 1, &byte);
    2576:	1cfa      	adds	r2, r7, #3
    2578:	687b      	ldr	r3, [r7, #4]
    257a:	2101      	movs	r1, #1
    257c:	0018      	movs	r0, r3
    257e:	f7ff ffdb 	bl	2538 <u8x8_byte_SendBytes>
    2582:	0003      	movs	r3, r0
}
    2584:	0018      	movs	r0, r3
    2586:	46bd      	mov	sp, r7
    2588:	b002      	add	sp, #8
    258a:	bd80      	pop	{r7, pc}

0000258c <u8x8_cad_SendCmd>:
*/

#include "u8x8.h"

uint8_t u8x8_cad_SendCmd(u8x8_t *u8x8, uint8_t cmd)
{
    258c:	b590      	push	{r4, r7, lr}
    258e:	b083      	sub	sp, #12
    2590:	af00      	add	r7, sp, #0
    2592:	6078      	str	r0, [r7, #4]
    2594:	000a      	movs	r2, r1
    2596:	1cfb      	adds	r3, r7, #3
    2598:	701a      	strb	r2, [r3, #0]
  return u8x8->cad_cb(u8x8, U8X8_MSG_CAD_SEND_CMD, cmd, NULL);
    259a:	687b      	ldr	r3, [r7, #4]
    259c:	68dc      	ldr	r4, [r3, #12]
    259e:	1cfb      	adds	r3, r7, #3
    25a0:	781a      	ldrb	r2, [r3, #0]
    25a2:	6878      	ldr	r0, [r7, #4]
    25a4:	2300      	movs	r3, #0
    25a6:	2115      	movs	r1, #21
    25a8:	47a0      	blx	r4
    25aa:	0003      	movs	r3, r0
}
    25ac:	0018      	movs	r0, r3
    25ae:	46bd      	mov	sp, r7
    25b0:	b003      	add	sp, #12
    25b2:	bd90      	pop	{r4, r7, pc}

000025b4 <u8x8_cad_SendArg>:

uint8_t u8x8_cad_SendArg(u8x8_t *u8x8, uint8_t arg)
{
    25b4:	b590      	push	{r4, r7, lr}
    25b6:	b083      	sub	sp, #12
    25b8:	af00      	add	r7, sp, #0
    25ba:	6078      	str	r0, [r7, #4]
    25bc:	000a      	movs	r2, r1
    25be:	1cfb      	adds	r3, r7, #3
    25c0:	701a      	strb	r2, [r3, #0]
  return u8x8->cad_cb(u8x8, U8X8_MSG_CAD_SEND_ARG, arg, NULL);
    25c2:	687b      	ldr	r3, [r7, #4]
    25c4:	68dc      	ldr	r4, [r3, #12]
    25c6:	1cfb      	adds	r3, r7, #3
    25c8:	781a      	ldrb	r2, [r3, #0]
    25ca:	6878      	ldr	r0, [r7, #4]
    25cc:	2300      	movs	r3, #0
    25ce:	2116      	movs	r1, #22
    25d0:	47a0      	blx	r4
    25d2:	0003      	movs	r3, r0
}
    25d4:	0018      	movs	r0, r3
    25d6:	46bd      	mov	sp, r7
    25d8:	b003      	add	sp, #12
    25da:	bd90      	pop	{r4, r7, pc}

000025dc <u8x8_cad_SendData>:
  }
  return 1;
}

uint8_t u8x8_cad_SendData(u8x8_t *u8x8, uint8_t cnt, uint8_t *data)
{
    25dc:	b590      	push	{r4, r7, lr}
    25de:	b085      	sub	sp, #20
    25e0:	af00      	add	r7, sp, #0
    25e2:	60f8      	str	r0, [r7, #12]
    25e4:	607a      	str	r2, [r7, #4]
    25e6:	230b      	movs	r3, #11
    25e8:	18fb      	adds	r3, r7, r3
    25ea:	1c0a      	adds	r2, r1, #0
    25ec:	701a      	strb	r2, [r3, #0]
  return u8x8->cad_cb(u8x8, U8X8_MSG_CAD_SEND_DATA, cnt, data);
    25ee:	68fb      	ldr	r3, [r7, #12]
    25f0:	68dc      	ldr	r4, [r3, #12]
    25f2:	6879      	ldr	r1, [r7, #4]
    25f4:	230b      	movs	r3, #11
    25f6:	18fb      	adds	r3, r7, r3
    25f8:	781a      	ldrb	r2, [r3, #0]
    25fa:	68f8      	ldr	r0, [r7, #12]
    25fc:	000b      	movs	r3, r1
    25fe:	2117      	movs	r1, #23
    2600:	47a0      	blx	r4
    2602:	0003      	movs	r3, r0
}
    2604:	0018      	movs	r0, r3
    2606:	46bd      	mov	sp, r7
    2608:	b005      	add	sp, #20
    260a:	bd90      	pop	{r4, r7, pc}

0000260c <u8x8_cad_StartTransfer>:

uint8_t u8x8_cad_StartTransfer(u8x8_t *u8x8)
{
    260c:	b590      	push	{r4, r7, lr}
    260e:	b083      	sub	sp, #12
    2610:	af00      	add	r7, sp, #0
    2612:	6078      	str	r0, [r7, #4]
  return u8x8->cad_cb(u8x8, U8X8_MSG_CAD_START_TRANSFER, 0, NULL);
    2614:	687b      	ldr	r3, [r7, #4]
    2616:	68dc      	ldr	r4, [r3, #12]
    2618:	6878      	ldr	r0, [r7, #4]
    261a:	2300      	movs	r3, #0
    261c:	2200      	movs	r2, #0
    261e:	2118      	movs	r1, #24
    2620:	47a0      	blx	r4
    2622:	0003      	movs	r3, r0
}
    2624:	0018      	movs	r0, r3
    2626:	46bd      	mov	sp, r7
    2628:	b003      	add	sp, #12
    262a:	bd90      	pop	{r4, r7, pc}

0000262c <u8x8_cad_EndTransfer>:

uint8_t u8x8_cad_EndTransfer(u8x8_t *u8x8)
{
    262c:	b590      	push	{r4, r7, lr}
    262e:	b083      	sub	sp, #12
    2630:	af00      	add	r7, sp, #0
    2632:	6078      	str	r0, [r7, #4]
  return u8x8->cad_cb(u8x8, U8X8_MSG_CAD_END_TRANSFER, 0, NULL);
    2634:	687b      	ldr	r3, [r7, #4]
    2636:	68dc      	ldr	r4, [r3, #12]
    2638:	6878      	ldr	r0, [r7, #4]
    263a:	2300      	movs	r3, #0
    263c:	2200      	movs	r2, #0
    263e:	2119      	movs	r1, #25
    2640:	47a0      	blx	r4
    2642:	0003      	movs	r3, r0
}
    2644:	0018      	movs	r0, r3
    2646:	46bd      	mov	sp, r7
    2648:	b003      	add	sp, #12
    264a:	bd90      	pop	{r4, r7, pc}

0000264c <u8x8_cad_SendSequence>:
  254 milli	delay by milliseconds
  255		end of sequence
*/

void u8x8_cad_SendSequence(u8x8_t *u8x8, uint8_t const *data)
{
    264c:	b590      	push	{r4, r7, lr}
    264e:	b085      	sub	sp, #20
    2650:	af00      	add	r7, sp, #0
    2652:	6078      	str	r0, [r7, #4]
    2654:	6039      	str	r1, [r7, #0]
  uint8_t cmd;
  uint8_t v;

  for(;;)
  {
    cmd = *data;
    2656:	230f      	movs	r3, #15
    2658:	18fb      	adds	r3, r7, r3
    265a:	683a      	ldr	r2, [r7, #0]
    265c:	7812      	ldrb	r2, [r2, #0]
    265e:	701a      	strb	r2, [r3, #0]
    data++;
    2660:	683b      	ldr	r3, [r7, #0]
    2662:	3301      	adds	r3, #1
    2664:	603b      	str	r3, [r7, #0]
    switch( cmd )
    2666:	230f      	movs	r3, #15
    2668:	18fb      	adds	r3, r7, r3
    266a:	781b      	ldrb	r3, [r3, #0]
    266c:	2b17      	cmp	r3, #23
    266e:	d01c      	beq.n	26aa <u8x8_cad_SendSequence+0x5e>
    2670:	dc02      	bgt.n	2678 <u8x8_cad_SendSequence+0x2c>
    2672:	2b15      	cmp	r3, #21
    2674:	db45      	blt.n	2702 <u8x8_cad_SendSequence+0xb6>
    2676:	e004      	b.n	2682 <u8x8_cad_SendSequence+0x36>
    2678:	2b19      	cmp	r3, #25
    267a:	dd26      	ble.n	26ca <u8x8_cad_SendSequence+0x7e>
    267c:	2bfe      	cmp	r3, #254	; 0xfe
    267e:	d02e      	beq.n	26de <u8x8_cad_SendSequence+0x92>
	  v = *data;
	  u8x8_gpio_Delay(u8x8, U8X8_MSG_DELAY_MILLI, v);	    
	  data++;
	  break;
      default:
	return;
    2680:	e03f      	b.n	2702 <u8x8_cad_SendSequence+0xb6>
	  v = *data;
    2682:	683b      	ldr	r3, [r7, #0]
    2684:	781a      	ldrb	r2, [r3, #0]
    2686:	230e      	movs	r3, #14
    2688:	18fb      	adds	r3, r7, r3
    268a:	701a      	strb	r2, [r3, #0]
	  u8x8->cad_cb(u8x8, cmd, v, NULL);
    268c:	687b      	ldr	r3, [r7, #4]
    268e:	68dc      	ldr	r4, [r3, #12]
    2690:	230e      	movs	r3, #14
    2692:	18fb      	adds	r3, r7, r3
    2694:	781a      	ldrb	r2, [r3, #0]
    2696:	230f      	movs	r3, #15
    2698:	18fb      	adds	r3, r7, r3
    269a:	7819      	ldrb	r1, [r3, #0]
    269c:	6878      	ldr	r0, [r7, #4]
    269e:	2300      	movs	r3, #0
    26a0:	47a0      	blx	r4
	  data++;
    26a2:	683b      	ldr	r3, [r7, #0]
    26a4:	3301      	adds	r3, #1
    26a6:	603b      	str	r3, [r7, #0]
	  break;
    26a8:	e02a      	b.n	2700 <u8x8_cad_SendSequence+0xb4>
	  v = *data;
    26aa:	683b      	ldr	r3, [r7, #0]
    26ac:	781a      	ldrb	r2, [r3, #0]
    26ae:	230e      	movs	r3, #14
    26b0:	18fb      	adds	r3, r7, r3
    26b2:	701a      	strb	r2, [r3, #0]
	  u8x8_cad_SendData(u8x8, 1, &v);
    26b4:	230e      	movs	r3, #14
    26b6:	18fa      	adds	r2, r7, r3
    26b8:	687b      	ldr	r3, [r7, #4]
    26ba:	2101      	movs	r1, #1
    26bc:	0018      	movs	r0, r3
    26be:	f7ff ff8d 	bl	25dc <u8x8_cad_SendData>
	  data++;
    26c2:	683b      	ldr	r3, [r7, #0]
    26c4:	3301      	adds	r3, #1
    26c6:	603b      	str	r3, [r7, #0]
	  break;
    26c8:	e01a      	b.n	2700 <u8x8_cad_SendSequence+0xb4>
	  u8x8->cad_cb(u8x8, cmd, 0, NULL);
    26ca:	687b      	ldr	r3, [r7, #4]
    26cc:	68dc      	ldr	r4, [r3, #12]
    26ce:	230f      	movs	r3, #15
    26d0:	18fb      	adds	r3, r7, r3
    26d2:	7819      	ldrb	r1, [r3, #0]
    26d4:	6878      	ldr	r0, [r7, #4]
    26d6:	2300      	movs	r3, #0
    26d8:	2200      	movs	r2, #0
    26da:	47a0      	blx	r4
	  break;
    26dc:	e010      	b.n	2700 <u8x8_cad_SendSequence+0xb4>
	  v = *data;
    26de:	683b      	ldr	r3, [r7, #0]
    26e0:	781a      	ldrb	r2, [r3, #0]
    26e2:	230e      	movs	r3, #14
    26e4:	18fb      	adds	r3, r7, r3
    26e6:	701a      	strb	r2, [r3, #0]
	  u8x8_gpio_Delay(u8x8, U8X8_MSG_DELAY_MILLI, v);	    
    26e8:	230e      	movs	r3, #14
    26ea:	18fb      	adds	r3, r7, r3
    26ec:	781a      	ldrb	r2, [r3, #0]
    26ee:	687b      	ldr	r3, [r7, #4]
    26f0:	2129      	movs	r1, #41	; 0x29
    26f2:	0018      	movs	r0, r3
    26f4:	f000 fb88 	bl	2e08 <u8x8_gpio_call>
	  data++;
    26f8:	683b      	ldr	r3, [r7, #0]
    26fa:	3301      	adds	r3, #1
    26fc:	603b      	str	r3, [r7, #0]
	  break;
    26fe:	46c0      	nop			; (mov r8, r8)
    cmd = *data;
    2700:	e7a9      	b.n	2656 <u8x8_cad_SendSequence+0xa>
	return;
    2702:	46c0      	nop			; (mov r8, r8)
    }
  }
}
    2704:	46bd      	mov	sp, r7
    2706:	b005      	add	sp, #20
    2708:	bd90      	pop	{r4, r7, pc}
	...

0000270c <u8x8_cad_empty>:


uint8_t u8x8_cad_empty(u8x8_t *u8x8, uint8_t msg, uint8_t arg_int, void *arg_ptr)
{
    270c:	b5b0      	push	{r4, r5, r7, lr}
    270e:	b084      	sub	sp, #16
    2710:	af00      	add	r7, sp, #0
    2712:	60f8      	str	r0, [r7, #12]
    2714:	0008      	movs	r0, r1
    2716:	0011      	movs	r1, r2
    2718:	607b      	str	r3, [r7, #4]
    271a:	230b      	movs	r3, #11
    271c:	18fb      	adds	r3, r7, r3
    271e:	1c02      	adds	r2, r0, #0
    2720:	701a      	strb	r2, [r3, #0]
    2722:	230a      	movs	r3, #10
    2724:	18fb      	adds	r3, r7, r3
    2726:	1c0a      	adds	r2, r1, #0
    2728:	701a      	strb	r2, [r3, #0]
  switch(msg)
    272a:	230b      	movs	r3, #11
    272c:	18fb      	adds	r3, r7, r3
    272e:	781b      	ldrb	r3, [r3, #0]
    2730:	3b14      	subs	r3, #20
    2732:	2b05      	cmp	r3, #5
    2734:	d824      	bhi.n	2780 <u8x8_cad_empty+0x74>
    2736:	009a      	lsls	r2, r3, #2
    2738:	4b15      	ldr	r3, [pc, #84]	; (2790 <u8x8_cad_empty+0x84>)
    273a:	18d3      	adds	r3, r2, r3
    273c:	681b      	ldr	r3, [r3, #0]
    273e:	469f      	mov	pc, r3
  {
    case U8X8_MSG_CAD_SEND_CMD:
      u8x8_byte_SendByte(u8x8, arg_int);
    2740:	230a      	movs	r3, #10
    2742:	18fb      	adds	r3, r7, r3
    2744:	781a      	ldrb	r2, [r3, #0]
    2746:	68fb      	ldr	r3, [r7, #12]
    2748:	0011      	movs	r1, r2
    274a:	0018      	movs	r0, r3
    274c:	f7ff ff0c 	bl	2568 <u8x8_byte_SendByte>
      break;
    2750:	e018      	b.n	2784 <u8x8_cad_empty+0x78>
    case U8X8_MSG_CAD_SEND_ARG:
      u8x8_byte_SendByte(u8x8, arg_int);
    2752:	230a      	movs	r3, #10
    2754:	18fb      	adds	r3, r7, r3
    2756:	781a      	ldrb	r2, [r3, #0]
    2758:	68fb      	ldr	r3, [r7, #12]
    275a:	0011      	movs	r1, r2
    275c:	0018      	movs	r0, r3
    275e:	f7ff ff03 	bl	2568 <u8x8_byte_SendByte>
      break;
    2762:	e00f      	b.n	2784 <u8x8_cad_empty+0x78>
    case U8X8_MSG_CAD_SEND_DATA:
    case U8X8_MSG_CAD_INIT:
    case U8X8_MSG_CAD_START_TRANSFER:
    case U8X8_MSG_CAD_END_TRANSFER:
      return u8x8->byte_cb(u8x8, msg, arg_int, arg_ptr);
    2764:	68fb      	ldr	r3, [r7, #12]
    2766:	691c      	ldr	r4, [r3, #16]
    2768:	687d      	ldr	r5, [r7, #4]
    276a:	230a      	movs	r3, #10
    276c:	18fb      	adds	r3, r7, r3
    276e:	781a      	ldrb	r2, [r3, #0]
    2770:	230b      	movs	r3, #11
    2772:	18fb      	adds	r3, r7, r3
    2774:	7819      	ldrb	r1, [r3, #0]
    2776:	68f8      	ldr	r0, [r7, #12]
    2778:	002b      	movs	r3, r5
    277a:	47a0      	blx	r4
    277c:	0003      	movs	r3, r0
    277e:	e002      	b.n	2786 <u8x8_cad_empty+0x7a>
    default:
      return 0;
    2780:	2300      	movs	r3, #0
    2782:	e000      	b.n	2786 <u8x8_cad_empty+0x7a>
  }
  return 1;
    2784:	2301      	movs	r3, #1
}
    2786:	0018      	movs	r0, r3
    2788:	46bd      	mov	sp, r7
    278a:	b004      	add	sp, #16
    278c:	bdb0      	pop	{r4, r5, r7, pc}
    278e:	46c0      	nop			; (mov r8, r8)
    2790:	000089a0 	.word	0x000089a0

00002794 <u8x8_d_helper_display_setup_memory>:
  this is a helper function for the U8X8_MSG_DISPLAY_SETUP_MEMORY function.
  It can be called within the display callback function to carry out the usual standard tasks.
  
*/
void u8x8_d_helper_display_setup_memory(u8x8_t *u8x8, const u8x8_display_info_t *display_info)
{
    2794:	b580      	push	{r7, lr}
    2796:	b082      	sub	sp, #8
    2798:	af00      	add	r7, sp, #0
    279a:	6078      	str	r0, [r7, #4]
    279c:	6039      	str	r1, [r7, #0]
      /* 1) set display info struct */
      u8x8->display_info = display_info;
    279e:	687b      	ldr	r3, [r7, #4]
    27a0:	683a      	ldr	r2, [r7, #0]
    27a2:	601a      	str	r2, [r3, #0]
      u8x8->x_offset = u8x8->display_info->default_x_offset;
    27a4:	687b      	ldr	r3, [r7, #4]
    27a6:	681b      	ldr	r3, [r3, #0]
    27a8:	7c99      	ldrb	r1, [r3, #18]
    27aa:	687b      	ldr	r3, [r7, #4]
    27ac:	2222      	movs	r2, #34	; 0x22
    27ae:	5499      	strb	r1, [r3, r2]
}
    27b0:	46c0      	nop			; (mov r8, r8)
    27b2:	46bd      	mov	sp, r7
    27b4:	b002      	add	sp, #8
    27b6:	bd80      	pop	{r7, pc}

000027b8 <u8x8_d_helper_display_init>:
  this is a helper function for the U8X8_MSG_DISPLAY_INIT function.
  It can be called within the display callback function to carry out the usual standard tasks.
  
*/
void u8x8_d_helper_display_init(u8x8_t *u8x8)
{
    27b8:	b590      	push	{r4, r7, lr}
    27ba:	b083      	sub	sp, #12
    27bc:	af00      	add	r7, sp, #0
    27be:	6078      	str	r0, [r7, #4]
      /* 2) apply port directions to the GPIO lines and apply default values for the IO lines*/
      u8x8_gpio_Init(u8x8);
    27c0:	687b      	ldr	r3, [r7, #4]
    27c2:	695c      	ldr	r4, [r3, #20]
    27c4:	6878      	ldr	r0, [r7, #4]
    27c6:	2300      	movs	r3, #0
    27c8:	2200      	movs	r2, #0
    27ca:	2128      	movs	r1, #40	; 0x28
    27cc:	47a0      	blx	r4
      u8x8_cad_Init(u8x8);              /* this will also call U8X8_MSG_BYTE_INIT, byte init will NOT call GPIO_INIT */
    27ce:	687b      	ldr	r3, [r7, #4]
    27d0:	68dc      	ldr	r4, [r3, #12]
    27d2:	6878      	ldr	r0, [r7, #4]
    27d4:	2300      	movs	r3, #0
    27d6:	2200      	movs	r2, #0
    27d8:	2114      	movs	r1, #20
    27da:	47a0      	blx	r4

      /* 3) do reset */
      u8x8_gpio_SetReset(u8x8, 1);
    27dc:	687b      	ldr	r3, [r7, #4]
    27de:	2201      	movs	r2, #1
    27e0:	214b      	movs	r1, #75	; 0x4b
    27e2:	0018      	movs	r0, r3
    27e4:	f000 fb10 	bl	2e08 <u8x8_gpio_call>
      u8x8_gpio_Delay(u8x8, U8X8_MSG_DELAY_MILLI, u8x8->display_info->reset_pulse_width_ms);
    27e8:	687b      	ldr	r3, [r7, #4]
    27ea:	681b      	ldr	r3, [r3, #0]
    27ec:	791a      	ldrb	r2, [r3, #4]
    27ee:	687b      	ldr	r3, [r7, #4]
    27f0:	2129      	movs	r1, #41	; 0x29
    27f2:	0018      	movs	r0, r3
    27f4:	f000 fb08 	bl	2e08 <u8x8_gpio_call>
      u8x8_gpio_SetReset(u8x8, 0);
    27f8:	687b      	ldr	r3, [r7, #4]
    27fa:	2200      	movs	r2, #0
    27fc:	214b      	movs	r1, #75	; 0x4b
    27fe:	0018      	movs	r0, r3
    2800:	f000 fb02 	bl	2e08 <u8x8_gpio_call>
      u8x8_gpio_Delay(u8x8, U8X8_MSG_DELAY_MILLI, u8x8->display_info->reset_pulse_width_ms);
    2804:	687b      	ldr	r3, [r7, #4]
    2806:	681b      	ldr	r3, [r3, #0]
    2808:	791a      	ldrb	r2, [r3, #4]
    280a:	687b      	ldr	r3, [r7, #4]
    280c:	2129      	movs	r1, #41	; 0x29
    280e:	0018      	movs	r0, r3
    2810:	f000 fafa 	bl	2e08 <u8x8_gpio_call>
      u8x8_gpio_SetReset(u8x8, 1);
    2814:	687b      	ldr	r3, [r7, #4]
    2816:	2201      	movs	r2, #1
    2818:	214b      	movs	r1, #75	; 0x4b
    281a:	0018      	movs	r0, r3
    281c:	f000 faf4 	bl	2e08 <u8x8_gpio_call>
      u8x8_gpio_Delay(u8x8, U8X8_MSG_DELAY_MILLI, u8x8->display_info->post_reset_wait_ms);
    2820:	687b      	ldr	r3, [r7, #4]
    2822:	681b      	ldr	r3, [r3, #0]
    2824:	795a      	ldrb	r2, [r3, #5]
    2826:	687b      	ldr	r3, [r7, #4]
    2828:	2129      	movs	r1, #41	; 0x29
    282a:	0018      	movs	r0, r3
    282c:	f000 faec 	bl	2e08 <u8x8_gpio_call>
}    
    2830:	46c0      	nop			; (mov r8, r8)
    2832:	46bd      	mov	sp, r7
    2834:	b003      	add	sp, #12
    2836:	bd90      	pop	{r4, r7, pc}

00002838 <u8x8_DrawTile>:

/*==========================================*/
/* official functions */

uint8_t u8x8_DrawTile(u8x8_t *u8x8, uint8_t x, uint8_t y, uint8_t cnt, uint8_t *tile_ptr)
{
    2838:	b590      	push	{r4, r7, lr}
    283a:	b085      	sub	sp, #20
    283c:	af00      	add	r7, sp, #0
    283e:	6078      	str	r0, [r7, #4]
    2840:	000c      	movs	r4, r1
    2842:	0010      	movs	r0, r2
    2844:	0019      	movs	r1, r3
    2846:	1cfb      	adds	r3, r7, #3
    2848:	1c22      	adds	r2, r4, #0
    284a:	701a      	strb	r2, [r3, #0]
    284c:	1cbb      	adds	r3, r7, #2
    284e:	1c02      	adds	r2, r0, #0
    2850:	701a      	strb	r2, [r3, #0]
    2852:	1c7b      	adds	r3, r7, #1
    2854:	1c0a      	adds	r2, r1, #0
    2856:	701a      	strb	r2, [r3, #0]
  u8x8_tile_t tile;
  tile.x_pos = x;
    2858:	2308      	movs	r3, #8
    285a:	18fb      	adds	r3, r7, r3
    285c:	1cfa      	adds	r2, r7, #3
    285e:	7812      	ldrb	r2, [r2, #0]
    2860:	715a      	strb	r2, [r3, #5]
  tile.y_pos = y;
    2862:	2308      	movs	r3, #8
    2864:	18fb      	adds	r3, r7, r3
    2866:	1cba      	adds	r2, r7, #2
    2868:	7812      	ldrb	r2, [r2, #0]
    286a:	719a      	strb	r2, [r3, #6]
  tile.cnt = cnt;
    286c:	2308      	movs	r3, #8
    286e:	18fb      	adds	r3, r7, r3
    2870:	1c7a      	adds	r2, r7, #1
    2872:	7812      	ldrb	r2, [r2, #0]
    2874:	711a      	strb	r2, [r3, #4]
  tile.tile_ptr = tile_ptr;
    2876:	2308      	movs	r3, #8
    2878:	18fb      	adds	r3, r7, r3
    287a:	6a3a      	ldr	r2, [r7, #32]
    287c:	601a      	str	r2, [r3, #0]
  return u8x8->display_cb(u8x8, U8X8_MSG_DISPLAY_DRAW_TILE, 1, (void *)&tile);
    287e:	687b      	ldr	r3, [r7, #4]
    2880:	689c      	ldr	r4, [r3, #8]
    2882:	2308      	movs	r3, #8
    2884:	18fb      	adds	r3, r7, r3
    2886:	6878      	ldr	r0, [r7, #4]
    2888:	2201      	movs	r2, #1
    288a:	210f      	movs	r1, #15
    288c:	47a0      	blx	r4
    288e:	0003      	movs	r3, r0
}
    2890:	0018      	movs	r0, r3
    2892:	46bd      	mov	sp, r7
    2894:	b005      	add	sp, #20
    2896:	bd90      	pop	{r4, r7, pc}

00002898 <u8x8_SetupMemory>:

/* should be implemented as macro */
void u8x8_SetupMemory(u8x8_t *u8x8)
{
    2898:	b590      	push	{r4, r7, lr}
    289a:	b083      	sub	sp, #12
    289c:	af00      	add	r7, sp, #0
    289e:	6078      	str	r0, [r7, #4]
  u8x8->display_cb(u8x8, U8X8_MSG_DISPLAY_SETUP_MEMORY, 0, NULL);  
    28a0:	687b      	ldr	r3, [r7, #4]
    28a2:	689c      	ldr	r4, [r3, #8]
    28a4:	6878      	ldr	r0, [r7, #4]
    28a6:	2300      	movs	r3, #0
    28a8:	2200      	movs	r2, #0
    28aa:	2109      	movs	r1, #9
    28ac:	47a0      	blx	r4
}
    28ae:	46c0      	nop			; (mov r8, r8)
    28b0:	46bd      	mov	sp, r7
    28b2:	b003      	add	sp, #12
    28b4:	bd90      	pop	{r4, r7, pc}

000028b6 <u8x8_InitDisplay>:
  In some cases it is not required to init the display (for example if the display is already running, but the controller comes out of deep sleep mode).
  Then InitDisplay can be skipped, but u8x8_InitInterface()  (== u8x8_gpio_Init() and u8x8_cad_Init()) need to be executed.

*/
void u8x8_InitDisplay(u8x8_t *u8x8)
{
    28b6:	b590      	push	{r4, r7, lr}
    28b8:	b083      	sub	sp, #12
    28ba:	af00      	add	r7, sp, #0
    28bc:	6078      	str	r0, [r7, #4]
  u8x8->display_cb(u8x8, U8X8_MSG_DISPLAY_INIT, 0, NULL);       /* this will call u8x8_d_helper_display_init() and send the init seqence to the display */
    28be:	687b      	ldr	r3, [r7, #4]
    28c0:	689c      	ldr	r4, [r3, #8]
    28c2:	6878      	ldr	r0, [r7, #4]
    28c4:	2300      	movs	r3, #0
    28c6:	2200      	movs	r2, #0
    28c8:	210a      	movs	r1, #10
    28ca:	47a0      	blx	r4
  /* u8x8->display_cb(u8x8, U8X8_MSG_DISPLAY_SET_FLIP_MODE, 0, NULL);  */ /* It would make sense to call flip mode 0 here after U8X8_MSG_DISPLAY_INIT */
}
    28cc:	46c0      	nop			; (mov r8, r8)
    28ce:	46bd      	mov	sp, r7
    28d0:	b003      	add	sp, #12
    28d2:	bd90      	pop	{r4, r7, pc}

000028d4 <u8x8_SetPowerSave>:

void u8x8_SetPowerSave(u8x8_t *u8x8, uint8_t is_enable)
{
    28d4:	b590      	push	{r4, r7, lr}
    28d6:	b083      	sub	sp, #12
    28d8:	af00      	add	r7, sp, #0
    28da:	6078      	str	r0, [r7, #4]
    28dc:	000a      	movs	r2, r1
    28de:	1cfb      	adds	r3, r7, #3
    28e0:	701a      	strb	r2, [r3, #0]
  u8x8->display_cb(u8x8, U8X8_MSG_DISPLAY_SET_POWER_SAVE, is_enable, NULL);  
    28e2:	687b      	ldr	r3, [r7, #4]
    28e4:	689c      	ldr	r4, [r3, #8]
    28e6:	1cfb      	adds	r3, r7, #3
    28e8:	781a      	ldrb	r2, [r3, #0]
    28ea:	6878      	ldr	r0, [r7, #4]
    28ec:	2300      	movs	r3, #0
    28ee:	210b      	movs	r1, #11
    28f0:	47a0      	blx	r4
}
    28f2:	46c0      	nop			; (mov r8, r8)
    28f4:	46bd      	mov	sp, r7
    28f6:	b003      	add	sp, #12
    28f8:	bd90      	pop	{r4, r7, pc}

000028fa <u8x8_SetContrast>:
{
  u8x8->display_cb(u8x8, U8X8_MSG_DISPLAY_SET_FLIP_MODE, mode, NULL);  
}

void u8x8_SetContrast(u8x8_t *u8x8, uint8_t value)
{
    28fa:	b590      	push	{r4, r7, lr}
    28fc:	b083      	sub	sp, #12
    28fe:	af00      	add	r7, sp, #0
    2900:	6078      	str	r0, [r7, #4]
    2902:	000a      	movs	r2, r1
    2904:	1cfb      	adds	r3, r7, #3
    2906:	701a      	strb	r2, [r3, #0]
  u8x8->display_cb(u8x8, U8X8_MSG_DISPLAY_SET_CONTRAST, value, NULL);  
    2908:	687b      	ldr	r3, [r7, #4]
    290a:	689c      	ldr	r4, [r3, #8]
    290c:	1cfb      	adds	r3, r7, #3
    290e:	781a      	ldrb	r2, [r3, #0]
    2910:	6878      	ldr	r0, [r7, #4]
    2912:	2300      	movs	r3, #0
    2914:	210e      	movs	r1, #14
    2916:	47a0      	blx	r4
}
    2918:	46c0      	nop			; (mov r8, r8)
    291a:	46bd      	mov	sp, r7
    291c:	b003      	add	sp, #12
    291e:	bd90      	pop	{r4, r7, pc}

00002920 <u8x8_RefreshDisplay>:

void u8x8_RefreshDisplay(u8x8_t *u8x8)
{
    2920:	b590      	push	{r4, r7, lr}
    2922:	b083      	sub	sp, #12
    2924:	af00      	add	r7, sp, #0
    2926:	6078      	str	r0, [r7, #4]
  u8x8->display_cb(u8x8, U8X8_MSG_DISPLAY_REFRESH, 0, NULL);  
    2928:	687b      	ldr	r3, [r7, #4]
    292a:	689c      	ldr	r4, [r3, #8]
    292c:	6878      	ldr	r0, [r7, #4]
    292e:	2300      	movs	r3, #0
    2930:	2200      	movs	r2, #0
    2932:	2110      	movs	r1, #16
    2934:	47a0      	blx	r4
}
    2936:	46c0      	nop			; (mov r8, r8)
    2938:	46bd      	mov	sp, r7
    293a:	b003      	add	sp, #12
    293c:	bd90      	pop	{r4, r7, pc}
	...

00002940 <u8x8_d_gp1287ai_common>:
    U8X8_END_TRANSFER(),

    U8X8_END() /* end of sequence */
};
uint8_t u8x8_d_gp1287ai_common(u8x8_t *u8x8, uint8_t msg, uint8_t arg_int, void *arg_ptr)
{
    2940:	b580      	push	{r7, lr}
    2942:	b088      	sub	sp, #32
    2944:	af00      	add	r7, sp, #0
    2946:	60f8      	str	r0, [r7, #12]
    2948:	0008      	movs	r0, r1
    294a:	0011      	movs	r1, r2
    294c:	607b      	str	r3, [r7, #4]
    294e:	230b      	movs	r3, #11
    2950:	18fb      	adds	r3, r7, r3
    2952:	1c02      	adds	r2, r0, #0
    2954:	701a      	strb	r2, [r3, #0]
    2956:	230a      	movs	r3, #10
    2958:	18fb      	adds	r3, r7, r3
    295a:	1c0a      	adds	r2, r1, #0
    295c:	701a      	strb	r2, [r3, #0]
    uint8_t *ptr;
    uint8_t x, y;
    uint16_t tx_cnt;
    uint8_t swapped_byte;
    switch (msg)
    295e:	230b      	movs	r3, #11
    2960:	18fb      	adds	r3, r7, r3
    2962:	781b      	ldrb	r3, [r3, #0]
    2964:	2b0e      	cmp	r3, #14
    2966:	d018      	beq.n	299a <u8x8_d_gp1287ai_common+0x5a>
    2968:	2b0f      	cmp	r3, #15
    296a:	d100      	bne.n	296e <u8x8_d_gp1287ai_common+0x2e>
    296c:	e0cf      	b.n	2b0e <u8x8_d_gp1287ai_common+0x1ce>
    296e:	2b0b      	cmp	r3, #11
    2970:	d000      	beq.n	2974 <u8x8_d_gp1287ai_common+0x34>
    2972:	e201      	b.n	2d78 <u8x8_d_gp1287ai_common+0x438>
    {
    case U8X8_MSG_DISPLAY_SET_POWER_SAVE:
        if (arg_int == 0)
    2974:	230a      	movs	r3, #10
    2976:	18fb      	adds	r3, r7, r3
    2978:	781b      	ldrb	r3, [r3, #0]
    297a:	2b00      	cmp	r3, #0
    297c:	d106      	bne.n	298c <u8x8_d_gp1287ai_common+0x4c>
            u8x8_cad_SendSequence(u8x8, u8x8_d_gp1287ai_wakeup_seq);
    297e:	4ac6      	ldr	r2, [pc, #792]	; (2c98 <u8x8_d_gp1287ai_common+0x358>)
    2980:	68fb      	ldr	r3, [r7, #12]
    2982:	0011      	movs	r1, r2
    2984:	0018      	movs	r0, r3
    2986:	f7ff fe61 	bl	264c <u8x8_cad_SendSequence>
        else
            u8x8_cad_SendSequence(u8x8, u8x8_d_gp1287ai_standby_seq);
        break;
    298a:	e1f7      	b.n	2d7c <u8x8_d_gp1287ai_common+0x43c>
            u8x8_cad_SendSequence(u8x8, u8x8_d_gp1287ai_standby_seq);
    298c:	4ac3      	ldr	r2, [pc, #780]	; (2c9c <u8x8_d_gp1287ai_common+0x35c>)
    298e:	68fb      	ldr	r3, [r7, #12]
    2990:	0011      	movs	r1, r2
    2992:	0018      	movs	r0, r3
    2994:	f7ff fe5a 	bl	264c <u8x8_cad_SendSequence>
        break;
    2998:	e1f0      	b.n	2d7c <u8x8_d_gp1287ai_common+0x43c>
#ifdef U8X8_WITH_SET_CONTRAST
    case U8X8_MSG_DISPLAY_SET_CONTRAST:
        u8x8_cad_StartTransfer(u8x8);
    299a:	68fb      	ldr	r3, [r7, #12]
    299c:	0018      	movs	r0, r3
    299e:	f7ff fe35 	bl	260c <u8x8_cad_StartTransfer>
        u8x8_cad_SendCmd(u8x8, SWAP8(0x0A0));
    29a2:	68fb      	ldr	r3, [r7, #12]
    29a4:	2105      	movs	r1, #5
    29a6:	0018      	movs	r0, r3
    29a8:	f7ff fdf0 	bl	258c <u8x8_cad_SendCmd>
        //u8x8_cad_SendArg(u8x8, SWAP8((arg_int * 4) >> 8));   /* Dimming level */
        //u8x8_cad_SendArg(u8x8, SWAP8((arg_int * 4) & 0xFF)); /* Dimming level */
		
		u8x8_cad_SendArg(u8x8, SWAP8((arg_int * 4) >> 8));   /* Dimming level */
    29ac:	230a      	movs	r3, #10
    29ae:	18fb      	adds	r3, r7, r3
    29b0:	781b      	ldrb	r3, [r3, #0]
    29b2:	009b      	lsls	r3, r3, #2
    29b4:	13db      	asrs	r3, r3, #15
    29b6:	b25b      	sxtb	r3, r3
    29b8:	2201      	movs	r2, #1
    29ba:	4013      	ands	r3, r2
    29bc:	b25a      	sxtb	r2, r3
    29be:	230a      	movs	r3, #10
    29c0:	18fb      	adds	r3, r7, r3
    29c2:	781b      	ldrb	r3, [r3, #0]
    29c4:	009b      	lsls	r3, r3, #2
    29c6:	135b      	asrs	r3, r3, #13
    29c8:	b25b      	sxtb	r3, r3
    29ca:	2102      	movs	r1, #2
    29cc:	400b      	ands	r3, r1
    29ce:	b25b      	sxtb	r3, r3
    29d0:	4313      	orrs	r3, r2
    29d2:	b25a      	sxtb	r2, r3
    29d4:	230a      	movs	r3, #10
    29d6:	18fb      	adds	r3, r7, r3
    29d8:	781b      	ldrb	r3, [r3, #0]
    29da:	009b      	lsls	r3, r3, #2
    29dc:	12db      	asrs	r3, r3, #11
    29de:	b25b      	sxtb	r3, r3
    29e0:	2104      	movs	r1, #4
    29e2:	400b      	ands	r3, r1
    29e4:	b25b      	sxtb	r3, r3
    29e6:	4313      	orrs	r3, r2
    29e8:	b25a      	sxtb	r2, r3
    29ea:	230a      	movs	r3, #10
    29ec:	18fb      	adds	r3, r7, r3
    29ee:	781b      	ldrb	r3, [r3, #0]
    29f0:	009b      	lsls	r3, r3, #2
    29f2:	125b      	asrs	r3, r3, #9
    29f4:	b25b      	sxtb	r3, r3
    29f6:	2108      	movs	r1, #8
    29f8:	400b      	ands	r3, r1
    29fa:	b25b      	sxtb	r3, r3
    29fc:	4313      	orrs	r3, r2
    29fe:	b25a      	sxtb	r2, r3
    2a00:	230a      	movs	r3, #10
    2a02:	18fb      	adds	r3, r7, r3
    2a04:	781b      	ldrb	r3, [r3, #0]
    2a06:	009b      	lsls	r3, r3, #2
    2a08:	121b      	asrs	r3, r3, #8
    2a0a:	005b      	lsls	r3, r3, #1
    2a0c:	b25b      	sxtb	r3, r3
    2a0e:	2110      	movs	r1, #16
    2a10:	400b      	ands	r3, r1
    2a12:	b25b      	sxtb	r3, r3
    2a14:	4313      	orrs	r3, r2
    2a16:	b25a      	sxtb	r2, r3
    2a18:	230a      	movs	r3, #10
    2a1a:	18fb      	adds	r3, r7, r3
    2a1c:	781b      	ldrb	r3, [r3, #0]
    2a1e:	009b      	lsls	r3, r3, #2
    2a20:	121b      	asrs	r3, r3, #8
    2a22:	00db      	lsls	r3, r3, #3
    2a24:	b25b      	sxtb	r3, r3
    2a26:	2120      	movs	r1, #32
    2a28:	400b      	ands	r3, r1
    2a2a:	b25b      	sxtb	r3, r3
    2a2c:	4313      	orrs	r3, r2
    2a2e:	b25a      	sxtb	r2, r3
    2a30:	230a      	movs	r3, #10
    2a32:	18fb      	adds	r3, r7, r3
    2a34:	781b      	ldrb	r3, [r3, #0]
    2a36:	009b      	lsls	r3, r3, #2
    2a38:	121b      	asrs	r3, r3, #8
    2a3a:	015b      	lsls	r3, r3, #5
    2a3c:	b25b      	sxtb	r3, r3
    2a3e:	2140      	movs	r1, #64	; 0x40
    2a40:	400b      	ands	r3, r1
    2a42:	b25b      	sxtb	r3, r3
    2a44:	4313      	orrs	r3, r2
    2a46:	b25a      	sxtb	r2, r3
    2a48:	230a      	movs	r3, #10
    2a4a:	18fb      	adds	r3, r7, r3
    2a4c:	781b      	ldrb	r3, [r3, #0]
    2a4e:	009b      	lsls	r3, r3, #2
    2a50:	121b      	asrs	r3, r3, #8
    2a52:	01db      	lsls	r3, r3, #7
    2a54:	b25b      	sxtb	r3, r3
    2a56:	4313      	orrs	r3, r2
    2a58:	b25b      	sxtb	r3, r3
    2a5a:	b2da      	uxtb	r2, r3
    2a5c:	68fb      	ldr	r3, [r7, #12]
    2a5e:	0011      	movs	r1, r2
    2a60:	0018      	movs	r0, r3
    2a62:	f7ff fda7 	bl	25b4 <u8x8_cad_SendArg>
		u8x8_cad_SendArg(u8x8, SWAP8(arg_int)); /* Dimming level */
    2a66:	230a      	movs	r3, #10
    2a68:	18fb      	adds	r3, r7, r3
    2a6a:	781b      	ldrb	r3, [r3, #0]
    2a6c:	09db      	lsrs	r3, r3, #7
    2a6e:	b2db      	uxtb	r3, r3
    2a70:	b25a      	sxtb	r2, r3
    2a72:	230a      	movs	r3, #10
    2a74:	18fb      	adds	r3, r7, r3
    2a76:	781b      	ldrb	r3, [r3, #0]
    2a78:	115b      	asrs	r3, r3, #5
    2a7a:	b25b      	sxtb	r3, r3
    2a7c:	2102      	movs	r1, #2
    2a7e:	400b      	ands	r3, r1
    2a80:	b25b      	sxtb	r3, r3
    2a82:	4313      	orrs	r3, r2
    2a84:	b25a      	sxtb	r2, r3
    2a86:	230a      	movs	r3, #10
    2a88:	18fb      	adds	r3, r7, r3
    2a8a:	781b      	ldrb	r3, [r3, #0]
    2a8c:	10db      	asrs	r3, r3, #3
    2a8e:	b25b      	sxtb	r3, r3
    2a90:	2104      	movs	r1, #4
    2a92:	400b      	ands	r3, r1
    2a94:	b25b      	sxtb	r3, r3
    2a96:	4313      	orrs	r3, r2
    2a98:	b25a      	sxtb	r2, r3
    2a9a:	230a      	movs	r3, #10
    2a9c:	18fb      	adds	r3, r7, r3
    2a9e:	781b      	ldrb	r3, [r3, #0]
    2aa0:	105b      	asrs	r3, r3, #1
    2aa2:	b25b      	sxtb	r3, r3
    2aa4:	2108      	movs	r1, #8
    2aa6:	400b      	ands	r3, r1
    2aa8:	b25b      	sxtb	r3, r3
    2aaa:	4313      	orrs	r3, r2
    2aac:	b25a      	sxtb	r2, r3
    2aae:	230a      	movs	r3, #10
    2ab0:	18fb      	adds	r3, r7, r3
    2ab2:	781b      	ldrb	r3, [r3, #0]
    2ab4:	005b      	lsls	r3, r3, #1
    2ab6:	b25b      	sxtb	r3, r3
    2ab8:	2110      	movs	r1, #16
    2aba:	400b      	ands	r3, r1
    2abc:	b25b      	sxtb	r3, r3
    2abe:	4313      	orrs	r3, r2
    2ac0:	b25a      	sxtb	r2, r3
    2ac2:	230a      	movs	r3, #10
    2ac4:	18fb      	adds	r3, r7, r3
    2ac6:	781b      	ldrb	r3, [r3, #0]
    2ac8:	00db      	lsls	r3, r3, #3
    2aca:	b25b      	sxtb	r3, r3
    2acc:	2120      	movs	r1, #32
    2ace:	400b      	ands	r3, r1
    2ad0:	b25b      	sxtb	r3, r3
    2ad2:	4313      	orrs	r3, r2
    2ad4:	b25a      	sxtb	r2, r3
    2ad6:	230a      	movs	r3, #10
    2ad8:	18fb      	adds	r3, r7, r3
    2ada:	781b      	ldrb	r3, [r3, #0]
    2adc:	015b      	lsls	r3, r3, #5
    2ade:	b25b      	sxtb	r3, r3
    2ae0:	2140      	movs	r1, #64	; 0x40
    2ae2:	400b      	ands	r3, r1
    2ae4:	b25b      	sxtb	r3, r3
    2ae6:	4313      	orrs	r3, r2
    2ae8:	b25a      	sxtb	r2, r3
    2aea:	230a      	movs	r3, #10
    2aec:	18fb      	adds	r3, r7, r3
    2aee:	781b      	ldrb	r3, [r3, #0]
    2af0:	01db      	lsls	r3, r3, #7
    2af2:	b25b      	sxtb	r3, r3
    2af4:	4313      	orrs	r3, r2
    2af6:	b25b      	sxtb	r3, r3
    2af8:	b2da      	uxtb	r2, r3
    2afa:	68fb      	ldr	r3, [r7, #12]
    2afc:	0011      	movs	r1, r2
    2afe:	0018      	movs	r0, r3
    2b00:	f7ff fd58 	bl	25b4 <u8x8_cad_SendArg>
		
        u8x8_cad_EndTransfer(u8x8);
    2b04:	68fb      	ldr	r3, [r7, #12]
    2b06:	0018      	movs	r0, r3
    2b08:	f7ff fd90 	bl	262c <u8x8_cad_EndTransfer>
        break;
    2b0c:	e136      	b.n	2d7c <u8x8_d_gp1287ai_common+0x43c>
#endif
    case U8X8_MSG_DISPLAY_DRAW_TILE:
        x = ((u8x8_tile_t *)arg_ptr)->x_pos * 8;
    2b0e:	687b      	ldr	r3, [r7, #4]
    2b10:	795a      	ldrb	r2, [r3, #5]
    2b12:	2319      	movs	r3, #25
    2b14:	18fb      	adds	r3, r7, r3
    2b16:	00d2      	lsls	r2, r2, #3
    2b18:	701a      	strb	r2, [r3, #0]
        y = ((u8x8_tile_t *)arg_ptr)->y_pos * 8 + 4;
    2b1a:	687b      	ldr	r3, [r7, #4]
    2b1c:	799b      	ldrb	r3, [r3, #6]
    2b1e:	00db      	lsls	r3, r3, #3
    2b20:	b2da      	uxtb	r2, r3
    2b22:	2318      	movs	r3, #24
    2b24:	18fb      	adds	r3, r7, r3
    2b26:	3204      	adds	r2, #4
    2b28:	701a      	strb	r2, [r3, #0]

        u8x8_cad_StartTransfer(u8x8);
    2b2a:	68fb      	ldr	r3, [r7, #12]
    2b2c:	0018      	movs	r0, r3
    2b2e:	f7ff fd6d 	bl	260c <u8x8_cad_StartTransfer>

        u8x8_cad_SendCmd(u8x8, SWAP8(0x0F0));
    2b32:	68fb      	ldr	r3, [r7, #12]
    2b34:	210f      	movs	r1, #15
    2b36:	0018      	movs	r0, r3
    2b38:	f7ff fd28 	bl	258c <u8x8_cad_SendCmd>
        u8x8_cad_SendArg(u8x8, SWAP8(x));
    2b3c:	2319      	movs	r3, #25
    2b3e:	18fb      	adds	r3, r7, r3
    2b40:	781b      	ldrb	r3, [r3, #0]
    2b42:	09db      	lsrs	r3, r3, #7
    2b44:	b2db      	uxtb	r3, r3
    2b46:	b25a      	sxtb	r2, r3
    2b48:	2319      	movs	r3, #25
    2b4a:	18fb      	adds	r3, r7, r3
    2b4c:	781b      	ldrb	r3, [r3, #0]
    2b4e:	115b      	asrs	r3, r3, #5
    2b50:	b25b      	sxtb	r3, r3
    2b52:	2102      	movs	r1, #2
    2b54:	400b      	ands	r3, r1
    2b56:	b25b      	sxtb	r3, r3
    2b58:	4313      	orrs	r3, r2
    2b5a:	b25a      	sxtb	r2, r3
    2b5c:	2319      	movs	r3, #25
    2b5e:	18fb      	adds	r3, r7, r3
    2b60:	781b      	ldrb	r3, [r3, #0]
    2b62:	10db      	asrs	r3, r3, #3
    2b64:	b25b      	sxtb	r3, r3
    2b66:	2104      	movs	r1, #4
    2b68:	400b      	ands	r3, r1
    2b6a:	b25b      	sxtb	r3, r3
    2b6c:	4313      	orrs	r3, r2
    2b6e:	b25a      	sxtb	r2, r3
    2b70:	2319      	movs	r3, #25
    2b72:	18fb      	adds	r3, r7, r3
    2b74:	781b      	ldrb	r3, [r3, #0]
    2b76:	105b      	asrs	r3, r3, #1
    2b78:	b25b      	sxtb	r3, r3
    2b7a:	2108      	movs	r1, #8
    2b7c:	400b      	ands	r3, r1
    2b7e:	b25b      	sxtb	r3, r3
    2b80:	4313      	orrs	r3, r2
    2b82:	b25a      	sxtb	r2, r3
    2b84:	2319      	movs	r3, #25
    2b86:	18fb      	adds	r3, r7, r3
    2b88:	781b      	ldrb	r3, [r3, #0]
    2b8a:	005b      	lsls	r3, r3, #1
    2b8c:	b25b      	sxtb	r3, r3
    2b8e:	2110      	movs	r1, #16
    2b90:	400b      	ands	r3, r1
    2b92:	b25b      	sxtb	r3, r3
    2b94:	4313      	orrs	r3, r2
    2b96:	b25a      	sxtb	r2, r3
    2b98:	2319      	movs	r3, #25
    2b9a:	18fb      	adds	r3, r7, r3
    2b9c:	781b      	ldrb	r3, [r3, #0]
    2b9e:	00db      	lsls	r3, r3, #3
    2ba0:	b25b      	sxtb	r3, r3
    2ba2:	2120      	movs	r1, #32
    2ba4:	400b      	ands	r3, r1
    2ba6:	b25b      	sxtb	r3, r3
    2ba8:	4313      	orrs	r3, r2
    2baa:	b25a      	sxtb	r2, r3
    2bac:	2319      	movs	r3, #25
    2bae:	18fb      	adds	r3, r7, r3
    2bb0:	781b      	ldrb	r3, [r3, #0]
    2bb2:	015b      	lsls	r3, r3, #5
    2bb4:	b25b      	sxtb	r3, r3
    2bb6:	2140      	movs	r1, #64	; 0x40
    2bb8:	400b      	ands	r3, r1
    2bba:	b25b      	sxtb	r3, r3
    2bbc:	4313      	orrs	r3, r2
    2bbe:	b25a      	sxtb	r2, r3
    2bc0:	2319      	movs	r3, #25
    2bc2:	18fb      	adds	r3, r7, r3
    2bc4:	781b      	ldrb	r3, [r3, #0]
    2bc6:	01db      	lsls	r3, r3, #7
    2bc8:	b25b      	sxtb	r3, r3
    2bca:	4313      	orrs	r3, r2
    2bcc:	b25b      	sxtb	r3, r3
    2bce:	b2da      	uxtb	r2, r3
    2bd0:	68fb      	ldr	r3, [r7, #12]
    2bd2:	0011      	movs	r1, r2
    2bd4:	0018      	movs	r0, r3
    2bd6:	f7ff fced 	bl	25b4 <u8x8_cad_SendArg>
        u8x8_cad_SendArg(u8x8, SWAP8(y));
    2bda:	2318      	movs	r3, #24
    2bdc:	18fb      	adds	r3, r7, r3
    2bde:	781b      	ldrb	r3, [r3, #0]
    2be0:	09db      	lsrs	r3, r3, #7
    2be2:	b2db      	uxtb	r3, r3
    2be4:	b25a      	sxtb	r2, r3
    2be6:	2318      	movs	r3, #24
    2be8:	18fb      	adds	r3, r7, r3
    2bea:	781b      	ldrb	r3, [r3, #0]
    2bec:	115b      	asrs	r3, r3, #5
    2bee:	b25b      	sxtb	r3, r3
    2bf0:	2102      	movs	r1, #2
    2bf2:	400b      	ands	r3, r1
    2bf4:	b25b      	sxtb	r3, r3
    2bf6:	4313      	orrs	r3, r2
    2bf8:	b25a      	sxtb	r2, r3
    2bfa:	2318      	movs	r3, #24
    2bfc:	18fb      	adds	r3, r7, r3
    2bfe:	781b      	ldrb	r3, [r3, #0]
    2c00:	10db      	asrs	r3, r3, #3
    2c02:	b25b      	sxtb	r3, r3
    2c04:	2104      	movs	r1, #4
    2c06:	400b      	ands	r3, r1
    2c08:	b25b      	sxtb	r3, r3
    2c0a:	4313      	orrs	r3, r2
    2c0c:	b25a      	sxtb	r2, r3
    2c0e:	2318      	movs	r3, #24
    2c10:	18fb      	adds	r3, r7, r3
    2c12:	781b      	ldrb	r3, [r3, #0]
    2c14:	105b      	asrs	r3, r3, #1
    2c16:	b25b      	sxtb	r3, r3
    2c18:	2108      	movs	r1, #8
    2c1a:	400b      	ands	r3, r1
    2c1c:	b25b      	sxtb	r3, r3
    2c1e:	4313      	orrs	r3, r2
    2c20:	b25a      	sxtb	r2, r3
    2c22:	2318      	movs	r3, #24
    2c24:	18fb      	adds	r3, r7, r3
    2c26:	781b      	ldrb	r3, [r3, #0]
    2c28:	005b      	lsls	r3, r3, #1
    2c2a:	b25b      	sxtb	r3, r3
    2c2c:	2110      	movs	r1, #16
    2c2e:	400b      	ands	r3, r1
    2c30:	b25b      	sxtb	r3, r3
    2c32:	4313      	orrs	r3, r2
    2c34:	b25a      	sxtb	r2, r3
    2c36:	2318      	movs	r3, #24
    2c38:	18fb      	adds	r3, r7, r3
    2c3a:	781b      	ldrb	r3, [r3, #0]
    2c3c:	00db      	lsls	r3, r3, #3
    2c3e:	b25b      	sxtb	r3, r3
    2c40:	2120      	movs	r1, #32
    2c42:	400b      	ands	r3, r1
    2c44:	b25b      	sxtb	r3, r3
    2c46:	4313      	orrs	r3, r2
    2c48:	b25a      	sxtb	r2, r3
    2c4a:	2318      	movs	r3, #24
    2c4c:	18fb      	adds	r3, r7, r3
    2c4e:	781b      	ldrb	r3, [r3, #0]
    2c50:	015b      	lsls	r3, r3, #5
    2c52:	b25b      	sxtb	r3, r3
    2c54:	2140      	movs	r1, #64	; 0x40
    2c56:	400b      	ands	r3, r1
    2c58:	b25b      	sxtb	r3, r3
    2c5a:	4313      	orrs	r3, r2
    2c5c:	b25a      	sxtb	r2, r3
    2c5e:	2318      	movs	r3, #24
    2c60:	18fb      	adds	r3, r7, r3
    2c62:	781b      	ldrb	r3, [r3, #0]
    2c64:	01db      	lsls	r3, r3, #7
    2c66:	b25b      	sxtb	r3, r3
    2c68:	4313      	orrs	r3, r2
    2c6a:	b25b      	sxtb	r3, r3
    2c6c:	b2da      	uxtb	r2, r3
    2c6e:	68fb      	ldr	r3, [r7, #12]
    2c70:	0011      	movs	r1, r2
    2c72:	0018      	movs	r0, r3
    2c74:	f7ff fc9e 	bl	25b4 <u8x8_cad_SendArg>
        u8x8_cad_SendArg(u8x8, SWAP8(0x007)); /* return every 8 pixels */
    2c78:	68fb      	ldr	r3, [r7, #12]
    2c7a:	21e0      	movs	r1, #224	; 0xe0
    2c7c:	0018      	movs	r0, r3
    2c7e:	f7ff fc99 	bl	25b4 <u8x8_cad_SendArg>
        do
        {
            ptr = ((u8x8_tile_t *)arg_ptr)->tile_ptr;
    2c82:	687b      	ldr	r3, [r7, #4]
    2c84:	681b      	ldr	r3, [r3, #0]
    2c86:	61fb      	str	r3, [r7, #28]
            tx_cnt = ((u8x8_tile_t *)arg_ptr)->cnt * 8;
    2c88:	687b      	ldr	r3, [r7, #4]
    2c8a:	791b      	ldrb	r3, [r3, #4]
    2c8c:	b29a      	uxth	r2, r3
    2c8e:	231a      	movs	r3, #26
    2c90:	18fb      	adds	r3, r7, r3
    2c92:	00d2      	lsls	r2, r2, #3
    2c94:	801a      	strh	r2, [r3, #0]
            while (tx_cnt > 0)
    2c96:	e059      	b.n	2d4c <u8x8_d_gp1287ai_common+0x40c>
    2c98:	00008a40 	.word	0x00008a40
    2c9c:	00008a38 	.word	0x00008a38
            {
                swapped_byte = SWAP8(*ptr);
    2ca0:	69fb      	ldr	r3, [r7, #28]
    2ca2:	781b      	ldrb	r3, [r3, #0]
    2ca4:	09db      	lsrs	r3, r3, #7
    2ca6:	b2db      	uxtb	r3, r3
    2ca8:	b25a      	sxtb	r2, r3
    2caa:	69fb      	ldr	r3, [r7, #28]
    2cac:	781b      	ldrb	r3, [r3, #0]
    2cae:	115b      	asrs	r3, r3, #5
    2cb0:	b25b      	sxtb	r3, r3
    2cb2:	2102      	movs	r1, #2
    2cb4:	400b      	ands	r3, r1
    2cb6:	b25b      	sxtb	r3, r3
    2cb8:	4313      	orrs	r3, r2
    2cba:	b25a      	sxtb	r2, r3
    2cbc:	69fb      	ldr	r3, [r7, #28]
    2cbe:	781b      	ldrb	r3, [r3, #0]
    2cc0:	10db      	asrs	r3, r3, #3
    2cc2:	b25b      	sxtb	r3, r3
    2cc4:	2104      	movs	r1, #4
    2cc6:	400b      	ands	r3, r1
    2cc8:	b25b      	sxtb	r3, r3
    2cca:	4313      	orrs	r3, r2
    2ccc:	b25a      	sxtb	r2, r3
    2cce:	69fb      	ldr	r3, [r7, #28]
    2cd0:	781b      	ldrb	r3, [r3, #0]
    2cd2:	105b      	asrs	r3, r3, #1
    2cd4:	b25b      	sxtb	r3, r3
    2cd6:	2108      	movs	r1, #8
    2cd8:	400b      	ands	r3, r1
    2cda:	b25b      	sxtb	r3, r3
    2cdc:	4313      	orrs	r3, r2
    2cde:	b25a      	sxtb	r2, r3
    2ce0:	69fb      	ldr	r3, [r7, #28]
    2ce2:	781b      	ldrb	r3, [r3, #0]
    2ce4:	005b      	lsls	r3, r3, #1
    2ce6:	b25b      	sxtb	r3, r3
    2ce8:	2110      	movs	r1, #16
    2cea:	400b      	ands	r3, r1
    2cec:	b25b      	sxtb	r3, r3
    2cee:	4313      	orrs	r3, r2
    2cf0:	b25a      	sxtb	r2, r3
    2cf2:	69fb      	ldr	r3, [r7, #28]
    2cf4:	781b      	ldrb	r3, [r3, #0]
    2cf6:	00db      	lsls	r3, r3, #3
    2cf8:	b25b      	sxtb	r3, r3
    2cfa:	2120      	movs	r1, #32
    2cfc:	400b      	ands	r3, r1
    2cfe:	b25b      	sxtb	r3, r3
    2d00:	4313      	orrs	r3, r2
    2d02:	b25a      	sxtb	r2, r3
    2d04:	69fb      	ldr	r3, [r7, #28]
    2d06:	781b      	ldrb	r3, [r3, #0]
    2d08:	015b      	lsls	r3, r3, #5
    2d0a:	b25b      	sxtb	r3, r3
    2d0c:	2140      	movs	r1, #64	; 0x40
    2d0e:	400b      	ands	r3, r1
    2d10:	b25b      	sxtb	r3, r3
    2d12:	4313      	orrs	r3, r2
    2d14:	b25a      	sxtb	r2, r3
    2d16:	69fb      	ldr	r3, [r7, #28]
    2d18:	781b      	ldrb	r3, [r3, #0]
    2d1a:	01db      	lsls	r3, r3, #7
    2d1c:	b25b      	sxtb	r3, r3
    2d1e:	4313      	orrs	r3, r2
    2d20:	b25b      	sxtb	r3, r3
    2d22:	b2da      	uxtb	r2, r3
    2d24:	2317      	movs	r3, #23
    2d26:	18fb      	adds	r3, r7, r3
    2d28:	701a      	strb	r2, [r3, #0]
                u8x8_cad_SendData(u8x8, 1, &swapped_byte);
    2d2a:	2317      	movs	r3, #23
    2d2c:	18fa      	adds	r2, r7, r3
    2d2e:	68fb      	ldr	r3, [r7, #12]
    2d30:	2101      	movs	r1, #1
    2d32:	0018      	movs	r0, r3
    2d34:	f7ff fc52 	bl	25dc <u8x8_cad_SendData>
                ptr += 1;
    2d38:	69fb      	ldr	r3, [r7, #28]
    2d3a:	3301      	adds	r3, #1
    2d3c:	61fb      	str	r3, [r7, #28]
                tx_cnt -= 1;
    2d3e:	231a      	movs	r3, #26
    2d40:	18fb      	adds	r3, r7, r3
    2d42:	221a      	movs	r2, #26
    2d44:	18ba      	adds	r2, r7, r2
    2d46:	8812      	ldrh	r2, [r2, #0]
    2d48:	3a01      	subs	r2, #1
    2d4a:	801a      	strh	r2, [r3, #0]
            while (tx_cnt > 0)
    2d4c:	231a      	movs	r3, #26
    2d4e:	18fb      	adds	r3, r7, r3
    2d50:	881b      	ldrh	r3, [r3, #0]
    2d52:	2b00      	cmp	r3, #0
    2d54:	d1a4      	bne.n	2ca0 <u8x8_d_gp1287ai_common+0x360>
            }
            arg_int--;
    2d56:	230a      	movs	r3, #10
    2d58:	18fb      	adds	r3, r7, r3
    2d5a:	781a      	ldrb	r2, [r3, #0]
    2d5c:	230a      	movs	r3, #10
    2d5e:	18fb      	adds	r3, r7, r3
    2d60:	3a01      	subs	r2, #1
    2d62:	701a      	strb	r2, [r3, #0]
        } while (arg_int > 0);
    2d64:	230a      	movs	r3, #10
    2d66:	18fb      	adds	r3, r7, r3
    2d68:	781b      	ldrb	r3, [r3, #0]
    2d6a:	2b00      	cmp	r3, #0
    2d6c:	d189      	bne.n	2c82 <u8x8_d_gp1287ai_common+0x342>

        u8x8_cad_EndTransfer(u8x8);
    2d6e:	68fb      	ldr	r3, [r7, #12]
    2d70:	0018      	movs	r0, r3
    2d72:	f7ff fc5b 	bl	262c <u8x8_cad_EndTransfer>
        break;
    2d76:	e001      	b.n	2d7c <u8x8_d_gp1287ai_common+0x43c>
    default:
        return 0;
    2d78:	2300      	movs	r3, #0
    2d7a:	e000      	b.n	2d7e <u8x8_d_gp1287ai_common+0x43e>
    }
    return 1;
    2d7c:	2301      	movs	r3, #1
}
    2d7e:	0018      	movs	r0, r3
    2d80:	46bd      	mov	sp, r7
    2d82:	b008      	add	sp, #32
    2d84:	bd80      	pop	{r7, pc}
    2d86:	46c0      	nop			; (mov r8, r8)

00002d88 <u8x8_d_gp1287ai_256x50>:
uint8_t u8x8_d_gp1287ai_256x50(u8x8_t *u8x8, uint8_t msg, uint8_t arg_int, void *arg_ptr)
{
    2d88:	b590      	push	{r4, r7, lr}
    2d8a:	b085      	sub	sp, #20
    2d8c:	af00      	add	r7, sp, #0
    2d8e:	60f8      	str	r0, [r7, #12]
    2d90:	0008      	movs	r0, r1
    2d92:	0011      	movs	r1, r2
    2d94:	607b      	str	r3, [r7, #4]
    2d96:	230b      	movs	r3, #11
    2d98:	18fb      	adds	r3, r7, r3
    2d9a:	1c02      	adds	r2, r0, #0
    2d9c:	701a      	strb	r2, [r3, #0]
    2d9e:	230a      	movs	r3, #10
    2da0:	18fb      	adds	r3, r7, r3
    2da2:	1c0a      	adds	r2, r1, #0
    2da4:	701a      	strb	r2, [r3, #0]
    switch (msg)
    2da6:	230b      	movs	r3, #11
    2da8:	18fb      	adds	r3, r7, r3
    2daa:	781b      	ldrb	r3, [r3, #0]
    2dac:	2b09      	cmp	r3, #9
    2dae:	d002      	beq.n	2db6 <u8x8_d_gp1287ai_256x50+0x2e>
    2db0:	2b0a      	cmp	r3, #10
    2db2:	d007      	beq.n	2dc4 <u8x8_d_gp1287ai_256x50+0x3c>
    2db4:	e011      	b.n	2dda <u8x8_d_gp1287ai_256x50+0x52>
    {
    case U8X8_MSG_DISPLAY_SETUP_MEMORY:
        u8x8_d_helper_display_setup_memory(u8x8, &u8x8_gp1287ai_display_info);
    2db6:	4a12      	ldr	r2, [pc, #72]	; (2e00 <u8x8_d_gp1287ai_256x50+0x78>)
    2db8:	68fb      	ldr	r3, [r7, #12]
    2dba:	0011      	movs	r1, r2
    2dbc:	0018      	movs	r0, r3
    2dbe:	f7ff fce9 	bl	2794 <u8x8_d_helper_display_setup_memory>
        break;
    2dc2:	e017      	b.n	2df4 <u8x8_d_gp1287ai_256x50+0x6c>
    case U8X8_MSG_DISPLAY_INIT:
        u8x8_d_helper_display_init(u8x8);
    2dc4:	68fb      	ldr	r3, [r7, #12]
    2dc6:	0018      	movs	r0, r3
    2dc8:	f7ff fcf6 	bl	27b8 <u8x8_d_helper_display_init>
        u8x8_cad_SendSequence(u8x8, u8x8_d_gp1287ai_init_seq);
    2dcc:	4a0d      	ldr	r2, [pc, #52]	; (2e04 <u8x8_d_gp1287ai_256x50+0x7c>)
    2dce:	68fb      	ldr	r3, [r7, #12]
    2dd0:	0011      	movs	r1, r2
    2dd2:	0018      	movs	r0, r3
    2dd4:	f7ff fc3a 	bl	264c <u8x8_cad_SendSequence>
        break;
    2dd8:	e00c      	b.n	2df4 <u8x8_d_gp1287ai_256x50+0x6c>
    default:
        return u8x8_d_gp1287ai_common(u8x8, msg, arg_int, arg_ptr);
    2dda:	687c      	ldr	r4, [r7, #4]
    2ddc:	230a      	movs	r3, #10
    2dde:	18fb      	adds	r3, r7, r3
    2de0:	781a      	ldrb	r2, [r3, #0]
    2de2:	230b      	movs	r3, #11
    2de4:	18fb      	adds	r3, r7, r3
    2de6:	7819      	ldrb	r1, [r3, #0]
    2de8:	68f8      	ldr	r0, [r7, #12]
    2dea:	0023      	movs	r3, r4
    2dec:	f7ff fda8 	bl	2940 <u8x8_d_gp1287ai_common>
    2df0:	0003      	movs	r3, r0
    2df2:	e000      	b.n	2df6 <u8x8_d_gp1287ai_256x50+0x6e>
    }
    return 1;
    2df4:	2301      	movs	r3, #1
}
    2df6:	0018      	movs	r0, r3
    2df8:	46bd      	mov	sp, r7
    2dfa:	b005      	add	sp, #20
    2dfc:	bd90      	pop	{r4, r7, pc}
    2dfe:	46c0      	nop			; (mov r8, r8)
    2e00:	000089b8 	.word	0x000089b8
    2e04:	000089d0 	.word	0x000089d0

00002e08 <u8x8_gpio_call>:

#include "u8x8.h"


void u8x8_gpio_call(u8x8_t *u8x8, uint8_t msg, uint8_t arg)
{
    2e08:	b590      	push	{r4, r7, lr}
    2e0a:	b083      	sub	sp, #12
    2e0c:	af00      	add	r7, sp, #0
    2e0e:	6078      	str	r0, [r7, #4]
    2e10:	0008      	movs	r0, r1
    2e12:	0011      	movs	r1, r2
    2e14:	1cfb      	adds	r3, r7, #3
    2e16:	1c02      	adds	r2, r0, #0
    2e18:	701a      	strb	r2, [r3, #0]
    2e1a:	1cbb      	adds	r3, r7, #2
    2e1c:	1c0a      	adds	r2, r1, #0
    2e1e:	701a      	strb	r2, [r3, #0]
  u8x8->gpio_and_delay_cb(u8x8, msg, arg, NULL);
    2e20:	687b      	ldr	r3, [r7, #4]
    2e22:	695c      	ldr	r4, [r3, #20]
    2e24:	1cbb      	adds	r3, r7, #2
    2e26:	781a      	ldrb	r2, [r3, #0]
    2e28:	1cfb      	adds	r3, r7, #3
    2e2a:	7819      	ldrb	r1, [r3, #0]
    2e2c:	6878      	ldr	r0, [r7, #4]
    2e2e:	2300      	movs	r3, #0
    2e30:	47a0      	blx	r4
}
    2e32:	46c0      	nop			; (mov r8, r8)
    2e34:	46bd      	mov	sp, r7
    2e36:	b003      	add	sp, #12
    2e38:	bd90      	pop	{r4, r7, pc}

00002e3a <u8x8_dummy_cb>:

#include "u8x8.h"

/* universal dummy callback, which will be default for all callbacks */
uint8_t u8x8_dummy_cb(U8X8_UNUSED u8x8_t *u8x8, U8X8_UNUSED uint8_t msg, U8X8_UNUSED uint8_t arg_int, U8X8_UNUSED void *arg_ptr)
{
    2e3a:	b580      	push	{r7, lr}
    2e3c:	b084      	sub	sp, #16
    2e3e:	af00      	add	r7, sp, #0
    2e40:	60f8      	str	r0, [r7, #12]
    2e42:	0008      	movs	r0, r1
    2e44:	0011      	movs	r1, r2
    2e46:	607b      	str	r3, [r7, #4]
    2e48:	230b      	movs	r3, #11
    2e4a:	18fb      	adds	r3, r7, r3
    2e4c:	1c02      	adds	r2, r0, #0
    2e4e:	701a      	strb	r2, [r3, #0]
    2e50:	230a      	movs	r3, #10
    2e52:	18fb      	adds	r3, r7, r3
    2e54:	1c0a      	adds	r2, r1, #0
    2e56:	701a      	strb	r2, [r3, #0]
  /* the dummy callback will not handle any message and will fail for all messages */
  return 0;
    2e58:	2300      	movs	r3, #0
}
    2e5a:	0018      	movs	r0, r3
    2e5c:	46bd      	mov	sp, r7
    2e5e:	b004      	add	sp, #16
    2e60:	bd80      	pop	{r7, pc}
	...

00002e64 <u8x8_SetupDefaults>:
    Setup u8x8
  Args:
    u8x8	An empty u8x8 structure
*/
void u8x8_SetupDefaults(u8x8_t *u8x8)
{
    2e64:	b580      	push	{r7, lr}
    2e66:	b082      	sub	sp, #8
    2e68:	af00      	add	r7, sp, #0
    2e6a:	6078      	str	r0, [r7, #4]
    u8x8->display_info = NULL;
    2e6c:	687b      	ldr	r3, [r7, #4]
    2e6e:	2200      	movs	r2, #0
    2e70:	601a      	str	r2, [r3, #0]
    u8x8->display_cb = u8x8_dummy_cb;
    2e72:	687b      	ldr	r3, [r7, #4]
    2e74:	4a10      	ldr	r2, [pc, #64]	; (2eb8 <u8x8_SetupDefaults+0x54>)
    2e76:	609a      	str	r2, [r3, #8]
    u8x8->cad_cb = u8x8_dummy_cb;
    2e78:	687b      	ldr	r3, [r7, #4]
    2e7a:	4a0f      	ldr	r2, [pc, #60]	; (2eb8 <u8x8_SetupDefaults+0x54>)
    2e7c:	60da      	str	r2, [r3, #12]
    u8x8->byte_cb = u8x8_dummy_cb;
    2e7e:	687b      	ldr	r3, [r7, #4]
    2e80:	4a0d      	ldr	r2, [pc, #52]	; (2eb8 <u8x8_SetupDefaults+0x54>)
    2e82:	611a      	str	r2, [r3, #16]
    u8x8->gpio_and_delay_cb = u8x8_dummy_cb;
    2e84:	687b      	ldr	r3, [r7, #4]
    2e86:	4a0c      	ldr	r2, [pc, #48]	; (2eb8 <u8x8_SetupDefaults+0x54>)
    2e88:	615a      	str	r2, [r3, #20]
    u8x8->is_font_inverse_mode = 0;
    2e8a:	687b      	ldr	r3, [r7, #4]
    2e8c:	2223      	movs	r2, #35	; 0x23
    2e8e:	2100      	movs	r1, #0
    2e90:	5499      	strb	r1, [r3, r2]
    //u8x8->device_address = 0;
    u8x8->utf8_state = 0;		/* also reset by u8x8_utf8_init */
    2e92:	687b      	ldr	r3, [r7, #4]
    2e94:	2226      	movs	r2, #38	; 0x26
    2e96:	2100      	movs	r1, #0
    2e98:	5499      	strb	r1, [r3, r2]
    u8x8->bus_clock = 0;		/* issue 769 */
    2e9a:	687b      	ldr	r3, [r7, #4]
    2e9c:	2200      	movs	r2, #0
    2e9e:	619a      	str	r2, [r3, #24]
    u8x8->i2c_address = 255;
    2ea0:	687b      	ldr	r3, [r7, #4]
    2ea2:	2224      	movs	r2, #36	; 0x24
    2ea4:	21ff      	movs	r1, #255	; 0xff
    2ea6:	5499      	strb	r1, [r3, r2]
    u8x8->debounce_default_pin_state = 255;	/* assume all low active buttons */
    2ea8:	687b      	ldr	r3, [r7, #4]
    2eaa:	2228      	movs	r2, #40	; 0x28
    2eac:	21ff      	movs	r1, #255	; 0xff
    2eae:	5499      	strb	r1, [r3, r2]
    uint8_t i;
    for( i = 0; i < U8X8_PIN_CNT; i++ )
      u8x8->pins[i] = U8X8_PIN_NONE;
  }
#endif
}
    2eb0:	46c0      	nop			; (mov r8, r8)
    2eb2:	46bd      	mov	sp, r7
    2eb4:	b002      	add	sp, #8
    2eb6:	bd80      	pop	{r7, pc}
    2eb8:	00002e3b 	.word	0x00002e3b

00002ebc <u8x8_Setup>:
    byte_cb			Display controller/communication specific callback funtion
    gpio_and_delay_cb	Environment specific callback function

*/
void u8x8_Setup(u8x8_t *u8x8, u8x8_msg_cb display_cb, u8x8_msg_cb cad_cb, u8x8_msg_cb byte_cb, u8x8_msg_cb gpio_and_delay_cb)
{
    2ebc:	b580      	push	{r7, lr}
    2ebe:	b084      	sub	sp, #16
    2ec0:	af00      	add	r7, sp, #0
    2ec2:	60f8      	str	r0, [r7, #12]
    2ec4:	60b9      	str	r1, [r7, #8]
    2ec6:	607a      	str	r2, [r7, #4]
    2ec8:	603b      	str	r3, [r7, #0]
  /* setup defaults and reset pins to U8X8_PIN_NONE */
  u8x8_SetupDefaults(u8x8);
    2eca:	68fb      	ldr	r3, [r7, #12]
    2ecc:	0018      	movs	r0, r3
    2ece:	f7ff ffc9 	bl	2e64 <u8x8_SetupDefaults>

  /* setup specific callbacks */
  u8x8->display_cb = display_cb;
    2ed2:	68fb      	ldr	r3, [r7, #12]
    2ed4:	68ba      	ldr	r2, [r7, #8]
    2ed6:	609a      	str	r2, [r3, #8]
  u8x8->cad_cb = cad_cb;
    2ed8:	68fb      	ldr	r3, [r7, #12]
    2eda:	687a      	ldr	r2, [r7, #4]
    2edc:	60da      	str	r2, [r3, #12]
  u8x8->byte_cb = byte_cb;
    2ede:	68fb      	ldr	r3, [r7, #12]
    2ee0:	683a      	ldr	r2, [r7, #0]
    2ee2:	611a      	str	r2, [r3, #16]
  u8x8->gpio_and_delay_cb = gpio_and_delay_cb;
    2ee4:	68fb      	ldr	r3, [r7, #12]
    2ee6:	69ba      	ldr	r2, [r7, #24]
    2ee8:	615a      	str	r2, [r3, #20]

  /* setup display info */
  u8x8_SetupMemory(u8x8);
    2eea:	68fb      	ldr	r3, [r7, #12]
    2eec:	0018      	movs	r0, r3
    2eee:	f7ff fcd3 	bl	2898 <u8x8_SetupMemory>
}
    2ef2:	46c0      	nop			; (mov r8, r8)
    2ef4:	46bd      	mov	sp, r7
    2ef6:	b004      	add	sp, #16
    2ef8:	bd80      	pop	{r7, pc}
	...

00002efc <Reset_Handler>:
/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
{
    2efc:	b580      	push	{r7, lr}
    2efe:	b082      	sub	sp, #8
    2f00:	af00      	add	r7, sp, #0
        uint32_t *pSrc, *pDest;

        /* Initialize the relocate segment */
        pSrc = &_etext;
    2f02:	4b19      	ldr	r3, [pc, #100]	; (2f68 <Reset_Handler+0x6c>)
    2f04:	607b      	str	r3, [r7, #4]
        pDest = &_srelocate;
    2f06:	4b19      	ldr	r3, [pc, #100]	; (2f6c <Reset_Handler+0x70>)
    2f08:	603b      	str	r3, [r7, #0]

        if (pSrc != pDest) {
    2f0a:	687a      	ldr	r2, [r7, #4]
    2f0c:	683b      	ldr	r3, [r7, #0]
    2f0e:	429a      	cmp	r2, r3
    2f10:	d00c      	beq.n	2f2c <Reset_Handler+0x30>
                for (; pDest < &_erelocate;) {
    2f12:	e007      	b.n	2f24 <Reset_Handler+0x28>
                        *pDest++ = *pSrc++;
    2f14:	683b      	ldr	r3, [r7, #0]
    2f16:	1d1a      	adds	r2, r3, #4
    2f18:	603a      	str	r2, [r7, #0]
    2f1a:	687a      	ldr	r2, [r7, #4]
    2f1c:	1d11      	adds	r1, r2, #4
    2f1e:	6079      	str	r1, [r7, #4]
    2f20:	6812      	ldr	r2, [r2, #0]
    2f22:	601a      	str	r2, [r3, #0]
                for (; pDest < &_erelocate;) {
    2f24:	683a      	ldr	r2, [r7, #0]
    2f26:	4b12      	ldr	r3, [pc, #72]	; (2f70 <Reset_Handler+0x74>)
    2f28:	429a      	cmp	r2, r3
    2f2a:	d3f3      	bcc.n	2f14 <Reset_Handler+0x18>
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
    2f2c:	4b11      	ldr	r3, [pc, #68]	; (2f74 <Reset_Handler+0x78>)
    2f2e:	603b      	str	r3, [r7, #0]
    2f30:	e004      	b.n	2f3c <Reset_Handler+0x40>
                *pDest++ = 0;
    2f32:	683b      	ldr	r3, [r7, #0]
    2f34:	1d1a      	adds	r2, r3, #4
    2f36:	603a      	str	r2, [r7, #0]
    2f38:	2200      	movs	r2, #0
    2f3a:	601a      	str	r2, [r3, #0]
        for (pDest = &_szero; pDest < &_ezero;) {
    2f3c:	683a      	ldr	r2, [r7, #0]
    2f3e:	4b0e      	ldr	r3, [pc, #56]	; (2f78 <Reset_Handler+0x7c>)
    2f40:	429a      	cmp	r2, r3
    2f42:	d3f6      	bcc.n	2f32 <Reset_Handler+0x36>
        }

        /* Set the vector table base address */
        pSrc = (uint32_t *) & _sfixed;
    2f44:	4b0d      	ldr	r3, [pc, #52]	; (2f7c <Reset_Handler+0x80>)
    2f46:	607b      	str	r3, [r7, #4]
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
    2f48:	4b0d      	ldr	r3, [pc, #52]	; (2f80 <Reset_Handler+0x84>)
    2f4a:	687a      	ldr	r2, [r7, #4]
    2f4c:	21ff      	movs	r1, #255	; 0xff
    2f4e:	438a      	bics	r2, r1
    2f50:	609a      	str	r2, [r3, #8]

        /* Overwriting the default value of the NVMCTRL.CTRLB.MANW bit (errata reference 13134) */
        NVMCTRL->CTRLB.bit.MANW = 1;
    2f52:	4a0c      	ldr	r2, [pc, #48]	; (2f84 <Reset_Handler+0x88>)
    2f54:	6853      	ldr	r3, [r2, #4]
    2f56:	2180      	movs	r1, #128	; 0x80
    2f58:	430b      	orrs	r3, r1
    2f5a:	6053      	str	r3, [r2, #4]

        /* Initialize the C library */
        __libc_init_array();
    2f5c:	f004 fe84 	bl	7c68 <__libc_init_array>

        /* Branch to main function */
        main();
    2f60:	f004 fbe4 	bl	772c <main>

        /* Infinite loop */
        while (1);
    2f64:	e7fe      	b.n	2f64 <Reset_Handler+0x68>
    2f66:	46c0      	nop			; (mov r8, r8)
    2f68:	00008d38 	.word	0x00008d38
    2f6c:	20000000 	.word	0x20000000
    2f70:	20000090 	.word	0x20000090
    2f74:	20000090 	.word	0x20000090
    2f78:	20000938 	.word	0x20000938
    2f7c:	00000000 	.word	0x00000000
    2f80:	e000ed00 	.word	0xe000ed00
    2f84:	41004000 	.word	0x41004000

00002f88 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
    2f88:	b580      	push	{r7, lr}
    2f8a:	af00      	add	r7, sp, #0
        while (1) {
    2f8c:	e7fe      	b.n	2f8c <Dummy_Handler+0x4>

00002f8e <hri_gclk_write_CLKCTRL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_gclk_write_CLKCTRL_reg(const void *const hw, hri_gclk_clkctrl_reg_t data)
{
    2f8e:	b580      	push	{r7, lr}
    2f90:	b082      	sub	sp, #8
    2f92:	af00      	add	r7, sp, #0
    2f94:	6078      	str	r0, [r7, #4]
    2f96:	000a      	movs	r2, r1
    2f98:	1cbb      	adds	r3, r7, #2
    2f9a:	801a      	strh	r2, [r3, #0]
	GCLK_CRITICAL_SECTION_ENTER();
	((Gclk *)hw)->CLKCTRL.reg = data;
    2f9c:	687b      	ldr	r3, [r7, #4]
    2f9e:	1cba      	adds	r2, r7, #2
    2fa0:	8812      	ldrh	r2, [r2, #0]
    2fa2:	805a      	strh	r2, [r3, #2]
	GCLK_CRITICAL_SECTION_LEAVE();
}
    2fa4:	46c0      	nop			; (mov r8, r8)
    2fa6:	46bd      	mov	sp, r7
    2fa8:	b002      	add	sp, #8
    2faa:	bd80      	pop	{r7, pc}

00002fac <hri_port_set_DIR_reg>:
{
	((Port *)hw)->Group[submodule_index].DIRTGL.reg = PORT_DIR_DIR(mask);
}

static inline void hri_port_set_DIR_reg(const void *const hw, uint8_t submodule_index, hri_port_dir_reg_t mask)
{
    2fac:	b580      	push	{r7, lr}
    2fae:	b084      	sub	sp, #16
    2fb0:	af00      	add	r7, sp, #0
    2fb2:	60f8      	str	r0, [r7, #12]
    2fb4:	607a      	str	r2, [r7, #4]
    2fb6:	230b      	movs	r3, #11
    2fb8:	18fb      	adds	r3, r7, r3
    2fba:	1c0a      	adds	r2, r1, #0
    2fbc:	701a      	strb	r2, [r3, #0]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    2fbe:	230b      	movs	r3, #11
    2fc0:	18fb      	adds	r3, r7, r3
    2fc2:	781b      	ldrb	r3, [r3, #0]
    2fc4:	68fa      	ldr	r2, [r7, #12]
    2fc6:	01db      	lsls	r3, r3, #7
    2fc8:	18d3      	adds	r3, r2, r3
    2fca:	3308      	adds	r3, #8
    2fcc:	687a      	ldr	r2, [r7, #4]
    2fce:	601a      	str	r2, [r3, #0]
}
    2fd0:	46c0      	nop			; (mov r8, r8)
    2fd2:	46bd      	mov	sp, r7
    2fd4:	b004      	add	sp, #16
    2fd6:	bd80      	pop	{r7, pc}

00002fd8 <hri_port_clear_DIR_reg>:
	((Port *)hw)->Group[submodule_index].DIRSET.reg = data;
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = ~data;
}

static inline void hri_port_clear_DIR_reg(const void *const hw, uint8_t submodule_index, hri_port_dir_reg_t mask)
{
    2fd8:	b580      	push	{r7, lr}
    2fda:	b084      	sub	sp, #16
    2fdc:	af00      	add	r7, sp, #0
    2fde:	60f8      	str	r0, [r7, #12]
    2fe0:	607a      	str	r2, [r7, #4]
    2fe2:	230b      	movs	r3, #11
    2fe4:	18fb      	adds	r3, r7, r3
    2fe6:	1c0a      	adds	r2, r1, #0
    2fe8:	701a      	strb	r2, [r3, #0]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    2fea:	230b      	movs	r3, #11
    2fec:	18fb      	adds	r3, r7, r3
    2fee:	781b      	ldrb	r3, [r3, #0]
    2ff0:	68fa      	ldr	r2, [r7, #12]
    2ff2:	01db      	lsls	r3, r3, #7
    2ff4:	18d3      	adds	r3, r2, r3
    2ff6:	3304      	adds	r3, #4
    2ff8:	687a      	ldr	r2, [r7, #4]
    2ffa:	601a      	str	r2, [r3, #0]
}
    2ffc:	46c0      	nop			; (mov r8, r8)
    2ffe:	46bd      	mov	sp, r7
    3000:	b004      	add	sp, #16
    3002:	bd80      	pop	{r7, pc}

00003004 <hri_port_set_OUT_reg>:
{
	((Port *)hw)->Group[submodule_index].OUTTGL.reg = PORT_OUT_OUT(mask);
}

static inline void hri_port_set_OUT_reg(const void *const hw, uint8_t submodule_index, hri_port_out_reg_t mask)
{
    3004:	b580      	push	{r7, lr}
    3006:	b084      	sub	sp, #16
    3008:	af00      	add	r7, sp, #0
    300a:	60f8      	str	r0, [r7, #12]
    300c:	607a      	str	r2, [r7, #4]
    300e:	230b      	movs	r3, #11
    3010:	18fb      	adds	r3, r7, r3
    3012:	1c0a      	adds	r2, r1, #0
    3014:	701a      	strb	r2, [r3, #0]
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    3016:	230b      	movs	r3, #11
    3018:	18fb      	adds	r3, r7, r3
    301a:	781b      	ldrb	r3, [r3, #0]
    301c:	68fa      	ldr	r2, [r7, #12]
    301e:	01db      	lsls	r3, r3, #7
    3020:	18d3      	adds	r3, r2, r3
    3022:	3318      	adds	r3, #24
    3024:	687a      	ldr	r2, [r7, #4]
    3026:	601a      	str	r2, [r3, #0]
}
    3028:	46c0      	nop			; (mov r8, r8)
    302a:	46bd      	mov	sp, r7
    302c:	b004      	add	sp, #16
    302e:	bd80      	pop	{r7, pc}

00003030 <hri_port_clear_OUT_reg>:
	((Port *)hw)->Group[submodule_index].OUTSET.reg = data;
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = ~data;
}

static inline void hri_port_clear_OUT_reg(const void *const hw, uint8_t submodule_index, hri_port_out_reg_t mask)
{
    3030:	b580      	push	{r7, lr}
    3032:	b084      	sub	sp, #16
    3034:	af00      	add	r7, sp, #0
    3036:	60f8      	str	r0, [r7, #12]
    3038:	607a      	str	r2, [r7, #4]
    303a:	230b      	movs	r3, #11
    303c:	18fb      	adds	r3, r7, r3
    303e:	1c0a      	adds	r2, r1, #0
    3040:	701a      	strb	r2, [r3, #0]
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    3042:	230b      	movs	r3, #11
    3044:	18fb      	adds	r3, r7, r3
    3046:	781b      	ldrb	r3, [r3, #0]
    3048:	68fa      	ldr	r2, [r7, #12]
    304a:	01db      	lsls	r3, r3, #7
    304c:	18d3      	adds	r3, r2, r3
    304e:	3314      	adds	r3, #20
    3050:	687a      	ldr	r2, [r7, #4]
    3052:	601a      	str	r2, [r3, #0]
}
    3054:	46c0      	nop			; (mov r8, r8)
    3056:	46bd      	mov	sp, r7
    3058:	b004      	add	sp, #16
    305a:	bd80      	pop	{r7, pc}

0000305c <hri_port_write_PMUX_PMUXE_bf>:
	return tmp;
}

static inline void hri_port_write_PMUX_PMUXE_bf(const void *const hw, uint8_t submodule_index, uint8_t index,
                                                hri_port_pmux_reg_t data)
{
    305c:	b590      	push	{r4, r7, lr}
    305e:	b085      	sub	sp, #20
    3060:	af00      	add	r7, sp, #0
    3062:	6078      	str	r0, [r7, #4]
    3064:	000c      	movs	r4, r1
    3066:	0010      	movs	r0, r2
    3068:	0019      	movs	r1, r3
    306a:	1cfb      	adds	r3, r7, #3
    306c:	1c22      	adds	r2, r4, #0
    306e:	701a      	strb	r2, [r3, #0]
    3070:	1cbb      	adds	r3, r7, #2
    3072:	1c02      	adds	r2, r0, #0
    3074:	701a      	strb	r2, [r3, #0]
    3076:	1c7b      	adds	r3, r7, #1
    3078:	1c0a      	adds	r2, r1, #0
    307a:	701a      	strb	r2, [r3, #0]
	uint8_t tmp;
	PORT_CRITICAL_SECTION_ENTER();
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
    307c:	1cfb      	adds	r3, r7, #3
    307e:	7819      	ldrb	r1, [r3, #0]
    3080:	1cbb      	adds	r3, r7, #2
    3082:	781a      	ldrb	r2, [r3, #0]
    3084:	230f      	movs	r3, #15
    3086:	18fb      	adds	r3, r7, r3
    3088:	6878      	ldr	r0, [r7, #4]
    308a:	2430      	movs	r4, #48	; 0x30
    308c:	01c9      	lsls	r1, r1, #7
    308e:	1841      	adds	r1, r0, r1
    3090:	188a      	adds	r2, r1, r2
    3092:	1912      	adds	r2, r2, r4
    3094:	7812      	ldrb	r2, [r2, #0]
    3096:	701a      	strb	r2, [r3, #0]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
    3098:	230f      	movs	r3, #15
    309a:	18fb      	adds	r3, r7, r3
    309c:	220f      	movs	r2, #15
    309e:	18ba      	adds	r2, r7, r2
    30a0:	7812      	ldrb	r2, [r2, #0]
    30a2:	210f      	movs	r1, #15
    30a4:	438a      	bics	r2, r1
    30a6:	701a      	strb	r2, [r3, #0]
	tmp |= PORT_PMUX_PMUXE(data);
    30a8:	1c7b      	adds	r3, r7, #1
    30aa:	781b      	ldrb	r3, [r3, #0]
    30ac:	220f      	movs	r2, #15
    30ae:	4013      	ands	r3, r2
    30b0:	b2d9      	uxtb	r1, r3
    30b2:	230f      	movs	r3, #15
    30b4:	18fb      	adds	r3, r7, r3
    30b6:	220f      	movs	r2, #15
    30b8:	18ba      	adds	r2, r7, r2
    30ba:	7812      	ldrb	r2, [r2, #0]
    30bc:	430a      	orrs	r2, r1
    30be:	701a      	strb	r2, [r3, #0]
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
    30c0:	1cfb      	adds	r3, r7, #3
    30c2:	781a      	ldrb	r2, [r3, #0]
    30c4:	1cbb      	adds	r3, r7, #2
    30c6:	781b      	ldrb	r3, [r3, #0]
    30c8:	6879      	ldr	r1, [r7, #4]
    30ca:	2030      	movs	r0, #48	; 0x30
    30cc:	01d2      	lsls	r2, r2, #7
    30ce:	188a      	adds	r2, r1, r2
    30d0:	18d3      	adds	r3, r2, r3
    30d2:	181b      	adds	r3, r3, r0
    30d4:	220f      	movs	r2, #15
    30d6:	18ba      	adds	r2, r7, r2
    30d8:	7812      	ldrb	r2, [r2, #0]
    30da:	701a      	strb	r2, [r3, #0]
	PORT_CRITICAL_SECTION_LEAVE();
}
    30dc:	46c0      	nop			; (mov r8, r8)
    30de:	46bd      	mov	sp, r7
    30e0:	b005      	add	sp, #20
    30e2:	bd90      	pop	{r4, r7, pc}

000030e4 <hri_port_write_PMUX_PMUXO_bf>:
	return tmp;
}

static inline void hri_port_write_PMUX_PMUXO_bf(const void *const hw, uint8_t submodule_index, uint8_t index,
                                                hri_port_pmux_reg_t data)
{
    30e4:	b590      	push	{r4, r7, lr}
    30e6:	b085      	sub	sp, #20
    30e8:	af00      	add	r7, sp, #0
    30ea:	6078      	str	r0, [r7, #4]
    30ec:	000c      	movs	r4, r1
    30ee:	0010      	movs	r0, r2
    30f0:	0019      	movs	r1, r3
    30f2:	1cfb      	adds	r3, r7, #3
    30f4:	1c22      	adds	r2, r4, #0
    30f6:	701a      	strb	r2, [r3, #0]
    30f8:	1cbb      	adds	r3, r7, #2
    30fa:	1c02      	adds	r2, r0, #0
    30fc:	701a      	strb	r2, [r3, #0]
    30fe:	1c7b      	adds	r3, r7, #1
    3100:	1c0a      	adds	r2, r1, #0
    3102:	701a      	strb	r2, [r3, #0]
	uint8_t tmp;
	PORT_CRITICAL_SECTION_ENTER();
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
    3104:	1cfb      	adds	r3, r7, #3
    3106:	7819      	ldrb	r1, [r3, #0]
    3108:	1cbb      	adds	r3, r7, #2
    310a:	781a      	ldrb	r2, [r3, #0]
    310c:	230f      	movs	r3, #15
    310e:	18fb      	adds	r3, r7, r3
    3110:	6878      	ldr	r0, [r7, #4]
    3112:	2430      	movs	r4, #48	; 0x30
    3114:	01c9      	lsls	r1, r1, #7
    3116:	1841      	adds	r1, r0, r1
    3118:	188a      	adds	r2, r1, r2
    311a:	1912      	adds	r2, r2, r4
    311c:	7812      	ldrb	r2, [r2, #0]
    311e:	701a      	strb	r2, [r3, #0]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
    3120:	230f      	movs	r3, #15
    3122:	18fb      	adds	r3, r7, r3
    3124:	220f      	movs	r2, #15
    3126:	18ba      	adds	r2, r7, r2
    3128:	7812      	ldrb	r2, [r2, #0]
    312a:	210f      	movs	r1, #15
    312c:	400a      	ands	r2, r1
    312e:	701a      	strb	r2, [r3, #0]
	tmp |= PORT_PMUX_PMUXO(data);
    3130:	1c7b      	adds	r3, r7, #1
    3132:	781b      	ldrb	r3, [r3, #0]
    3134:	011b      	lsls	r3, r3, #4
    3136:	b2d9      	uxtb	r1, r3
    3138:	230f      	movs	r3, #15
    313a:	18fb      	adds	r3, r7, r3
    313c:	220f      	movs	r2, #15
    313e:	18ba      	adds	r2, r7, r2
    3140:	7812      	ldrb	r2, [r2, #0]
    3142:	430a      	orrs	r2, r1
    3144:	701a      	strb	r2, [r3, #0]
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
    3146:	1cfb      	adds	r3, r7, #3
    3148:	781a      	ldrb	r2, [r3, #0]
    314a:	1cbb      	adds	r3, r7, #2
    314c:	781b      	ldrb	r3, [r3, #0]
    314e:	6879      	ldr	r1, [r7, #4]
    3150:	2030      	movs	r0, #48	; 0x30
    3152:	01d2      	lsls	r2, r2, #7
    3154:	188a      	adds	r2, r1, r2
    3156:	18d3      	adds	r3, r2, r3
    3158:	181b      	adds	r3, r3, r0
    315a:	220f      	movs	r2, #15
    315c:	18ba      	adds	r2, r7, r2
    315e:	7812      	ldrb	r2, [r2, #0]
    3160:	701a      	strb	r2, [r3, #0]
	PORT_CRITICAL_SECTION_LEAVE();
}
    3162:	46c0      	nop			; (mov r8, r8)
    3164:	46bd      	mov	sp, r7
    3166:	b005      	add	sp, #20
    3168:	bd90      	pop	{r4, r7, pc}

0000316a <hri_port_write_PINCFG_PMUXEN_bit>:
	return (bool)tmp;
}

static inline void hri_port_write_PINCFG_PMUXEN_bit(const void *const hw, uint8_t submodule_index, uint8_t index,
                                                    bool value)
{
    316a:	b590      	push	{r4, r7, lr}
    316c:	b085      	sub	sp, #20
    316e:	af00      	add	r7, sp, #0
    3170:	6078      	str	r0, [r7, #4]
    3172:	000c      	movs	r4, r1
    3174:	0010      	movs	r0, r2
    3176:	0019      	movs	r1, r3
    3178:	1cfb      	adds	r3, r7, #3
    317a:	1c22      	adds	r2, r4, #0
    317c:	701a      	strb	r2, [r3, #0]
    317e:	1cbb      	adds	r3, r7, #2
    3180:	1c02      	adds	r2, r0, #0
    3182:	701a      	strb	r2, [r3, #0]
    3184:	1c7b      	adds	r3, r7, #1
    3186:	1c0a      	adds	r2, r1, #0
    3188:	701a      	strb	r2, [r3, #0]
	uint8_t tmp;
	PORT_CRITICAL_SECTION_ENTER();
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    318a:	1cfb      	adds	r3, r7, #3
    318c:	7819      	ldrb	r1, [r3, #0]
    318e:	1cbb      	adds	r3, r7, #2
    3190:	781a      	ldrb	r2, [r3, #0]
    3192:	230f      	movs	r3, #15
    3194:	18fb      	adds	r3, r7, r3
    3196:	6878      	ldr	r0, [r7, #4]
    3198:	2440      	movs	r4, #64	; 0x40
    319a:	01c9      	lsls	r1, r1, #7
    319c:	1841      	adds	r1, r0, r1
    319e:	188a      	adds	r2, r1, r2
    31a0:	1912      	adds	r2, r2, r4
    31a2:	7812      	ldrb	r2, [r2, #0]
    31a4:	701a      	strb	r2, [r3, #0]
	tmp &= ~PORT_PINCFG_PMUXEN;
    31a6:	230f      	movs	r3, #15
    31a8:	18fb      	adds	r3, r7, r3
    31aa:	220f      	movs	r2, #15
    31ac:	18ba      	adds	r2, r7, r2
    31ae:	7812      	ldrb	r2, [r2, #0]
    31b0:	2101      	movs	r1, #1
    31b2:	438a      	bics	r2, r1
    31b4:	701a      	strb	r2, [r3, #0]
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
    31b6:	1c7b      	adds	r3, r7, #1
    31b8:	7819      	ldrb	r1, [r3, #0]
    31ba:	230f      	movs	r3, #15
    31bc:	18fb      	adds	r3, r7, r3
    31be:	220f      	movs	r2, #15
    31c0:	18ba      	adds	r2, r7, r2
    31c2:	7812      	ldrb	r2, [r2, #0]
    31c4:	430a      	orrs	r2, r1
    31c6:	701a      	strb	r2, [r3, #0]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    31c8:	1cfb      	adds	r3, r7, #3
    31ca:	781a      	ldrb	r2, [r3, #0]
    31cc:	1cbb      	adds	r3, r7, #2
    31ce:	781b      	ldrb	r3, [r3, #0]
    31d0:	6879      	ldr	r1, [r7, #4]
    31d2:	2040      	movs	r0, #64	; 0x40
    31d4:	01d2      	lsls	r2, r2, #7
    31d6:	188a      	adds	r2, r1, r2
    31d8:	18d3      	adds	r3, r2, r3
    31da:	181b      	adds	r3, r3, r0
    31dc:	220f      	movs	r2, #15
    31de:	18ba      	adds	r2, r7, r2
    31e0:	7812      	ldrb	r2, [r2, #0]
    31e2:	701a      	strb	r2, [r3, #0]
	PORT_CRITICAL_SECTION_LEAVE();
}
    31e4:	46c0      	nop			; (mov r8, r8)
    31e6:	46bd      	mov	sp, r7
    31e8:	b005      	add	sp, #20
    31ea:	bd90      	pop	{r4, r7, pc}

000031ec <hri_port_set_PINCFG_PULLEN_bit>:
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg ^= PORT_PINCFG_INEN;
	PORT_CRITICAL_SECTION_LEAVE();
}

static inline void hri_port_set_PINCFG_PULLEN_bit(const void *const hw, uint8_t submodule_index, uint8_t index)
{
    31ec:	b5b0      	push	{r4, r5, r7, lr}
    31ee:	b082      	sub	sp, #8
    31f0:	af00      	add	r7, sp, #0
    31f2:	6078      	str	r0, [r7, #4]
    31f4:	0008      	movs	r0, r1
    31f6:	0011      	movs	r1, r2
    31f8:	1cfb      	adds	r3, r7, #3
    31fa:	1c02      	adds	r2, r0, #0
    31fc:	701a      	strb	r2, [r3, #0]
    31fe:	1cbb      	adds	r3, r7, #2
    3200:	1c0a      	adds	r2, r1, #0
    3202:	701a      	strb	r2, [r3, #0]
	PORT_CRITICAL_SECTION_ENTER();
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg |= PORT_PINCFG_PULLEN;
    3204:	1cfb      	adds	r3, r7, #3
    3206:	781a      	ldrb	r2, [r3, #0]
    3208:	1cbb      	adds	r3, r7, #2
    320a:	781b      	ldrb	r3, [r3, #0]
    320c:	1cf9      	adds	r1, r7, #3
    320e:	7808      	ldrb	r0, [r1, #0]
    3210:	1cb9      	adds	r1, r7, #2
    3212:	7809      	ldrb	r1, [r1, #0]
    3214:	687c      	ldr	r4, [r7, #4]
    3216:	2540      	movs	r5, #64	; 0x40
    3218:	01c0      	lsls	r0, r0, #7
    321a:	1820      	adds	r0, r4, r0
    321c:	1841      	adds	r1, r0, r1
    321e:	1949      	adds	r1, r1, r5
    3220:	7809      	ldrb	r1, [r1, #0]
    3222:	b2c9      	uxtb	r1, r1
    3224:	2004      	movs	r0, #4
    3226:	4301      	orrs	r1, r0
    3228:	b2cc      	uxtb	r4, r1
    322a:	6879      	ldr	r1, [r7, #4]
    322c:	2040      	movs	r0, #64	; 0x40
    322e:	01d2      	lsls	r2, r2, #7
    3230:	188a      	adds	r2, r1, r2
    3232:	18d3      	adds	r3, r2, r3
    3234:	181b      	adds	r3, r3, r0
    3236:	1c22      	adds	r2, r4, #0
    3238:	701a      	strb	r2, [r3, #0]
	PORT_CRITICAL_SECTION_LEAVE();
}
    323a:	46c0      	nop			; (mov r8, r8)
    323c:	46bd      	mov	sp, r7
    323e:	b002      	add	sp, #8
    3240:	bdb0      	pop	{r4, r5, r7, pc}

00003242 <hri_port_clear_PINCFG_PULLEN_bit>:
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
	PORT_CRITICAL_SECTION_LEAVE();
}

static inline void hri_port_clear_PINCFG_PULLEN_bit(const void *const hw, uint8_t submodule_index, uint8_t index)
{
    3242:	b5b0      	push	{r4, r5, r7, lr}
    3244:	b082      	sub	sp, #8
    3246:	af00      	add	r7, sp, #0
    3248:	6078      	str	r0, [r7, #4]
    324a:	0008      	movs	r0, r1
    324c:	0011      	movs	r1, r2
    324e:	1cfb      	adds	r3, r7, #3
    3250:	1c02      	adds	r2, r0, #0
    3252:	701a      	strb	r2, [r3, #0]
    3254:	1cbb      	adds	r3, r7, #2
    3256:	1c0a      	adds	r2, r1, #0
    3258:	701a      	strb	r2, [r3, #0]
	PORT_CRITICAL_SECTION_ENTER();
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
    325a:	1cfb      	adds	r3, r7, #3
    325c:	781a      	ldrb	r2, [r3, #0]
    325e:	1cbb      	adds	r3, r7, #2
    3260:	781b      	ldrb	r3, [r3, #0]
    3262:	1cf9      	adds	r1, r7, #3
    3264:	7808      	ldrb	r0, [r1, #0]
    3266:	1cb9      	adds	r1, r7, #2
    3268:	7809      	ldrb	r1, [r1, #0]
    326a:	687c      	ldr	r4, [r7, #4]
    326c:	2540      	movs	r5, #64	; 0x40
    326e:	01c0      	lsls	r0, r0, #7
    3270:	1820      	adds	r0, r4, r0
    3272:	1841      	adds	r1, r0, r1
    3274:	1949      	adds	r1, r1, r5
    3276:	7809      	ldrb	r1, [r1, #0]
    3278:	b2c9      	uxtb	r1, r1
    327a:	2004      	movs	r0, #4
    327c:	4381      	bics	r1, r0
    327e:	b2cc      	uxtb	r4, r1
    3280:	6879      	ldr	r1, [r7, #4]
    3282:	2040      	movs	r0, #64	; 0x40
    3284:	01d2      	lsls	r2, r2, #7
    3286:	188a      	adds	r2, r1, r2
    3288:	18d3      	adds	r3, r2, r3
    328a:	181b      	adds	r3, r3, r0
    328c:	1c22      	adds	r2, r4, #0
    328e:	701a      	strb	r2, [r3, #0]
	PORT_CRITICAL_SECTION_LEAVE();
}
    3290:	46c0      	nop			; (mov r8, r8)
    3292:	46bd      	mov	sp, r7
    3294:	b002      	add	sp, #8
    3296:	bdb0      	pop	{r4, r5, r7, pc}

00003298 <hri_port_write_WRCONFIG_reg>:
	return ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
}

static inline void hri_port_write_WRCONFIG_reg(const void *const hw, uint8_t submodule_index,
                                               hri_port_wrconfig_reg_t data)
{
    3298:	b580      	push	{r7, lr}
    329a:	b084      	sub	sp, #16
    329c:	af00      	add	r7, sp, #0
    329e:	60f8      	str	r0, [r7, #12]
    32a0:	607a      	str	r2, [r7, #4]
    32a2:	230b      	movs	r3, #11
    32a4:	18fb      	adds	r3, r7, r3
    32a6:	1c0a      	adds	r2, r1, #0
    32a8:	701a      	strb	r2, [r3, #0]
	PORT_CRITICAL_SECTION_ENTER();
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    32aa:	230b      	movs	r3, #11
    32ac:	18fb      	adds	r3, r7, r3
    32ae:	781b      	ldrb	r3, [r3, #0]
    32b0:	68fa      	ldr	r2, [r7, #12]
    32b2:	01db      	lsls	r3, r3, #7
    32b4:	18d3      	adds	r3, r2, r3
    32b6:	3328      	adds	r3, #40	; 0x28
    32b8:	687a      	ldr	r2, [r7, #4]
    32ba:	601a      	str	r2, [r3, #0]
	PORT_CRITICAL_SECTION_LEAVE();
}
    32bc:	46c0      	nop			; (mov r8, r8)
    32be:	46bd      	mov	sp, r7
    32c0:	b004      	add	sp, #16
    32c2:	bd80      	pop	{r7, pc}

000032c4 <_gpio_set_direction>:
/**
 * \brief Set direction on port with mask
 */
static inline void _gpio_set_direction(const enum gpio_port port, const uint32_t mask,
                                       const enum gpio_direction direction)
{
    32c4:	b580      	push	{r7, lr}
    32c6:	b082      	sub	sp, #8
    32c8:	af00      	add	r7, sp, #0
    32ca:	6039      	str	r1, [r7, #0]
    32cc:	0011      	movs	r1, r2
    32ce:	1dfb      	adds	r3, r7, #7
    32d0:	1c02      	adds	r2, r0, #0
    32d2:	701a      	strb	r2, [r3, #0]
    32d4:	1dbb      	adds	r3, r7, #6
    32d6:	1c0a      	adds	r2, r1, #0
    32d8:	701a      	strb	r2, [r3, #0]
	switch (direction) {
    32da:	1dbb      	adds	r3, r7, #6
    32dc:	781b      	ldrb	r3, [r3, #0]
    32de:	2b01      	cmp	r3, #1
    32e0:	d023      	beq.n	332a <_gpio_set_direction+0x66>
    32e2:	2b02      	cmp	r3, #2
    32e4:	d03f      	beq.n	3366 <_gpio_set_direction+0xa2>
    32e6:	2b00      	cmp	r3, #0
    32e8:	d15d      	bne.n	33a6 <_gpio_set_direction+0xe2>
	case GPIO_DIRECTION_OFF:
		hri_port_clear_DIR_reg(PORT_IOBUS, port, mask);
    32ea:	683a      	ldr	r2, [r7, #0]
    32ec:	1dfb      	adds	r3, r7, #7
    32ee:	7819      	ldrb	r1, [r3, #0]
    32f0:	23c0      	movs	r3, #192	; 0xc0
    32f2:	05db      	lsls	r3, r3, #23
    32f4:	0018      	movs	r0, r3
    32f6:	f7ff fe6f 	bl	2fd8 <hri_port_clear_DIR_reg>
		hri_port_write_WRCONFIG_reg(PORT, port, PORT_WRCONFIG_WRPINCFG | (mask & 0xffff));
    32fa:	683b      	ldr	r3, [r7, #0]
    32fc:	041b      	lsls	r3, r3, #16
    32fe:	0c1b      	lsrs	r3, r3, #16
    3300:	2280      	movs	r2, #128	; 0x80
    3302:	05d2      	lsls	r2, r2, #23
    3304:	431a      	orrs	r2, r3
    3306:	1dfb      	adds	r3, r7, #7
    3308:	781b      	ldrb	r3, [r3, #0]
    330a:	482c      	ldr	r0, [pc, #176]	; (33bc <_gpio_set_direction+0xf8>)
    330c:	0019      	movs	r1, r3
    330e:	f7ff ffc3 	bl	3298 <hri_port_write_WRCONFIG_reg>
		hri_port_write_WRCONFIG_reg(
		    PORT, port, PORT_WRCONFIG_HWSEL | PORT_WRCONFIG_WRPINCFG | ((mask & 0xffff0000) >> 16));
    3312:	683b      	ldr	r3, [r7, #0]
    3314:	0c1b      	lsrs	r3, r3, #16
		hri_port_write_WRCONFIG_reg(
    3316:	22c0      	movs	r2, #192	; 0xc0
    3318:	0612      	lsls	r2, r2, #24
    331a:	431a      	orrs	r2, r3
    331c:	1dfb      	adds	r3, r7, #7
    331e:	781b      	ldrb	r3, [r3, #0]
    3320:	4826      	ldr	r0, [pc, #152]	; (33bc <_gpio_set_direction+0xf8>)
    3322:	0019      	movs	r1, r3
    3324:	f7ff ffb8 	bl	3298 <hri_port_write_WRCONFIG_reg>
		break;
    3328:	e043      	b.n	33b2 <_gpio_set_direction+0xee>

	case GPIO_DIRECTION_IN:
		hri_port_clear_DIR_reg(PORT_IOBUS, port, mask);
    332a:	683a      	ldr	r2, [r7, #0]
    332c:	1dfb      	adds	r3, r7, #7
    332e:	7819      	ldrb	r1, [r3, #0]
    3330:	23c0      	movs	r3, #192	; 0xc0
    3332:	05db      	lsls	r3, r3, #23
    3334:	0018      	movs	r0, r3
    3336:	f7ff fe4f 	bl	2fd8 <hri_port_clear_DIR_reg>
		hri_port_write_WRCONFIG_reg(PORT, port, PORT_WRCONFIG_WRPINCFG | PORT_WRCONFIG_INEN | (mask & 0xffff));
    333a:	683b      	ldr	r3, [r7, #0]
    333c:	041b      	lsls	r3, r3, #16
    333e:	0c1b      	lsrs	r3, r3, #16
    3340:	4a1f      	ldr	r2, [pc, #124]	; (33c0 <_gpio_set_direction+0xfc>)
    3342:	431a      	orrs	r2, r3
    3344:	1dfb      	adds	r3, r7, #7
    3346:	781b      	ldrb	r3, [r3, #0]
    3348:	481c      	ldr	r0, [pc, #112]	; (33bc <_gpio_set_direction+0xf8>)
    334a:	0019      	movs	r1, r3
    334c:	f7ff ffa4 	bl	3298 <hri_port_write_WRCONFIG_reg>
		hri_port_write_WRCONFIG_reg(PORT,
		                            port,
		                            PORT_WRCONFIG_HWSEL | PORT_WRCONFIG_WRPINCFG | PORT_WRCONFIG_INEN
		                                | ((mask & 0xffff0000) >> 16));
    3350:	683b      	ldr	r3, [r7, #0]
    3352:	0c1b      	lsrs	r3, r3, #16
		hri_port_write_WRCONFIG_reg(PORT,
    3354:	4a1b      	ldr	r2, [pc, #108]	; (33c4 <_gpio_set_direction+0x100>)
    3356:	431a      	orrs	r2, r3
    3358:	1dfb      	adds	r3, r7, #7
    335a:	781b      	ldrb	r3, [r3, #0]
    335c:	4817      	ldr	r0, [pc, #92]	; (33bc <_gpio_set_direction+0xf8>)
    335e:	0019      	movs	r1, r3
    3360:	f7ff ff9a 	bl	3298 <hri_port_write_WRCONFIG_reg>
		break;
    3364:	e025      	b.n	33b2 <_gpio_set_direction+0xee>

	case GPIO_DIRECTION_OUT:
		hri_port_set_DIR_reg(PORT_IOBUS, port, mask);
    3366:	683a      	ldr	r2, [r7, #0]
    3368:	1dfb      	adds	r3, r7, #7
    336a:	7819      	ldrb	r1, [r3, #0]
    336c:	23c0      	movs	r3, #192	; 0xc0
    336e:	05db      	lsls	r3, r3, #23
    3370:	0018      	movs	r0, r3
    3372:	f7ff fe1b 	bl	2fac <hri_port_set_DIR_reg>
		hri_port_write_WRCONFIG_reg(PORT, port, PORT_WRCONFIG_WRPINCFG | (mask & 0xffff));
    3376:	683b      	ldr	r3, [r7, #0]
    3378:	041b      	lsls	r3, r3, #16
    337a:	0c1b      	lsrs	r3, r3, #16
    337c:	2280      	movs	r2, #128	; 0x80
    337e:	05d2      	lsls	r2, r2, #23
    3380:	431a      	orrs	r2, r3
    3382:	1dfb      	adds	r3, r7, #7
    3384:	781b      	ldrb	r3, [r3, #0]
    3386:	480d      	ldr	r0, [pc, #52]	; (33bc <_gpio_set_direction+0xf8>)
    3388:	0019      	movs	r1, r3
    338a:	f7ff ff85 	bl	3298 <hri_port_write_WRCONFIG_reg>
		hri_port_write_WRCONFIG_reg(
		    PORT, port, PORT_WRCONFIG_HWSEL | PORT_WRCONFIG_WRPINCFG | ((mask & 0xffff0000) >> 16));
    338e:	683b      	ldr	r3, [r7, #0]
    3390:	0c1b      	lsrs	r3, r3, #16
		hri_port_write_WRCONFIG_reg(
    3392:	22c0      	movs	r2, #192	; 0xc0
    3394:	0612      	lsls	r2, r2, #24
    3396:	431a      	orrs	r2, r3
    3398:	1dfb      	adds	r3, r7, #7
    339a:	781b      	ldrb	r3, [r3, #0]
    339c:	4807      	ldr	r0, [pc, #28]	; (33bc <_gpio_set_direction+0xf8>)
    339e:	0019      	movs	r1, r3
    33a0:	f7ff ff7a 	bl	3298 <hri_port_write_WRCONFIG_reg>
		break;
    33a4:	e005      	b.n	33b2 <_gpio_set_direction+0xee>

	default:
		ASSERT(false);
    33a6:	4b08      	ldr	r3, [pc, #32]	; (33c8 <_gpio_set_direction+0x104>)
    33a8:	2245      	movs	r2, #69	; 0x45
    33aa:	0019      	movs	r1, r3
    33ac:	2000      	movs	r0, #0
    33ae:	f000 ffb7 	bl	4320 <assert>
	}
}
    33b2:	46c0      	nop			; (mov r8, r8)
    33b4:	46bd      	mov	sp, r7
    33b6:	b002      	add	sp, #8
    33b8:	bd80      	pop	{r7, pc}
    33ba:	46c0      	nop			; (mov r8, r8)
    33bc:	41004400 	.word	0x41004400
    33c0:	40020000 	.word	0x40020000
    33c4:	c0020000 	.word	0xc0020000
    33c8:	00008a50 	.word	0x00008a50

000033cc <_gpio_set_level>:

/**
 * \brief Set output level on port with mask
 */
static inline void _gpio_set_level(const enum gpio_port port, const uint32_t mask, const bool level)
{
    33cc:	b580      	push	{r7, lr}
    33ce:	b082      	sub	sp, #8
    33d0:	af00      	add	r7, sp, #0
    33d2:	6039      	str	r1, [r7, #0]
    33d4:	0011      	movs	r1, r2
    33d6:	1dfb      	adds	r3, r7, #7
    33d8:	1c02      	adds	r2, r0, #0
    33da:	701a      	strb	r2, [r3, #0]
    33dc:	1dbb      	adds	r3, r7, #6
    33de:	1c0a      	adds	r2, r1, #0
    33e0:	701a      	strb	r2, [r3, #0]
	if (level) {
    33e2:	1dbb      	adds	r3, r7, #6
    33e4:	781b      	ldrb	r3, [r3, #0]
    33e6:	2b00      	cmp	r3, #0
    33e8:	d008      	beq.n	33fc <_gpio_set_level+0x30>
		hri_port_set_OUT_reg(PORT_IOBUS, port, mask);
    33ea:	683a      	ldr	r2, [r7, #0]
    33ec:	1dfb      	adds	r3, r7, #7
    33ee:	7819      	ldrb	r1, [r3, #0]
    33f0:	23c0      	movs	r3, #192	; 0xc0
    33f2:	05db      	lsls	r3, r3, #23
    33f4:	0018      	movs	r0, r3
    33f6:	f7ff fe05 	bl	3004 <hri_port_set_OUT_reg>
	} else {
		hri_port_clear_OUT_reg(PORT_IOBUS, port, mask);
	}
}
    33fa:	e007      	b.n	340c <_gpio_set_level+0x40>
		hri_port_clear_OUT_reg(PORT_IOBUS, port, mask);
    33fc:	683a      	ldr	r2, [r7, #0]
    33fe:	1dfb      	adds	r3, r7, #7
    3400:	7819      	ldrb	r1, [r3, #0]
    3402:	23c0      	movs	r3, #192	; 0xc0
    3404:	05db      	lsls	r3, r3, #23
    3406:	0018      	movs	r0, r3
    3408:	f7ff fe12 	bl	3030 <hri_port_clear_OUT_reg>
}
    340c:	46c0      	nop			; (mov r8, r8)
    340e:	46bd      	mov	sp, r7
    3410:	b002      	add	sp, #8
    3412:	bd80      	pop	{r7, pc}

00003414 <_gpio_set_pin_pull_mode>:
/**
 * \brief Set pin pull mode
 */
static inline void _gpio_set_pin_pull_mode(const enum gpio_port port, const uint8_t pin,
                                           const enum gpio_pull_mode pull_mode)
{
    3414:	b590      	push	{r4, r7, lr}
    3416:	b083      	sub	sp, #12
    3418:	af00      	add	r7, sp, #0
    341a:	0004      	movs	r4, r0
    341c:	0008      	movs	r0, r1
    341e:	0011      	movs	r1, r2
    3420:	1dfb      	adds	r3, r7, #7
    3422:	1c22      	adds	r2, r4, #0
    3424:	701a      	strb	r2, [r3, #0]
    3426:	1dbb      	adds	r3, r7, #6
    3428:	1c02      	adds	r2, r0, #0
    342a:	701a      	strb	r2, [r3, #0]
    342c:	1d7b      	adds	r3, r7, #5
    342e:	1c0a      	adds	r2, r1, #0
    3430:	701a      	strb	r2, [r3, #0]
	switch (pull_mode) {
    3432:	1d7b      	adds	r3, r7, #5
    3434:	781b      	ldrb	r3, [r3, #0]
    3436:	2b01      	cmp	r3, #1
    3438:	d00c      	beq.n	3454 <_gpio_set_pin_pull_mode+0x40>
    343a:	2b02      	cmp	r3, #2
    343c:	d029      	beq.n	3492 <_gpio_set_pin_pull_mode+0x7e>
    343e:	2b00      	cmp	r3, #0
    3440:	d146      	bne.n	34d0 <_gpio_set_pin_pull_mode+0xbc>
	case GPIO_PULL_OFF:
		hri_port_clear_PINCFG_PULLEN_bit(PORT, port, pin);
    3442:	1dbb      	adds	r3, r7, #6
    3444:	781a      	ldrb	r2, [r3, #0]
    3446:	1dfb      	adds	r3, r7, #7
    3448:	781b      	ldrb	r3, [r3, #0]
    344a:	4827      	ldr	r0, [pc, #156]	; (34e8 <_gpio_set_pin_pull_mode+0xd4>)
    344c:	0019      	movs	r1, r3
    344e:	f7ff fef8 	bl	3242 <hri_port_clear_PINCFG_PULLEN_bit>
		break;
    3452:	e044      	b.n	34de <_gpio_set_pin_pull_mode+0xca>

	case GPIO_PULL_UP:
		hri_port_clear_DIR_reg(PORT_IOBUS, port, 1U << pin);
    3454:	1dbb      	adds	r3, r7, #6
    3456:	781b      	ldrb	r3, [r3, #0]
    3458:	2201      	movs	r2, #1
    345a:	409a      	lsls	r2, r3
    345c:	1dfb      	adds	r3, r7, #7
    345e:	7819      	ldrb	r1, [r3, #0]
    3460:	23c0      	movs	r3, #192	; 0xc0
    3462:	05db      	lsls	r3, r3, #23
    3464:	0018      	movs	r0, r3
    3466:	f7ff fdb7 	bl	2fd8 <hri_port_clear_DIR_reg>
		hri_port_set_PINCFG_PULLEN_bit(PORT, port, pin);
    346a:	1dbb      	adds	r3, r7, #6
    346c:	781a      	ldrb	r2, [r3, #0]
    346e:	1dfb      	adds	r3, r7, #7
    3470:	781b      	ldrb	r3, [r3, #0]
    3472:	481d      	ldr	r0, [pc, #116]	; (34e8 <_gpio_set_pin_pull_mode+0xd4>)
    3474:	0019      	movs	r1, r3
    3476:	f7ff feb9 	bl	31ec <hri_port_set_PINCFG_PULLEN_bit>
		hri_port_set_OUT_reg(PORT_IOBUS, port, 1U << pin);
    347a:	1dbb      	adds	r3, r7, #6
    347c:	781b      	ldrb	r3, [r3, #0]
    347e:	2201      	movs	r2, #1
    3480:	409a      	lsls	r2, r3
    3482:	1dfb      	adds	r3, r7, #7
    3484:	7819      	ldrb	r1, [r3, #0]
    3486:	23c0      	movs	r3, #192	; 0xc0
    3488:	05db      	lsls	r3, r3, #23
    348a:	0018      	movs	r0, r3
    348c:	f7ff fdba 	bl	3004 <hri_port_set_OUT_reg>
		break;
    3490:	e025      	b.n	34de <_gpio_set_pin_pull_mode+0xca>

	case GPIO_PULL_DOWN:
		hri_port_clear_DIR_reg(PORT_IOBUS, port, 1U << pin);
    3492:	1dbb      	adds	r3, r7, #6
    3494:	781b      	ldrb	r3, [r3, #0]
    3496:	2201      	movs	r2, #1
    3498:	409a      	lsls	r2, r3
    349a:	1dfb      	adds	r3, r7, #7
    349c:	7819      	ldrb	r1, [r3, #0]
    349e:	23c0      	movs	r3, #192	; 0xc0
    34a0:	05db      	lsls	r3, r3, #23
    34a2:	0018      	movs	r0, r3
    34a4:	f7ff fd98 	bl	2fd8 <hri_port_clear_DIR_reg>
		hri_port_set_PINCFG_PULLEN_bit(PORT, port, pin);
    34a8:	1dbb      	adds	r3, r7, #6
    34aa:	781a      	ldrb	r2, [r3, #0]
    34ac:	1dfb      	adds	r3, r7, #7
    34ae:	781b      	ldrb	r3, [r3, #0]
    34b0:	480d      	ldr	r0, [pc, #52]	; (34e8 <_gpio_set_pin_pull_mode+0xd4>)
    34b2:	0019      	movs	r1, r3
    34b4:	f7ff fe9a 	bl	31ec <hri_port_set_PINCFG_PULLEN_bit>
		hri_port_clear_OUT_reg(PORT_IOBUS, port, 1U << pin);
    34b8:	1dbb      	adds	r3, r7, #6
    34ba:	781b      	ldrb	r3, [r3, #0]
    34bc:	2201      	movs	r2, #1
    34be:	409a      	lsls	r2, r3
    34c0:	1dfb      	adds	r3, r7, #7
    34c2:	7819      	ldrb	r1, [r3, #0]
    34c4:	23c0      	movs	r3, #192	; 0xc0
    34c6:	05db      	lsls	r3, r3, #23
    34c8:	0018      	movs	r0, r3
    34ca:	f7ff fdb1 	bl	3030 <hri_port_clear_OUT_reg>
		break;
    34ce:	e006      	b.n	34de <_gpio_set_pin_pull_mode+0xca>

	default:
		ASSERT(false);
    34d0:	4b06      	ldr	r3, [pc, #24]	; (34ec <_gpio_set_pin_pull_mode+0xd8>)
    34d2:	2288      	movs	r2, #136	; 0x88
    34d4:	0019      	movs	r1, r3
    34d6:	2000      	movs	r0, #0
    34d8:	f000 ff22 	bl	4320 <assert>
		break;
    34dc:	46c0      	nop			; (mov r8, r8)
	}
}
    34de:	46c0      	nop			; (mov r8, r8)
    34e0:	46bd      	mov	sp, r7
    34e2:	b003      	add	sp, #12
    34e4:	bd90      	pop	{r4, r7, pc}
    34e6:	46c0      	nop			; (mov r8, r8)
    34e8:	41004400 	.word	0x41004400
    34ec:	00008a50 	.word	0x00008a50

000034f0 <_gpio_set_pin_function>:

/**
 * \brief Set gpio pin function
 */
static inline void _gpio_set_pin_function(const uint32_t gpio, const uint32_t function)
{
    34f0:	b590      	push	{r4, r7, lr}
    34f2:	b085      	sub	sp, #20
    34f4:	af00      	add	r7, sp, #0
    34f6:	6078      	str	r0, [r7, #4]
    34f8:	6039      	str	r1, [r7, #0]
	uint8_t port = GPIO_PORT(gpio);
    34fa:	687b      	ldr	r3, [r7, #4]
    34fc:	095a      	lsrs	r2, r3, #5
    34fe:	230f      	movs	r3, #15
    3500:	18fb      	adds	r3, r7, r3
    3502:	701a      	strb	r2, [r3, #0]
	uint8_t pin  = GPIO_PIN(gpio);
    3504:	687b      	ldr	r3, [r7, #4]
    3506:	b2da      	uxtb	r2, r3
    3508:	230e      	movs	r3, #14
    350a:	18fb      	adds	r3, r7, r3
    350c:	211f      	movs	r1, #31
    350e:	400a      	ands	r2, r1
    3510:	701a      	strb	r2, [r3, #0]

	if (function == GPIO_PIN_FUNCTION_OFF) {
    3512:	683b      	ldr	r3, [r7, #0]
    3514:	3301      	adds	r3, #1
    3516:	d10a      	bne.n	352e <_gpio_set_pin_function+0x3e>
		hri_port_write_PINCFG_PMUXEN_bit(PORT, port, pin, false);
    3518:	230e      	movs	r3, #14
    351a:	18fb      	adds	r3, r7, r3
    351c:	781a      	ldrb	r2, [r3, #0]
    351e:	230f      	movs	r3, #15
    3520:	18fb      	adds	r3, r7, r3
    3522:	7819      	ldrb	r1, [r3, #0]
    3524:	481b      	ldr	r0, [pc, #108]	; (3594 <_gpio_set_pin_function+0xa4>)
    3526:	2300      	movs	r3, #0
    3528:	f7ff fe1f 	bl	316a <hri_port_write_PINCFG_PMUXEN_bit>
		} else {
			// Even numbered pin
			hri_port_write_PMUX_PMUXE_bf(PORT, port, pin >> 1, function & 0xffff);
		}
	}
}
    352c:	e02e      	b.n	358c <_gpio_set_pin_function+0x9c>
		hri_port_write_PINCFG_PMUXEN_bit(PORT, port, pin, true);
    352e:	230e      	movs	r3, #14
    3530:	18fb      	adds	r3, r7, r3
    3532:	781a      	ldrb	r2, [r3, #0]
    3534:	230f      	movs	r3, #15
    3536:	18fb      	adds	r3, r7, r3
    3538:	7819      	ldrb	r1, [r3, #0]
    353a:	4816      	ldr	r0, [pc, #88]	; (3594 <_gpio_set_pin_function+0xa4>)
    353c:	2301      	movs	r3, #1
    353e:	f7ff fe14 	bl	316a <hri_port_write_PINCFG_PMUXEN_bit>
		if (pin & 1) {
    3542:	230e      	movs	r3, #14
    3544:	18fb      	adds	r3, r7, r3
    3546:	781b      	ldrb	r3, [r3, #0]
    3548:	2201      	movs	r2, #1
    354a:	4013      	ands	r3, r2
    354c:	d00f      	beq.n	356e <_gpio_set_pin_function+0x7e>
			hri_port_write_PMUX_PMUXO_bf(PORT, port, pin >> 1, function & 0xffff);
    354e:	230e      	movs	r3, #14
    3550:	18fb      	adds	r3, r7, r3
    3552:	781b      	ldrb	r3, [r3, #0]
    3554:	085b      	lsrs	r3, r3, #1
    3556:	b2da      	uxtb	r2, r3
    3558:	683b      	ldr	r3, [r7, #0]
    355a:	b2d8      	uxtb	r0, r3
    355c:	230f      	movs	r3, #15
    355e:	18fb      	adds	r3, r7, r3
    3560:	7819      	ldrb	r1, [r3, #0]
    3562:	4c0c      	ldr	r4, [pc, #48]	; (3594 <_gpio_set_pin_function+0xa4>)
    3564:	0003      	movs	r3, r0
    3566:	0020      	movs	r0, r4
    3568:	f7ff fdbc 	bl	30e4 <hri_port_write_PMUX_PMUXO_bf>
}
    356c:	e00e      	b.n	358c <_gpio_set_pin_function+0x9c>
			hri_port_write_PMUX_PMUXE_bf(PORT, port, pin >> 1, function & 0xffff);
    356e:	230e      	movs	r3, #14
    3570:	18fb      	adds	r3, r7, r3
    3572:	781b      	ldrb	r3, [r3, #0]
    3574:	085b      	lsrs	r3, r3, #1
    3576:	b2da      	uxtb	r2, r3
    3578:	683b      	ldr	r3, [r7, #0]
    357a:	b2d8      	uxtb	r0, r3
    357c:	230f      	movs	r3, #15
    357e:	18fb      	adds	r3, r7, r3
    3580:	7819      	ldrb	r1, [r3, #0]
    3582:	4c04      	ldr	r4, [pc, #16]	; (3594 <_gpio_set_pin_function+0xa4>)
    3584:	0003      	movs	r3, r0
    3586:	0020      	movs	r0, r4
    3588:	f7ff fd68 	bl	305c <hri_port_write_PMUX_PMUXE_bf>
}
    358c:	46c0      	nop			; (mov r8, r8)
    358e:	46bd      	mov	sp, r7
    3590:	b005      	add	sp, #20
    3592:	bd90      	pop	{r4, r7, pc}
    3594:	41004400 	.word	0x41004400

00003598 <gpio_set_pin_pull_mode>:
 * \param[in] pull_mode GPIO_PULL_DOWN = Pull pin low with internal resistor
 *                      GPIO_PULL_UP   = Pull pin high with internal resistor
 *                      GPIO_PULL_OFF  = Disable pin pull mode
 */
static inline void gpio_set_pin_pull_mode(const uint8_t pin, const enum gpio_pull_mode pull_mode)
{
    3598:	b580      	push	{r7, lr}
    359a:	b082      	sub	sp, #8
    359c:	af00      	add	r7, sp, #0
    359e:	0002      	movs	r2, r0
    35a0:	1dfb      	adds	r3, r7, #7
    35a2:	701a      	strb	r2, [r3, #0]
    35a4:	1dbb      	adds	r3, r7, #6
    35a6:	1c0a      	adds	r2, r1, #0
    35a8:	701a      	strb	r2, [r3, #0]
	_gpio_set_pin_pull_mode((enum gpio_port)GPIO_PORT(pin), pin & 0x1F, pull_mode);
    35aa:	1dfb      	adds	r3, r7, #7
    35ac:	781b      	ldrb	r3, [r3, #0]
    35ae:	095b      	lsrs	r3, r3, #5
    35b0:	b2d8      	uxtb	r0, r3
    35b2:	1dfb      	adds	r3, r7, #7
    35b4:	781b      	ldrb	r3, [r3, #0]
    35b6:	221f      	movs	r2, #31
    35b8:	4013      	ands	r3, r2
    35ba:	b2d9      	uxtb	r1, r3
    35bc:	1dbb      	adds	r3, r7, #6
    35be:	781b      	ldrb	r3, [r3, #0]
    35c0:	001a      	movs	r2, r3
    35c2:	f7ff ff27 	bl	3414 <_gpio_set_pin_pull_mode>
}
    35c6:	46c0      	nop			; (mov r8, r8)
    35c8:	46bd      	mov	sp, r7
    35ca:	b002      	add	sp, #8
    35cc:	bd80      	pop	{r7, pc}

000035ce <gpio_set_pin_function>:
 * \param[in] function  The pin function is given by a 32-bit wide bitfield
 *                      found in the header files for the device
 *
 */
static inline void gpio_set_pin_function(const uint32_t pin, uint32_t function)
{
    35ce:	b580      	push	{r7, lr}
    35d0:	b082      	sub	sp, #8
    35d2:	af00      	add	r7, sp, #0
    35d4:	6078      	str	r0, [r7, #4]
    35d6:	6039      	str	r1, [r7, #0]
	_gpio_set_pin_function(pin, function);
    35d8:	683a      	ldr	r2, [r7, #0]
    35da:	687b      	ldr	r3, [r7, #4]
    35dc:	0011      	movs	r1, r2
    35de:	0018      	movs	r0, r3
    35e0:	f7ff ff86 	bl	34f0 <_gpio_set_pin_function>
}
    35e4:	46c0      	nop			; (mov r8, r8)
    35e6:	46bd      	mov	sp, r7
    35e8:	b002      	add	sp, #8
    35ea:	bd80      	pop	{r7, pc}

000035ec <gpio_set_pin_direction>:
 *                      GPIO_DIRECTION_OUT = Data direction out
 *                      GPIO_DIRECTION_OFF = Disables the pin
 *                      (low power state)
 */
static inline void gpio_set_pin_direction(const uint8_t pin, const enum gpio_direction direction)
{
    35ec:	b580      	push	{r7, lr}
    35ee:	b082      	sub	sp, #8
    35f0:	af00      	add	r7, sp, #0
    35f2:	0002      	movs	r2, r0
    35f4:	1dfb      	adds	r3, r7, #7
    35f6:	701a      	strb	r2, [r3, #0]
    35f8:	1dbb      	adds	r3, r7, #6
    35fa:	1c0a      	adds	r2, r1, #0
    35fc:	701a      	strb	r2, [r3, #0]
	_gpio_set_direction((enum gpio_port)GPIO_PORT(pin), 1U << GPIO_PIN(pin), direction);
    35fe:	1dfb      	adds	r3, r7, #7
    3600:	781b      	ldrb	r3, [r3, #0]
    3602:	095b      	lsrs	r3, r3, #5
    3604:	b2d8      	uxtb	r0, r3
    3606:	1dfb      	adds	r3, r7, #7
    3608:	781b      	ldrb	r3, [r3, #0]
    360a:	221f      	movs	r2, #31
    360c:	4013      	ands	r3, r2
    360e:	2201      	movs	r2, #1
    3610:	409a      	lsls	r2, r3
    3612:	0011      	movs	r1, r2
    3614:	1dbb      	adds	r3, r7, #6
    3616:	781b      	ldrb	r3, [r3, #0]
    3618:	001a      	movs	r2, r3
    361a:	f7ff fe53 	bl	32c4 <_gpio_set_direction>
}
    361e:	46c0      	nop			; (mov r8, r8)
    3620:	46bd      	mov	sp, r7
    3622:	b002      	add	sp, #8
    3624:	bd80      	pop	{r7, pc}

00003626 <gpio_set_pin_level>:
 * \param[in] pin       The pin number for device
 * \param[in] level true  = Pin level set to "high" state
 *                  false = Pin level set to "low" state
 */
static inline void gpio_set_pin_level(const uint8_t pin, const bool level)
{
    3626:	b580      	push	{r7, lr}
    3628:	b082      	sub	sp, #8
    362a:	af00      	add	r7, sp, #0
    362c:	0002      	movs	r2, r0
    362e:	1dfb      	adds	r3, r7, #7
    3630:	701a      	strb	r2, [r3, #0]
    3632:	1dbb      	adds	r3, r7, #6
    3634:	1c0a      	adds	r2, r1, #0
    3636:	701a      	strb	r2, [r3, #0]
	_gpio_set_level((enum gpio_port)GPIO_PORT(pin), 1U << GPIO_PIN(pin), level);
    3638:	1dfb      	adds	r3, r7, #7
    363a:	781b      	ldrb	r3, [r3, #0]
    363c:	095b      	lsrs	r3, r3, #5
    363e:	b2d8      	uxtb	r0, r3
    3640:	1dfb      	adds	r3, r7, #7
    3642:	781b      	ldrb	r3, [r3, #0]
    3644:	221f      	movs	r2, #31
    3646:	4013      	ands	r3, r2
    3648:	2201      	movs	r2, #1
    364a:	409a      	lsls	r2, r3
    364c:	0011      	movs	r1, r2
    364e:	1dbb      	adds	r3, r7, #6
    3650:	781b      	ldrb	r3, [r3, #0]
    3652:	001a      	movs	r2, r3
    3654:	f7ff feba 	bl	33cc <_gpio_set_level>
}
    3658:	46c0      	nop			; (mov r8, r8)
    365a:	46bd      	mov	sp, r7
    365c:	b002      	add	sp, #8
    365e:	bd80      	pop	{r7, pc}

00003660 <init_mcu>:
 * This function calls the various initialization functions.
 * Currently the following initialization functions are supported:
 *  - System clock initialization
 */
static inline void init_mcu(void)
{
    3660:	b580      	push	{r7, lr}
    3662:	af00      	add	r7, sp, #0
	_init_chip();
    3664:	f000 ff2a 	bl	44bc <_init_chip>
}
    3668:	46c0      	nop			; (mov r8, r8)
    366a:	46bd      	mov	sp, r7
    366c:	bd80      	pop	{r7, pc}
	...

00003670 <_gclk_enable_channel>:
 *
 * \param[in] channel The channel to enable clock for
 * \param[in] source The clock source for the given channel
 */
static inline void _gclk_enable_channel(const uint8_t channel, const uint8_t source)
{
    3670:	b580      	push	{r7, lr}
    3672:	b082      	sub	sp, #8
    3674:	af00      	add	r7, sp, #0
    3676:	0002      	movs	r2, r0
    3678:	1dfb      	adds	r3, r7, #7
    367a:	701a      	strb	r2, [r3, #0]
    367c:	1dbb      	adds	r3, r7, #6
    367e:	1c0a      	adds	r2, r1, #0
    3680:	701a      	strb	r2, [r3, #0]

	hri_gclk_write_CLKCTRL_reg(GCLK,
	                           GCLK_CLKCTRL_ID(channel) | GCLK_CLKCTRL_GEN(source) | (1 << GCLK_CLKCTRL_CLKEN_Pos));
    3682:	1dfb      	adds	r3, r7, #7
    3684:	781b      	ldrb	r3, [r3, #0]
    3686:	b29b      	uxth	r3, r3
    3688:	223f      	movs	r2, #63	; 0x3f
    368a:	4013      	ands	r3, r2
    368c:	b29a      	uxth	r2, r3
    368e:	1dbb      	adds	r3, r7, #6
    3690:	781b      	ldrb	r3, [r3, #0]
    3692:	b29b      	uxth	r3, r3
    3694:	021b      	lsls	r3, r3, #8
    3696:	b299      	uxth	r1, r3
    3698:	23f0      	movs	r3, #240	; 0xf0
    369a:	011b      	lsls	r3, r3, #4
    369c:	400b      	ands	r3, r1
    369e:	b29b      	uxth	r3, r3
    36a0:	4313      	orrs	r3, r2
    36a2:	b29b      	uxth	r3, r3
	hri_gclk_write_CLKCTRL_reg(GCLK,
    36a4:	2280      	movs	r2, #128	; 0x80
    36a6:	01d2      	lsls	r2, r2, #7
    36a8:	4313      	orrs	r3, r2
    36aa:	b29b      	uxth	r3, r3
    36ac:	4a04      	ldr	r2, [pc, #16]	; (36c0 <_gclk_enable_channel+0x50>)
    36ae:	0019      	movs	r1, r3
    36b0:	0010      	movs	r0, r2
    36b2:	f7ff fc6c 	bl	2f8e <hri_gclk_write_CLKCTRL_reg>
}
    36b6:	46c0      	nop			; (mov r8, r8)
    36b8:	46bd      	mov	sp, r7
    36ba:	b002      	add	sp, #8
    36bc:	bd80      	pop	{r7, pc}
    36be:	46c0      	nop			; (mov r8, r8)
    36c0:	40000c00 	.word	0x40000c00

000036c4 <_pm_get_ahb_index>:
 * \param[in] module Module to get index for
 *
 * \return index of the given module if succeeds, ERR_INVALID_ARG otherwise
 */
static inline int32_t _pm_get_ahb_index(const void *const module)
{
    36c4:	b580      	push	{r7, lr}
    36c6:	b082      	sub	sp, #8
    36c8:	af00      	add	r7, sp, #0
    36ca:	6078      	str	r0, [r7, #4]
	if ((uint32_t)module == (uint32_t)PM_BUS_APBA) {
    36cc:	687b      	ldr	r3, [r7, #4]
    36ce:	2b01      	cmp	r3, #1
    36d0:	d101      	bne.n	36d6 <_pm_get_ahb_index+0x12>
		return 0;
    36d2:	2300      	movs	r3, #0
    36d4:	e017      	b.n	3706 <_pm_get_ahb_index+0x42>
	} else if ((uint32_t)module == (uint32_t)PM_BUS_APBB) {
    36d6:	687b      	ldr	r3, [r7, #4]
    36d8:	2b02      	cmp	r3, #2
    36da:	d101      	bne.n	36e0 <_pm_get_ahb_index+0x1c>
		return 1;
    36dc:	2301      	movs	r3, #1
    36de:	e012      	b.n	3706 <_pm_get_ahb_index+0x42>
	} else if ((uint32_t)module == (uint32_t)PM_BUS_APBC) {
    36e0:	687b      	ldr	r3, [r7, #4]
    36e2:	2b03      	cmp	r3, #3
    36e4:	d101      	bne.n	36ea <_pm_get_ahb_index+0x26>
		return 2;
    36e6:	2302      	movs	r3, #2
    36e8:	e00d      	b.n	3706 <_pm_get_ahb_index+0x42>
	}
	if ((uint32_t)module == (uint32_t)DSU) {
    36ea:	687b      	ldr	r3, [r7, #4]
    36ec:	4a08      	ldr	r2, [pc, #32]	; (3710 <_pm_get_ahb_index+0x4c>)
    36ee:	4293      	cmp	r3, r2
    36f0:	d101      	bne.n	36f6 <_pm_get_ahb_index+0x32>
		return 3;
    36f2:	2303      	movs	r3, #3
    36f4:	e007      	b.n	3706 <_pm_get_ahb_index+0x42>
	} else if ((uint32_t)module == (uint32_t)NVMCTRL) {
    36f6:	687b      	ldr	r3, [r7, #4]
    36f8:	4a06      	ldr	r2, [pc, #24]	; (3714 <_pm_get_ahb_index+0x50>)
    36fa:	4293      	cmp	r3, r2
    36fc:	d101      	bne.n	3702 <_pm_get_ahb_index+0x3e>
		return 4;
    36fe:	2304      	movs	r3, #4
    3700:	e001      	b.n	3706 <_pm_get_ahb_index+0x42>
	}

	return ERR_INVALID_ARG;
    3702:	230d      	movs	r3, #13
    3704:	425b      	negs	r3, r3
}
    3706:	0018      	movs	r0, r3
    3708:	46bd      	mov	sp, r7
    370a:	b002      	add	sp, #8
    370c:	bd80      	pop	{r7, pc}
    370e:	46c0      	nop			; (mov r8, r8)
    3710:	41002000 	.word	0x41002000
    3714:	41004000 	.word	0x41004000

00003718 <_pm_get_apbb_index>:
 * \param[in] module Module to get index for
 *
 * \return index of the given module if succeeds, ERR_INVALID_ARG otherwise
 */
static inline int32_t _pm_get_apbb_index(const void *const module)
{
    3718:	b580      	push	{r7, lr}
    371a:	b082      	sub	sp, #8
    371c:	af00      	add	r7, sp, #0
    371e:	6078      	str	r0, [r7, #4]
	if ((uint32_t)module == (uint32_t)PAC1) {
    3720:	687a      	ldr	r2, [r7, #4]
    3722:	2382      	movs	r3, #130	; 0x82
    3724:	05db      	lsls	r3, r3, #23
    3726:	429a      	cmp	r2, r3
    3728:	d101      	bne.n	372e <_pm_get_apbb_index+0x16>
		return 0;
    372a:	2300      	movs	r3, #0
    372c:	e013      	b.n	3756 <_pm_get_apbb_index+0x3e>
	} else if ((uint32_t)module == (uint32_t)DSU) {
    372e:	687b      	ldr	r3, [r7, #4]
    3730:	4a0b      	ldr	r2, [pc, #44]	; (3760 <_pm_get_apbb_index+0x48>)
    3732:	4293      	cmp	r3, r2
    3734:	d101      	bne.n	373a <_pm_get_apbb_index+0x22>
		return 1;
    3736:	2301      	movs	r3, #1
    3738:	e00d      	b.n	3756 <_pm_get_apbb_index+0x3e>
	} else if ((uint32_t)module == (uint32_t)NVMCTRL) {
    373a:	687b      	ldr	r3, [r7, #4]
    373c:	4a09      	ldr	r2, [pc, #36]	; (3764 <_pm_get_apbb_index+0x4c>)
    373e:	4293      	cmp	r3, r2
    3740:	d101      	bne.n	3746 <_pm_get_apbb_index+0x2e>
		return 2;
    3742:	2302      	movs	r3, #2
    3744:	e007      	b.n	3756 <_pm_get_apbb_index+0x3e>
	}
	if ((uint32_t)module == (uint32_t)PORT) {
    3746:	687b      	ldr	r3, [r7, #4]
    3748:	4a07      	ldr	r2, [pc, #28]	; (3768 <_pm_get_apbb_index+0x50>)
    374a:	4293      	cmp	r3, r2
    374c:	d101      	bne.n	3752 <_pm_get_apbb_index+0x3a>
		return 3;
    374e:	2303      	movs	r3, #3
    3750:	e001      	b.n	3756 <_pm_get_apbb_index+0x3e>
	}

	return ERR_INVALID_ARG;
    3752:	230d      	movs	r3, #13
    3754:	425b      	negs	r3, r3
}
    3756:	0018      	movs	r0, r3
    3758:	46bd      	mov	sp, r7
    375a:	b002      	add	sp, #8
    375c:	bd80      	pop	{r7, pc}
    375e:	46c0      	nop			; (mov r8, r8)
    3760:	41002000 	.word	0x41002000
    3764:	41004000 	.word	0x41004000
    3768:	41004400 	.word	0x41004400

0000376c <_pm_enable_bus_clock>:
 *
 * \param[in] bus A bus to enable clock on
 * \param[in] module A hardware module to enable clock for
 */
static inline void _pm_enable_bus_clock(const enum _pm_bus bus, const void *const module)
{
    376c:	b580      	push	{r7, lr}
    376e:	b084      	sub	sp, #16
    3770:	af00      	add	r7, sp, #0
    3772:	0002      	movs	r2, r0
    3774:	6039      	str	r1, [r7, #0]
    3776:	1dfb      	adds	r3, r7, #7
    3778:	701a      	strb	r2, [r3, #0]
	uint32_t peripheral = ((uint32_t)module & 0x0000ff00) >> 10;
    377a:	683b      	ldr	r3, [r7, #0]
    377c:	0a9b      	lsrs	r3, r3, #10
    377e:	223f      	movs	r2, #63	; 0x3f
    3780:	4013      	ands	r3, r2
    3782:	60fb      	str	r3, [r7, #12]

	switch (bus) {
    3784:	1dfb      	adds	r3, r7, #7
    3786:	781b      	ldrb	r3, [r3, #0]
    3788:	2b01      	cmp	r3, #1
    378a:	d01e      	beq.n	37ca <_pm_enable_bus_clock+0x5e>
    378c:	dc02      	bgt.n	3794 <_pm_enable_bus_clock+0x28>
    378e:	2b00      	cmp	r3, #0
    3790:	d005      	beq.n	379e <_pm_enable_bus_clock+0x32>
    3792:	e044      	b.n	381e <_pm_enable_bus_clock+0xb2>
    3794:	2b02      	cmp	r3, #2
    3796:	d022      	beq.n	37de <_pm_enable_bus_clock+0x72>
    3798:	2b03      	cmp	r3, #3
    379a:	d036      	beq.n	380a <_pm_enable_bus_clock+0x9e>
    379c:	e03f      	b.n	381e <_pm_enable_bus_clock+0xb2>
	case PM_BUS_AHB:
		if (_pm_get_ahb_index(module) >= 0) {
    379e:	683b      	ldr	r3, [r7, #0]
    37a0:	0018      	movs	r0, r3
    37a2:	f7ff ff8f 	bl	36c4 <_pm_get_ahb_index>
    37a6:	1e03      	subs	r3, r0, #0
    37a8:	db40      	blt.n	382c <_pm_enable_bus_clock+0xc0>
			peripheral = (uint32_t)_pm_get_ahb_index(module);
    37aa:	683b      	ldr	r3, [r7, #0]
    37ac:	0018      	movs	r0, r3
    37ae:	f7ff ff89 	bl	36c4 <_pm_get_ahb_index>
    37b2:	0003      	movs	r3, r0
    37b4:	60fb      	str	r3, [r7, #12]
			PM->AHBMASK.reg |= 1 << peripheral;
    37b6:	4b21      	ldr	r3, [pc, #132]	; (383c <_pm_enable_bus_clock+0xd0>)
    37b8:	4a20      	ldr	r2, [pc, #128]	; (383c <_pm_enable_bus_clock+0xd0>)
    37ba:	6952      	ldr	r2, [r2, #20]
    37bc:	2001      	movs	r0, #1
    37be:	68f9      	ldr	r1, [r7, #12]
    37c0:	4088      	lsls	r0, r1
    37c2:	0001      	movs	r1, r0
    37c4:	430a      	orrs	r2, r1
    37c6:	615a      	str	r2, [r3, #20]
		}
		break;
    37c8:	e030      	b.n	382c <_pm_enable_bus_clock+0xc0>
	case PM_BUS_APBA:
		PM->APBAMASK.reg |= 1 << peripheral;
    37ca:	4b1c      	ldr	r3, [pc, #112]	; (383c <_pm_enable_bus_clock+0xd0>)
    37cc:	4a1b      	ldr	r2, [pc, #108]	; (383c <_pm_enable_bus_clock+0xd0>)
    37ce:	6992      	ldr	r2, [r2, #24]
    37d0:	2001      	movs	r0, #1
    37d2:	68f9      	ldr	r1, [r7, #12]
    37d4:	4088      	lsls	r0, r1
    37d6:	0001      	movs	r1, r0
    37d8:	430a      	orrs	r2, r1
    37da:	619a      	str	r2, [r3, #24]
		break;
    37dc:	e029      	b.n	3832 <_pm_enable_bus_clock+0xc6>
	case PM_BUS_APBB:
		if (_pm_get_apbb_index(module) >= 0) {
    37de:	683b      	ldr	r3, [r7, #0]
    37e0:	0018      	movs	r0, r3
    37e2:	f7ff ff99 	bl	3718 <_pm_get_apbb_index>
    37e6:	1e03      	subs	r3, r0, #0
    37e8:	db22      	blt.n	3830 <_pm_enable_bus_clock+0xc4>
			peripheral = (uint32_t)_pm_get_apbb_index(module);
    37ea:	683b      	ldr	r3, [r7, #0]
    37ec:	0018      	movs	r0, r3
    37ee:	f7ff ff93 	bl	3718 <_pm_get_apbb_index>
    37f2:	0003      	movs	r3, r0
    37f4:	60fb      	str	r3, [r7, #12]
			PM->APBBMASK.reg |= 1 << peripheral;
    37f6:	4b11      	ldr	r3, [pc, #68]	; (383c <_pm_enable_bus_clock+0xd0>)
    37f8:	4a10      	ldr	r2, [pc, #64]	; (383c <_pm_enable_bus_clock+0xd0>)
    37fa:	69d2      	ldr	r2, [r2, #28]
    37fc:	2001      	movs	r0, #1
    37fe:	68f9      	ldr	r1, [r7, #12]
    3800:	4088      	lsls	r0, r1
    3802:	0001      	movs	r1, r0
    3804:	430a      	orrs	r2, r1
    3806:	61da      	str	r2, [r3, #28]
		}
		break;
    3808:	e012      	b.n	3830 <_pm_enable_bus_clock+0xc4>
	case PM_BUS_APBC:
		PM->APBCMASK.reg |= 1 << peripheral;
    380a:	4b0c      	ldr	r3, [pc, #48]	; (383c <_pm_enable_bus_clock+0xd0>)
    380c:	4a0b      	ldr	r2, [pc, #44]	; (383c <_pm_enable_bus_clock+0xd0>)
    380e:	6a12      	ldr	r2, [r2, #32]
    3810:	2001      	movs	r0, #1
    3812:	68f9      	ldr	r1, [r7, #12]
    3814:	4088      	lsls	r0, r1
    3816:	0001      	movs	r1, r0
    3818:	430a      	orrs	r2, r1
    381a:	621a      	str	r2, [r3, #32]
		break;
    381c:	e009      	b.n	3832 <_pm_enable_bus_clock+0xc6>
	default:
		ASSERT(false);
    381e:	4b08      	ldr	r3, [pc, #32]	; (3840 <_pm_enable_bus_clock+0xd4>)
    3820:	228d      	movs	r2, #141	; 0x8d
    3822:	0019      	movs	r1, r3
    3824:	2000      	movs	r0, #0
    3826:	f000 fd7b 	bl	4320 <assert>
		break;
    382a:	e002      	b.n	3832 <_pm_enable_bus_clock+0xc6>
		break;
    382c:	46c0      	nop			; (mov r8, r8)
    382e:	e000      	b.n	3832 <_pm_enable_bus_clock+0xc6>
		break;
    3830:	46c0      	nop			; (mov r8, r8)
	}
}
    3832:	46c0      	nop			; (mov r8, r8)
    3834:	46bd      	mov	sp, r7
    3836:	b004      	add	sp, #16
    3838:	bd80      	pop	{r7, pc}
    383a:	46c0      	nop			; (mov r8, r8)
    383c:	40000400 	.word	0x40000400
    3840:	00008a6c 	.word	0x00008a6c

00003844 <EXTERNAL_IRQ_0_init>:
struct usart_sync_descriptor DEBUG_SERIAL;

//struct i2c_m_sync_desc EXT_I2C;

void EXTERNAL_IRQ_0_init(void)
{
    3844:	b580      	push	{r7, lr}
    3846:	af00      	add	r7, sp, #0
	_gclk_enable_channel(EIC_GCLK_ID, CONF_GCLK_EIC_SRC);
    3848:	2100      	movs	r1, #0
    384a:	2003      	movs	r0, #3
    384c:	f7ff ff10 	bl	3670 <_gclk_enable_channel>

	// Set pin direction to input
	gpio_set_pin_direction(BTN, GPIO_DIRECTION_IN);
    3850:	2101      	movs	r1, #1
    3852:	2021      	movs	r0, #33	; 0x21
    3854:	f7ff feca 	bl	35ec <gpio_set_pin_direction>

	gpio_set_pin_pull_mode(BTN,
    3858:	2100      	movs	r1, #0
    385a:	2021      	movs	r0, #33	; 0x21
    385c:	f7ff fe9c 	bl	3598 <gpio_set_pin_pull_mode>
	                       // <GPIO_PULL_OFF"> Off
	                       // <GPIO_PULL_UP"> Pull-up
	                       // <GPIO_PULL_DOWN"> Pull-down
	                       GPIO_PULL_OFF);

	gpio_set_pin_function(BTN, PINMUX_PB01A_EIC_EXTINT1);
    3860:	2384      	movs	r3, #132	; 0x84
    3862:	039b      	lsls	r3, r3, #14
    3864:	0019      	movs	r1, r3
    3866:	2021      	movs	r0, #33	; 0x21
    3868:	f7ff feb1 	bl	35ce <gpio_set_pin_function>

	// Set pin direction to input
	gpio_set_pin_direction(RTC_IRQ, GPIO_DIRECTION_IN);
    386c:	2101      	movs	r1, #1
    386e:	200a      	movs	r0, #10
    3870:	f7ff febc 	bl	35ec <gpio_set_pin_direction>

	gpio_set_pin_pull_mode(RTC_IRQ,
    3874:	2100      	movs	r1, #0
    3876:	200a      	movs	r0, #10
    3878:	f7ff fe8e 	bl	3598 <gpio_set_pin_pull_mode>
	                       // <GPIO_PULL_OFF"> Off
	                       // <GPIO_PULL_UP"> Pull-up
	                       // <GPIO_PULL_DOWN"> Pull-down
	                       GPIO_PULL_OFF);

	gpio_set_pin_function(RTC_IRQ, PINMUX_PA10A_EIC_EXTINT10);
    387c:	23a0      	movs	r3, #160	; 0xa0
    387e:	031b      	lsls	r3, r3, #12
    3880:	0019      	movs	r1, r3
    3882:	200a      	movs	r0, #10
    3884:	f7ff fea3 	bl	35ce <gpio_set_pin_function>

	// Set pin direction to input
	

	ext_irq_init();
    3888:	f000 f8b8 	bl	39fc <ext_irq_init>
}
    388c:	46c0      	nop			; (mov r8, r8)
    388e:	46bd      	mov	sp, r7
    3890:	bd80      	pop	{r7, pc}
	...

00003894 <DEBUG_SERIAL_PORT_init>:
	//spi_m_sync_init(&RF_SPI, SERCOM1);
	//RF_SPI_PORT_init();
//}

void DEBUG_SERIAL_PORT_init(void)
{
    3894:	b580      	push	{r7, lr}
    3896:	af00      	add	r7, sp, #0
	gpio_set_pin_function(PA16, PINMUX_PA16D_SERCOM3_PAD0);
    3898:	4b06      	ldr	r3, [pc, #24]	; (38b4 <DEBUG_SERIAL_PORT_init+0x20>)
    389a:	0019      	movs	r1, r3
    389c:	2010      	movs	r0, #16
    389e:	f7ff fe96 	bl	35ce <gpio_set_pin_function>
	gpio_set_pin_function(PA17, PINMUX_PA17D_SERCOM3_PAD1);
    38a2:	4b05      	ldr	r3, [pc, #20]	; (38b8 <DEBUG_SERIAL_PORT_init+0x24>)
    38a4:	0019      	movs	r1, r3
    38a6:	2011      	movs	r0, #17
    38a8:	f7ff fe91 	bl	35ce <gpio_set_pin_function>
}
    38ac:	46c0      	nop			; (mov r8, r8)
    38ae:	46bd      	mov	sp, r7
    38b0:	bd80      	pop	{r7, pc}
    38b2:	46c0      	nop			; (mov r8, r8)
    38b4:	00100003 	.word	0x00100003
    38b8:	00110003 	.word	0x00110003

000038bc <DEBUG_SERIAL_CLOCK_init>:

void DEBUG_SERIAL_CLOCK_init(void)
{
    38bc:	b580      	push	{r7, lr}
    38be:	af00      	add	r7, sp, #0
	_pm_enable_bus_clock(PM_BUS_APBC, SERCOM3);
    38c0:	4b05      	ldr	r3, [pc, #20]	; (38d8 <DEBUG_SERIAL_CLOCK_init+0x1c>)
    38c2:	0019      	movs	r1, r3
    38c4:	2003      	movs	r0, #3
    38c6:	f7ff ff51 	bl	376c <_pm_enable_bus_clock>
	_gclk_enable_channel(SERCOM3_GCLK_ID_CORE, CONF_GCLK_SERCOM3_CORE_SRC);
    38ca:	2100      	movs	r1, #0
    38cc:	2010      	movs	r0, #16
    38ce:	f7ff fecf 	bl	3670 <_gclk_enable_channel>
}
    38d2:	46c0      	nop			; (mov r8, r8)
    38d4:	46bd      	mov	sp, r7
    38d6:	bd80      	pop	{r7, pc}
    38d8:	42001400 	.word	0x42001400

000038dc <DEBUG_SERIAL_init>:

void DEBUG_SERIAL_init(void)
{
    38dc:	b580      	push	{r7, lr}
    38de:	af00      	add	r7, sp, #0
	DEBUG_SERIAL_CLOCK_init();
    38e0:	f7ff ffec 	bl	38bc <DEBUG_SERIAL_CLOCK_init>
	usart_sync_init(&DEBUG_SERIAL, SERCOM3, (void *)NULL);
    38e4:	4905      	ldr	r1, [pc, #20]	; (38fc <DEBUG_SERIAL_init+0x20>)
    38e6:	4b06      	ldr	r3, [pc, #24]	; (3900 <DEBUG_SERIAL_init+0x24>)
    38e8:	2200      	movs	r2, #0
    38ea:	0018      	movs	r0, r3
    38ec:	f000 fc36 	bl	415c <usart_sync_init>
	DEBUG_SERIAL_PORT_init();
    38f0:	f7ff ffd0 	bl	3894 <DEBUG_SERIAL_PORT_init>
}
    38f4:	46c0      	nop			; (mov r8, r8)
    38f6:	46bd      	mov	sp, r7
    38f8:	bd80      	pop	{r7, pc}
    38fa:	46c0      	nop			; (mov r8, r8)
    38fc:	42001400 	.word	0x42001400
    3900:	200007dc 	.word	0x200007dc

00003904 <delay_driver_init>:




void delay_driver_init(void)
{
    3904:	b580      	push	{r7, lr}
    3906:	af00      	add	r7, sp, #0
	delay_init(SysTick);
    3908:	4b03      	ldr	r3, [pc, #12]	; (3918 <delay_driver_init+0x14>)
    390a:	0018      	movs	r0, r3
    390c:	f000 f84c 	bl	39a8 <delay_init>
}
    3910:	46c0      	nop			; (mov r8, r8)
    3912:	46bd      	mov	sp, r7
    3914:	bd80      	pop	{r7, pc}
    3916:	46c0      	nop			; (mov r8, r8)
    3918:	e000e010 	.word	0xe000e010

0000391c <system_init>:

void system_init(void)
{
    391c:	b580      	push	{r7, lr}
    391e:	af00      	add	r7, sp, #0
	init_mcu();
    3920:	f7ff fe9e 	bl	3660 <init_mcu>


	gpio_set_pin_level(LED_G, false);
    3924:	2100      	movs	r1, #0
    3926:	2020      	movs	r0, #32
    3928:	f7ff fe7d 	bl	3626 <gpio_set_pin_level>
	gpio_set_pin_direction(LED_G, GPIO_DIRECTION_OUT);
    392c:	2102      	movs	r1, #2
    392e:	2020      	movs	r0, #32
    3930:	f7ff fe5c 	bl	35ec <gpio_set_pin_direction>
	gpio_set_pin_function(LED_G, GPIO_PIN_FUNCTION_OFF);
    3934:	2301      	movs	r3, #1
    3936:	425b      	negs	r3, r3
    3938:	0019      	movs	r1, r3
    393a:	2020      	movs	r0, #32
    393c:	f7ff fe47 	bl	35ce <gpio_set_pin_function>

	gpio_set_pin_level(IO4,
    3940:	2100      	movs	r1, #0
    3942:	2027      	movs	r0, #39	; 0x27
    3944:	f7ff fe6f 	bl	3626 <gpio_set_pin_level>
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(IO4, GPIO_DIRECTION_OUT);
    3948:	2102      	movs	r1, #2
    394a:	2027      	movs	r0, #39	; 0x27
    394c:	f7ff fe4e 	bl	35ec <gpio_set_pin_direction>
	gpio_set_pin_function(IO4, GPIO_PIN_FUNCTION_OFF);
    3950:	2301      	movs	r3, #1
    3952:	425b      	negs	r3, r3
    3954:	0019      	movs	r1, r3
    3956:	2027      	movs	r0, #39	; 0x27
    3958:	f7ff fe39 	bl	35ce <gpio_set_pin_function>


	gpio_set_pin_level(IO3,
    395c:	2100      	movs	r1, #0
    395e:	2028      	movs	r0, #40	; 0x28
    3960:	f7ff fe61 	bl	3626 <gpio_set_pin_level>
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(IO3, GPIO_DIRECTION_OUT);
    3964:	2102      	movs	r1, #2
    3966:	2028      	movs	r0, #40	; 0x28
    3968:	f7ff fe40 	bl	35ec <gpio_set_pin_direction>
	gpio_set_pin_function(IO3, GPIO_PIN_FUNCTION_OFF);
    396c:	2301      	movs	r3, #1
    396e:	425b      	negs	r3, r3
    3970:	0019      	movs	r1, r3
    3972:	2028      	movs	r0, #40	; 0x28
    3974:	f7ff fe2b 	bl	35ce <gpio_set_pin_function>
	// GPIO on PB31

	gpio_set_pin_level(LED_R,
    3978:	2101      	movs	r1, #1
    397a:	203f      	movs	r0, #63	; 0x3f
    397c:	f7ff fe53 	bl	3626 <gpio_set_pin_level>
	                   // <false"> Low
	                   // <true"> High
	                   true);

	// Set pin direction to output
	gpio_set_pin_direction(LED_R, GPIO_DIRECTION_OUT);
    3980:	2102      	movs	r1, #2
    3982:	203f      	movs	r0, #63	; 0x3f
    3984:	f7ff fe32 	bl	35ec <gpio_set_pin_direction>

	gpio_set_pin_function(LED_R, GPIO_PIN_FUNCTION_OFF);
    3988:	2301      	movs	r3, #1
    398a:	425b      	negs	r3, r3
    398c:	0019      	movs	r1, r3
    398e:	203f      	movs	r0, #63	; 0x3f
    3990:	f7ff fe1d 	bl	35ce <gpio_set_pin_function>

	EXTERNAL_IRQ_0_init();
    3994:	f7ff ff56 	bl	3844 <EXTERNAL_IRQ_0_init>

	//EXT_SPI_init();

	//RF_SPI_init();

	DEBUG_SERIAL_init();
    3998:	f7ff ffa0 	bl	38dc <DEBUG_SERIAL_init>

	delay_driver_init();
    399c:	f7ff ffb2 	bl	3904 <delay_driver_init>
}
    39a0:	46c0      	nop			; (mov r8, r8)
    39a2:	46bd      	mov	sp, r7
    39a4:	bd80      	pop	{r7, pc}
	...

000039a8 <delay_init>:

/**
 * \brief Initialize Delay driver
 */
void delay_init(void *const hw)
{
    39a8:	b580      	push	{r7, lr}
    39aa:	b082      	sub	sp, #8
    39ac:	af00      	add	r7, sp, #0
    39ae:	6078      	str	r0, [r7, #4]
	_delay_init(hardware = hw);
    39b0:	4b05      	ldr	r3, [pc, #20]	; (39c8 <delay_init+0x20>)
    39b2:	687a      	ldr	r2, [r7, #4]
    39b4:	601a      	str	r2, [r3, #0]
    39b6:	4b04      	ldr	r3, [pc, #16]	; (39c8 <delay_init+0x20>)
    39b8:	681b      	ldr	r3, [r3, #0]
    39ba:	0018      	movs	r0, r3
    39bc:	f002 fcfc 	bl	63b8 <_delay_init>
}
    39c0:	46c0      	nop			; (mov r8, r8)
    39c2:	46bd      	mov	sp, r7
    39c4:	b002      	add	sp, #8
    39c6:	bd80      	pop	{r7, pc}
    39c8:	200007ac 	.word	0x200007ac

000039cc <delay_ms>:

/**
 * \brief Perform delay in ms
 */
void delay_ms(const uint16_t ms)
{
    39cc:	b590      	push	{r4, r7, lr}
    39ce:	b083      	sub	sp, #12
    39d0:	af00      	add	r7, sp, #0
    39d2:	0002      	movs	r2, r0
    39d4:	1dbb      	adds	r3, r7, #6
    39d6:	801a      	strh	r2, [r3, #0]
	_delay_cycles(hardware, _get_cycles_for_ms(ms));
    39d8:	4b07      	ldr	r3, [pc, #28]	; (39f8 <delay_ms+0x2c>)
    39da:	681c      	ldr	r4, [r3, #0]
    39dc:	1dbb      	adds	r3, r7, #6
    39de:	881b      	ldrh	r3, [r3, #0]
    39e0:	0018      	movs	r0, r3
    39e2:	f000 fd45 	bl	4470 <_get_cycles_for_ms>
    39e6:	0003      	movs	r3, r0
    39e8:	0019      	movs	r1, r3
    39ea:	0020      	movs	r0, r4
    39ec:	f002 fcf0 	bl	63d0 <_delay_cycles>
}
    39f0:	46c0      	nop			; (mov r8, r8)
    39f2:	46bd      	mov	sp, r7
    39f4:	b003      	add	sp, #12
    39f6:	bd90      	pop	{r4, r7, pc}
    39f8:	200007ac 	.word	0x200007ac

000039fc <ext_irq_init>:

/**
 * \brief Initialize external irq component if any
 */
int32_t ext_irq_init(void)
{
    39fc:	b580      	push	{r7, lr}
    39fe:	b082      	sub	sp, #8
    3a00:	af00      	add	r7, sp, #0
	uint16_t i;

	for (i = 0; i < EXT_IRQ_AMOUNT; i++) {
    3a02:	1dbb      	adds	r3, r7, #6
    3a04:	2200      	movs	r2, #0
    3a06:	801a      	strh	r2, [r3, #0]
    3a08:	e013      	b.n	3a32 <ext_irq_init+0x36>
		ext_irqs[i].pin = 0xFFFFFFFF;
    3a0a:	1dbb      	adds	r3, r7, #6
    3a0c:	881b      	ldrh	r3, [r3, #0]
    3a0e:	4a0f      	ldr	r2, [pc, #60]	; (3a4c <ext_irq_init+0x50>)
    3a10:	00db      	lsls	r3, r3, #3
    3a12:	18d3      	adds	r3, r2, r3
    3a14:	3304      	adds	r3, #4
    3a16:	2201      	movs	r2, #1
    3a18:	4252      	negs	r2, r2
    3a1a:	601a      	str	r2, [r3, #0]
		ext_irqs[i].cb  = NULL;
    3a1c:	1dbb      	adds	r3, r7, #6
    3a1e:	881a      	ldrh	r2, [r3, #0]
    3a20:	4b0a      	ldr	r3, [pc, #40]	; (3a4c <ext_irq_init+0x50>)
    3a22:	00d2      	lsls	r2, r2, #3
    3a24:	2100      	movs	r1, #0
    3a26:	50d1      	str	r1, [r2, r3]
	for (i = 0; i < EXT_IRQ_AMOUNT; i++) {
    3a28:	1dbb      	adds	r3, r7, #6
    3a2a:	881a      	ldrh	r2, [r3, #0]
    3a2c:	1dbb      	adds	r3, r7, #6
    3a2e:	3201      	adds	r2, #1
    3a30:	801a      	strh	r2, [r3, #0]
    3a32:	1dbb      	adds	r3, r7, #6
    3a34:	881b      	ldrh	r3, [r3, #0]
    3a36:	2b02      	cmp	r3, #2
    3a38:	d9e7      	bls.n	3a0a <ext_irq_init+0xe>
	}

	return _ext_irq_init(process_ext_irq);
    3a3a:	4b05      	ldr	r3, [pc, #20]	; (3a50 <ext_irq_init+0x54>)
    3a3c:	0018      	movs	r0, r3
    3a3e:	f000 fe77 	bl	4730 <_ext_irq_init>
    3a42:	0003      	movs	r3, r0
}
    3a44:	0018      	movs	r0, r3
    3a46:	46bd      	mov	sp, r7
    3a48:	b002      	add	sp, #8
    3a4a:	bd80      	pop	{r7, pc}
    3a4c:	200007b0 	.word	0x200007b0
    3a50:	00003c29 	.word	0x00003c29

00003a54 <ext_irq_register>:

/**
 * \brief Register callback for the given external interrupt
 */
int32_t ext_irq_register(const uint32_t pin, ext_irq_cb_t cb)
{
    3a54:	b580      	push	{r7, lr}
    3a56:	b086      	sub	sp, #24
    3a58:	af00      	add	r7, sp, #0
    3a5a:	6078      	str	r0, [r7, #4]
    3a5c:	6039      	str	r1, [r7, #0]
	uint8_t i = 0, j = 0;
    3a5e:	2317      	movs	r3, #23
    3a60:	18fb      	adds	r3, r7, r3
    3a62:	2200      	movs	r2, #0
    3a64:	701a      	strb	r2, [r3, #0]
    3a66:	2316      	movs	r3, #22
    3a68:	18fb      	adds	r3, r7, r3
    3a6a:	2200      	movs	r2, #0
    3a6c:	701a      	strb	r2, [r3, #0]
	bool    found = false;
    3a6e:	2315      	movs	r3, #21
    3a70:	18fb      	adds	r3, r7, r3
    3a72:	2200      	movs	r2, #0
    3a74:	701a      	strb	r2, [r3, #0]

	for (; i < EXT_IRQ_AMOUNT; i++) {
    3a76:	e01d      	b.n	3ab4 <ext_irq_register+0x60>
		if (ext_irqs[i].pin == pin) {
    3a78:	2317      	movs	r3, #23
    3a7a:	18fb      	adds	r3, r7, r3
    3a7c:	781b      	ldrb	r3, [r3, #0]
    3a7e:	4a69      	ldr	r2, [pc, #420]	; (3c24 <ext_irq_register+0x1d0>)
    3a80:	00db      	lsls	r3, r3, #3
    3a82:	18d3      	adds	r3, r2, r3
    3a84:	3304      	adds	r3, #4
    3a86:	681a      	ldr	r2, [r3, #0]
    3a88:	687b      	ldr	r3, [r7, #4]
    3a8a:	429a      	cmp	r2, r3
    3a8c:	d10b      	bne.n	3aa6 <ext_irq_register+0x52>
			ext_irqs[i].cb = cb;
    3a8e:	2317      	movs	r3, #23
    3a90:	18fb      	adds	r3, r7, r3
    3a92:	781a      	ldrb	r2, [r3, #0]
    3a94:	4b63      	ldr	r3, [pc, #396]	; (3c24 <ext_irq_register+0x1d0>)
    3a96:	00d2      	lsls	r2, r2, #3
    3a98:	6839      	ldr	r1, [r7, #0]
    3a9a:	50d1      	str	r1, [r2, r3]
			found          = true;
    3a9c:	2315      	movs	r3, #21
    3a9e:	18fb      	adds	r3, r7, r3
    3aa0:	2201      	movs	r2, #1
    3aa2:	701a      	strb	r2, [r3, #0]
			break;
    3aa4:	e00b      	b.n	3abe <ext_irq_register+0x6a>
	for (; i < EXT_IRQ_AMOUNT; i++) {
    3aa6:	2317      	movs	r3, #23
    3aa8:	18fb      	adds	r3, r7, r3
    3aaa:	781a      	ldrb	r2, [r3, #0]
    3aac:	2317      	movs	r3, #23
    3aae:	18fb      	adds	r3, r7, r3
    3ab0:	3201      	adds	r2, #1
    3ab2:	701a      	strb	r2, [r3, #0]
    3ab4:	2317      	movs	r3, #23
    3ab6:	18fb      	adds	r3, r7, r3
    3ab8:	781b      	ldrb	r3, [r3, #0]
    3aba:	2b02      	cmp	r3, #2
    3abc:	d9dc      	bls.n	3a78 <ext_irq_register+0x24>
		}
	}

	if (NULL == cb) {
    3abe:	683b      	ldr	r3, [r7, #0]
    3ac0:	2b00      	cmp	r3, #0
    3ac2:	d111      	bne.n	3ae8 <ext_irq_register+0x94>
		if (!found) {
    3ac4:	2315      	movs	r3, #21
    3ac6:	18fb      	adds	r3, r7, r3
    3ac8:	781b      	ldrb	r3, [r3, #0]
    3aca:	2201      	movs	r2, #1
    3acc:	4053      	eors	r3, r2
    3ace:	b2db      	uxtb	r3, r3
    3ad0:	2b00      	cmp	r3, #0
    3ad2:	d002      	beq.n	3ada <ext_irq_register+0x86>
			return ERR_INVALID_ARG;
    3ad4:	230d      	movs	r3, #13
    3ad6:	425b      	negs	r3, r3
    3ad8:	e09f      	b.n	3c1a <ext_irq_register+0x1c6>
		}
		return _ext_irq_enable(pin, false);
    3ada:	687b      	ldr	r3, [r7, #4]
    3adc:	2100      	movs	r1, #0
    3ade:	0018      	movs	r0, r3
    3ae0:	f000 fe82 	bl	47e8 <_ext_irq_enable>
    3ae4:	0003      	movs	r3, r0
    3ae6:	e098      	b.n	3c1a <ext_irq_register+0x1c6>
	}

	if (!found) {
    3ae8:	2315      	movs	r3, #21
    3aea:	18fb      	adds	r3, r7, r3
    3aec:	781b      	ldrb	r3, [r3, #0]
    3aee:	2201      	movs	r2, #1
    3af0:	4053      	eors	r3, r2
    3af2:	b2db      	uxtb	r3, r3
    3af4:	2b00      	cmp	r3, #0
    3af6:	d100      	bne.n	3afa <ext_irq_register+0xa6>
    3af8:	e07e      	b.n	3bf8 <ext_irq_register+0x1a4>
		for (i = 0; i < EXT_IRQ_AMOUNT; i++) {
    3afa:	2317      	movs	r3, #23
    3afc:	18fb      	adds	r3, r7, r3
    3afe:	2200      	movs	r2, #0
    3b00:	701a      	strb	r2, [r3, #0]
    3b02:	e023      	b.n	3b4c <ext_irq_register+0xf8>
			if (NULL == ext_irqs[i].cb) {
    3b04:	2317      	movs	r3, #23
    3b06:	18fb      	adds	r3, r7, r3
    3b08:	781a      	ldrb	r2, [r3, #0]
    3b0a:	4b46      	ldr	r3, [pc, #280]	; (3c24 <ext_irq_register+0x1d0>)
    3b0c:	00d2      	lsls	r2, r2, #3
    3b0e:	58d3      	ldr	r3, [r2, r3]
    3b10:	2b00      	cmp	r3, #0
    3b12:	d114      	bne.n	3b3e <ext_irq_register+0xea>
				ext_irqs[i].cb  = cb;
    3b14:	2317      	movs	r3, #23
    3b16:	18fb      	adds	r3, r7, r3
    3b18:	781a      	ldrb	r2, [r3, #0]
    3b1a:	4b42      	ldr	r3, [pc, #264]	; (3c24 <ext_irq_register+0x1d0>)
    3b1c:	00d2      	lsls	r2, r2, #3
    3b1e:	6839      	ldr	r1, [r7, #0]
    3b20:	50d1      	str	r1, [r2, r3]
				ext_irqs[i].pin = pin;
    3b22:	2317      	movs	r3, #23
    3b24:	18fb      	adds	r3, r7, r3
    3b26:	781b      	ldrb	r3, [r3, #0]
    3b28:	4a3e      	ldr	r2, [pc, #248]	; (3c24 <ext_irq_register+0x1d0>)
    3b2a:	00db      	lsls	r3, r3, #3
    3b2c:	18d3      	adds	r3, r2, r3
    3b2e:	3304      	adds	r3, #4
    3b30:	687a      	ldr	r2, [r7, #4]
    3b32:	601a      	str	r2, [r3, #0]
				found           = true;
    3b34:	2315      	movs	r3, #21
    3b36:	18fb      	adds	r3, r7, r3
    3b38:	2201      	movs	r2, #1
    3b3a:	701a      	strb	r2, [r3, #0]
				break;
    3b3c:	e00b      	b.n	3b56 <ext_irq_register+0x102>
		for (i = 0; i < EXT_IRQ_AMOUNT; i++) {
    3b3e:	2317      	movs	r3, #23
    3b40:	18fb      	adds	r3, r7, r3
    3b42:	781a      	ldrb	r2, [r3, #0]
    3b44:	2317      	movs	r3, #23
    3b46:	18fb      	adds	r3, r7, r3
    3b48:	3201      	adds	r2, #1
    3b4a:	701a      	strb	r2, [r3, #0]
    3b4c:	2317      	movs	r3, #23
    3b4e:	18fb      	adds	r3, r7, r3
    3b50:	781b      	ldrb	r3, [r3, #0]
    3b52:	2b02      	cmp	r3, #2
    3b54:	d9d6      	bls.n	3b04 <ext_irq_register+0xb0>
			}
		}
		for (; (j < EXT_IRQ_AMOUNT) && (i < EXT_IRQ_AMOUNT); j++) {
    3b56:	e045      	b.n	3be4 <ext_irq_register+0x190>
			if ((ext_irqs[i].pin < ext_irqs[j].pin) && (ext_irqs[j].pin != 0xFFFFFFFF)) {
    3b58:	2317      	movs	r3, #23
    3b5a:	18fb      	adds	r3, r7, r3
    3b5c:	781b      	ldrb	r3, [r3, #0]
    3b5e:	4a31      	ldr	r2, [pc, #196]	; (3c24 <ext_irq_register+0x1d0>)
    3b60:	00db      	lsls	r3, r3, #3
    3b62:	18d3      	adds	r3, r2, r3
    3b64:	3304      	adds	r3, #4
    3b66:	681a      	ldr	r2, [r3, #0]
    3b68:	2316      	movs	r3, #22
    3b6a:	18fb      	adds	r3, r7, r3
    3b6c:	781b      	ldrb	r3, [r3, #0]
    3b6e:	492d      	ldr	r1, [pc, #180]	; (3c24 <ext_irq_register+0x1d0>)
    3b70:	00db      	lsls	r3, r3, #3
    3b72:	18cb      	adds	r3, r1, r3
    3b74:	3304      	adds	r3, #4
    3b76:	681b      	ldr	r3, [r3, #0]
    3b78:	429a      	cmp	r2, r3
    3b7a:	d22c      	bcs.n	3bd6 <ext_irq_register+0x182>
    3b7c:	2316      	movs	r3, #22
    3b7e:	18fb      	adds	r3, r7, r3
    3b80:	781b      	ldrb	r3, [r3, #0]
    3b82:	4a28      	ldr	r2, [pc, #160]	; (3c24 <ext_irq_register+0x1d0>)
    3b84:	00db      	lsls	r3, r3, #3
    3b86:	18d3      	adds	r3, r2, r3
    3b88:	3304      	adds	r3, #4
    3b8a:	681b      	ldr	r3, [r3, #0]
    3b8c:	3301      	adds	r3, #1
    3b8e:	d022      	beq.n	3bd6 <ext_irq_register+0x182>
				struct ext_irq tmp = ext_irqs[j];
    3b90:	2316      	movs	r3, #22
    3b92:	18fb      	adds	r3, r7, r3
    3b94:	781b      	ldrb	r3, [r3, #0]
    3b96:	220c      	movs	r2, #12
    3b98:	18ba      	adds	r2, r7, r2
    3b9a:	4922      	ldr	r1, [pc, #136]	; (3c24 <ext_irq_register+0x1d0>)
    3b9c:	00db      	lsls	r3, r3, #3
    3b9e:	18cb      	adds	r3, r1, r3
    3ba0:	cb03      	ldmia	r3!, {r0, r1}
    3ba2:	c203      	stmia	r2!, {r0, r1}

				ext_irqs[j] = ext_irqs[i];
    3ba4:	2316      	movs	r3, #22
    3ba6:	18fb      	adds	r3, r7, r3
    3ba8:	781b      	ldrb	r3, [r3, #0]
    3baa:	2217      	movs	r2, #23
    3bac:	18ba      	adds	r2, r7, r2
    3bae:	7812      	ldrb	r2, [r2, #0]
    3bb0:	481c      	ldr	r0, [pc, #112]	; (3c24 <ext_irq_register+0x1d0>)
    3bb2:	00db      	lsls	r3, r3, #3
    3bb4:	491b      	ldr	r1, [pc, #108]	; (3c24 <ext_irq_register+0x1d0>)
    3bb6:	00d2      	lsls	r2, r2, #3
    3bb8:	18c3      	adds	r3, r0, r3
    3bba:	188a      	adds	r2, r1, r2
    3bbc:	ca03      	ldmia	r2!, {r0, r1}
    3bbe:	c303      	stmia	r3!, {r0, r1}
				ext_irqs[i] = tmp;
    3bc0:	2317      	movs	r3, #23
    3bc2:	18fb      	adds	r3, r7, r3
    3bc4:	781b      	ldrb	r3, [r3, #0]
    3bc6:	4a17      	ldr	r2, [pc, #92]	; (3c24 <ext_irq_register+0x1d0>)
    3bc8:	00db      	lsls	r3, r3, #3
    3bca:	210c      	movs	r1, #12
    3bcc:	1879      	adds	r1, r7, r1
    3bce:	18d3      	adds	r3, r2, r3
    3bd0:	000a      	movs	r2, r1
    3bd2:	ca03      	ldmia	r2!, {r0, r1}
    3bd4:	c303      	stmia	r3!, {r0, r1}
		for (; (j < EXT_IRQ_AMOUNT) && (i < EXT_IRQ_AMOUNT); j++) {
    3bd6:	2316      	movs	r3, #22
    3bd8:	18fb      	adds	r3, r7, r3
    3bda:	781a      	ldrb	r2, [r3, #0]
    3bdc:	2316      	movs	r3, #22
    3bde:	18fb      	adds	r3, r7, r3
    3be0:	3201      	adds	r2, #1
    3be2:	701a      	strb	r2, [r3, #0]
    3be4:	2316      	movs	r3, #22
    3be6:	18fb      	adds	r3, r7, r3
    3be8:	781b      	ldrb	r3, [r3, #0]
    3bea:	2b02      	cmp	r3, #2
    3bec:	d804      	bhi.n	3bf8 <ext_irq_register+0x1a4>
    3bee:	2317      	movs	r3, #23
    3bf0:	18fb      	adds	r3, r7, r3
    3bf2:	781b      	ldrb	r3, [r3, #0]
    3bf4:	2b02      	cmp	r3, #2
    3bf6:	d9af      	bls.n	3b58 <ext_irq_register+0x104>
			}
		}
	}

	if (!found) {
    3bf8:	2315      	movs	r3, #21
    3bfa:	18fb      	adds	r3, r7, r3
    3bfc:	781b      	ldrb	r3, [r3, #0]
    3bfe:	2201      	movs	r2, #1
    3c00:	4053      	eors	r3, r2
    3c02:	b2db      	uxtb	r3, r3
    3c04:	2b00      	cmp	r3, #0
    3c06:	d002      	beq.n	3c0e <ext_irq_register+0x1ba>
		return ERR_INVALID_ARG;
    3c08:	230d      	movs	r3, #13
    3c0a:	425b      	negs	r3, r3
    3c0c:	e005      	b.n	3c1a <ext_irq_register+0x1c6>
	}

	return _ext_irq_enable(pin, true);
    3c0e:	687b      	ldr	r3, [r7, #4]
    3c10:	2101      	movs	r1, #1
    3c12:	0018      	movs	r0, r3
    3c14:	f000 fde8 	bl	47e8 <_ext_irq_enable>
    3c18:	0003      	movs	r3, r0
}
    3c1a:	0018      	movs	r0, r3
    3c1c:	46bd      	mov	sp, r7
    3c1e:	b006      	add	sp, #24
    3c20:	bd80      	pop	{r7, pc}
    3c22:	46c0      	nop			; (mov r8, r8)
    3c24:	200007b0 	.word	0x200007b0

00003c28 <process_ext_irq>:
 * \brief Interrupt processing routine
 *
 * \param[in] pin The pin which triggered the interrupt
 */
static void process_ext_irq(const uint32_t pin)
{
    3c28:	b580      	push	{r7, lr}
    3c2a:	b084      	sub	sp, #16
    3c2c:	af00      	add	r7, sp, #0
    3c2e:	6078      	str	r0, [r7, #4]
	uint8_t lower = 0, middle, upper = EXT_IRQ_AMOUNT;
    3c30:	230f      	movs	r3, #15
    3c32:	18fb      	adds	r3, r7, r3
    3c34:	2200      	movs	r2, #0
    3c36:	701a      	strb	r2, [r3, #0]
    3c38:	230e      	movs	r3, #14
    3c3a:	18fb      	adds	r3, r7, r3
    3c3c:	2203      	movs	r2, #3
    3c3e:	701a      	strb	r2, [r3, #0]

	while (upper >= lower) {
    3c40:	e050      	b.n	3ce4 <process_ext_irq+0xbc>
		middle = (upper + lower) >> 1;
    3c42:	230e      	movs	r3, #14
    3c44:	18fb      	adds	r3, r7, r3
    3c46:	781a      	ldrb	r2, [r3, #0]
    3c48:	230f      	movs	r3, #15
    3c4a:	18fb      	adds	r3, r7, r3
    3c4c:	781b      	ldrb	r3, [r3, #0]
    3c4e:	18d3      	adds	r3, r2, r3
    3c50:	105a      	asrs	r2, r3, #1
    3c52:	230d      	movs	r3, #13
    3c54:	18fb      	adds	r3, r7, r3
    3c56:	701a      	strb	r2, [r3, #0]
		if (middle >= EXT_IRQ_AMOUNT) {
    3c58:	230d      	movs	r3, #13
    3c5a:	18fb      	adds	r3, r7, r3
    3c5c:	781b      	ldrb	r3, [r3, #0]
    3c5e:	2b02      	cmp	r3, #2
    3c60:	d849      	bhi.n	3cf6 <process_ext_irq+0xce>
			return;
		}

		if (ext_irqs[middle].pin == pin) {
    3c62:	230d      	movs	r3, #13
    3c64:	18fb      	adds	r3, r7, r3
    3c66:	781b      	ldrb	r3, [r3, #0]
    3c68:	4a26      	ldr	r2, [pc, #152]	; (3d04 <process_ext_irq+0xdc>)
    3c6a:	00db      	lsls	r3, r3, #3
    3c6c:	18d3      	adds	r3, r2, r3
    3c6e:	3304      	adds	r3, #4
    3c70:	681a      	ldr	r2, [r3, #0]
    3c72:	687b      	ldr	r3, [r7, #4]
    3c74:	429a      	cmp	r2, r3
    3c76:	d10f      	bne.n	3c98 <process_ext_irq+0x70>
			if (ext_irqs[middle].cb) {
    3c78:	230d      	movs	r3, #13
    3c7a:	18fb      	adds	r3, r7, r3
    3c7c:	781a      	ldrb	r2, [r3, #0]
    3c7e:	4b21      	ldr	r3, [pc, #132]	; (3d04 <process_ext_irq+0xdc>)
    3c80:	00d2      	lsls	r2, r2, #3
    3c82:	58d3      	ldr	r3, [r2, r3]
    3c84:	2b00      	cmp	r3, #0
    3c86:	d038      	beq.n	3cfa <process_ext_irq+0xd2>
				ext_irqs[middle].cb();
    3c88:	230d      	movs	r3, #13
    3c8a:	18fb      	adds	r3, r7, r3
    3c8c:	781a      	ldrb	r2, [r3, #0]
    3c8e:	4b1d      	ldr	r3, [pc, #116]	; (3d04 <process_ext_irq+0xdc>)
    3c90:	00d2      	lsls	r2, r2, #3
    3c92:	58d3      	ldr	r3, [r2, r3]
    3c94:	4798      	blx	r3
			}
			return;
    3c96:	e030      	b.n	3cfa <process_ext_irq+0xd2>
		}

		if (ext_irqs[middle].pin < pin) {
    3c98:	230d      	movs	r3, #13
    3c9a:	18fb      	adds	r3, r7, r3
    3c9c:	781b      	ldrb	r3, [r3, #0]
    3c9e:	4a19      	ldr	r2, [pc, #100]	; (3d04 <process_ext_irq+0xdc>)
    3ca0:	00db      	lsls	r3, r3, #3
    3ca2:	18d3      	adds	r3, r2, r3
    3ca4:	3304      	adds	r3, #4
    3ca6:	681a      	ldr	r2, [r3, #0]
    3ca8:	687b      	ldr	r3, [r7, #4]
    3caa:	429a      	cmp	r2, r3
    3cac:	d20d      	bcs.n	3cca <process_ext_irq+0xa2>
			lower = middle + 1;
    3cae:	230f      	movs	r3, #15
    3cb0:	18fb      	adds	r3, r7, r3
    3cb2:	220d      	movs	r2, #13
    3cb4:	18ba      	adds	r2, r7, r2
    3cb6:	7812      	ldrb	r2, [r2, #0]
    3cb8:	3201      	adds	r2, #1
    3cba:	701a      	strb	r2, [r3, #0]
    3cbc:	230e      	movs	r3, #14
    3cbe:	18fb      	adds	r3, r7, r3
    3cc0:	220e      	movs	r2, #14
    3cc2:	18ba      	adds	r2, r7, r2
    3cc4:	7812      	ldrb	r2, [r2, #0]
    3cc6:	701a      	strb	r2, [r3, #0]
    3cc8:	e00c      	b.n	3ce4 <process_ext_irq+0xbc>
		} else {
			upper = middle - 1;
    3cca:	230e      	movs	r3, #14
    3ccc:	18fb      	adds	r3, r7, r3
    3cce:	220d      	movs	r2, #13
    3cd0:	18ba      	adds	r2, r7, r2
    3cd2:	7812      	ldrb	r2, [r2, #0]
    3cd4:	3a01      	subs	r2, #1
    3cd6:	701a      	strb	r2, [r3, #0]
    3cd8:	230f      	movs	r3, #15
    3cda:	18fb      	adds	r3, r7, r3
    3cdc:	220f      	movs	r2, #15
    3cde:	18ba      	adds	r2, r7, r2
    3ce0:	7812      	ldrb	r2, [r2, #0]
    3ce2:	701a      	strb	r2, [r3, #0]
	while (upper >= lower) {
    3ce4:	230e      	movs	r3, #14
    3ce6:	18fa      	adds	r2, r7, r3
    3ce8:	230f      	movs	r3, #15
    3cea:	18fb      	adds	r3, r7, r3
    3cec:	7812      	ldrb	r2, [r2, #0]
    3cee:	781b      	ldrb	r3, [r3, #0]
    3cf0:	429a      	cmp	r2, r3
    3cf2:	d2a6      	bcs.n	3c42 <process_ext_irq+0x1a>
    3cf4:	e002      	b.n	3cfc <process_ext_irq+0xd4>
			return;
    3cf6:	46c0      	nop			; (mov r8, r8)
    3cf8:	e000      	b.n	3cfc <process_ext_irq+0xd4>
			return;
    3cfa:	46c0      	nop			; (mov r8, r8)
		}
	}
}
    3cfc:	46bd      	mov	sp, r7
    3cfe:	b004      	add	sp, #16
    3d00:	bd80      	pop	{r7, pc}
    3d02:	46c0      	nop			; (mov r8, r8)
    3d04:	200007b0 	.word	0x200007b0

00003d08 <i2c_m_sync_read>:

/**
 * \brief Sync version of I2C I/O read
 */
static int32_t i2c_m_sync_read(struct io_descriptor *io, uint8_t *buf, const uint16_t n)
{
    3d08:	b580      	push	{r7, lr}
    3d0a:	b08a      	sub	sp, #40	; 0x28
    3d0c:	af00      	add	r7, sp, #0
    3d0e:	60f8      	str	r0, [r7, #12]
    3d10:	60b9      	str	r1, [r7, #8]
    3d12:	1dbb      	adds	r3, r7, #6
    3d14:	801a      	strh	r2, [r3, #0]
	struct i2c_m_sync_desc *i2c = CONTAINER_OF(io, struct i2c_m_sync_desc, io);
    3d16:	68fb      	ldr	r3, [r7, #12]
    3d18:	3b14      	subs	r3, #20
    3d1a:	627b      	str	r3, [r7, #36]	; 0x24
	struct _i2c_m_msg       msg;
	int32_t                 ret;

	msg.addr   = i2c->slave_addr;
    3d1c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    3d1e:	8b9a      	ldrh	r2, [r3, #28]
    3d20:	2314      	movs	r3, #20
    3d22:	18fb      	adds	r3, r7, r3
    3d24:	801a      	strh	r2, [r3, #0]
	msg.len    = n;
    3d26:	1dbb      	adds	r3, r7, #6
    3d28:	881a      	ldrh	r2, [r3, #0]
    3d2a:	2314      	movs	r3, #20
    3d2c:	18fb      	adds	r3, r7, r3
    3d2e:	605a      	str	r2, [r3, #4]
	msg.flags  = I2C_M_STOP | I2C_M_RD;
    3d30:	2314      	movs	r3, #20
    3d32:	18fb      	adds	r3, r7, r3
    3d34:	4a0c      	ldr	r2, [pc, #48]	; (3d68 <i2c_m_sync_read+0x60>)
    3d36:	805a      	strh	r2, [r3, #2]
	msg.buffer = buf;
    3d38:	2314      	movs	r3, #20
    3d3a:	18fb      	adds	r3, r7, r3
    3d3c:	68ba      	ldr	r2, [r7, #8]
    3d3e:	609a      	str	r2, [r3, #8]

	ret = _i2c_m_sync_transfer(&i2c->device, &msg);
    3d40:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    3d42:	2214      	movs	r2, #20
    3d44:	18ba      	adds	r2, r7, r2
    3d46:	0011      	movs	r1, r2
    3d48:	0018      	movs	r0, r3
    3d4a:	f001 fdaf 	bl	58ac <_i2c_m_sync_transfer>
    3d4e:	0003      	movs	r3, r0
    3d50:	623b      	str	r3, [r7, #32]

	if (ret) {
    3d52:	6a3b      	ldr	r3, [r7, #32]
    3d54:	2b00      	cmp	r3, #0
    3d56:	d001      	beq.n	3d5c <i2c_m_sync_read+0x54>
		return ret;
    3d58:	6a3b      	ldr	r3, [r7, #32]
    3d5a:	e001      	b.n	3d60 <i2c_m_sync_read+0x58>
	}

	return n;
    3d5c:	1dbb      	adds	r3, r7, #6
    3d5e:	881b      	ldrh	r3, [r3, #0]
}
    3d60:	0018      	movs	r0, r3
    3d62:	46bd      	mov	sp, r7
    3d64:	b00a      	add	sp, #40	; 0x28
    3d66:	bd80      	pop	{r7, pc}
    3d68:	ffff8001 	.word	0xffff8001

00003d6c <i2c_m_sync_write>:

/**
 * \brief Sync version of I2C I/O write
 */
static int32_t i2c_m_sync_write(struct io_descriptor *io, const uint8_t *buf, const uint16_t n)
{
    3d6c:	b580      	push	{r7, lr}
    3d6e:	b08a      	sub	sp, #40	; 0x28
    3d70:	af00      	add	r7, sp, #0
    3d72:	60f8      	str	r0, [r7, #12]
    3d74:	60b9      	str	r1, [r7, #8]
    3d76:	1dbb      	adds	r3, r7, #6
    3d78:	801a      	strh	r2, [r3, #0]
	struct i2c_m_sync_desc *i2c = CONTAINER_OF(io, struct i2c_m_sync_desc, io);
    3d7a:	68fb      	ldr	r3, [r7, #12]
    3d7c:	3b14      	subs	r3, #20
    3d7e:	627b      	str	r3, [r7, #36]	; 0x24
	struct _i2c_m_msg       msg;
	int32_t                 ret;

	msg.addr   = i2c->slave_addr;
    3d80:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    3d82:	8b9a      	ldrh	r2, [r3, #28]
    3d84:	2314      	movs	r3, #20
    3d86:	18fb      	adds	r3, r7, r3
    3d88:	801a      	strh	r2, [r3, #0]
	msg.len    = n;
    3d8a:	1dbb      	adds	r3, r7, #6
    3d8c:	881a      	ldrh	r2, [r3, #0]
    3d8e:	2314      	movs	r3, #20
    3d90:	18fb      	adds	r3, r7, r3
    3d92:	605a      	str	r2, [r3, #4]
	msg.flags  = I2C_M_STOP;
    3d94:	2314      	movs	r3, #20
    3d96:	18fb      	adds	r3, r7, r3
    3d98:	4a0c      	ldr	r2, [pc, #48]	; (3dcc <i2c_m_sync_write+0x60>)
    3d9a:	805a      	strh	r2, [r3, #2]
	msg.buffer = (uint8_t *)buf;
    3d9c:	2314      	movs	r3, #20
    3d9e:	18fb      	adds	r3, r7, r3
    3da0:	68ba      	ldr	r2, [r7, #8]
    3da2:	609a      	str	r2, [r3, #8]

	ret = _i2c_m_sync_transfer(&i2c->device, &msg);
    3da4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    3da6:	2214      	movs	r2, #20
    3da8:	18ba      	adds	r2, r7, r2
    3daa:	0011      	movs	r1, r2
    3dac:	0018      	movs	r0, r3
    3dae:	f001 fd7d 	bl	58ac <_i2c_m_sync_transfer>
    3db2:	0003      	movs	r3, r0
    3db4:	623b      	str	r3, [r7, #32]

	if (ret) {
    3db6:	6a3b      	ldr	r3, [r7, #32]
    3db8:	2b00      	cmp	r3, #0
    3dba:	d001      	beq.n	3dc0 <i2c_m_sync_write+0x54>
		return ret;
    3dbc:	6a3b      	ldr	r3, [r7, #32]
    3dbe:	e001      	b.n	3dc4 <i2c_m_sync_write+0x58>
	}

	return n;
    3dc0:	1dbb      	adds	r3, r7, #6
    3dc2:	881b      	ldrh	r3, [r3, #0]
}
    3dc4:	0018      	movs	r0, r3
    3dc6:	46bd      	mov	sp, r7
    3dc8:	b00a      	add	sp, #40	; 0x28
    3dca:	bd80      	pop	{r7, pc}
    3dcc:	ffff8000 	.word	0xffff8000

00003dd0 <i2c_m_sync_init>:

/**
 * \brief Sync version of i2c initialize
 */
int32_t i2c_m_sync_init(struct i2c_m_sync_desc *i2c, void *hw)
{
    3dd0:	b580      	push	{r7, lr}
    3dd2:	b084      	sub	sp, #16
    3dd4:	af00      	add	r7, sp, #0
    3dd6:	6078      	str	r0, [r7, #4]
    3dd8:	6039      	str	r1, [r7, #0]
	int32_t init_status;
	ASSERT(i2c);
    3dda:	687b      	ldr	r3, [r7, #4]
    3ddc:	1e5a      	subs	r2, r3, #1
    3dde:	4193      	sbcs	r3, r2
    3de0:	b2db      	uxtb	r3, r3
    3de2:	490e      	ldr	r1, [pc, #56]	; (3e1c <i2c_m_sync_init+0x4c>)
    3de4:	225e      	movs	r2, #94	; 0x5e
    3de6:	0018      	movs	r0, r3
    3de8:	f000 fa9a 	bl	4320 <assert>

	init_status = _i2c_m_sync_init(&i2c->device, hw);
    3dec:	687b      	ldr	r3, [r7, #4]
    3dee:	683a      	ldr	r2, [r7, #0]
    3df0:	0011      	movs	r1, r2
    3df2:	0018      	movs	r0, r3
    3df4:	f001 fc1e 	bl	5634 <_i2c_m_sync_init>
    3df8:	0003      	movs	r3, r0
    3dfa:	60fb      	str	r3, [r7, #12]
	if (init_status) {
    3dfc:	68fb      	ldr	r3, [r7, #12]
    3dfe:	2b00      	cmp	r3, #0
    3e00:	d001      	beq.n	3e06 <i2c_m_sync_init+0x36>
		return init_status;
    3e02:	68fb      	ldr	r3, [r7, #12]
    3e04:	e006      	b.n	3e14 <i2c_m_sync_init+0x44>
	}

	/* Init I/O */
	i2c->io.read  = i2c_m_sync_read;
    3e06:	687b      	ldr	r3, [r7, #4]
    3e08:	4a05      	ldr	r2, [pc, #20]	; (3e20 <i2c_m_sync_init+0x50>)
    3e0a:	619a      	str	r2, [r3, #24]
	i2c->io.write = i2c_m_sync_write;
    3e0c:	687b      	ldr	r3, [r7, #4]
    3e0e:	4a05      	ldr	r2, [pc, #20]	; (3e24 <i2c_m_sync_init+0x54>)
    3e10:	615a      	str	r2, [r3, #20]

	return ERR_NONE;
    3e12:	2300      	movs	r3, #0
}
    3e14:	0018      	movs	r0, r3
    3e16:	46bd      	mov	sp, r7
    3e18:	b004      	add	sp, #16
    3e1a:	bd80      	pop	{r7, pc}
    3e1c:	00008a84 	.word	0x00008a84
    3e20:	00003d09 	.word	0x00003d09
    3e24:	00003d6d 	.word	0x00003d6d

00003e28 <i2c_m_sync_enable>:

/**
 * \brief Sync version of i2c enable
 */
int32_t i2c_m_sync_enable(struct i2c_m_sync_desc *i2c)
{
    3e28:	b580      	push	{r7, lr}
    3e2a:	b082      	sub	sp, #8
    3e2c:	af00      	add	r7, sp, #0
    3e2e:	6078      	str	r0, [r7, #4]
	return _i2c_m_sync_enable(&i2c->device);
    3e30:	687b      	ldr	r3, [r7, #4]
    3e32:	0018      	movs	r0, r3
    3e34:	f001 fc80 	bl	5738 <_i2c_m_sync_enable>
    3e38:	0003      	movs	r3, r0
}
    3e3a:	0018      	movs	r0, r3
    3e3c:	46bd      	mov	sp, r7
    3e3e:	b002      	add	sp, #8
    3e40:	bd80      	pop	{r7, pc}

00003e42 <i2c_m_sync_set_slaveaddr>:

/**
 * \brief Sync version of i2c set slave address
 */
int32_t i2c_m_sync_set_slaveaddr(struct i2c_m_sync_desc *i2c, int16_t addr, int32_t addr_len)
{
    3e42:	b580      	push	{r7, lr}
    3e44:	b084      	sub	sp, #16
    3e46:	af00      	add	r7, sp, #0
    3e48:	60f8      	str	r0, [r7, #12]
    3e4a:	607a      	str	r2, [r7, #4]
    3e4c:	230a      	movs	r3, #10
    3e4e:	18fb      	adds	r3, r7, r3
    3e50:	1c0a      	adds	r2, r1, #0
    3e52:	801a      	strh	r2, [r3, #0]
	return i2c->slave_addr = (addr & 0x3ff) | (addr_len & I2C_M_TEN);
    3e54:	230a      	movs	r3, #10
    3e56:	18fb      	adds	r3, r7, r3
    3e58:	881b      	ldrh	r3, [r3, #0]
    3e5a:	059b      	lsls	r3, r3, #22
    3e5c:	0d9b      	lsrs	r3, r3, #22
    3e5e:	b21a      	sxth	r2, r3
    3e60:	687b      	ldr	r3, [r7, #4]
    3e62:	b219      	sxth	r1, r3
    3e64:	2380      	movs	r3, #128	; 0x80
    3e66:	00db      	lsls	r3, r3, #3
    3e68:	400b      	ands	r3, r1
    3e6a:	b21b      	sxth	r3, r3
    3e6c:	4313      	orrs	r3, r2
    3e6e:	b21b      	sxth	r3, r3
    3e70:	b29a      	uxth	r2, r3
    3e72:	68fb      	ldr	r3, [r7, #12]
    3e74:	839a      	strh	r2, [r3, #28]
    3e76:	68fb      	ldr	r3, [r7, #12]
    3e78:	8b9b      	ldrh	r3, [r3, #28]
}
    3e7a:	0018      	movs	r0, r3
    3e7c:	46bd      	mov	sp, r7
    3e7e:	b004      	add	sp, #16
    3e80:	bd80      	pop	{r7, pc}

00003e82 <i2c_m_sync_get_io_descriptor>:

/**
 * \brief Retrieve I/O descriptor
 */
int32_t i2c_m_sync_get_io_descriptor(struct i2c_m_sync_desc *const i2c, struct io_descriptor **io)
{
    3e82:	b580      	push	{r7, lr}
    3e84:	b082      	sub	sp, #8
    3e86:	af00      	add	r7, sp, #0
    3e88:	6078      	str	r0, [r7, #4]
    3e8a:	6039      	str	r1, [r7, #0]
	*io = &i2c->io;
    3e8c:	687b      	ldr	r3, [r7, #4]
    3e8e:	3314      	adds	r3, #20
    3e90:	001a      	movs	r2, r3
    3e92:	683b      	ldr	r3, [r7, #0]
    3e94:	601a      	str	r2, [r3, #0]
	return ERR_NONE;
    3e96:	2300      	movs	r3, #0
}
    3e98:	0018      	movs	r0, r3
    3e9a:	46bd      	mov	sp, r7
    3e9c:	b002      	add	sp, #8
    3e9e:	bd80      	pop	{r7, pc}

00003ea0 <io_write>:

/**
 * \brief I/O write interface
 */
int32_t io_write(struct io_descriptor *const io_descr, const uint8_t *const buf, const uint16_t length)
{
    3ea0:	b580      	push	{r7, lr}
    3ea2:	b084      	sub	sp, #16
    3ea4:	af00      	add	r7, sp, #0
    3ea6:	60f8      	str	r0, [r7, #12]
    3ea8:	60b9      	str	r1, [r7, #8]
    3eaa:	1dbb      	adds	r3, r7, #6
    3eac:	801a      	strh	r2, [r3, #0]
	ASSERT(io_descr && buf);
    3eae:	68fb      	ldr	r3, [r7, #12]
    3eb0:	2b00      	cmp	r3, #0
    3eb2:	d004      	beq.n	3ebe <io_write+0x1e>
    3eb4:	68bb      	ldr	r3, [r7, #8]
    3eb6:	2b00      	cmp	r3, #0
    3eb8:	d001      	beq.n	3ebe <io_write+0x1e>
    3eba:	2301      	movs	r3, #1
    3ebc:	e000      	b.n	3ec0 <io_write+0x20>
    3ebe:	2300      	movs	r3, #0
    3ec0:	1c1a      	adds	r2, r3, #0
    3ec2:	2301      	movs	r3, #1
    3ec4:	4013      	ands	r3, r2
    3ec6:	b2db      	uxtb	r3, r3
    3ec8:	4908      	ldr	r1, [pc, #32]	; (3eec <io_write+0x4c>)
    3eca:	2234      	movs	r2, #52	; 0x34
    3ecc:	0018      	movs	r0, r3
    3ece:	f000 fa27 	bl	4320 <assert>
	return io_descr->write(io_descr, buf, length);
    3ed2:	68fb      	ldr	r3, [r7, #12]
    3ed4:	681b      	ldr	r3, [r3, #0]
    3ed6:	1dba      	adds	r2, r7, #6
    3ed8:	8812      	ldrh	r2, [r2, #0]
    3eda:	68b9      	ldr	r1, [r7, #8]
    3edc:	68f8      	ldr	r0, [r7, #12]
    3ede:	4798      	blx	r3
    3ee0:	0003      	movs	r3, r0
}
    3ee2:	0018      	movs	r0, r3
    3ee4:	46bd      	mov	sp, r7
    3ee6:	b004      	add	sp, #16
    3ee8:	bd80      	pop	{r7, pc}
    3eea:	46c0      	nop			; (mov r8, r8)
    3eec:	00008aa0 	.word	0x00008aa0

00003ef0 <io_read>:

/**
 * \brief I/O read interface
 */
int32_t io_read(struct io_descriptor *const io_descr, uint8_t *const buf, const uint16_t length)
{
    3ef0:	b580      	push	{r7, lr}
    3ef2:	b084      	sub	sp, #16
    3ef4:	af00      	add	r7, sp, #0
    3ef6:	60f8      	str	r0, [r7, #12]
    3ef8:	60b9      	str	r1, [r7, #8]
    3efa:	1dbb      	adds	r3, r7, #6
    3efc:	801a      	strh	r2, [r3, #0]
	ASSERT(io_descr && buf);
    3efe:	68fb      	ldr	r3, [r7, #12]
    3f00:	2b00      	cmp	r3, #0
    3f02:	d004      	beq.n	3f0e <io_read+0x1e>
    3f04:	68bb      	ldr	r3, [r7, #8]
    3f06:	2b00      	cmp	r3, #0
    3f08:	d001      	beq.n	3f0e <io_read+0x1e>
    3f0a:	2301      	movs	r3, #1
    3f0c:	e000      	b.n	3f10 <io_read+0x20>
    3f0e:	2300      	movs	r3, #0
    3f10:	1c1a      	adds	r2, r3, #0
    3f12:	2301      	movs	r3, #1
    3f14:	4013      	ands	r3, r2
    3f16:	b2db      	uxtb	r3, r3
    3f18:	4908      	ldr	r1, [pc, #32]	; (3f3c <io_read+0x4c>)
    3f1a:	223d      	movs	r2, #61	; 0x3d
    3f1c:	0018      	movs	r0, r3
    3f1e:	f000 f9ff 	bl	4320 <assert>
	return io_descr->read(io_descr, buf, length);
    3f22:	68fb      	ldr	r3, [r7, #12]
    3f24:	685b      	ldr	r3, [r3, #4]
    3f26:	1dba      	adds	r2, r7, #6
    3f28:	8812      	ldrh	r2, [r2, #0]
    3f2a:	68b9      	ldr	r1, [r7, #8]
    3f2c:	68f8      	ldr	r0, [r7, #12]
    3f2e:	4798      	blx	r3
    3f30:	0003      	movs	r3, r0
}
    3f32:	0018      	movs	r0, r3
    3f34:	46bd      	mov	sp, r7
    3f36:	b004      	add	sp, #16
    3f38:	bd80      	pop	{r7, pc}
    3f3a:	46c0      	nop			; (mov r8, r8)
    3f3c:	00008aa0 	.word	0x00008aa0

00003f40 <spi_m_sync_init>:
	ASSERT(spi);
	spi->func = (struct _spi_m_sync_hpl_interface *)func;
}

int32_t spi_m_sync_init(struct spi_m_sync_descriptor *spi, void *const hw)
{
    3f40:	b580      	push	{r7, lr}
    3f42:	b084      	sub	sp, #16
    3f44:	af00      	add	r7, sp, #0
    3f46:	6078      	str	r0, [r7, #4]
    3f48:	6039      	str	r1, [r7, #0]
	int32_t rc = 0;
    3f4a:	2300      	movs	r3, #0
    3f4c:	60fb      	str	r3, [r7, #12]
	ASSERT(spi && hw);
    3f4e:	687b      	ldr	r3, [r7, #4]
    3f50:	2b00      	cmp	r3, #0
    3f52:	d004      	beq.n	3f5e <spi_m_sync_init+0x1e>
    3f54:	683b      	ldr	r3, [r7, #0]
    3f56:	2b00      	cmp	r3, #0
    3f58:	d001      	beq.n	3f5e <spi_m_sync_init+0x1e>
    3f5a:	2301      	movs	r3, #1
    3f5c:	e000      	b.n	3f60 <spi_m_sync_init+0x20>
    3f5e:	2300      	movs	r3, #0
    3f60:	1c1a      	adds	r2, r3, #0
    3f62:	2301      	movs	r3, #1
    3f64:	4013      	ands	r3, r2
    3f66:	b2db      	uxtb	r3, r3
    3f68:	4911      	ldr	r1, [pc, #68]	; (3fb0 <spi_m_sync_init+0x70>)
    3f6a:	2240      	movs	r2, #64	; 0x40
    3f6c:	0018      	movs	r0, r3
    3f6e:	f000 f9d7 	bl	4320 <assert>
	spi->dev.prvt = (void *)hw;
    3f72:	687b      	ldr	r3, [r7, #4]
    3f74:	683a      	ldr	r2, [r7, #0]
    3f76:	605a      	str	r2, [r3, #4]
	rc            = _spi_m_sync_init(&spi->dev, hw);
    3f78:	687b      	ldr	r3, [r7, #4]
    3f7a:	3304      	adds	r3, #4
    3f7c:	683a      	ldr	r2, [r7, #0]
    3f7e:	0011      	movs	r1, r2
    3f80:	0018      	movs	r0, r3
    3f82:	f001 fe35 	bl	5bf0 <_spi_m_sync_init>
    3f86:	0003      	movs	r3, r0
    3f88:	60fb      	str	r3, [r7, #12]

	if (rc < 0) {
    3f8a:	68fb      	ldr	r3, [r7, #12]
    3f8c:	2b00      	cmp	r3, #0
    3f8e:	da01      	bge.n	3f94 <spi_m_sync_init+0x54>
		return rc;
    3f90:	68fb      	ldr	r3, [r7, #12]
    3f92:	e009      	b.n	3fa8 <spi_m_sync_init+0x68>
	}

	spi->flags    = SPI_DEACTIVATE_NEXT;
    3f94:	687b      	ldr	r3, [r7, #4]
    3f96:	4a07      	ldr	r2, [pc, #28]	; (3fb4 <spi_m_sync_init+0x74>)
    3f98:	829a      	strh	r2, [r3, #20]
	spi->io.read  = _spi_m_sync_io_read;
    3f9a:	687b      	ldr	r3, [r7, #4]
    3f9c:	4a06      	ldr	r2, [pc, #24]	; (3fb8 <spi_m_sync_init+0x78>)
    3f9e:	611a      	str	r2, [r3, #16]
	spi->io.write = _spi_m_sync_io_write;
    3fa0:	687b      	ldr	r3, [r7, #4]
    3fa2:	4a06      	ldr	r2, [pc, #24]	; (3fbc <spi_m_sync_init+0x7c>)
    3fa4:	60da      	str	r2, [r3, #12]

	return ERR_NONE;
    3fa6:	2300      	movs	r3, #0
}
    3fa8:	0018      	movs	r0, r3
    3faa:	46bd      	mov	sp, r7
    3fac:	b004      	add	sp, #16
    3fae:	bd80      	pop	{r7, pc}
    3fb0:	00008ab4 	.word	0x00008ab4
    3fb4:	ffff8000 	.word	0xffff8000
    3fb8:	00003ff1 	.word	0x00003ff1
    3fbc:	0000404d 	.word	0x0000404d

00003fc0 <spi_m_sync_enable>:
	ASSERT(spi);
	_spi_m_sync_deinit(&spi->dev);
}

void spi_m_sync_enable(struct spi_m_sync_descriptor *spi)
{
    3fc0:	b580      	push	{r7, lr}
    3fc2:	b082      	sub	sp, #8
    3fc4:	af00      	add	r7, sp, #0
    3fc6:	6078      	str	r0, [r7, #4]
	ASSERT(spi);
    3fc8:	687b      	ldr	r3, [r7, #4]
    3fca:	1e5a      	subs	r2, r3, #1
    3fcc:	4193      	sbcs	r3, r2
    3fce:	b2db      	uxtb	r3, r3
    3fd0:	4906      	ldr	r1, [pc, #24]	; (3fec <spi_m_sync_enable+0x2c>)
    3fd2:	2257      	movs	r2, #87	; 0x57
    3fd4:	0018      	movs	r0, r3
    3fd6:	f000 f9a3 	bl	4320 <assert>
	_spi_m_sync_enable(&spi->dev);
    3fda:	687b      	ldr	r3, [r7, #4]
    3fdc:	3304      	adds	r3, #4
    3fde:	0018      	movs	r0, r3
    3fe0:	f001 fe84 	bl	5cec <_spi_m_sync_enable>
}
    3fe4:	46c0      	nop			; (mov r8, r8)
    3fe6:	46bd      	mov	sp, r7
    3fe8:	b002      	add	sp, #8
    3fea:	bd80      	pop	{r7, pc}
    3fec:	00008ab4 	.word	0x00008ab4

00003ff0 <_spi_m_sync_io_read>:
 *  \return Operation status.
 *  \retval size Success.
 *  \retval >=0 Time out, with number of characters read.
 */
static int32_t _spi_m_sync_io_read(struct io_descriptor *io, uint8_t *buf, const uint16_t length)
{
    3ff0:	b580      	push	{r7, lr}
    3ff2:	b088      	sub	sp, #32
    3ff4:	af00      	add	r7, sp, #0
    3ff6:	60f8      	str	r0, [r7, #12]
    3ff8:	60b9      	str	r1, [r7, #8]
    3ffa:	1dbb      	adds	r3, r7, #6
    3ffc:	801a      	strh	r2, [r3, #0]
	ASSERT(io);
    3ffe:	68fb      	ldr	r3, [r7, #12]
    4000:	1e5a      	subs	r2, r3, #1
    4002:	4193      	sbcs	r3, r2
    4004:	b2db      	uxtb	r3, r3
    4006:	4910      	ldr	r1, [pc, #64]	; (4048 <_spi_m_sync_io_read+0x58>)
    4008:	2287      	movs	r2, #135	; 0x87
    400a:	0018      	movs	r0, r3
    400c:	f000 f988 	bl	4320 <assert>

	struct spi_m_sync_descriptor *spi = CONTAINER_OF(io, struct spi_m_sync_descriptor, io);
    4010:	68fb      	ldr	r3, [r7, #12]
    4012:	3b0c      	subs	r3, #12
    4014:	61fb      	str	r3, [r7, #28]
	struct spi_xfer               xfer;

	xfer.rxbuf = buf;
    4016:	2310      	movs	r3, #16
    4018:	18fb      	adds	r3, r7, r3
    401a:	68ba      	ldr	r2, [r7, #8]
    401c:	605a      	str	r2, [r3, #4]
	xfer.txbuf = 0;
    401e:	2310      	movs	r3, #16
    4020:	18fb      	adds	r3, r7, r3
    4022:	2200      	movs	r2, #0
    4024:	601a      	str	r2, [r3, #0]
	xfer.size  = length;
    4026:	1dbb      	adds	r3, r7, #6
    4028:	881a      	ldrh	r2, [r3, #0]
    402a:	2310      	movs	r3, #16
    402c:	18fb      	adds	r3, r7, r3
    402e:	609a      	str	r2, [r3, #8]

	return spi_m_sync_transfer(spi, &xfer);
    4030:	2310      	movs	r3, #16
    4032:	18fa      	adds	r2, r7, r3
    4034:	69fb      	ldr	r3, [r7, #28]
    4036:	0011      	movs	r1, r2
    4038:	0018      	movs	r0, r3
    403a:	f000 f835 	bl	40a8 <spi_m_sync_transfer>
    403e:	0003      	movs	r3, r0
}
    4040:	0018      	movs	r0, r3
    4042:	46bd      	mov	sp, r7
    4044:	b008      	add	sp, #32
    4046:	bd80      	pop	{r7, pc}
    4048:	00008ab4 	.word	0x00008ab4

0000404c <_spi_m_sync_io_write>:
 *  \return Operation status.
 *  \retval size Success.
 *  \retval >=0 Timeout, with number of characters transferred.
 */
static int32_t _spi_m_sync_io_write(struct io_descriptor *const io, const uint8_t *const buf, const uint16_t length)
{
    404c:	b580      	push	{r7, lr}
    404e:	b088      	sub	sp, #32
    4050:	af00      	add	r7, sp, #0
    4052:	60f8      	str	r0, [r7, #12]
    4054:	60b9      	str	r1, [r7, #8]
    4056:	1dbb      	adds	r3, r7, #6
    4058:	801a      	strh	r2, [r3, #0]
	ASSERT(io);
    405a:	68fb      	ldr	r3, [r7, #12]
    405c:	1e5a      	subs	r2, r3, #1
    405e:	4193      	sbcs	r3, r2
    4060:	b2db      	uxtb	r3, r3
    4062:	4910      	ldr	r1, [pc, #64]	; (40a4 <_spi_m_sync_io_write+0x58>)
    4064:	22a3      	movs	r2, #163	; 0xa3
    4066:	0018      	movs	r0, r3
    4068:	f000 f95a 	bl	4320 <assert>

	struct spi_m_sync_descriptor *spi = CONTAINER_OF(io, struct spi_m_sync_descriptor, io);
    406c:	68fb      	ldr	r3, [r7, #12]
    406e:	3b0c      	subs	r3, #12
    4070:	61fb      	str	r3, [r7, #28]
	struct spi_xfer               xfer;

	xfer.rxbuf = 0;
    4072:	2310      	movs	r3, #16
    4074:	18fb      	adds	r3, r7, r3
    4076:	2200      	movs	r2, #0
    4078:	605a      	str	r2, [r3, #4]
	xfer.txbuf = (uint8_t *)buf;
    407a:	2310      	movs	r3, #16
    407c:	18fb      	adds	r3, r7, r3
    407e:	68ba      	ldr	r2, [r7, #8]
    4080:	601a      	str	r2, [r3, #0]
	xfer.size  = length;
    4082:	1dbb      	adds	r3, r7, #6
    4084:	881a      	ldrh	r2, [r3, #0]
    4086:	2310      	movs	r3, #16
    4088:	18fb      	adds	r3, r7, r3
    408a:	609a      	str	r2, [r3, #8]

	return spi_m_sync_transfer(spi, &xfer);
    408c:	2310      	movs	r3, #16
    408e:	18fa      	adds	r2, r7, r3
    4090:	69fb      	ldr	r3, [r7, #28]
    4092:	0011      	movs	r1, r2
    4094:	0018      	movs	r0, r3
    4096:	f000 f807 	bl	40a8 <spi_m_sync_transfer>
    409a:	0003      	movs	r3, r0
}
    409c:	0018      	movs	r0, r3
    409e:	46bd      	mov	sp, r7
    40a0:	b008      	add	sp, #32
    40a2:	bd80      	pop	{r7, pc}
    40a4:	00008ab4 	.word	0x00008ab4

000040a8 <spi_m_sync_transfer>:

int32_t spi_m_sync_transfer(struct spi_m_sync_descriptor *spi, const struct spi_xfer *p_xfer)
{
    40a8:	b580      	push	{r7, lr}
    40aa:	b086      	sub	sp, #24
    40ac:	af00      	add	r7, sp, #0
    40ae:	6078      	str	r0, [r7, #4]
    40b0:	6039      	str	r1, [r7, #0]
	struct spi_msg msg;

	ASSERT(spi && p_xfer);
    40b2:	687b      	ldr	r3, [r7, #4]
    40b4:	2b00      	cmp	r3, #0
    40b6:	d004      	beq.n	40c2 <spi_m_sync_transfer+0x1a>
    40b8:	683b      	ldr	r3, [r7, #0]
    40ba:	2b00      	cmp	r3, #0
    40bc:	d001      	beq.n	40c2 <spi_m_sync_transfer+0x1a>
    40be:	2301      	movs	r3, #1
    40c0:	e000      	b.n	40c4 <spi_m_sync_transfer+0x1c>
    40c2:	2300      	movs	r3, #0
    40c4:	1c1a      	adds	r2, r3, #0
    40c6:	2301      	movs	r3, #1
    40c8:	4013      	ands	r3, r2
    40ca:	b2db      	uxtb	r3, r3
    40cc:	4910      	ldr	r1, [pc, #64]	; (4110 <spi_m_sync_transfer+0x68>)
    40ce:	22b3      	movs	r2, #179	; 0xb3
    40d0:	0018      	movs	r0, r3
    40d2:	f000 f925 	bl	4320 <assert>

	msg.txbuf = p_xfer->txbuf;
    40d6:	683b      	ldr	r3, [r7, #0]
    40d8:	681a      	ldr	r2, [r3, #0]
    40da:	230c      	movs	r3, #12
    40dc:	18fb      	adds	r3, r7, r3
    40de:	601a      	str	r2, [r3, #0]
	msg.rxbuf = p_xfer->rxbuf;
    40e0:	683b      	ldr	r3, [r7, #0]
    40e2:	685a      	ldr	r2, [r3, #4]
    40e4:	230c      	movs	r3, #12
    40e6:	18fb      	adds	r3, r7, r3
    40e8:	605a      	str	r2, [r3, #4]
	msg.size  = p_xfer->size;
    40ea:	683b      	ldr	r3, [r7, #0]
    40ec:	689a      	ldr	r2, [r3, #8]
    40ee:	230c      	movs	r3, #12
    40f0:	18fb      	adds	r3, r7, r3
    40f2:	609a      	str	r2, [r3, #8]
	return _spi_m_sync_trans(&spi->dev, &msg);
    40f4:	687b      	ldr	r3, [r7, #4]
    40f6:	3304      	adds	r3, #4
    40f8:	220c      	movs	r2, #12
    40fa:	18ba      	adds	r2, r7, r2
    40fc:	0011      	movs	r1, r2
    40fe:	0018      	movs	r0, r3
    4100:	f001 fea0 	bl	5e44 <_spi_m_sync_trans>
    4104:	0003      	movs	r3, r0
}
    4106:	0018      	movs	r0, r3
    4108:	46bd      	mov	sp, r7
    410a:	b006      	add	sp, #24
    410c:	bd80      	pop	{r7, pc}
    410e:	46c0      	nop			; (mov r8, r8)
    4110:	00008ab4 	.word	0x00008ab4

00004114 <spi_m_sync_get_io_descriptor>:

int32_t spi_m_sync_get_io_descriptor(struct spi_m_sync_descriptor *const spi, struct io_descriptor **io)
{
    4114:	b580      	push	{r7, lr}
    4116:	b082      	sub	sp, #8
    4118:	af00      	add	r7, sp, #0
    411a:	6078      	str	r0, [r7, #4]
    411c:	6039      	str	r1, [r7, #0]
	ASSERT(spi && io);
    411e:	687b      	ldr	r3, [r7, #4]
    4120:	2b00      	cmp	r3, #0
    4122:	d004      	beq.n	412e <spi_m_sync_get_io_descriptor+0x1a>
    4124:	683b      	ldr	r3, [r7, #0]
    4126:	2b00      	cmp	r3, #0
    4128:	d001      	beq.n	412e <spi_m_sync_get_io_descriptor+0x1a>
    412a:	2301      	movs	r3, #1
    412c:	e000      	b.n	4130 <spi_m_sync_get_io_descriptor+0x1c>
    412e:	2300      	movs	r3, #0
    4130:	1c1a      	adds	r2, r3, #0
    4132:	2301      	movs	r3, #1
    4134:	4013      	ands	r3, r2
    4136:	b2db      	uxtb	r3, r3
    4138:	4907      	ldr	r1, [pc, #28]	; (4158 <spi_m_sync_get_io_descriptor+0x44>)
    413a:	22bd      	movs	r2, #189	; 0xbd
    413c:	0018      	movs	r0, r3
    413e:	f000 f8ef 	bl	4320 <assert>
	*io = &spi->io;
    4142:	687b      	ldr	r3, [r7, #4]
    4144:	330c      	adds	r3, #12
    4146:	001a      	movs	r2, r3
    4148:	683b      	ldr	r3, [r7, #0]
    414a:	601a      	str	r2, [r3, #0]
	return 0;
    414c:	2300      	movs	r3, #0
}
    414e:	0018      	movs	r0, r3
    4150:	46bd      	mov	sp, r7
    4152:	b002      	add	sp, #8
    4154:	bd80      	pop	{r7, pc}
    4156:	46c0      	nop			; (mov r8, r8)
    4158:	00008ab4 	.word	0x00008ab4

0000415c <usart_sync_init>:

/**
 * \brief Initialize usart interface
 */
int32_t usart_sync_init(struct usart_sync_descriptor *const descr, void *const hw, void *const func)
{
    415c:	b580      	push	{r7, lr}
    415e:	b086      	sub	sp, #24
    4160:	af00      	add	r7, sp, #0
    4162:	60f8      	str	r0, [r7, #12]
    4164:	60b9      	str	r1, [r7, #8]
    4166:	607a      	str	r2, [r7, #4]
	int32_t init_status;
	ASSERT(descr && hw);
    4168:	68fb      	ldr	r3, [r7, #12]
    416a:	2b00      	cmp	r3, #0
    416c:	d004      	beq.n	4178 <usart_sync_init+0x1c>
    416e:	68bb      	ldr	r3, [r7, #8]
    4170:	2b00      	cmp	r3, #0
    4172:	d001      	beq.n	4178 <usart_sync_init+0x1c>
    4174:	2301      	movs	r3, #1
    4176:	e000      	b.n	417a <usart_sync_init+0x1e>
    4178:	2300      	movs	r3, #0
    417a:	1c1a      	adds	r2, r3, #0
    417c:	2301      	movs	r3, #1
    417e:	4013      	ands	r3, r2
    4180:	b2db      	uxtb	r3, r3
    4182:	490f      	ldr	r1, [pc, #60]	; (41c0 <usart_sync_init+0x64>)
    4184:	2234      	movs	r2, #52	; 0x34
    4186:	0018      	movs	r0, r3
    4188:	f000 f8ca 	bl	4320 <assert>
	init_status = _usart_sync_init(&descr->device, hw);
    418c:	68fb      	ldr	r3, [r7, #12]
    418e:	3308      	adds	r3, #8
    4190:	68ba      	ldr	r2, [r7, #8]
    4192:	0011      	movs	r1, r2
    4194:	0018      	movs	r0, r3
    4196:	f001 f803 	bl	51a0 <_usart_sync_init>
    419a:	0003      	movs	r3, r0
    419c:	617b      	str	r3, [r7, #20]
	if (init_status) {
    419e:	697b      	ldr	r3, [r7, #20]
    41a0:	2b00      	cmp	r3, #0
    41a2:	d001      	beq.n	41a8 <usart_sync_init+0x4c>
		return init_status;
    41a4:	697b      	ldr	r3, [r7, #20]
    41a6:	e006      	b.n	41b6 <usart_sync_init+0x5a>
	}

	descr->io.read  = usart_sync_read;
    41a8:	68fb      	ldr	r3, [r7, #12]
    41aa:	4a06      	ldr	r2, [pc, #24]	; (41c4 <usart_sync_init+0x68>)
    41ac:	605a      	str	r2, [r3, #4]
	descr->io.write = usart_sync_write;
    41ae:	68fb      	ldr	r3, [r7, #12]
    41b0:	4a05      	ldr	r2, [pc, #20]	; (41c8 <usart_sync_init+0x6c>)
    41b2:	601a      	str	r2, [r3, #0]

	return ERR_NONE;
    41b4:	2300      	movs	r3, #0
}
    41b6:	0018      	movs	r0, r3
    41b8:	46bd      	mov	sp, r7
    41ba:	b006      	add	sp, #24
    41bc:	bd80      	pop	{r7, pc}
    41be:	46c0      	nop			; (mov r8, r8)
    41c0:	00008ad0 	.word	0x00008ad0
    41c4:	00004291 	.word	0x00004291
    41c8:	000041cd 	.word	0x000041cd

000041cc <usart_sync_write>:
 * \param[in] length The number of bytes to write
 *
 * \return The number of bytes written.
 */
static int32_t usart_sync_write(struct io_descriptor *const io_descr, const uint8_t *const buf, const uint16_t length)
{
    41cc:	b580      	push	{r7, lr}
    41ce:	b086      	sub	sp, #24
    41d0:	af00      	add	r7, sp, #0
    41d2:	60f8      	str	r0, [r7, #12]
    41d4:	60b9      	str	r1, [r7, #8]
    41d6:	1dbb      	adds	r3, r7, #6
    41d8:	801a      	strh	r2, [r3, #0]
	uint32_t                      offset = 0;
    41da:	2300      	movs	r3, #0
    41dc:	617b      	str	r3, [r7, #20]
	struct usart_sync_descriptor *descr  = CONTAINER_OF(io_descr, struct usart_sync_descriptor, io);
    41de:	68fb      	ldr	r3, [r7, #12]
    41e0:	613b      	str	r3, [r7, #16]

	ASSERT(io_descr && buf && length);
    41e2:	68fb      	ldr	r3, [r7, #12]
    41e4:	2b00      	cmp	r3, #0
    41e6:	d008      	beq.n	41fa <usart_sync_write+0x2e>
    41e8:	68bb      	ldr	r3, [r7, #8]
    41ea:	2b00      	cmp	r3, #0
    41ec:	d005      	beq.n	41fa <usart_sync_write+0x2e>
    41ee:	1dbb      	adds	r3, r7, #6
    41f0:	881b      	ldrh	r3, [r3, #0]
    41f2:	2b00      	cmp	r3, #0
    41f4:	d001      	beq.n	41fa <usart_sync_write+0x2e>
    41f6:	2301      	movs	r3, #1
    41f8:	e000      	b.n	41fc <usart_sync_write+0x30>
    41fa:	2300      	movs	r3, #0
    41fc:	1c1a      	adds	r2, r3, #0
    41fe:	2301      	movs	r3, #1
    4200:	4013      	ands	r3, r2
    4202:	b2db      	uxtb	r3, r3
    4204:	4921      	ldr	r1, [pc, #132]	; (428c <usart_sync_write+0xc0>)
    4206:	22f1      	movs	r2, #241	; 0xf1
    4208:	0018      	movs	r0, r3
    420a:	f000 f889 	bl	4320 <assert>
	while (!_usart_sync_is_ready_to_send(&descr->device))
    420e:	46c0      	nop			; (mov r8, r8)
    4210:	693b      	ldr	r3, [r7, #16]
    4212:	3308      	adds	r3, #8
    4214:	0018      	movs	r0, r3
    4216:	f001 f802 	bl	521e <_usart_sync_is_ready_to_send>
    421a:	0003      	movs	r3, r0
    421c:	001a      	movs	r2, r3
    421e:	2301      	movs	r3, #1
    4220:	4053      	eors	r3, r2
    4222:	b2db      	uxtb	r3, r3
    4224:	2b00      	cmp	r3, #0
    4226:	d1f3      	bne.n	4210 <usart_sync_write+0x44>
		;
	do {
		_usart_sync_write_byte(&descr->device, buf[offset]);
    4228:	693b      	ldr	r3, [r7, #16]
    422a:	3308      	adds	r3, #8
    422c:	0018      	movs	r0, r3
    422e:	68ba      	ldr	r2, [r7, #8]
    4230:	697b      	ldr	r3, [r7, #20]
    4232:	18d3      	adds	r3, r2, r3
    4234:	781b      	ldrb	r3, [r3, #0]
    4236:	0019      	movs	r1, r3
    4238:	f000 ffce 	bl	51d8 <_usart_sync_write_byte>
		while (!_usart_sync_is_ready_to_send(&descr->device))
    423c:	46c0      	nop			; (mov r8, r8)
    423e:	693b      	ldr	r3, [r7, #16]
    4240:	3308      	adds	r3, #8
    4242:	0018      	movs	r0, r3
    4244:	f000 ffeb 	bl	521e <_usart_sync_is_ready_to_send>
    4248:	0003      	movs	r3, r0
    424a:	001a      	movs	r2, r3
    424c:	2301      	movs	r3, #1
    424e:	4053      	eors	r3, r2
    4250:	b2db      	uxtb	r3, r3
    4252:	2b00      	cmp	r3, #0
    4254:	d1f3      	bne.n	423e <usart_sync_write+0x72>
			;
	} while (++offset < length);
    4256:	697b      	ldr	r3, [r7, #20]
    4258:	3301      	adds	r3, #1
    425a:	617b      	str	r3, [r7, #20]
    425c:	1dbb      	adds	r3, r7, #6
    425e:	881b      	ldrh	r3, [r3, #0]
    4260:	697a      	ldr	r2, [r7, #20]
    4262:	429a      	cmp	r2, r3
    4264:	d3e0      	bcc.n	4228 <usart_sync_write+0x5c>
	while (!_usart_sync_is_transmit_done(&descr->device))
    4266:	46c0      	nop			; (mov r8, r8)
    4268:	693b      	ldr	r3, [r7, #16]
    426a:	3308      	adds	r3, #8
    426c:	0018      	movs	r0, r3
    426e:	f000 ffe4 	bl	523a <_usart_sync_is_transmit_done>
    4272:	0003      	movs	r3, r0
    4274:	001a      	movs	r2, r3
    4276:	2301      	movs	r3, #1
    4278:	4053      	eors	r3, r2
    427a:	b2db      	uxtb	r3, r3
    427c:	2b00      	cmp	r3, #0
    427e:	d1f3      	bne.n	4268 <usart_sync_write+0x9c>
		;
	return (int32_t)offset;
    4280:	697b      	ldr	r3, [r7, #20]
}
    4282:	0018      	movs	r0, r3
    4284:	46bd      	mov	sp, r7
    4286:	b006      	add	sp, #24
    4288:	bd80      	pop	{r7, pc}
    428a:	46c0      	nop			; (mov r8, r8)
    428c:	00008ad0 	.word	0x00008ad0

00004290 <usart_sync_read>:
 * \param[in] length The size of a buffer
 *
 * \return The number of bytes read.
 */
static int32_t usart_sync_read(struct io_descriptor *const io_descr, uint8_t *const buf, const uint16_t length)
{
    4290:	b590      	push	{r4, r7, lr}
    4292:	b087      	sub	sp, #28
    4294:	af00      	add	r7, sp, #0
    4296:	60f8      	str	r0, [r7, #12]
    4298:	60b9      	str	r1, [r7, #8]
    429a:	1dbb      	adds	r3, r7, #6
    429c:	801a      	strh	r2, [r3, #0]
	uint32_t                      offset = 0;
    429e:	2300      	movs	r3, #0
    42a0:	617b      	str	r3, [r7, #20]
	struct usart_sync_descriptor *descr  = CONTAINER_OF(io_descr, struct usart_sync_descriptor, io);
    42a2:	68fb      	ldr	r3, [r7, #12]
    42a4:	613b      	str	r3, [r7, #16]

	ASSERT(io_descr && buf && length);
    42a6:	68fb      	ldr	r3, [r7, #12]
    42a8:	2b00      	cmp	r3, #0
    42aa:	d008      	beq.n	42be <usart_sync_read+0x2e>
    42ac:	68bb      	ldr	r3, [r7, #8]
    42ae:	2b00      	cmp	r3, #0
    42b0:	d005      	beq.n	42be <usart_sync_read+0x2e>
    42b2:	1dbb      	adds	r3, r7, #6
    42b4:	881b      	ldrh	r3, [r3, #0]
    42b6:	2b00      	cmp	r3, #0
    42b8:	d001      	beq.n	42be <usart_sync_read+0x2e>
    42ba:	2301      	movs	r3, #1
    42bc:	e000      	b.n	42c0 <usart_sync_read+0x30>
    42be:	2300      	movs	r3, #0
    42c0:	1c1a      	adds	r2, r3, #0
    42c2:	2301      	movs	r3, #1
    42c4:	4013      	ands	r3, r2
    42c6:	b2d8      	uxtb	r0, r3
    42c8:	2386      	movs	r3, #134	; 0x86
    42ca:	005a      	lsls	r2, r3, #1
    42cc:	4b13      	ldr	r3, [pc, #76]	; (431c <usart_sync_read+0x8c>)
    42ce:	0019      	movs	r1, r3
    42d0:	f000 f826 	bl	4320 <assert>
	do {
		while (!_usart_sync_is_byte_received(&descr->device))
    42d4:	46c0      	nop			; (mov r8, r8)
    42d6:	693b      	ldr	r3, [r7, #16]
    42d8:	3308      	adds	r3, #8
    42da:	0018      	movs	r0, r3
    42dc:	f000 ffbb 	bl	5256 <_usart_sync_is_byte_received>
    42e0:	0003      	movs	r3, r0
    42e2:	001a      	movs	r2, r3
    42e4:	2301      	movs	r3, #1
    42e6:	4053      	eors	r3, r2
    42e8:	b2db      	uxtb	r3, r3
    42ea:	2b00      	cmp	r3, #0
    42ec:	d1f3      	bne.n	42d6 <usart_sync_read+0x46>
			;
		buf[offset] = _usart_sync_read_byte(&descr->device);
    42ee:	68ba      	ldr	r2, [r7, #8]
    42f0:	697b      	ldr	r3, [r7, #20]
    42f2:	18d4      	adds	r4, r2, r3
    42f4:	693b      	ldr	r3, [r7, #16]
    42f6:	3308      	adds	r3, #8
    42f8:	0018      	movs	r0, r3
    42fa:	f000 ff81 	bl	5200 <_usart_sync_read_byte>
    42fe:	0003      	movs	r3, r0
    4300:	7023      	strb	r3, [r4, #0]
	} while (++offset < length);
    4302:	697b      	ldr	r3, [r7, #20]
    4304:	3301      	adds	r3, #1
    4306:	617b      	str	r3, [r7, #20]
    4308:	1dbb      	adds	r3, r7, #6
    430a:	881b      	ldrh	r3, [r3, #0]
    430c:	697a      	ldr	r2, [r7, #20]
    430e:	429a      	cmp	r2, r3
    4310:	d3e0      	bcc.n	42d4 <usart_sync_read+0x44>

	return (int32_t)offset;
    4312:	697b      	ldr	r3, [r7, #20]
}
    4314:	0018      	movs	r0, r3
    4316:	46bd      	mov	sp, r7
    4318:	b007      	add	sp, #28
    431a:	bd90      	pop	{r4, r7, pc}
    431c:	00008ad0 	.word	0x00008ad0

00004320 <assert>:

/**
 * \brief Assert function
 */
void assert(const bool condition, const char *const file, const int line)
{
    4320:	b580      	push	{r7, lr}
    4322:	b084      	sub	sp, #16
    4324:	af00      	add	r7, sp, #0
    4326:	60b9      	str	r1, [r7, #8]
    4328:	607a      	str	r2, [r7, #4]
    432a:	230f      	movs	r3, #15
    432c:	18fb      	adds	r3, r7, r3
    432e:	1c02      	adds	r2, r0, #0
    4330:	701a      	strb	r2, [r3, #0]
	if (!(condition)) {
    4332:	230f      	movs	r3, #15
    4334:	18fb      	adds	r3, r7, r3
    4336:	781b      	ldrb	r3, [r3, #0]
    4338:	2201      	movs	r2, #1
    433a:	4053      	eors	r3, r2
    433c:	b2db      	uxtb	r3, r3
    433e:	2b00      	cmp	r3, #0
    4340:	d000      	beq.n	4344 <assert+0x24>
		__asm("BKPT #0");
    4342:	be00      	bkpt	0x0000
	}
	(void)file;
	(void)line;
}
    4344:	46c0      	nop			; (mov r8, r8)
    4346:	46bd      	mov	sp, r7
    4348:	b004      	add	sp, #16
    434a:	bd80      	pop	{r7, pc}

0000434c <_sbrk>:

/**
 * \brief Replacement of C library of _sbrk
 */
extern caddr_t _sbrk(int incr)
{
    434c:	b580      	push	{r7, lr}
    434e:	b084      	sub	sp, #16
    4350:	af00      	add	r7, sp, #0
    4352:	6078      	str	r0, [r7, #4]
	static unsigned char *heap = NULL;
	unsigned char *       prev_heap;

	if (heap == NULL) {
    4354:	4b0a      	ldr	r3, [pc, #40]	; (4380 <_sbrk+0x34>)
    4356:	681b      	ldr	r3, [r3, #0]
    4358:	2b00      	cmp	r3, #0
    435a:	d102      	bne.n	4362 <_sbrk+0x16>
		heap = (unsigned char *)&_end;
    435c:	4b08      	ldr	r3, [pc, #32]	; (4380 <_sbrk+0x34>)
    435e:	4a09      	ldr	r2, [pc, #36]	; (4384 <_sbrk+0x38>)
    4360:	601a      	str	r2, [r3, #0]
	}
	prev_heap = heap;
    4362:	4b07      	ldr	r3, [pc, #28]	; (4380 <_sbrk+0x34>)
    4364:	681b      	ldr	r3, [r3, #0]
    4366:	60fb      	str	r3, [r7, #12]

	heap += incr;
    4368:	4b05      	ldr	r3, [pc, #20]	; (4380 <_sbrk+0x34>)
    436a:	681a      	ldr	r2, [r3, #0]
    436c:	687b      	ldr	r3, [r7, #4]
    436e:	18d2      	adds	r2, r2, r3
    4370:	4b03      	ldr	r3, [pc, #12]	; (4380 <_sbrk+0x34>)
    4372:	601a      	str	r2, [r3, #0]

	return (caddr_t)prev_heap;
    4374:	68fb      	ldr	r3, [r7, #12]
}
    4376:	0018      	movs	r0, r3
    4378:	46bd      	mov	sp, r7
    437a:	b004      	add	sp, #16
    437c:	bd80      	pop	{r7, pc}
    437e:	46c0      	nop			; (mov r8, r8)
    4380:	200007c8 	.word	0x200007c8
    4384:	20002938 	.word	0x20002938

00004388 <_get_cycles_for_ms_internal>:

/**
 * \brief Retrieve the amount of cycles to delay for the given amount of ms
 */
static inline uint32_t _get_cycles_for_ms_internal(const uint16_t ms, const uint32_t freq, const uint8_t power)
{
    4388:	b590      	push	{r4, r7, lr}
    438a:	b083      	sub	sp, #12
    438c:	af00      	add	r7, sp, #0
    438e:	6039      	str	r1, [r7, #0]
    4390:	0011      	movs	r1, r2
    4392:	1dbb      	adds	r3, r7, #6
    4394:	1c02      	adds	r2, r0, #0
    4396:	801a      	strh	r2, [r3, #0]
    4398:	1d7b      	adds	r3, r7, #5
    439a:	1c0a      	adds	r2, r1, #0
    439c:	701a      	strb	r2, [r3, #0]
	switch (power) {
    439e:	1d7b      	adds	r3, r7, #5
    43a0:	781b      	ldrb	r3, [r3, #0]
    43a2:	3b04      	subs	r3, #4
    43a4:	2b04      	cmp	r3, #4
    43a6:	d84c      	bhi.n	4442 <_get_cycles_for_ms_internal+0xba>
    43a8:	009a      	lsls	r2, r3, #2
    43aa:	4b2e      	ldr	r3, [pc, #184]	; (4464 <_get_cycles_for_ms_internal+0xdc>)
    43ac:	18d3      	adds	r3, r2, r3
    43ae:	681b      	ldr	r3, [r3, #0]
    43b0:	469f      	mov	pc, r3
	case 8:
		return (ms * (freq / 100000)) * 100;
    43b2:	1dbb      	adds	r3, r7, #6
    43b4:	881c      	ldrh	r4, [r3, #0]
    43b6:	683b      	ldr	r3, [r7, #0]
    43b8:	492b      	ldr	r1, [pc, #172]	; (4468 <_get_cycles_for_ms_internal+0xe0>)
    43ba:	0018      	movs	r0, r3
    43bc:	f003 fbba 	bl	7b34 <__udivsi3>
    43c0:	0003      	movs	r3, r0
    43c2:	4363      	muls	r3, r4
    43c4:	2264      	movs	r2, #100	; 0x64
    43c6:	4353      	muls	r3, r2
    43c8:	e047      	b.n	445a <_get_cycles_for_ms_internal+0xd2>
	case 7:
		return (ms * (freq / 10000)) * 10;
    43ca:	1dbb      	adds	r3, r7, #6
    43cc:	881c      	ldrh	r4, [r3, #0]
    43ce:	683b      	ldr	r3, [r7, #0]
    43d0:	4926      	ldr	r1, [pc, #152]	; (446c <_get_cycles_for_ms_internal+0xe4>)
    43d2:	0018      	movs	r0, r3
    43d4:	f003 fbae 	bl	7b34 <__udivsi3>
    43d8:	0003      	movs	r3, r0
    43da:	4363      	muls	r3, r4
    43dc:	001a      	movs	r2, r3
    43de:	0013      	movs	r3, r2
    43e0:	009b      	lsls	r3, r3, #2
    43e2:	189b      	adds	r3, r3, r2
    43e4:	005b      	lsls	r3, r3, #1
    43e6:	e038      	b.n	445a <_get_cycles_for_ms_internal+0xd2>
	case 6:
		return (ms * (freq / 1000));
    43e8:	1dbb      	adds	r3, r7, #6
    43ea:	881c      	ldrh	r4, [r3, #0]
    43ec:	683a      	ldr	r2, [r7, #0]
    43ee:	23fa      	movs	r3, #250	; 0xfa
    43f0:	0099      	lsls	r1, r3, #2
    43f2:	0010      	movs	r0, r2
    43f4:	f003 fb9e 	bl	7b34 <__udivsi3>
    43f8:	0003      	movs	r3, r0
    43fa:	4363      	muls	r3, r4
    43fc:	e02d      	b.n	445a <_get_cycles_for_ms_internal+0xd2>
	case 5:
		return (ms * (freq / 100) - 1) / 10 + 1;
    43fe:	1dbb      	adds	r3, r7, #6
    4400:	881c      	ldrh	r4, [r3, #0]
    4402:	683b      	ldr	r3, [r7, #0]
    4404:	2164      	movs	r1, #100	; 0x64
    4406:	0018      	movs	r0, r3
    4408:	f003 fb94 	bl	7b34 <__udivsi3>
    440c:	0003      	movs	r3, r0
    440e:	4363      	muls	r3, r4
    4410:	3b01      	subs	r3, #1
    4412:	210a      	movs	r1, #10
    4414:	0018      	movs	r0, r3
    4416:	f003 fb8d 	bl	7b34 <__udivsi3>
    441a:	0003      	movs	r3, r0
    441c:	3301      	adds	r3, #1
    441e:	e01c      	b.n	445a <_get_cycles_for_ms_internal+0xd2>
	case 4:
		return (ms * (freq / 10) - 1) / 100 + 1;
    4420:	1dbb      	adds	r3, r7, #6
    4422:	881c      	ldrh	r4, [r3, #0]
    4424:	683b      	ldr	r3, [r7, #0]
    4426:	210a      	movs	r1, #10
    4428:	0018      	movs	r0, r3
    442a:	f003 fb83 	bl	7b34 <__udivsi3>
    442e:	0003      	movs	r3, r0
    4430:	4363      	muls	r3, r4
    4432:	3b01      	subs	r3, #1
    4434:	2164      	movs	r1, #100	; 0x64
    4436:	0018      	movs	r0, r3
    4438:	f003 fb7c 	bl	7b34 <__udivsi3>
    443c:	0003      	movs	r3, r0
    443e:	3301      	adds	r3, #1
    4440:	e00b      	b.n	445a <_get_cycles_for_ms_internal+0xd2>
	default:
		return (ms * freq - 1) / 1000 + 1;
    4442:	1dbb      	adds	r3, r7, #6
    4444:	881b      	ldrh	r3, [r3, #0]
    4446:	683a      	ldr	r2, [r7, #0]
    4448:	4353      	muls	r3, r2
    444a:	1e5a      	subs	r2, r3, #1
    444c:	23fa      	movs	r3, #250	; 0xfa
    444e:	0099      	lsls	r1, r3, #2
    4450:	0010      	movs	r0, r2
    4452:	f003 fb6f 	bl	7b34 <__udivsi3>
    4456:	0003      	movs	r3, r0
    4458:	3301      	adds	r3, #1
	}
}
    445a:	0018      	movs	r0, r3
    445c:	46bd      	mov	sp, r7
    445e:	b003      	add	sp, #12
    4460:	bd90      	pop	{r4, r7, pc}
    4462:	46c0      	nop			; (mov r8, r8)
    4464:	00008aec 	.word	0x00008aec
    4468:	000186a0 	.word	0x000186a0
    446c:	00002710 	.word	0x00002710

00004470 <_get_cycles_for_ms>:

/**
 * \brief Retrieve the amount of cycles to delay for the given amount of ms
 */
uint32_t _get_cycles_for_ms(const uint16_t ms)
{
    4470:	b580      	push	{r7, lr}
    4472:	b082      	sub	sp, #8
    4474:	af00      	add	r7, sp, #0
    4476:	0002      	movs	r2, r0
    4478:	1dbb      	adds	r3, r7, #6
    447a:	801a      	strh	r2, [r3, #0]
	return _get_cycles_for_ms_internal(ms, CONF_CPU_FREQUENCY, CPU_FREQ_POWER);
    447c:	4905      	ldr	r1, [pc, #20]	; (4494 <_get_cycles_for_ms+0x24>)
    447e:	1dbb      	adds	r3, r7, #6
    4480:	881b      	ldrh	r3, [r3, #0]
    4482:	2208      	movs	r2, #8
    4484:	0018      	movs	r0, r3
    4486:	f7ff ff7f 	bl	4388 <_get_cycles_for_ms_internal>
    448a:	0003      	movs	r3, r0
}
    448c:	0018      	movs	r0, r3
    448e:	46bd      	mov	sp, r7
    4490:	b002      	add	sp, #8
    4492:	bd80      	pop	{r7, pc}
    4494:	02dc6c00 	.word	0x02dc6c00

00004498 <hri_nvmctrl_set_CTRLB_RWS_bf>:
	((Nvmctrl *)hw)->CTRLB.reg ^= NVMCTRL_CTRLB_CACHEDIS;
	NVMCTRL_CRITICAL_SECTION_LEAVE();
}

static inline void hri_nvmctrl_set_CTRLB_RWS_bf(const void *const hw, hri_nvmctrl_ctrlb_reg_t mask)
{
    4498:	b580      	push	{r7, lr}
    449a:	b082      	sub	sp, #8
    449c:	af00      	add	r7, sp, #0
    449e:	6078      	str	r0, [r7, #4]
    44a0:	6039      	str	r1, [r7, #0]
	NVMCTRL_CRITICAL_SECTION_ENTER();
	((Nvmctrl *)hw)->CTRLB.reg |= NVMCTRL_CTRLB_RWS(mask);
    44a2:	687b      	ldr	r3, [r7, #4]
    44a4:	685a      	ldr	r2, [r3, #4]
    44a6:	683b      	ldr	r3, [r7, #0]
    44a8:	005b      	lsls	r3, r3, #1
    44aa:	211e      	movs	r1, #30
    44ac:	400b      	ands	r3, r1
    44ae:	431a      	orrs	r2, r3
    44b0:	687b      	ldr	r3, [r7, #4]
    44b2:	605a      	str	r2, [r3, #4]
	NVMCTRL_CRITICAL_SECTION_LEAVE();
}
    44b4:	46c0      	nop			; (mov r8, r8)
    44b6:	46bd      	mov	sp, r7
    44b8:	b002      	add	sp, #8
    44ba:	bd80      	pop	{r7, pc}

000044bc <_init_chip>:

/**
 * \brief Initialize the hardware abstraction layer
 */
void _init_chip(void)
{
    44bc:	b580      	push	{r7, lr}
    44be:	af00      	add	r7, sp, #0
	hri_nvmctrl_set_CTRLB_RWS_bf(NVMCTRL, CONF_NVM_WAIT_STATE);
    44c0:	4b09      	ldr	r3, [pc, #36]	; (44e8 <_init_chip+0x2c>)
    44c2:	2103      	movs	r1, #3
    44c4:	0018      	movs	r0, r3
    44c6:	f7ff ffe7 	bl	4498 <hri_nvmctrl_set_CTRLB_RWS_bf>

	_pm_init();
    44ca:	f000 fb6b 	bl	4ba4 <_pm_init>
	_sysctrl_init_sources();
    44ce:	f001 fe79 	bl	61c4 <_sysctrl_init_sources>
#if _GCLK_INIT_1ST
	_gclk_init_generators_by_fref(_GCLK_INIT_1ST);
    44d2:	2008      	movs	r0, #8
    44d4:	f000 fada 	bl	4a8c <_gclk_init_generators_by_fref>
#endif
	_sysctrl_init_referenced_generators();
    44d8:	f001 fee6 	bl	62a8 <_sysctrl_init_referenced_generators>
	_gclk_init_generators_by_fref(_GCLK_INIT_LAST);
    44dc:	20f7      	movs	r0, #247	; 0xf7
    44de:	f000 fad5 	bl	4a8c <_gclk_init_generators_by_fref>
}
    44e2:	46c0      	nop			; (mov r8, r8)
    44e4:	46bd      	mov	sp, r7
    44e6:	bd80      	pop	{r7, pc}
    44e8:	41004000 	.word	0x41004000

000044ec <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
    44ec:	b580      	push	{r7, lr}
    44ee:	b082      	sub	sp, #8
    44f0:	af00      	add	r7, sp, #0
    44f2:	0002      	movs	r2, r0
    44f4:	1dfb      	adds	r3, r7, #7
    44f6:	701a      	strb	r2, [r3, #0]
  if ((int32_t)(IRQn) >= 0)
    44f8:	1dfb      	adds	r3, r7, #7
    44fa:	781b      	ldrb	r3, [r3, #0]
    44fc:	2b7f      	cmp	r3, #127	; 0x7f
    44fe:	d809      	bhi.n	4514 <__NVIC_EnableIRQ+0x28>
  {
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    4500:	4b06      	ldr	r3, [pc, #24]	; (451c <__NVIC_EnableIRQ+0x30>)
    4502:	1dfa      	adds	r2, r7, #7
    4504:	7812      	ldrb	r2, [r2, #0]
    4506:	0011      	movs	r1, r2
    4508:	221f      	movs	r2, #31
    450a:	400a      	ands	r2, r1
    450c:	2101      	movs	r1, #1
    450e:	4091      	lsls	r1, r2
    4510:	000a      	movs	r2, r1
    4512:	601a      	str	r2, [r3, #0]
  }
}
    4514:	46c0      	nop			; (mov r8, r8)
    4516:	46bd      	mov	sp, r7
    4518:	b002      	add	sp, #8
    451a:	bd80      	pop	{r7, pc}
    451c:	e000e100 	.word	0xe000e100

00004520 <__NVIC_DisableIRQ>:
  \details Disables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
    4520:	b580      	push	{r7, lr}
    4522:	b082      	sub	sp, #8
    4524:	af00      	add	r7, sp, #0
    4526:	0002      	movs	r2, r0
    4528:	1dfb      	adds	r3, r7, #7
    452a:	701a      	strb	r2, [r3, #0]
  if ((int32_t)(IRQn) >= 0)
    452c:	1dfb      	adds	r3, r7, #7
    452e:	781b      	ldrb	r3, [r3, #0]
    4530:	2b7f      	cmp	r3, #127	; 0x7f
    4532:	d80e      	bhi.n	4552 <__NVIC_DisableIRQ+0x32>
  {
    NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    4534:	4909      	ldr	r1, [pc, #36]	; (455c <__NVIC_DisableIRQ+0x3c>)
    4536:	1dfb      	adds	r3, r7, #7
    4538:	781b      	ldrb	r3, [r3, #0]
    453a:	001a      	movs	r2, r3
    453c:	231f      	movs	r3, #31
    453e:	4013      	ands	r3, r2
    4540:	2201      	movs	r2, #1
    4542:	409a      	lsls	r2, r3
    4544:	0013      	movs	r3, r2
    4546:	2280      	movs	r2, #128	; 0x80
    4548:	508b      	str	r3, [r1, r2]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
    454a:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    454e:	f3bf 8f6f 	isb	sy
    __DSB();
    __ISB();
  }
}
    4552:	46c0      	nop			; (mov r8, r8)
    4554:	46bd      	mov	sp, r7
    4556:	b002      	add	sp, #8
    4558:	bd80      	pop	{r7, pc}
    455a:	46c0      	nop			; (mov r8, r8)
    455c:	e000e100 	.word	0xe000e100

00004560 <__NVIC_ClearPendingIRQ>:
  \details Clears the pending bit of a device specific interrupt in the NVIC pending register.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
    4560:	b580      	push	{r7, lr}
    4562:	b082      	sub	sp, #8
    4564:	af00      	add	r7, sp, #0
    4566:	0002      	movs	r2, r0
    4568:	1dfb      	adds	r3, r7, #7
    456a:	701a      	strb	r2, [r3, #0]
  if ((int32_t)(IRQn) >= 0)
    456c:	1dfb      	adds	r3, r7, #7
    456e:	781b      	ldrb	r3, [r3, #0]
    4570:	2b7f      	cmp	r3, #127	; 0x7f
    4572:	d80a      	bhi.n	458a <__NVIC_ClearPendingIRQ+0x2a>
  {
    NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    4574:	4907      	ldr	r1, [pc, #28]	; (4594 <__NVIC_ClearPendingIRQ+0x34>)
    4576:	1dfb      	adds	r3, r7, #7
    4578:	781b      	ldrb	r3, [r3, #0]
    457a:	001a      	movs	r2, r3
    457c:	231f      	movs	r3, #31
    457e:	4013      	ands	r3, r2
    4580:	2201      	movs	r2, #1
    4582:	409a      	lsls	r2, r3
    4584:	23c0      	movs	r3, #192	; 0xc0
    4586:	005b      	lsls	r3, r3, #1
    4588:	50ca      	str	r2, [r1, r3]
  }
}
    458a:	46c0      	nop			; (mov r8, r8)
    458c:	46bd      	mov	sp, r7
    458e:	b002      	add	sp, #8
    4590:	bd80      	pop	{r7, pc}
    4592:	46c0      	nop			; (mov r8, r8)
    4594:	e000e100 	.word	0xe000e100

00004598 <hri_eic_wait_for_sync>:
typedef uint8_t  hri_eic_nmictrl_reg_t;
typedef uint8_t  hri_eic_nmiflag_reg_t;
typedef uint8_t  hri_eic_status_reg_t;

static inline void hri_eic_wait_for_sync(const void *const hw)
{
    4598:	b580      	push	{r7, lr}
    459a:	b082      	sub	sp, #8
    459c:	af00      	add	r7, sp, #0
    459e:	6078      	str	r0, [r7, #4]
	while (((const Eic *)hw)->STATUS.bit.SYNCBUSY)
    45a0:	46c0      	nop			; (mov r8, r8)
    45a2:	687b      	ldr	r3, [r7, #4]
    45a4:	785b      	ldrb	r3, [r3, #1]
    45a6:	061b      	lsls	r3, r3, #24
    45a8:	0fdb      	lsrs	r3, r3, #31
    45aa:	b2db      	uxtb	r3, r3
    45ac:	2b00      	cmp	r3, #0
    45ae:	d1f8      	bne.n	45a2 <hri_eic_wait_for_sync+0xa>
		;
}
    45b0:	46c0      	nop			; (mov r8, r8)
    45b2:	46bd      	mov	sp, r7
    45b4:	b002      	add	sp, #8
    45b6:	bd80      	pop	{r7, pc}

000045b8 <hri_eic_read_INTFLAG_reg>:
	tmp &= mask;
	return tmp;
}

static inline hri_eic_intflag_reg_t hri_eic_read_INTFLAG_reg(const void *const hw)
{
    45b8:	b580      	push	{r7, lr}
    45ba:	b082      	sub	sp, #8
    45bc:	af00      	add	r7, sp, #0
    45be:	6078      	str	r0, [r7, #4]
	return ((Eic *)hw)->INTFLAG.reg;
    45c0:	687b      	ldr	r3, [r7, #4]
    45c2:	691b      	ldr	r3, [r3, #16]
}
    45c4:	0018      	movs	r0, r3
    45c6:	46bd      	mov	sp, r7
    45c8:	b002      	add	sp, #8
    45ca:	bd80      	pop	{r7, pc}

000045cc <hri_eic_clear_INTFLAG_reg>:

static inline void hri_eic_clear_INTFLAG_reg(const void *const hw, hri_eic_intflag_reg_t mask)
{
    45cc:	b580      	push	{r7, lr}
    45ce:	b082      	sub	sp, #8
    45d0:	af00      	add	r7, sp, #0
    45d2:	6078      	str	r0, [r7, #4]
    45d4:	6039      	str	r1, [r7, #0]
	((Eic *)hw)->INTFLAG.reg = mask;
    45d6:	687b      	ldr	r3, [r7, #4]
    45d8:	683a      	ldr	r2, [r7, #0]
    45da:	611a      	str	r2, [r3, #16]
}
    45dc:	46c0      	nop			; (mov r8, r8)
    45de:	46bd      	mov	sp, r7
    45e0:	b002      	add	sp, #8
    45e2:	bd80      	pop	{r7, pc}

000045e4 <hri_eic_set_INTEN_reg>:
{
	((Eic *)hw)->INTENCLR.reg = EIC_INTENSET_EXTINT15;
}

static inline void hri_eic_set_INTEN_reg(const void *const hw, hri_eic_intenset_reg_t mask)
{
    45e4:	b580      	push	{r7, lr}
    45e6:	b082      	sub	sp, #8
    45e8:	af00      	add	r7, sp, #0
    45ea:	6078      	str	r0, [r7, #4]
    45ec:	6039      	str	r1, [r7, #0]
	((Eic *)hw)->INTENSET.reg = mask;
    45ee:	687b      	ldr	r3, [r7, #4]
    45f0:	683a      	ldr	r2, [r7, #0]
    45f2:	60da      	str	r2, [r3, #12]
}
    45f4:	46c0      	nop			; (mov r8, r8)
    45f6:	46bd      	mov	sp, r7
    45f8:	b002      	add	sp, #8
    45fa:	bd80      	pop	{r7, pc}

000045fc <hri_eic_read_INTEN_reg>:
	tmp &= mask;
	return tmp;
}

static inline hri_eic_intenset_reg_t hri_eic_read_INTEN_reg(const void *const hw)
{
    45fc:	b580      	push	{r7, lr}
    45fe:	b082      	sub	sp, #8
    4600:	af00      	add	r7, sp, #0
    4602:	6078      	str	r0, [r7, #4]
	return ((Eic *)hw)->INTENSET.reg;
    4604:	687b      	ldr	r3, [r7, #4]
    4606:	68db      	ldr	r3, [r3, #12]
}
    4608:	0018      	movs	r0, r3
    460a:	46bd      	mov	sp, r7
    460c:	b002      	add	sp, #8
    460e:	bd80      	pop	{r7, pc}

00004610 <hri_eic_clear_INTEN_reg>:
	((Eic *)hw)->INTENSET.reg = data;
	((Eic *)hw)->INTENCLR.reg = ~data;
}

static inline void hri_eic_clear_INTEN_reg(const void *const hw, hri_eic_intenset_reg_t mask)
{
    4610:	b580      	push	{r7, lr}
    4612:	b082      	sub	sp, #8
    4614:	af00      	add	r7, sp, #0
    4616:	6078      	str	r0, [r7, #4]
    4618:	6039      	str	r1, [r7, #0]
	((Eic *)hw)->INTENCLR.reg = mask;
    461a:	687b      	ldr	r3, [r7, #4]
    461c:	683a      	ldr	r2, [r7, #0]
    461e:	609a      	str	r2, [r3, #8]
}
    4620:	46c0      	nop			; (mov r8, r8)
    4622:	46bd      	mov	sp, r7
    4624:	b002      	add	sp, #8
    4626:	bd80      	pop	{r7, pc}

00004628 <hri_eic_set_CTRL_ENABLE_bit>:
	tmp = (tmp & EIC_CTRL_SWRST) >> EIC_CTRL_SWRST_Pos;
	return (bool)tmp;
}

static inline void hri_eic_set_CTRL_ENABLE_bit(const void *const hw)
{
    4628:	b580      	push	{r7, lr}
    462a:	b082      	sub	sp, #8
    462c:	af00      	add	r7, sp, #0
    462e:	6078      	str	r0, [r7, #4]
	EIC_CRITICAL_SECTION_ENTER();
	((Eic *)hw)->CTRL.reg |= EIC_CTRL_ENABLE;
    4630:	687b      	ldr	r3, [r7, #4]
    4632:	781b      	ldrb	r3, [r3, #0]
    4634:	b2db      	uxtb	r3, r3
    4636:	2202      	movs	r2, #2
    4638:	4313      	orrs	r3, r2
    463a:	b2da      	uxtb	r2, r3
    463c:	687b      	ldr	r3, [r7, #4]
    463e:	701a      	strb	r2, [r3, #0]
	hri_eic_wait_for_sync(hw);
    4640:	687b      	ldr	r3, [r7, #4]
    4642:	0018      	movs	r0, r3
    4644:	f7ff ffa8 	bl	4598 <hri_eic_wait_for_sync>
	EIC_CRITICAL_SECTION_LEAVE();
}
    4648:	46c0      	nop			; (mov r8, r8)
    464a:	46bd      	mov	sp, r7
    464c:	b002      	add	sp, #8
    464e:	bd80      	pop	{r7, pc}

00004650 <hri_eic_get_CTRL_reg>:
	hri_eic_wait_for_sync(hw);
	EIC_CRITICAL_SECTION_LEAVE();
}

static inline hri_eic_ctrl_reg_t hri_eic_get_CTRL_reg(const void *const hw, hri_eic_ctrl_reg_t mask)
{
    4650:	b580      	push	{r7, lr}
    4652:	b084      	sub	sp, #16
    4654:	af00      	add	r7, sp, #0
    4656:	6078      	str	r0, [r7, #4]
    4658:	000a      	movs	r2, r1
    465a:	1cfb      	adds	r3, r7, #3
    465c:	701a      	strb	r2, [r3, #0]
	uint8_t tmp;
	hri_eic_wait_for_sync(hw);
    465e:	687b      	ldr	r3, [r7, #4]
    4660:	0018      	movs	r0, r3
    4662:	f7ff ff99 	bl	4598 <hri_eic_wait_for_sync>
	tmp = ((Eic *)hw)->CTRL.reg;
    4666:	230f      	movs	r3, #15
    4668:	18fb      	adds	r3, r7, r3
    466a:	687a      	ldr	r2, [r7, #4]
    466c:	7812      	ldrb	r2, [r2, #0]
    466e:	701a      	strb	r2, [r3, #0]
	tmp &= mask;
    4670:	230f      	movs	r3, #15
    4672:	18fb      	adds	r3, r7, r3
    4674:	220f      	movs	r2, #15
    4676:	18ba      	adds	r2, r7, r2
    4678:	1cf9      	adds	r1, r7, #3
    467a:	7812      	ldrb	r2, [r2, #0]
    467c:	7809      	ldrb	r1, [r1, #0]
    467e:	400a      	ands	r2, r1
    4680:	701a      	strb	r2, [r3, #0]
	return tmp;
    4682:	230f      	movs	r3, #15
    4684:	18fb      	adds	r3, r7, r3
    4686:	781b      	ldrb	r3, [r3, #0]
}
    4688:	0018      	movs	r0, r3
    468a:	46bd      	mov	sp, r7
    468c:	b004      	add	sp, #16
    468e:	bd80      	pop	{r7, pc}

00004690 <hri_eic_write_CTRL_reg>:

static inline void hri_eic_write_CTRL_reg(const void *const hw, hri_eic_ctrl_reg_t data)
{
    4690:	b580      	push	{r7, lr}
    4692:	b082      	sub	sp, #8
    4694:	af00      	add	r7, sp, #0
    4696:	6078      	str	r0, [r7, #4]
    4698:	000a      	movs	r2, r1
    469a:	1cfb      	adds	r3, r7, #3
    469c:	701a      	strb	r2, [r3, #0]
	EIC_CRITICAL_SECTION_ENTER();
	((Eic *)hw)->CTRL.reg = data;
    469e:	687b      	ldr	r3, [r7, #4]
    46a0:	1cfa      	adds	r2, r7, #3
    46a2:	7812      	ldrb	r2, [r2, #0]
    46a4:	701a      	strb	r2, [r3, #0]
	hri_eic_wait_for_sync(hw);
    46a6:	687b      	ldr	r3, [r7, #4]
    46a8:	0018      	movs	r0, r3
    46aa:	f7ff ff75 	bl	4598 <hri_eic_wait_for_sync>
	EIC_CRITICAL_SECTION_LEAVE();
}
    46ae:	46c0      	nop			; (mov r8, r8)
    46b0:	46bd      	mov	sp, r7
    46b2:	b002      	add	sp, #8
    46b4:	bd80      	pop	{r7, pc}

000046b6 <hri_eic_write_NMICTRL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_eic_write_NMICTRL_reg(const void *const hw, hri_eic_nmictrl_reg_t data)
{
    46b6:	b580      	push	{r7, lr}
    46b8:	b082      	sub	sp, #8
    46ba:	af00      	add	r7, sp, #0
    46bc:	6078      	str	r0, [r7, #4]
    46be:	000a      	movs	r2, r1
    46c0:	1cfb      	adds	r3, r7, #3
    46c2:	701a      	strb	r2, [r3, #0]
	EIC_CRITICAL_SECTION_ENTER();
	((Eic *)hw)->NMICTRL.reg = data;
    46c4:	687b      	ldr	r3, [r7, #4]
    46c6:	1cfa      	adds	r2, r7, #3
    46c8:	7812      	ldrb	r2, [r2, #0]
    46ca:	709a      	strb	r2, [r3, #2]
	EIC_CRITICAL_SECTION_LEAVE();
}
    46cc:	46c0      	nop			; (mov r8, r8)
    46ce:	46bd      	mov	sp, r7
    46d0:	b002      	add	sp, #8
    46d2:	bd80      	pop	{r7, pc}

000046d4 <hri_eic_write_EVCTRL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_eic_write_EVCTRL_reg(const void *const hw, hri_eic_evctrl_reg_t data)
{
    46d4:	b580      	push	{r7, lr}
    46d6:	b082      	sub	sp, #8
    46d8:	af00      	add	r7, sp, #0
    46da:	6078      	str	r0, [r7, #4]
    46dc:	6039      	str	r1, [r7, #0]
	EIC_CRITICAL_SECTION_ENTER();
	((Eic *)hw)->EVCTRL.reg = data;
    46de:	687b      	ldr	r3, [r7, #4]
    46e0:	683a      	ldr	r2, [r7, #0]
    46e2:	605a      	str	r2, [r3, #4]
	EIC_CRITICAL_SECTION_LEAVE();
}
    46e4:	46c0      	nop			; (mov r8, r8)
    46e6:	46bd      	mov	sp, r7
    46e8:	b002      	add	sp, #8
    46ea:	bd80      	pop	{r7, pc}

000046ec <hri_eic_write_WAKEUP_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_eic_write_WAKEUP_reg(const void *const hw, hri_eic_wakeup_reg_t data)
{
    46ec:	b580      	push	{r7, lr}
    46ee:	b082      	sub	sp, #8
    46f0:	af00      	add	r7, sp, #0
    46f2:	6078      	str	r0, [r7, #4]
    46f4:	6039      	str	r1, [r7, #0]
	EIC_CRITICAL_SECTION_ENTER();
	((Eic *)hw)->WAKEUP.reg = data;
    46f6:	687b      	ldr	r3, [r7, #4]
    46f8:	683a      	ldr	r2, [r7, #0]
    46fa:	615a      	str	r2, [r3, #20]
	EIC_CRITICAL_SECTION_LEAVE();
}
    46fc:	46c0      	nop			; (mov r8, r8)
    46fe:	46bd      	mov	sp, r7
    4700:	b002      	add	sp, #8
    4702:	bd80      	pop	{r7, pc}

00004704 <hri_eic_write_CONFIG_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_eic_write_CONFIG_reg(const void *const hw, uint8_t index, hri_eic_config_reg_t data)
{
    4704:	b580      	push	{r7, lr}
    4706:	b084      	sub	sp, #16
    4708:	af00      	add	r7, sp, #0
    470a:	60f8      	str	r0, [r7, #12]
    470c:	607a      	str	r2, [r7, #4]
    470e:	230b      	movs	r3, #11
    4710:	18fb      	adds	r3, r7, r3
    4712:	1c0a      	adds	r2, r1, #0
    4714:	701a      	strb	r2, [r3, #0]
	EIC_CRITICAL_SECTION_ENTER();
	((Eic *)hw)->CONFIG[index].reg = data;
    4716:	230b      	movs	r3, #11
    4718:	18fb      	adds	r3, r7, r3
    471a:	781a      	ldrb	r2, [r3, #0]
    471c:	68fb      	ldr	r3, [r7, #12]
    471e:	3206      	adds	r2, #6
    4720:	0092      	lsls	r2, r2, #2
    4722:	6879      	ldr	r1, [r7, #4]
    4724:	50d1      	str	r1, [r2, r3]
	EIC_CRITICAL_SECTION_LEAVE();
}
    4726:	46c0      	nop			; (mov r8, r8)
    4728:	46bd      	mov	sp, r7
    472a:	b004      	add	sp, #16
    472c:	bd80      	pop	{r7, pc}
	...

00004730 <_ext_irq_init>:

/**
 * \brief Initialize external interrupt module
 */
int32_t _ext_irq_init(void (*cb)(const uint32_t pin))
{
    4730:	b580      	push	{r7, lr}
    4732:	b082      	sub	sp, #8
    4734:	af00      	add	r7, sp, #0
    4736:	6078      	str	r0, [r7, #4]
	hri_eic_wait_for_sync(EIC);
    4738:	4b28      	ldr	r3, [pc, #160]	; (47dc <_ext_irq_init+0xac>)
    473a:	0018      	movs	r0, r3
    473c:	f7ff ff2c 	bl	4598 <hri_eic_wait_for_sync>
	if (hri_eic_get_CTRL_reg(EIC, EIC_CTRL_ENABLE)) {
    4740:	4b26      	ldr	r3, [pc, #152]	; (47dc <_ext_irq_init+0xac>)
    4742:	2102      	movs	r1, #2
    4744:	0018      	movs	r0, r3
    4746:	f7ff ff83 	bl	4650 <hri_eic_get_CTRL_reg>
    474a:	1e03      	subs	r3, r0, #0
    474c:	d008      	beq.n	4760 <_ext_irq_init+0x30>
		hri_eic_write_CTRL_reg(EIC, 0);
    474e:	4b23      	ldr	r3, [pc, #140]	; (47dc <_ext_irq_init+0xac>)
    4750:	2100      	movs	r1, #0
    4752:	0018      	movs	r0, r3
    4754:	f7ff ff9c 	bl	4690 <hri_eic_write_CTRL_reg>
		hri_eic_wait_for_sync(EIC);
    4758:	4b20      	ldr	r3, [pc, #128]	; (47dc <_ext_irq_init+0xac>)
    475a:	0018      	movs	r0, r3
    475c:	f7ff ff1c 	bl	4598 <hri_eic_wait_for_sync>
	}
	hri_eic_write_CTRL_reg(EIC, EIC_CTRL_SWRST);
    4760:	4b1e      	ldr	r3, [pc, #120]	; (47dc <_ext_irq_init+0xac>)
    4762:	2101      	movs	r1, #1
    4764:	0018      	movs	r0, r3
    4766:	f7ff ff93 	bl	4690 <hri_eic_write_CTRL_reg>
	hri_eic_wait_for_sync(EIC);
    476a:	4b1c      	ldr	r3, [pc, #112]	; (47dc <_ext_irq_init+0xac>)
    476c:	0018      	movs	r0, r3
    476e:	f7ff ff13 	bl	4598 <hri_eic_wait_for_sync>

	hri_eic_write_NMICTRL_reg(
    4772:	4b1a      	ldr	r3, [pc, #104]	; (47dc <_ext_irq_init+0xac>)
    4774:	2100      	movs	r1, #0
    4776:	0018      	movs	r0, r3
    4778:	f7ff ff9d 	bl	46b6 <hri_eic_write_NMICTRL_reg>
	    EIC, (CONF_EIC_NMIFILTEN << EIC_NMICTRL_NMIFILTEN_Pos) | EIC_NMICTRL_NMISENSE(CONF_EIC_NMISENSE));
	hri_eic_write_EVCTRL_reg(EIC,
    477c:	2380      	movs	r3, #128	; 0x80
    477e:	00db      	lsls	r3, r3, #3
    4780:	4a16      	ldr	r2, [pc, #88]	; (47dc <_ext_irq_init+0xac>)
    4782:	0019      	movs	r1, r3
    4784:	0010      	movs	r0, r2
    4786:	f7ff ffa5 	bl	46d4 <hri_eic_write_EVCTRL_reg>
	                             | (CONF_EIC_EXTINTEO6 << 6) | (CONF_EIC_EXTINTEO7 << 7) | (CONF_EIC_EXTINTEO8 << 8)
	                             | (CONF_EIC_EXTINTEO9 << 9) | (CONF_EIC_EXTINTEO10 << 10) | (CONF_EIC_EXTINTEO11 << 11)
	                             | (CONF_EIC_EXTINTEO12 << 12) | (CONF_EIC_EXTINTEO13 << 13)
	                             | (CONF_EIC_EXTINTEO14 << 14) | (CONF_EIC_EXTINTEO15 << 15) | 0);

	hri_eic_write_WAKEUP_reg(EIC,
    478a:	2380      	movs	r3, #128	; 0x80
    478c:	01db      	lsls	r3, r3, #7
    478e:	4a13      	ldr	r2, [pc, #76]	; (47dc <_ext_irq_init+0xac>)
    4790:	0019      	movs	r1, r3
    4792:	0010      	movs	r0, r2
    4794:	f7ff ffaa 	bl	46ec <hri_eic_write_WAKEUP_reg>
	                             | (CONF_EIC_WAKEUPEN3 << 3) | (CONF_EIC_WAKEUPEN4 << 4) | (CONF_EIC_WAKEUPEN5 << 5)
	                             | (CONF_EIC_WAKEUPEN6 << 6) | (CONF_EIC_WAKEUPEN7 << 7) | (CONF_EIC_WAKEUPEN8 << 8)
	                             | (CONF_EIC_WAKEUPEN9 << 9) | (CONF_EIC_WAKEUPEN10 << 10) | (CONF_EIC_WAKEUPEN11 << 11)
	                             | (CONF_EIC_WAKEUPEN12 << 12) | (CONF_EIC_WAKEUPEN13 << 13)
	                             | (CONF_EIC_WAKEUPEN14 << 14) | (CONF_EIC_WAKEUPEN15 << 15) | 0);
	hri_eic_write_CONFIG_reg(EIC,
    4798:	4b10      	ldr	r3, [pc, #64]	; (47dc <_ext_irq_init+0xac>)
    479a:	2290      	movs	r2, #144	; 0x90
    479c:	2100      	movs	r1, #0
    479e:	0018      	movs	r0, r3
    47a0:	f7ff ffb0 	bl	4704 <hri_eic_write_CONFIG_reg>
	                             | (CONF_EIC_FILTEN5 << EIC_CONFIG_FILTEN5_Pos) | EIC_CONFIG_SENSE5(CONF_EIC_SENSE5)
	                             | (CONF_EIC_FILTEN6 << EIC_CONFIG_FILTEN6_Pos) | EIC_CONFIG_SENSE6(CONF_EIC_SENSE6)
	                             | (CONF_EIC_FILTEN7 << EIC_CONFIG_FILTEN7_Pos) | EIC_CONFIG_SENSE7(CONF_EIC_SENSE7)
	                             | 0);

	hri_eic_write_CONFIG_reg(EIC,
    47a4:	4a0e      	ldr	r2, [pc, #56]	; (47e0 <_ext_irq_init+0xb0>)
    47a6:	4b0d      	ldr	r3, [pc, #52]	; (47dc <_ext_irq_init+0xac>)
    47a8:	2101      	movs	r1, #1
    47aa:	0018      	movs	r0, r3
    47ac:	f7ff ffaa 	bl	4704 <hri_eic_write_CONFIG_reg>
	                             | (CONF_EIC_FILTEN13 << EIC_CONFIG_FILTEN5_Pos) | EIC_CONFIG_SENSE5(CONF_EIC_SENSE13)
	                             | (CONF_EIC_FILTEN14 << EIC_CONFIG_FILTEN6_Pos) | EIC_CONFIG_SENSE6(CONF_EIC_SENSE14)
	                             | (CONF_EIC_FILTEN15 << EIC_CONFIG_FILTEN7_Pos) | EIC_CONFIG_SENSE7(CONF_EIC_SENSE15)
	                             | 0);

	hri_eic_set_CTRL_ENABLE_bit(EIC);
    47b0:	4b0a      	ldr	r3, [pc, #40]	; (47dc <_ext_irq_init+0xac>)
    47b2:	0018      	movs	r0, r3
    47b4:	f7ff ff38 	bl	4628 <hri_eic_set_CTRL_ENABLE_bit>

	NVIC_DisableIRQ(EIC_IRQn);
    47b8:	2004      	movs	r0, #4
    47ba:	f7ff feb1 	bl	4520 <__NVIC_DisableIRQ>
	NVIC_ClearPendingIRQ(EIC_IRQn);
    47be:	2004      	movs	r0, #4
    47c0:	f7ff fece 	bl	4560 <__NVIC_ClearPendingIRQ>
	NVIC_EnableIRQ(EIC_IRQn);
    47c4:	2004      	movs	r0, #4
    47c6:	f7ff fe91 	bl	44ec <__NVIC_EnableIRQ>

	callback = cb;
    47ca:	4b06      	ldr	r3, [pc, #24]	; (47e4 <_ext_irq_init+0xb4>)
    47cc:	687a      	ldr	r2, [r7, #4]
    47ce:	601a      	str	r2, [r3, #0]

	return ERR_NONE;
    47d0:	2300      	movs	r3, #0
}
    47d2:	0018      	movs	r0, r3
    47d4:	46bd      	mov	sp, r7
    47d6:	b002      	add	sp, #8
    47d8:	bd80      	pop	{r7, pc}
    47da:	46c0      	nop			; (mov r8, r8)
    47dc:	40001800 	.word	0x40001800
    47e0:	01000200 	.word	0x01000200
    47e4:	200007cc 	.word	0x200007cc

000047e8 <_ext_irq_enable>:

/**
 * \brief Enable / disable external irq
 */
int32_t _ext_irq_enable(const uint32_t pin, const bool enable)
{
    47e8:	b580      	push	{r7, lr}
    47ea:	b084      	sub	sp, #16
    47ec:	af00      	add	r7, sp, #0
    47ee:	6078      	str	r0, [r7, #4]
    47f0:	000a      	movs	r2, r1
    47f2:	1cfb      	adds	r3, r7, #3
    47f4:	701a      	strb	r2, [r3, #0]
	uint8_t extint = INVALID_EXTINT_NUMBER;
    47f6:	230f      	movs	r3, #15
    47f8:	18fb      	adds	r3, r7, r3
    47fa:	22ff      	movs	r2, #255	; 0xff
    47fc:	701a      	strb	r2, [r3, #0]
	uint8_t i      = 0;
    47fe:	230e      	movs	r3, #14
    4800:	18fb      	adds	r3, r7, r3
    4802:	2200      	movs	r2, #0
    4804:	701a      	strb	r2, [r3, #0]

	for (; i < ARRAY_SIZE(_map); i++) {
    4806:	e01b      	b.n	4840 <_ext_irq_enable+0x58>
		if (_map[i].pin == pin) {
    4808:	230e      	movs	r3, #14
    480a:	18fb      	adds	r3, r7, r3
    480c:	781b      	ldrb	r3, [r3, #0]
    480e:	4a28      	ldr	r2, [pc, #160]	; (48b0 <_ext_irq_enable+0xc8>)
    4810:	00db      	lsls	r3, r3, #3
    4812:	18d3      	adds	r3, r2, r3
    4814:	3304      	adds	r3, #4
    4816:	681a      	ldr	r2, [r3, #0]
    4818:	687b      	ldr	r3, [r7, #4]
    481a:	429a      	cmp	r2, r3
    481c:	d109      	bne.n	4832 <_ext_irq_enable+0x4a>
			extint = _map[i].extint;
    481e:	230e      	movs	r3, #14
    4820:	18fb      	adds	r3, r7, r3
    4822:	7819      	ldrb	r1, [r3, #0]
    4824:	230f      	movs	r3, #15
    4826:	18fb      	adds	r3, r7, r3
    4828:	4a21      	ldr	r2, [pc, #132]	; (48b0 <_ext_irq_enable+0xc8>)
    482a:	00c9      	lsls	r1, r1, #3
    482c:	5c8a      	ldrb	r2, [r1, r2]
    482e:	701a      	strb	r2, [r3, #0]
			break;
    4830:	e00b      	b.n	484a <_ext_irq_enable+0x62>
	for (; i < ARRAY_SIZE(_map); i++) {
    4832:	230e      	movs	r3, #14
    4834:	18fb      	adds	r3, r7, r3
    4836:	781a      	ldrb	r2, [r3, #0]
    4838:	230e      	movs	r3, #14
    483a:	18fb      	adds	r3, r7, r3
    483c:	3201      	adds	r2, #1
    483e:	701a      	strb	r2, [r3, #0]
    4840:	230e      	movs	r3, #14
    4842:	18fb      	adds	r3, r7, r3
    4844:	781b      	ldrb	r3, [r3, #0]
    4846:	2b02      	cmp	r3, #2
    4848:	d9de      	bls.n	4808 <_ext_irq_enable+0x20>
		}
	}
	if (INVALID_EXTINT_NUMBER == extint) {
    484a:	230f      	movs	r3, #15
    484c:	18fb      	adds	r3, r7, r3
    484e:	781b      	ldrb	r3, [r3, #0]
    4850:	2bff      	cmp	r3, #255	; 0xff
    4852:	d102      	bne.n	485a <_ext_irq_enable+0x72>
		return ERR_INVALID_ARG;
    4854:	230d      	movs	r3, #13
    4856:	425b      	negs	r3, r3
    4858:	e026      	b.n	48a8 <_ext_irq_enable+0xc0>
	}

	if (enable) {
    485a:	1cfb      	adds	r3, r7, #3
    485c:	781b      	ldrb	r3, [r3, #0]
    485e:	2b00      	cmp	r3, #0
    4860:	d00b      	beq.n	487a <_ext_irq_enable+0x92>
		hri_eic_set_INTEN_reg(EIC, 1ul << extint);
    4862:	230f      	movs	r3, #15
    4864:	18fb      	adds	r3, r7, r3
    4866:	781b      	ldrb	r3, [r3, #0]
    4868:	2201      	movs	r2, #1
    486a:	409a      	lsls	r2, r3
    486c:	0013      	movs	r3, r2
    486e:	4a11      	ldr	r2, [pc, #68]	; (48b4 <_ext_irq_enable+0xcc>)
    4870:	0019      	movs	r1, r3
    4872:	0010      	movs	r0, r2
    4874:	f7ff feb6 	bl	45e4 <hri_eic_set_INTEN_reg>
    4878:	e015      	b.n	48a6 <_ext_irq_enable+0xbe>
	} else {
		hri_eic_clear_INTEN_reg(EIC, 1ul << extint);
    487a:	230f      	movs	r3, #15
    487c:	18fb      	adds	r3, r7, r3
    487e:	781b      	ldrb	r3, [r3, #0]
    4880:	2201      	movs	r2, #1
    4882:	409a      	lsls	r2, r3
    4884:	0013      	movs	r3, r2
    4886:	4a0b      	ldr	r2, [pc, #44]	; (48b4 <_ext_irq_enable+0xcc>)
    4888:	0019      	movs	r1, r3
    488a:	0010      	movs	r0, r2
    488c:	f7ff fec0 	bl	4610 <hri_eic_clear_INTEN_reg>
		hri_eic_clear_INTFLAG_reg(EIC, 1ul << extint);
    4890:	230f      	movs	r3, #15
    4892:	18fb      	adds	r3, r7, r3
    4894:	781b      	ldrb	r3, [r3, #0]
    4896:	2201      	movs	r2, #1
    4898:	409a      	lsls	r2, r3
    489a:	0013      	movs	r3, r2
    489c:	4a05      	ldr	r2, [pc, #20]	; (48b4 <_ext_irq_enable+0xcc>)
    489e:	0019      	movs	r1, r3
    48a0:	0010      	movs	r0, r2
    48a2:	f7ff fe93 	bl	45cc <hri_eic_clear_INTFLAG_reg>
	}

	return ERR_NONE;
    48a6:	2300      	movs	r3, #0
}
    48a8:	0018      	movs	r0, r3
    48aa:	46bd      	mov	sp, r7
    48ac:	b004      	add	sp, #16
    48ae:	bd80      	pop	{r7, pc}
    48b0:	00008b00 	.word	0x00008b00
    48b4:	40001800 	.word	0x40001800

000048b8 <EIC_Handler>:

/**
 * \brief EIC interrupt handler
 */
void EIC_Handler(void)
{
    48b8:	b590      	push	{r4, r7, lr}
    48ba:	b085      	sub	sp, #20
    48bc:	af00      	add	r7, sp, #0
	volatile uint32_t flags = hri_eic_read_INTFLAG_reg(EIC) & hri_eic_read_INTEN_reg(EIC);
    48be:	4b59      	ldr	r3, [pc, #356]	; (4a24 <EIC_Handler+0x16c>)
    48c0:	0018      	movs	r0, r3
    48c2:	f7ff fe79 	bl	45b8 <hri_eic_read_INTFLAG_reg>
    48c6:	0004      	movs	r4, r0
    48c8:	4b56      	ldr	r3, [pc, #344]	; (4a24 <EIC_Handler+0x16c>)
    48ca:	0018      	movs	r0, r3
    48cc:	f7ff fe96 	bl	45fc <hri_eic_read_INTEN_reg>
    48d0:	0003      	movs	r3, r0
    48d2:	4023      	ands	r3, r4
    48d4:	603b      	str	r3, [r7, #0]
	int8_t            pos;
	uint32_t          pin = INVALID_PIN_NUMBER;
    48d6:	2301      	movs	r3, #1
    48d8:	425b      	negs	r3, r3
    48da:	60bb      	str	r3, [r7, #8]

	hri_eic_clear_INTFLAG_reg(EIC, flags);
    48dc:	683b      	ldr	r3, [r7, #0]
    48de:	4a51      	ldr	r2, [pc, #324]	; (4a24 <EIC_Handler+0x16c>)
    48e0:	0019      	movs	r1, r3
    48e2:	0010      	movs	r0, r2
    48e4:	f7ff fe72 	bl	45cc <hri_eic_clear_INTFLAG_reg>

	ASSERT(callback);
    48e8:	4b4f      	ldr	r3, [pc, #316]	; (4a28 <EIC_Handler+0x170>)
    48ea:	681b      	ldr	r3, [r3, #0]
    48ec:	1e5a      	subs	r2, r3, #1
    48ee:	4193      	sbcs	r3, r2
    48f0:	b2db      	uxtb	r3, r3
    48f2:	494e      	ldr	r1, [pc, #312]	; (4a2c <EIC_Handler+0x174>)
    48f4:	22d2      	movs	r2, #210	; 0xd2
    48f6:	0018      	movs	r0, r3
    48f8:	f7ff fd12 	bl	4320 <assert>

	while (flags) {
    48fc:	e08a      	b.n	4a14 <EIC_Handler+0x15c>
		pos = ffs(flags) - 1;
    48fe:	683b      	ldr	r3, [r7, #0]
    4900:	0018      	movs	r0, r3
    4902:	f003 f9a3 	bl	7c4c <ffs>
    4906:	0003      	movs	r3, r0
    4908:	b2db      	uxtb	r3, r3
    490a:	3b01      	subs	r3, #1
    490c:	b2da      	uxtb	r2, r3
    490e:	230f      	movs	r3, #15
    4910:	18fb      	adds	r3, r7, r3
    4912:	701a      	strb	r2, [r3, #0]
		while (-1 != pos) {
    4914:	e066      	b.n	49e4 <EIC_Handler+0x12c>
			uint8_t lower = 0, middle, upper = EXT_IRQ_AMOUNT;
    4916:	1dfb      	adds	r3, r7, #7
    4918:	2200      	movs	r2, #0
    491a:	701a      	strb	r2, [r3, #0]
    491c:	1dbb      	adds	r3, r7, #6
    491e:	2203      	movs	r2, #3
    4920:	701a      	strb	r2, [r3, #0]

			while (upper >= lower) {
    4922:	e03b      	b.n	499c <EIC_Handler+0xe4>
				middle = (upper + lower) >> 1;
    4924:	1dbb      	adds	r3, r7, #6
    4926:	781a      	ldrb	r2, [r3, #0]
    4928:	1dfb      	adds	r3, r7, #7
    492a:	781b      	ldrb	r3, [r3, #0]
    492c:	18d3      	adds	r3, r2, r3
    492e:	105a      	asrs	r2, r3, #1
    4930:	1d7b      	adds	r3, r7, #5
    4932:	701a      	strb	r2, [r3, #0]
				if (_map[middle].extint == pos) {
    4934:	1d7b      	adds	r3, r7, #5
    4936:	781a      	ldrb	r2, [r3, #0]
    4938:	4b3d      	ldr	r3, [pc, #244]	; (4a30 <EIC_Handler+0x178>)
    493a:	00d2      	lsls	r2, r2, #3
    493c:	5cd3      	ldrb	r3, [r2, r3]
    493e:	001a      	movs	r2, r3
    4940:	230f      	movs	r3, #15
    4942:	18fb      	adds	r3, r7, r3
    4944:	781b      	ldrb	r3, [r3, #0]
    4946:	b25b      	sxtb	r3, r3
    4948:	429a      	cmp	r2, r3
    494a:	d108      	bne.n	495e <EIC_Handler+0xa6>
					pin = _map[middle].pin;
    494c:	1d7b      	adds	r3, r7, #5
    494e:	781b      	ldrb	r3, [r3, #0]
    4950:	4a37      	ldr	r2, [pc, #220]	; (4a30 <EIC_Handler+0x178>)
    4952:	00db      	lsls	r3, r3, #3
    4954:	18d3      	adds	r3, r2, r3
    4956:	3304      	adds	r3, #4
    4958:	681b      	ldr	r3, [r3, #0]
    495a:	60bb      	str	r3, [r7, #8]
					break;
    495c:	e024      	b.n	49a8 <EIC_Handler+0xf0>
				}
				if (_map[middle].extint < pos) {
    495e:	1d7b      	adds	r3, r7, #5
    4960:	781a      	ldrb	r2, [r3, #0]
    4962:	4b33      	ldr	r3, [pc, #204]	; (4a30 <EIC_Handler+0x178>)
    4964:	00d2      	lsls	r2, r2, #3
    4966:	5cd3      	ldrb	r3, [r2, r3]
    4968:	001a      	movs	r2, r3
    496a:	230f      	movs	r3, #15
    496c:	18fb      	adds	r3, r7, r3
    496e:	781b      	ldrb	r3, [r3, #0]
    4970:	b25b      	sxtb	r3, r3
    4972:	429a      	cmp	r2, r3
    4974:	da09      	bge.n	498a <EIC_Handler+0xd2>
					lower = middle + 1;
    4976:	1dfb      	adds	r3, r7, #7
    4978:	1d7a      	adds	r2, r7, #5
    497a:	7812      	ldrb	r2, [r2, #0]
    497c:	3201      	adds	r2, #1
    497e:	701a      	strb	r2, [r3, #0]
    4980:	1dbb      	adds	r3, r7, #6
    4982:	1dba      	adds	r2, r7, #6
    4984:	7812      	ldrb	r2, [r2, #0]
    4986:	701a      	strb	r2, [r3, #0]
    4988:	e008      	b.n	499c <EIC_Handler+0xe4>
				} else {
					upper = middle - 1;
    498a:	1dbb      	adds	r3, r7, #6
    498c:	1d7a      	adds	r2, r7, #5
    498e:	7812      	ldrb	r2, [r2, #0]
    4990:	3a01      	subs	r2, #1
    4992:	701a      	strb	r2, [r3, #0]
    4994:	1dfb      	adds	r3, r7, #7
    4996:	1dfa      	adds	r2, r7, #7
    4998:	7812      	ldrb	r2, [r2, #0]
    499a:	701a      	strb	r2, [r3, #0]
			while (upper >= lower) {
    499c:	1dba      	adds	r2, r7, #6
    499e:	1dfb      	adds	r3, r7, #7
    49a0:	7812      	ldrb	r2, [r2, #0]
    49a2:	781b      	ldrb	r3, [r3, #0]
    49a4:	429a      	cmp	r2, r3
    49a6:	d2bd      	bcs.n	4924 <EIC_Handler+0x6c>
				}
			}

			if (INVALID_PIN_NUMBER != pin) {
    49a8:	68bb      	ldr	r3, [r7, #8]
    49aa:	3301      	adds	r3, #1
    49ac:	d004      	beq.n	49b8 <EIC_Handler+0x100>
				callback(pin);
    49ae:	4b1e      	ldr	r3, [pc, #120]	; (4a28 <EIC_Handler+0x170>)
    49b0:	681b      	ldr	r3, [r3, #0]
    49b2:	68ba      	ldr	r2, [r7, #8]
    49b4:	0010      	movs	r0, r2
    49b6:	4798      	blx	r3
			}
			flags &= ~(1ul << pos);
    49b8:	230f      	movs	r3, #15
    49ba:	18fb      	adds	r3, r7, r3
    49bc:	781b      	ldrb	r3, [r3, #0]
    49be:	b25b      	sxtb	r3, r3
    49c0:	2201      	movs	r2, #1
    49c2:	409a      	lsls	r2, r3
    49c4:	0013      	movs	r3, r2
    49c6:	43db      	mvns	r3, r3
    49c8:	683a      	ldr	r2, [r7, #0]
    49ca:	4013      	ands	r3, r2
    49cc:	603b      	str	r3, [r7, #0]
			pos = ffs(flags) - 1;
    49ce:	683b      	ldr	r3, [r7, #0]
    49d0:	0018      	movs	r0, r3
    49d2:	f003 f93b 	bl	7c4c <ffs>
    49d6:	0003      	movs	r3, r0
    49d8:	b2db      	uxtb	r3, r3
    49da:	3b01      	subs	r3, #1
    49dc:	b2da      	uxtb	r2, r3
    49de:	230f      	movs	r3, #15
    49e0:	18fb      	adds	r3, r7, r3
    49e2:	701a      	strb	r2, [r3, #0]
		while (-1 != pos) {
    49e4:	230f      	movs	r3, #15
    49e6:	18fb      	adds	r3, r7, r3
    49e8:	781b      	ldrb	r3, [r3, #0]
    49ea:	b25b      	sxtb	r3, r3
    49ec:	3301      	adds	r3, #1
    49ee:	d192      	bne.n	4916 <EIC_Handler+0x5e>
		}
		flags = hri_eic_read_INTFLAG_reg(EIC) & hri_eic_read_INTEN_reg(EIC);
    49f0:	4b0c      	ldr	r3, [pc, #48]	; (4a24 <EIC_Handler+0x16c>)
    49f2:	0018      	movs	r0, r3
    49f4:	f7ff fde0 	bl	45b8 <hri_eic_read_INTFLAG_reg>
    49f8:	0004      	movs	r4, r0
    49fa:	4b0a      	ldr	r3, [pc, #40]	; (4a24 <EIC_Handler+0x16c>)
    49fc:	0018      	movs	r0, r3
    49fe:	f7ff fdfd 	bl	45fc <hri_eic_read_INTEN_reg>
    4a02:	0003      	movs	r3, r0
    4a04:	4023      	ands	r3, r4
    4a06:	603b      	str	r3, [r7, #0]
		hri_eic_clear_INTFLAG_reg(EIC, flags);
    4a08:	683b      	ldr	r3, [r7, #0]
    4a0a:	4a06      	ldr	r2, [pc, #24]	; (4a24 <EIC_Handler+0x16c>)
    4a0c:	0019      	movs	r1, r3
    4a0e:	0010      	movs	r0, r2
    4a10:	f7ff fddc 	bl	45cc <hri_eic_clear_INTFLAG_reg>
	while (flags) {
    4a14:	683b      	ldr	r3, [r7, #0]
    4a16:	2b00      	cmp	r3, #0
    4a18:	d000      	beq.n	4a1c <EIC_Handler+0x164>
    4a1a:	e770      	b.n	48fe <EIC_Handler+0x46>
	}
}
    4a1c:	46c0      	nop			; (mov r8, r8)
    4a1e:	46bd      	mov	sp, r7
    4a20:	b005      	add	sp, #20
    4a22:	bd90      	pop	{r4, r7, pc}
    4a24:	40001800 	.word	0x40001800
    4a28:	200007cc 	.word	0x200007cc
    4a2c:	00008b18 	.word	0x00008b18
    4a30:	00008b00 	.word	0x00008b00

00004a34 <hri_gclk_wait_for_sync>:
{
    4a34:	b580      	push	{r7, lr}
    4a36:	b082      	sub	sp, #8
    4a38:	af00      	add	r7, sp, #0
    4a3a:	6078      	str	r0, [r7, #4]
	while (((const Gclk *)hw)->STATUS.bit.SYNCBUSY)
    4a3c:	46c0      	nop			; (mov r8, r8)
    4a3e:	687b      	ldr	r3, [r7, #4]
    4a40:	785b      	ldrb	r3, [r3, #1]
    4a42:	061b      	lsls	r3, r3, #24
    4a44:	0fdb      	lsrs	r3, r3, #31
    4a46:	b2db      	uxtb	r3, r3
    4a48:	2b00      	cmp	r3, #0
    4a4a:	d1f8      	bne.n	4a3e <hri_gclk_wait_for_sync+0xa>
}
    4a4c:	46c0      	nop			; (mov r8, r8)
    4a4e:	46bd      	mov	sp, r7
    4a50:	b002      	add	sp, #8
    4a52:	bd80      	pop	{r7, pc}

00004a54 <hri_gclk_write_GENCTRL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_gclk_write_GENCTRL_reg(const void *const hw, hri_gclk_genctrl_reg_t data)
{
    4a54:	b580      	push	{r7, lr}
    4a56:	b082      	sub	sp, #8
    4a58:	af00      	add	r7, sp, #0
    4a5a:	6078      	str	r0, [r7, #4]
    4a5c:	6039      	str	r1, [r7, #0]
	GCLK_CRITICAL_SECTION_ENTER();
	((Gclk *)hw)->GENCTRL.reg = data;
    4a5e:	687b      	ldr	r3, [r7, #4]
    4a60:	683a      	ldr	r2, [r7, #0]
    4a62:	605a      	str	r2, [r3, #4]
	hri_gclk_wait_for_sync(hw);
    4a64:	687b      	ldr	r3, [r7, #4]
    4a66:	0018      	movs	r0, r3
    4a68:	f7ff ffe4 	bl	4a34 <hri_gclk_wait_for_sync>
	GCLK_CRITICAL_SECTION_LEAVE();
}
    4a6c:	46c0      	nop			; (mov r8, r8)
    4a6e:	46bd      	mov	sp, r7
    4a70:	b002      	add	sp, #8
    4a72:	bd80      	pop	{r7, pc}

00004a74 <hri_gclk_write_GENDIV_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_gclk_write_GENDIV_reg(const void *const hw, hri_gclk_gendiv_reg_t data)
{
    4a74:	b580      	push	{r7, lr}
    4a76:	b082      	sub	sp, #8
    4a78:	af00      	add	r7, sp, #0
    4a7a:	6078      	str	r0, [r7, #4]
    4a7c:	6039      	str	r1, [r7, #0]
	GCLK_CRITICAL_SECTION_ENTER();
	((Gclk *)hw)->GENDIV.reg = data;
    4a7e:	687b      	ldr	r3, [r7, #4]
    4a80:	683a      	ldr	r2, [r7, #0]
    4a82:	609a      	str	r2, [r3, #8]
	GCLK_CRITICAL_SECTION_LEAVE();
}
    4a84:	46c0      	nop			; (mov r8, r8)
    4a86:	46bd      	mov	sp, r7
    4a88:	b002      	add	sp, #8
    4a8a:	bd80      	pop	{r7, pc}

00004a8c <_gclk_init_generators_by_fref>:
	        | CONF_GCLK_GEN_7_SRC | GCLK_GENCTRL_ID(7));
#endif
}

void _gclk_init_generators_by_fref(uint32_t bm)
{
    4a8c:	b580      	push	{r7, lr}
    4a8e:	b082      	sub	sp, #8
    4a90:	af00      	add	r7, sp, #0
    4a92:	6078      	str	r0, [r7, #4]

#if CONF_GCLK_GENERATOR_0_CONFIG == 1
	if (bm & (1ul << 0)) {
    4a94:	687b      	ldr	r3, [r7, #4]
    4a96:	2201      	movs	r2, #1
    4a98:	4013      	ands	r3, r2
    4a9a:	d00c      	beq.n	4ab6 <_gclk_init_generators_by_fref+0x2a>
		hri_gclk_write_GENDIV_reg(GCLK, GCLK_GENDIV_DIV(CONF_GCLK_GEN_0_DIV) | GCLK_GENDIV_ID(0));
    4a9c:	2380      	movs	r3, #128	; 0x80
    4a9e:	005b      	lsls	r3, r3, #1
    4aa0:	4a0f      	ldr	r2, [pc, #60]	; (4ae0 <_gclk_init_generators_by_fref+0x54>)
    4aa2:	0019      	movs	r1, r3
    4aa4:	0010      	movs	r0, r2
    4aa6:	f7ff ffe5 	bl	4a74 <hri_gclk_write_GENDIV_reg>
		hri_gclk_write_GENCTRL_reg(
    4aaa:	4a0e      	ldr	r2, [pc, #56]	; (4ae4 <_gclk_init_generators_by_fref+0x58>)
    4aac:	4b0c      	ldr	r3, [pc, #48]	; (4ae0 <_gclk_init_generators_by_fref+0x54>)
    4aae:	0011      	movs	r1, r2
    4ab0:	0018      	movs	r0, r3
    4ab2:	f7ff ffcf 	bl	4a54 <hri_gclk_write_GENCTRL_reg>
		        | (CONF_GCLK_GENERATOR_2_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_2_SRC | GCLK_GENCTRL_ID(2));
	}
#endif

#if CONF_GCLK_GENERATOR_3_CONFIG == 1
	if (bm & (1ul << 3)) {
    4ab6:	687b      	ldr	r3, [r7, #4]
    4ab8:	2208      	movs	r2, #8
    4aba:	4013      	ands	r3, r2
    4abc:	d00c      	beq.n	4ad8 <_gclk_init_generators_by_fref+0x4c>
		hri_gclk_write_GENDIV_reg(GCLK, GCLK_GENDIV_DIV(CONF_GCLK_GEN_3_DIV) | GCLK_GENDIV_ID(3));
    4abe:	2304      	movs	r3, #4
    4ac0:	33ff      	adds	r3, #255	; 0xff
    4ac2:	4a07      	ldr	r2, [pc, #28]	; (4ae0 <_gclk_init_generators_by_fref+0x54>)
    4ac4:	0019      	movs	r1, r3
    4ac6:	0010      	movs	r0, r2
    4ac8:	f7ff ffd4 	bl	4a74 <hri_gclk_write_GENDIV_reg>
		hri_gclk_write_GENCTRL_reg(
    4acc:	4a06      	ldr	r2, [pc, #24]	; (4ae8 <_gclk_init_generators_by_fref+0x5c>)
    4ace:	4b04      	ldr	r3, [pc, #16]	; (4ae0 <_gclk_init_generators_by_fref+0x54>)
    4ad0:	0011      	movs	r1, r2
    4ad2:	0018      	movs	r0, r3
    4ad4:	f7ff ffbe 	bl	4a54 <hri_gclk_write_GENCTRL_reg>
		        | (CONF_GCLK_GEN_7_DIVSEL << GCLK_GENCTRL_DIVSEL_Pos) | (CONF_GCLK_GEN_7_OE << GCLK_GENCTRL_OE_Pos)
		        | (CONF_GCLK_GEN_7_OOV << GCLK_GENCTRL_OOV_Pos) | (CONF_GCLK_GEN_7_IDC << GCLK_GENCTRL_IDC_Pos)
		        | (CONF_GCLK_GENERATOR_7_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_7_SRC | GCLK_GENCTRL_ID(7));
	}
#endif
}
    4ad8:	46c0      	nop			; (mov r8, r8)
    4ada:	46bd      	mov	sp, r7
    4adc:	b002      	add	sp, #8
    4ade:	bd80      	pop	{r7, pc}
    4ae0:	40000c00 	.word	0x40000c00
    4ae4:	00010700 	.word	0x00010700
    4ae8:	00010403 	.word	0x00010403

00004aec <hri_pm_set_CPUSEL_CPUDIV_bf>:
{
	return ((Pm *)hw)->SLEEP.reg;
}

static inline void hri_pm_set_CPUSEL_CPUDIV_bf(const void *const hw, hri_pm_cpusel_reg_t mask)
{
    4aec:	b580      	push	{r7, lr}
    4aee:	b082      	sub	sp, #8
    4af0:	af00      	add	r7, sp, #0
    4af2:	6078      	str	r0, [r7, #4]
    4af4:	000a      	movs	r2, r1
    4af6:	1cfb      	adds	r3, r7, #3
    4af8:	701a      	strb	r2, [r3, #0]
	PM_CRITICAL_SECTION_ENTER();
	((Pm *)hw)->CPUSEL.reg |= PM_CPUSEL_CPUDIV(mask);
    4afa:	687b      	ldr	r3, [r7, #4]
    4afc:	7a1b      	ldrb	r3, [r3, #8]
    4afe:	b2da      	uxtb	r2, r3
    4b00:	1cfb      	adds	r3, r7, #3
    4b02:	781b      	ldrb	r3, [r3, #0]
    4b04:	2107      	movs	r1, #7
    4b06:	400b      	ands	r3, r1
    4b08:	b2db      	uxtb	r3, r3
    4b0a:	4313      	orrs	r3, r2
    4b0c:	b2da      	uxtb	r2, r3
    4b0e:	687b      	ldr	r3, [r7, #4]
    4b10:	721a      	strb	r2, [r3, #8]
	PM_CRITICAL_SECTION_LEAVE();
}
    4b12:	46c0      	nop			; (mov r8, r8)
    4b14:	46bd      	mov	sp, r7
    4b16:	b002      	add	sp, #8
    4b18:	bd80      	pop	{r7, pc}

00004b1a <hri_pm_set_APBASEL_APBADIV_bf>:
{
	return ((Pm *)hw)->CPUSEL.reg;
}

static inline void hri_pm_set_APBASEL_APBADIV_bf(const void *const hw, hri_pm_apbasel_reg_t mask)
{
    4b1a:	b580      	push	{r7, lr}
    4b1c:	b082      	sub	sp, #8
    4b1e:	af00      	add	r7, sp, #0
    4b20:	6078      	str	r0, [r7, #4]
    4b22:	000a      	movs	r2, r1
    4b24:	1cfb      	adds	r3, r7, #3
    4b26:	701a      	strb	r2, [r3, #0]
	PM_CRITICAL_SECTION_ENTER();
	((Pm *)hw)->APBASEL.reg |= PM_APBASEL_APBADIV(mask);
    4b28:	687b      	ldr	r3, [r7, #4]
    4b2a:	7a5b      	ldrb	r3, [r3, #9]
    4b2c:	b2da      	uxtb	r2, r3
    4b2e:	1cfb      	adds	r3, r7, #3
    4b30:	781b      	ldrb	r3, [r3, #0]
    4b32:	2107      	movs	r1, #7
    4b34:	400b      	ands	r3, r1
    4b36:	b2db      	uxtb	r3, r3
    4b38:	4313      	orrs	r3, r2
    4b3a:	b2da      	uxtb	r2, r3
    4b3c:	687b      	ldr	r3, [r7, #4]
    4b3e:	725a      	strb	r2, [r3, #9]
	PM_CRITICAL_SECTION_LEAVE();
}
    4b40:	46c0      	nop			; (mov r8, r8)
    4b42:	46bd      	mov	sp, r7
    4b44:	b002      	add	sp, #8
    4b46:	bd80      	pop	{r7, pc}

00004b48 <hri_pm_set_APBBSEL_APBBDIV_bf>:
{
	return ((Pm *)hw)->APBASEL.reg;
}

static inline void hri_pm_set_APBBSEL_APBBDIV_bf(const void *const hw, hri_pm_apbbsel_reg_t mask)
{
    4b48:	b580      	push	{r7, lr}
    4b4a:	b082      	sub	sp, #8
    4b4c:	af00      	add	r7, sp, #0
    4b4e:	6078      	str	r0, [r7, #4]
    4b50:	000a      	movs	r2, r1
    4b52:	1cfb      	adds	r3, r7, #3
    4b54:	701a      	strb	r2, [r3, #0]
	PM_CRITICAL_SECTION_ENTER();
	((Pm *)hw)->APBBSEL.reg |= PM_APBBSEL_APBBDIV(mask);
    4b56:	687b      	ldr	r3, [r7, #4]
    4b58:	7a9b      	ldrb	r3, [r3, #10]
    4b5a:	b2da      	uxtb	r2, r3
    4b5c:	1cfb      	adds	r3, r7, #3
    4b5e:	781b      	ldrb	r3, [r3, #0]
    4b60:	2107      	movs	r1, #7
    4b62:	400b      	ands	r3, r1
    4b64:	b2db      	uxtb	r3, r3
    4b66:	4313      	orrs	r3, r2
    4b68:	b2da      	uxtb	r2, r3
    4b6a:	687b      	ldr	r3, [r7, #4]
    4b6c:	729a      	strb	r2, [r3, #10]
	PM_CRITICAL_SECTION_LEAVE();
}
    4b6e:	46c0      	nop			; (mov r8, r8)
    4b70:	46bd      	mov	sp, r7
    4b72:	b002      	add	sp, #8
    4b74:	bd80      	pop	{r7, pc}

00004b76 <hri_pm_set_APBCSEL_APBCDIV_bf>:
{
	return ((Pm *)hw)->APBBSEL.reg;
}

static inline void hri_pm_set_APBCSEL_APBCDIV_bf(const void *const hw, hri_pm_apbcsel_reg_t mask)
{
    4b76:	b580      	push	{r7, lr}
    4b78:	b082      	sub	sp, #8
    4b7a:	af00      	add	r7, sp, #0
    4b7c:	6078      	str	r0, [r7, #4]
    4b7e:	000a      	movs	r2, r1
    4b80:	1cfb      	adds	r3, r7, #3
    4b82:	701a      	strb	r2, [r3, #0]
	PM_CRITICAL_SECTION_ENTER();
	((Pm *)hw)->APBCSEL.reg |= PM_APBCSEL_APBCDIV(mask);
    4b84:	687b      	ldr	r3, [r7, #4]
    4b86:	7adb      	ldrb	r3, [r3, #11]
    4b88:	b2da      	uxtb	r2, r3
    4b8a:	1cfb      	adds	r3, r7, #3
    4b8c:	781b      	ldrb	r3, [r3, #0]
    4b8e:	2107      	movs	r1, #7
    4b90:	400b      	ands	r3, r1
    4b92:	b2db      	uxtb	r3, r3
    4b94:	4313      	orrs	r3, r2
    4b96:	b2da      	uxtb	r2, r3
    4b98:	687b      	ldr	r3, [r7, #4]
    4b9a:	72da      	strb	r2, [r3, #11]
	PM_CRITICAL_SECTION_LEAVE();
}
    4b9c:	46c0      	nop			; (mov r8, r8)
    4b9e:	46bd      	mov	sp, r7
    4ba0:	b002      	add	sp, #8
    4ba2:	bd80      	pop	{r7, pc}

00004ba4 <_pm_init>:

/**
 * \brief Power Manager Init
 */
void _pm_init(void)
{
    4ba4:	b580      	push	{r7, lr}
    4ba6:	af00      	add	r7, sp, #0
	hri_pm_set_CPUSEL_CPUDIV_bf(PM, CONF_CPU_DIV);
    4ba8:	4b0b      	ldr	r3, [pc, #44]	; (4bd8 <_pm_init+0x34>)
    4baa:	2100      	movs	r1, #0
    4bac:	0018      	movs	r0, r3
    4bae:	f7ff ff9d 	bl	4aec <hri_pm_set_CPUSEL_CPUDIV_bf>
	hri_pm_set_APBASEL_APBADIV_bf(PM, CONF_APBA_DIV);
    4bb2:	4b09      	ldr	r3, [pc, #36]	; (4bd8 <_pm_init+0x34>)
    4bb4:	2100      	movs	r1, #0
    4bb6:	0018      	movs	r0, r3
    4bb8:	f7ff ffaf 	bl	4b1a <hri_pm_set_APBASEL_APBADIV_bf>
	hri_pm_set_APBBSEL_APBBDIV_bf(PM, CONF_APBB_DIV);
    4bbc:	4b06      	ldr	r3, [pc, #24]	; (4bd8 <_pm_init+0x34>)
    4bbe:	2100      	movs	r1, #0
    4bc0:	0018      	movs	r0, r3
    4bc2:	f7ff ffc1 	bl	4b48 <hri_pm_set_APBBSEL_APBBDIV_bf>
	hri_pm_set_APBCSEL_APBCDIV_bf(PM, CONF_APBC_DIV);
    4bc6:	4b04      	ldr	r3, [pc, #16]	; (4bd8 <_pm_init+0x34>)
    4bc8:	2100      	movs	r1, #0
    4bca:	0018      	movs	r0, r3
    4bcc:	f7ff ffd3 	bl	4b76 <hri_pm_set_APBCSEL_APBCDIV_bf>
}
    4bd0:	46c0      	nop			; (mov r8, r8)
    4bd2:	46bd      	mov	sp, r7
    4bd4:	bd80      	pop	{r7, pc}
    4bd6:	46c0      	nop			; (mov r8, r8)
    4bd8:	40000400 	.word	0x40000400

00004bdc <hri_sercomi2cm_wait_for_sync>:
typedef uint8_t  hri_sercomusart_dbgctrl_reg_t;
typedef uint8_t  hri_sercomusart_intenset_reg_t;
typedef uint8_t  hri_sercomusart_intflag_reg_t;

static inline void hri_sercomi2cm_wait_for_sync(const void *const hw)
{
    4bdc:	b580      	push	{r7, lr}
    4bde:	b082      	sub	sp, #8
    4be0:	af00      	add	r7, sp, #0
    4be2:	6078      	str	r0, [r7, #4]
	while (((const Sercom *)hw)->I2CM.STATUS.bit.SYNCBUSY)
    4be4:	46c0      	nop			; (mov r8, r8)
    4be6:	687b      	ldr	r3, [r7, #4]
    4be8:	8a1b      	ldrh	r3, [r3, #16]
    4bea:	041b      	lsls	r3, r3, #16
    4bec:	0fdb      	lsrs	r3, r3, #31
    4bee:	b2db      	uxtb	r3, r3
    4bf0:	2b00      	cmp	r3, #0
    4bf2:	d1f8      	bne.n	4be6 <hri_sercomi2cm_wait_for_sync+0xa>
		;
}
    4bf4:	46c0      	nop			; (mov r8, r8)
    4bf6:	46bd      	mov	sp, r7
    4bf8:	b002      	add	sp, #8
    4bfa:	bd80      	pop	{r7, pc}

00004bfc <hri_sercomspi_wait_for_sync>:
{
	return ((const Sercom *)hw)->I2CS.STATUS.bit.SYNCBUSY;
}

static inline void hri_sercomspi_wait_for_sync(const void *const hw)
{
    4bfc:	b580      	push	{r7, lr}
    4bfe:	b082      	sub	sp, #8
    4c00:	af00      	add	r7, sp, #0
    4c02:	6078      	str	r0, [r7, #4]
	while (((const Sercom *)hw)->SPI.STATUS.bit.SYNCBUSY)
    4c04:	46c0      	nop			; (mov r8, r8)
    4c06:	687b      	ldr	r3, [r7, #4]
    4c08:	8a1b      	ldrh	r3, [r3, #16]
    4c0a:	041b      	lsls	r3, r3, #16
    4c0c:	0fdb      	lsrs	r3, r3, #31
    4c0e:	b2db      	uxtb	r3, r3
    4c10:	2b00      	cmp	r3, #0
    4c12:	d1f8      	bne.n	4c06 <hri_sercomspi_wait_for_sync+0xa>
		;
}
    4c14:	46c0      	nop			; (mov r8, r8)
    4c16:	46bd      	mov	sp, r7
    4c18:	b002      	add	sp, #8
    4c1a:	bd80      	pop	{r7, pc}

00004c1c <hri_sercomspi_is_syncing>:

static inline bool hri_sercomspi_is_syncing(const void *const hw)
{
    4c1c:	b580      	push	{r7, lr}
    4c1e:	b082      	sub	sp, #8
    4c20:	af00      	add	r7, sp, #0
    4c22:	6078      	str	r0, [r7, #4]
	return ((const Sercom *)hw)->SPI.STATUS.bit.SYNCBUSY;
    4c24:	687b      	ldr	r3, [r7, #4]
    4c26:	8a1b      	ldrh	r3, [r3, #16]
    4c28:	041b      	lsls	r3, r3, #16
    4c2a:	0fdb      	lsrs	r3, r3, #31
    4c2c:	b2db      	uxtb	r3, r3
    4c2e:	1e5a      	subs	r2, r3, #1
    4c30:	4193      	sbcs	r3, r2
    4c32:	b2db      	uxtb	r3, r3
}
    4c34:	0018      	movs	r0, r3
    4c36:	46bd      	mov	sp, r7
    4c38:	b002      	add	sp, #8
    4c3a:	bd80      	pop	{r7, pc}

00004c3c <hri_sercomusart_wait_for_sync>:

static inline void hri_sercomusart_wait_for_sync(const void *const hw)
{
    4c3c:	b580      	push	{r7, lr}
    4c3e:	b082      	sub	sp, #8
    4c40:	af00      	add	r7, sp, #0
    4c42:	6078      	str	r0, [r7, #4]
	while (((const Sercom *)hw)->USART.STATUS.bit.SYNCBUSY)
    4c44:	46c0      	nop			; (mov r8, r8)
    4c46:	687b      	ldr	r3, [r7, #4]
    4c48:	8a1b      	ldrh	r3, [r3, #16]
    4c4a:	041b      	lsls	r3, r3, #16
    4c4c:	0fdb      	lsrs	r3, r3, #31
    4c4e:	b2db      	uxtb	r3, r3
    4c50:	2b00      	cmp	r3, #0
    4c52:	d1f8      	bne.n	4c46 <hri_sercomusart_wait_for_sync+0xa>
		;
}
    4c54:	46c0      	nop			; (mov r8, r8)
    4c56:	46bd      	mov	sp, r7
    4c58:	b002      	add	sp, #8
    4c5a:	bd80      	pop	{r7, pc}

00004c5c <hri_sercomi2cm_clear_interrupt_MB_bit>:
{
	return (((Sercom *)hw)->I2CM.INTFLAG.reg & SERCOM_I2CM_INTFLAG_MB) >> SERCOM_I2CM_INTFLAG_MB_Pos;
}

static inline void hri_sercomi2cm_clear_interrupt_MB_bit(const void *const hw)
{
    4c5c:	b580      	push	{r7, lr}
    4c5e:	b082      	sub	sp, #8
    4c60:	af00      	add	r7, sp, #0
    4c62:	6078      	str	r0, [r7, #4]
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_MB;
    4c64:	687b      	ldr	r3, [r7, #4]
    4c66:	2201      	movs	r2, #1
    4c68:	739a      	strb	r2, [r3, #14]
}
    4c6a:	46c0      	nop			; (mov r8, r8)
    4c6c:	46bd      	mov	sp, r7
    4c6e:	b002      	add	sp, #8
    4c70:	bd80      	pop	{r7, pc}

00004c72 <hri_sercomi2cm_clear_interrupt_SB_bit>:
{
	return (((Sercom *)hw)->I2CM.INTFLAG.reg & SERCOM_I2CM_INTFLAG_SB) >> SERCOM_I2CM_INTFLAG_SB_Pos;
}

static inline void hri_sercomi2cm_clear_interrupt_SB_bit(const void *const hw)
{
    4c72:	b580      	push	{r7, lr}
    4c74:	b082      	sub	sp, #8
    4c76:	af00      	add	r7, sp, #0
    4c78:	6078      	str	r0, [r7, #4]
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_SB;
    4c7a:	687b      	ldr	r3, [r7, #4]
    4c7c:	2202      	movs	r2, #2
    4c7e:	739a      	strb	r2, [r3, #14]
}
    4c80:	46c0      	nop			; (mov r8, r8)
    4c82:	46bd      	mov	sp, r7
    4c84:	b002      	add	sp, #8
    4c86:	bd80      	pop	{r7, pc}

00004c88 <hri_sercomi2cm_read_INTFLAG_reg>:
	tmp &= mask;
	return tmp;
}

static inline hri_sercomi2cm_intflag_reg_t hri_sercomi2cm_read_INTFLAG_reg(const void *const hw)
{
    4c88:	b580      	push	{r7, lr}
    4c8a:	b082      	sub	sp, #8
    4c8c:	af00      	add	r7, sp, #0
    4c8e:	6078      	str	r0, [r7, #4]
	return ((Sercom *)hw)->I2CM.INTFLAG.reg;
    4c90:	687b      	ldr	r3, [r7, #4]
    4c92:	7b9b      	ldrb	r3, [r3, #14]
    4c94:	b2db      	uxtb	r3, r3
}
    4c96:	0018      	movs	r0, r3
    4c98:	46bd      	mov	sp, r7
    4c9a:	b002      	add	sp, #8
    4c9c:	bd80      	pop	{r7, pc}

00004c9e <hri_sercomspi_get_INTFLAG_reg>:
	((Sercom *)hw)->SPI.INTFLAG.reg = SERCOM_SPI_INTFLAG_RXC;
}

static inline hri_sercomspi_intflag_reg_t hri_sercomspi_get_INTFLAG_reg(const void *const           hw,
                                                                        hri_sercomspi_intflag_reg_t mask)
{
    4c9e:	b580      	push	{r7, lr}
    4ca0:	b084      	sub	sp, #16
    4ca2:	af00      	add	r7, sp, #0
    4ca4:	6078      	str	r0, [r7, #4]
    4ca6:	000a      	movs	r2, r1
    4ca8:	1cfb      	adds	r3, r7, #3
    4caa:	701a      	strb	r2, [r3, #0]
	uint8_t tmp;
	tmp = ((Sercom *)hw)->SPI.INTFLAG.reg;
    4cac:	230f      	movs	r3, #15
    4cae:	18fb      	adds	r3, r7, r3
    4cb0:	687a      	ldr	r2, [r7, #4]
    4cb2:	7b92      	ldrb	r2, [r2, #14]
    4cb4:	701a      	strb	r2, [r3, #0]
	tmp &= mask;
    4cb6:	230f      	movs	r3, #15
    4cb8:	18fb      	adds	r3, r7, r3
    4cba:	220f      	movs	r2, #15
    4cbc:	18ba      	adds	r2, r7, r2
    4cbe:	1cf9      	adds	r1, r7, #3
    4cc0:	7812      	ldrb	r2, [r2, #0]
    4cc2:	7809      	ldrb	r1, [r1, #0]
    4cc4:	400a      	ands	r2, r1
    4cc6:	701a      	strb	r2, [r3, #0]
	return tmp;
    4cc8:	230f      	movs	r3, #15
    4cca:	18fb      	adds	r3, r7, r3
    4ccc:	781b      	ldrb	r3, [r3, #0]
}
    4cce:	0018      	movs	r0, r3
    4cd0:	46bd      	mov	sp, r7
    4cd2:	b004      	add	sp, #16
    4cd4:	bd80      	pop	{r7, pc}

00004cd6 <hri_sercomspi_read_INTFLAG_reg>:

static inline hri_sercomspi_intflag_reg_t hri_sercomspi_read_INTFLAG_reg(const void *const hw)
{
    4cd6:	b580      	push	{r7, lr}
    4cd8:	b082      	sub	sp, #8
    4cda:	af00      	add	r7, sp, #0
    4cdc:	6078      	str	r0, [r7, #4]
	return ((Sercom *)hw)->SPI.INTFLAG.reg;
    4cde:	687b      	ldr	r3, [r7, #4]
    4ce0:	7b9b      	ldrb	r3, [r3, #14]
    4ce2:	b2db      	uxtb	r3, r3
}
    4ce4:	0018      	movs	r0, r3
    4ce6:	46bd      	mov	sp, r7
    4ce8:	b002      	add	sp, #8
    4cea:	bd80      	pop	{r7, pc}

00004cec <hri_sercomspi_clear_INTFLAG_reg>:

static inline void hri_sercomspi_clear_INTFLAG_reg(const void *const hw, hri_sercomspi_intflag_reg_t mask)
{
    4cec:	b580      	push	{r7, lr}
    4cee:	b082      	sub	sp, #8
    4cf0:	af00      	add	r7, sp, #0
    4cf2:	6078      	str	r0, [r7, #4]
    4cf4:	000a      	movs	r2, r1
    4cf6:	1cfb      	adds	r3, r7, #3
    4cf8:	701a      	strb	r2, [r3, #0]
	((Sercom *)hw)->SPI.INTFLAG.reg = mask;
    4cfa:	687b      	ldr	r3, [r7, #4]
    4cfc:	1cfa      	adds	r2, r7, #3
    4cfe:	7812      	ldrb	r2, [r2, #0]
    4d00:	739a      	strb	r2, [r3, #14]
}
    4d02:	46c0      	nop			; (mov r8, r8)
    4d04:	46bd      	mov	sp, r7
    4d06:	b002      	add	sp, #8
    4d08:	bd80      	pop	{r7, pc}

00004d0a <hri_sercomusart_get_interrupt_DRE_bit>:
{
	((Sercom *)hw)->USART.INTFLAG.reg = SERCOM_USART_INTFLAG_RXS;
}

static inline bool hri_sercomusart_get_interrupt_DRE_bit(const void *const hw)
{
    4d0a:	b580      	push	{r7, lr}
    4d0c:	b082      	sub	sp, #8
    4d0e:	af00      	add	r7, sp, #0
    4d10:	6078      	str	r0, [r7, #4]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_DRE) >> SERCOM_USART_INTFLAG_DRE_Pos;
    4d12:	687b      	ldr	r3, [r7, #4]
    4d14:	7b9b      	ldrb	r3, [r3, #14]
    4d16:	b2db      	uxtb	r3, r3
    4d18:	001a      	movs	r2, r3
    4d1a:	2301      	movs	r3, #1
    4d1c:	4013      	ands	r3, r2
    4d1e:	1e5a      	subs	r2, r3, #1
    4d20:	4193      	sbcs	r3, r2
    4d22:	b2db      	uxtb	r3, r3
}
    4d24:	0018      	movs	r0, r3
    4d26:	46bd      	mov	sp, r7
    4d28:	b002      	add	sp, #8
    4d2a:	bd80      	pop	{r7, pc}

00004d2c <hri_sercomusart_get_interrupt_TXC_bit>:
{
	((Sercom *)hw)->USART.INTFLAG.reg = SERCOM_USART_INTFLAG_DRE;
}

static inline bool hri_sercomusart_get_interrupt_TXC_bit(const void *const hw)
{
    4d2c:	b580      	push	{r7, lr}
    4d2e:	b082      	sub	sp, #8
    4d30:	af00      	add	r7, sp, #0
    4d32:	6078      	str	r0, [r7, #4]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_TXC) >> SERCOM_USART_INTFLAG_TXC_Pos;
    4d34:	687b      	ldr	r3, [r7, #4]
    4d36:	7b9b      	ldrb	r3, [r3, #14]
    4d38:	b2db      	uxtb	r3, r3
    4d3a:	085b      	lsrs	r3, r3, #1
    4d3c:	2201      	movs	r2, #1
    4d3e:	4013      	ands	r3, r2
    4d40:	1e5a      	subs	r2, r3, #1
    4d42:	4193      	sbcs	r3, r2
    4d44:	b2db      	uxtb	r3, r3
}
    4d46:	0018      	movs	r0, r3
    4d48:	46bd      	mov	sp, r7
    4d4a:	b002      	add	sp, #8
    4d4c:	bd80      	pop	{r7, pc}

00004d4e <hri_sercomusart_get_interrupt_RXC_bit>:
{
	((Sercom *)hw)->USART.INTFLAG.reg = SERCOM_USART_INTFLAG_TXC;
}

static inline bool hri_sercomusart_get_interrupt_RXC_bit(const void *const hw)
{
    4d4e:	b580      	push	{r7, lr}
    4d50:	b082      	sub	sp, #8
    4d52:	af00      	add	r7, sp, #0
    4d54:	6078      	str	r0, [r7, #4]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_RXC) >> SERCOM_USART_INTFLAG_RXC_Pos;
    4d56:	687b      	ldr	r3, [r7, #4]
    4d58:	7b9b      	ldrb	r3, [r3, #14]
    4d5a:	b2db      	uxtb	r3, r3
    4d5c:	089b      	lsrs	r3, r3, #2
    4d5e:	2201      	movs	r2, #1
    4d60:	4013      	ands	r3, r2
    4d62:	1e5a      	subs	r2, r3, #1
    4d64:	4193      	sbcs	r3, r2
    4d66:	b2db      	uxtb	r3, r3
}
    4d68:	0018      	movs	r0, r3
    4d6a:	46bd      	mov	sp, r7
    4d6c:	b002      	add	sp, #8
    4d6e:	bd80      	pop	{r7, pc}

00004d70 <hri_sercomi2cm_set_CTRLA_ENABLE_bit>:
	tmp = (tmp & SERCOM_I2CM_CTRLA_SWRST) >> SERCOM_I2CM_CTRLA_SWRST_Pos;
	return (bool)tmp;
}

static inline void hri_sercomi2cm_set_CTRLA_ENABLE_bit(const void *const hw)
{
    4d70:	b580      	push	{r7, lr}
    4d72:	b082      	sub	sp, #8
    4d74:	af00      	add	r7, sp, #0
    4d76:	6078      	str	r0, [r7, #4]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->I2CM.CTRLA.reg |= SERCOM_I2CM_CTRLA_ENABLE;
    4d78:	687b      	ldr	r3, [r7, #4]
    4d7a:	681b      	ldr	r3, [r3, #0]
    4d7c:	2202      	movs	r2, #2
    4d7e:	431a      	orrs	r2, r3
    4d80:	687b      	ldr	r3, [r7, #4]
    4d82:	601a      	str	r2, [r3, #0]
	hri_sercomi2cm_wait_for_sync(hw);
    4d84:	687b      	ldr	r3, [r7, #4]
    4d86:	0018      	movs	r0, r3
    4d88:	f7ff ff28 	bl	4bdc <hri_sercomi2cm_wait_for_sync>
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    4d8c:	46c0      	nop			; (mov r8, r8)
    4d8e:	46bd      	mov	sp, r7
    4d90:	b002      	add	sp, #8
    4d92:	bd80      	pop	{r7, pc}

00004d94 <hri_sercomi2cm_get_CTRLA_reg>:
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline hri_sercomi2cm_ctrla_reg_t hri_sercomi2cm_get_CTRLA_reg(const void *const          hw,
                                                                      hri_sercomi2cm_ctrla_reg_t mask)
{
    4d94:	b580      	push	{r7, lr}
    4d96:	b084      	sub	sp, #16
    4d98:	af00      	add	r7, sp, #0
    4d9a:	6078      	str	r0, [r7, #4]
    4d9c:	6039      	str	r1, [r7, #0]
	uint32_t tmp;
	hri_sercomi2cm_wait_for_sync(hw);
    4d9e:	687b      	ldr	r3, [r7, #4]
    4da0:	0018      	movs	r0, r3
    4da2:	f7ff ff1b 	bl	4bdc <hri_sercomi2cm_wait_for_sync>
	tmp = ((Sercom *)hw)->I2CM.CTRLA.reg;
    4da6:	687b      	ldr	r3, [r7, #4]
    4da8:	681b      	ldr	r3, [r3, #0]
    4daa:	60fb      	str	r3, [r7, #12]
	tmp &= mask;
    4dac:	68fb      	ldr	r3, [r7, #12]
    4dae:	683a      	ldr	r2, [r7, #0]
    4db0:	4013      	ands	r3, r2
    4db2:	60fb      	str	r3, [r7, #12]
	return tmp;
    4db4:	68fb      	ldr	r3, [r7, #12]
}
    4db6:	0018      	movs	r0, r3
    4db8:	46bd      	mov	sp, r7
    4dba:	b004      	add	sp, #16
    4dbc:	bd80      	pop	{r7, pc}

00004dbe <hri_sercomi2cm_write_CTRLA_reg>:

static inline void hri_sercomi2cm_write_CTRLA_reg(const void *const hw, hri_sercomi2cm_ctrla_reg_t data)
{
    4dbe:	b580      	push	{r7, lr}
    4dc0:	b082      	sub	sp, #8
    4dc2:	af00      	add	r7, sp, #0
    4dc4:	6078      	str	r0, [r7, #4]
    4dc6:	6039      	str	r1, [r7, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->I2CM.CTRLA.reg = data;
    4dc8:	687b      	ldr	r3, [r7, #4]
    4dca:	683a      	ldr	r2, [r7, #0]
    4dcc:	601a      	str	r2, [r3, #0]
	hri_sercomi2cm_wait_for_sync(hw);
    4dce:	687b      	ldr	r3, [r7, #4]
    4dd0:	0018      	movs	r0, r3
    4dd2:	f7ff ff03 	bl	4bdc <hri_sercomi2cm_wait_for_sync>
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    4dd6:	46c0      	nop			; (mov r8, r8)
    4dd8:	46bd      	mov	sp, r7
    4dda:	b002      	add	sp, #8
    4ddc:	bd80      	pop	{r7, pc}

00004dde <hri_sercomspi_set_CTRLA_ENABLE_bit>:
	tmp = (tmp & SERCOM_SPI_CTRLA_SWRST) >> SERCOM_SPI_CTRLA_SWRST_Pos;
	return (bool)tmp;
}

static inline void hri_sercomspi_set_CTRLA_ENABLE_bit(const void *const hw)
{
    4dde:	b580      	push	{r7, lr}
    4de0:	b082      	sub	sp, #8
    4de2:	af00      	add	r7, sp, #0
    4de4:	6078      	str	r0, [r7, #4]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->SPI.CTRLA.reg |= SERCOM_SPI_CTRLA_ENABLE;
    4de6:	687b      	ldr	r3, [r7, #4]
    4de8:	681b      	ldr	r3, [r3, #0]
    4dea:	2202      	movs	r2, #2
    4dec:	431a      	orrs	r2, r3
    4dee:	687b      	ldr	r3, [r7, #4]
    4df0:	601a      	str	r2, [r3, #0]
	hri_sercomspi_wait_for_sync(hw);
    4df2:	687b      	ldr	r3, [r7, #4]
    4df4:	0018      	movs	r0, r3
    4df6:	f7ff ff01 	bl	4bfc <hri_sercomspi_wait_for_sync>
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    4dfa:	46c0      	nop			; (mov r8, r8)
    4dfc:	46bd      	mov	sp, r7
    4dfe:	b002      	add	sp, #8
    4e00:	bd80      	pop	{r7, pc}

00004e02 <hri_sercomspi_get_CTRLA_ENABLE_bit>:

static inline bool hri_sercomspi_get_CTRLA_ENABLE_bit(const void *const hw)
{
    4e02:	b580      	push	{r7, lr}
    4e04:	b084      	sub	sp, #16
    4e06:	af00      	add	r7, sp, #0
    4e08:	6078      	str	r0, [r7, #4]
	uint32_t tmp;
	hri_sercomspi_wait_for_sync(hw);
    4e0a:	687b      	ldr	r3, [r7, #4]
    4e0c:	0018      	movs	r0, r3
    4e0e:	f7ff fef5 	bl	4bfc <hri_sercomspi_wait_for_sync>
	tmp = ((Sercom *)hw)->SPI.CTRLA.reg;
    4e12:	687b      	ldr	r3, [r7, #4]
    4e14:	681b      	ldr	r3, [r3, #0]
    4e16:	60fb      	str	r3, [r7, #12]
	tmp = (tmp & SERCOM_SPI_CTRLA_ENABLE) >> SERCOM_SPI_CTRLA_ENABLE_Pos;
    4e18:	68fb      	ldr	r3, [r7, #12]
    4e1a:	085b      	lsrs	r3, r3, #1
    4e1c:	2201      	movs	r2, #1
    4e1e:	4013      	ands	r3, r2
    4e20:	60fb      	str	r3, [r7, #12]
	return (bool)tmp;
    4e22:	68fb      	ldr	r3, [r7, #12]
    4e24:	1e5a      	subs	r2, r3, #1
    4e26:	4193      	sbcs	r3, r2
    4e28:	b2db      	uxtb	r3, r3
}
    4e2a:	0018      	movs	r0, r3
    4e2c:	46bd      	mov	sp, r7
    4e2e:	b004      	add	sp, #16
    4e30:	bd80      	pop	{r7, pc}

00004e32 <hri_sercomspi_get_CTRLA_reg>:
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline hri_sercomspi_ctrla_reg_t hri_sercomspi_get_CTRLA_reg(const void *const         hw,
                                                                    hri_sercomspi_ctrla_reg_t mask)
{
    4e32:	b580      	push	{r7, lr}
    4e34:	b084      	sub	sp, #16
    4e36:	af00      	add	r7, sp, #0
    4e38:	6078      	str	r0, [r7, #4]
    4e3a:	6039      	str	r1, [r7, #0]
	uint32_t tmp;
	hri_sercomspi_wait_for_sync(hw);
    4e3c:	687b      	ldr	r3, [r7, #4]
    4e3e:	0018      	movs	r0, r3
    4e40:	f7ff fedc 	bl	4bfc <hri_sercomspi_wait_for_sync>
	tmp = ((Sercom *)hw)->SPI.CTRLA.reg;
    4e44:	687b      	ldr	r3, [r7, #4]
    4e46:	681b      	ldr	r3, [r3, #0]
    4e48:	60fb      	str	r3, [r7, #12]
	tmp &= mask;
    4e4a:	68fb      	ldr	r3, [r7, #12]
    4e4c:	683a      	ldr	r2, [r7, #0]
    4e4e:	4013      	ands	r3, r2
    4e50:	60fb      	str	r3, [r7, #12]
	return tmp;
    4e52:	68fb      	ldr	r3, [r7, #12]
}
    4e54:	0018      	movs	r0, r3
    4e56:	46bd      	mov	sp, r7
    4e58:	b004      	add	sp, #16
    4e5a:	bd80      	pop	{r7, pc}

00004e5c <hri_sercomspi_write_CTRLA_reg>:

static inline void hri_sercomspi_write_CTRLA_reg(const void *const hw, hri_sercomspi_ctrla_reg_t data)
{
    4e5c:	b580      	push	{r7, lr}
    4e5e:	b082      	sub	sp, #8
    4e60:	af00      	add	r7, sp, #0
    4e62:	6078      	str	r0, [r7, #4]
    4e64:	6039      	str	r1, [r7, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->SPI.CTRLA.reg = data;
    4e66:	687b      	ldr	r3, [r7, #4]
    4e68:	683a      	ldr	r2, [r7, #0]
    4e6a:	601a      	str	r2, [r3, #0]
	hri_sercomspi_wait_for_sync(hw);
    4e6c:	687b      	ldr	r3, [r7, #4]
    4e6e:	0018      	movs	r0, r3
    4e70:	f7ff fec4 	bl	4bfc <hri_sercomspi_wait_for_sync>
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    4e74:	46c0      	nop			; (mov r8, r8)
    4e76:	46bd      	mov	sp, r7
    4e78:	b002      	add	sp, #8
    4e7a:	bd80      	pop	{r7, pc}

00004e7c <hri_sercomusart_get_CTRLA_reg>:
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline hri_sercomusart_ctrla_reg_t hri_sercomusart_get_CTRLA_reg(const void *const           hw,
                                                                        hri_sercomusart_ctrla_reg_t mask)
{
    4e7c:	b580      	push	{r7, lr}
    4e7e:	b084      	sub	sp, #16
    4e80:	af00      	add	r7, sp, #0
    4e82:	6078      	str	r0, [r7, #4]
    4e84:	6039      	str	r1, [r7, #0]
	uint32_t tmp;
	hri_sercomusart_wait_for_sync(hw);
    4e86:	687b      	ldr	r3, [r7, #4]
    4e88:	0018      	movs	r0, r3
    4e8a:	f7ff fed7 	bl	4c3c <hri_sercomusart_wait_for_sync>
	tmp = ((Sercom *)hw)->USART.CTRLA.reg;
    4e8e:	687b      	ldr	r3, [r7, #4]
    4e90:	681b      	ldr	r3, [r3, #0]
    4e92:	60fb      	str	r3, [r7, #12]
	tmp &= mask;
    4e94:	68fb      	ldr	r3, [r7, #12]
    4e96:	683a      	ldr	r2, [r7, #0]
    4e98:	4013      	ands	r3, r2
    4e9a:	60fb      	str	r3, [r7, #12]
	return tmp;
    4e9c:	68fb      	ldr	r3, [r7, #12]
}
    4e9e:	0018      	movs	r0, r3
    4ea0:	46bd      	mov	sp, r7
    4ea2:	b004      	add	sp, #16
    4ea4:	bd80      	pop	{r7, pc}

00004ea6 <hri_sercomusart_write_CTRLA_reg>:

static inline void hri_sercomusart_write_CTRLA_reg(const void *const hw, hri_sercomusart_ctrla_reg_t data)
{
    4ea6:	b580      	push	{r7, lr}
    4ea8:	b082      	sub	sp, #8
    4eaa:	af00      	add	r7, sp, #0
    4eac:	6078      	str	r0, [r7, #4]
    4eae:	6039      	str	r1, [r7, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.CTRLA.reg = data;
    4eb0:	687b      	ldr	r3, [r7, #4]
    4eb2:	683a      	ldr	r2, [r7, #0]
    4eb4:	601a      	str	r2, [r3, #0]
	hri_sercomusart_wait_for_sync(hw);
    4eb6:	687b      	ldr	r3, [r7, #4]
    4eb8:	0018      	movs	r0, r3
    4eba:	f7ff febf 	bl	4c3c <hri_sercomusart_wait_for_sync>
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    4ebe:	46c0      	nop			; (mov r8, r8)
    4ec0:	46bd      	mov	sp, r7
    4ec2:	b002      	add	sp, #8
    4ec4:	bd80      	pop	{r7, pc}

00004ec6 <hri_sercomi2cm_set_CTRLB_SMEN_bit>:
	hri_sercomusart_wait_for_sync(hw);
	return ((Sercom *)hw)->USART.CTRLA.reg;
}

static inline void hri_sercomi2cm_set_CTRLB_SMEN_bit(const void *const hw)
{
    4ec6:	b580      	push	{r7, lr}
    4ec8:	b082      	sub	sp, #8
    4eca:	af00      	add	r7, sp, #0
    4ecc:	6078      	str	r0, [r7, #4]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_SMEN;
    4ece:	687b      	ldr	r3, [r7, #4]
    4ed0:	685b      	ldr	r3, [r3, #4]
    4ed2:	2280      	movs	r2, #128	; 0x80
    4ed4:	0052      	lsls	r2, r2, #1
    4ed6:	431a      	orrs	r2, r3
    4ed8:	687b      	ldr	r3, [r7, #4]
    4eda:	605a      	str	r2, [r3, #4]
	hri_sercomi2cm_wait_for_sync(hw);
    4edc:	687b      	ldr	r3, [r7, #4]
    4ede:	0018      	movs	r0, r3
    4ee0:	f7ff fe7c 	bl	4bdc <hri_sercomi2cm_wait_for_sync>
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    4ee4:	46c0      	nop			; (mov r8, r8)
    4ee6:	46bd      	mov	sp, r7
    4ee8:	b002      	add	sp, #8
    4eea:	bd80      	pop	{r7, pc}

00004eec <hri_sercomi2cm_clear_CTRLB_SMEN_bit>:
	hri_sercomi2cm_wait_for_sync(hw);
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline void hri_sercomi2cm_clear_CTRLB_SMEN_bit(const void *const hw)
{
    4eec:	b580      	push	{r7, lr}
    4eee:	b082      	sub	sp, #8
    4ef0:	af00      	add	r7, sp, #0
    4ef2:	6078      	str	r0, [r7, #4]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->I2CM.CTRLB.reg &= ~SERCOM_I2CM_CTRLB_SMEN;
    4ef4:	687b      	ldr	r3, [r7, #4]
    4ef6:	685b      	ldr	r3, [r3, #4]
    4ef8:	4a05      	ldr	r2, [pc, #20]	; (4f10 <hri_sercomi2cm_clear_CTRLB_SMEN_bit+0x24>)
    4efa:	401a      	ands	r2, r3
    4efc:	687b      	ldr	r3, [r7, #4]
    4efe:	605a      	str	r2, [r3, #4]
	hri_sercomi2cm_wait_for_sync(hw);
    4f00:	687b      	ldr	r3, [r7, #4]
    4f02:	0018      	movs	r0, r3
    4f04:	f7ff fe6a 	bl	4bdc <hri_sercomi2cm_wait_for_sync>
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    4f08:	46c0      	nop			; (mov r8, r8)
    4f0a:	46bd      	mov	sp, r7
    4f0c:	b002      	add	sp, #8
    4f0e:	bd80      	pop	{r7, pc}
    4f10:	fffffeff 	.word	0xfffffeff

00004f14 <hri_sercomi2cm_set_CTRLB_ACKACT_bit>:
	hri_sercomi2cm_wait_for_sync(hw);
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline void hri_sercomi2cm_set_CTRLB_ACKACT_bit(const void *const hw)
{
    4f14:	b580      	push	{r7, lr}
    4f16:	b082      	sub	sp, #8
    4f18:	af00      	add	r7, sp, #0
    4f1a:	6078      	str	r0, [r7, #4]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_ACKACT;
    4f1c:	687b      	ldr	r3, [r7, #4]
    4f1e:	685b      	ldr	r3, [r3, #4]
    4f20:	2280      	movs	r2, #128	; 0x80
    4f22:	02d2      	lsls	r2, r2, #11
    4f24:	431a      	orrs	r2, r3
    4f26:	687b      	ldr	r3, [r7, #4]
    4f28:	605a      	str	r2, [r3, #4]
	hri_sercomi2cm_wait_for_sync(hw);
    4f2a:	687b      	ldr	r3, [r7, #4]
    4f2c:	0018      	movs	r0, r3
    4f2e:	f7ff fe55 	bl	4bdc <hri_sercomi2cm_wait_for_sync>
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    4f32:	46c0      	nop			; (mov r8, r8)
    4f34:	46bd      	mov	sp, r7
    4f36:	b002      	add	sp, #8
    4f38:	bd80      	pop	{r7, pc}
	...

00004f3c <hri_sercomi2cm_clear_CTRLB_ACKACT_bit>:
	hri_sercomi2cm_wait_for_sync(hw);
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline void hri_sercomi2cm_clear_CTRLB_ACKACT_bit(const void *const hw)
{
    4f3c:	b580      	push	{r7, lr}
    4f3e:	b082      	sub	sp, #8
    4f40:	af00      	add	r7, sp, #0
    4f42:	6078      	str	r0, [r7, #4]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->I2CM.CTRLB.reg &= ~SERCOM_I2CM_CTRLB_ACKACT;
    4f44:	687b      	ldr	r3, [r7, #4]
    4f46:	685b      	ldr	r3, [r3, #4]
    4f48:	4a05      	ldr	r2, [pc, #20]	; (4f60 <hri_sercomi2cm_clear_CTRLB_ACKACT_bit+0x24>)
    4f4a:	401a      	ands	r2, r3
    4f4c:	687b      	ldr	r3, [r7, #4]
    4f4e:	605a      	str	r2, [r3, #4]
	hri_sercomi2cm_wait_for_sync(hw);
    4f50:	687b      	ldr	r3, [r7, #4]
    4f52:	0018      	movs	r0, r3
    4f54:	f7ff fe42 	bl	4bdc <hri_sercomi2cm_wait_for_sync>
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    4f58:	46c0      	nop			; (mov r8, r8)
    4f5a:	46bd      	mov	sp, r7
    4f5c:	b002      	add	sp, #8
    4f5e:	bd80      	pop	{r7, pc}
    4f60:	fffbffff 	.word	0xfffbffff

00004f64 <hri_sercomi2cm_set_CTRLB_CMD_bf>:
	hri_sercomi2cm_wait_for_sync(hw);
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline void hri_sercomi2cm_set_CTRLB_CMD_bf(const void *const hw, hri_sercomi2cm_ctrlb_reg_t mask)
{
    4f64:	b580      	push	{r7, lr}
    4f66:	b082      	sub	sp, #8
    4f68:	af00      	add	r7, sp, #0
    4f6a:	6078      	str	r0, [r7, #4]
    4f6c:	6039      	str	r1, [r7, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
    4f6e:	687b      	ldr	r3, [r7, #4]
    4f70:	685a      	ldr	r2, [r3, #4]
    4f72:	683b      	ldr	r3, [r7, #0]
    4f74:	0419      	lsls	r1, r3, #16
    4f76:	23c0      	movs	r3, #192	; 0xc0
    4f78:	029b      	lsls	r3, r3, #10
    4f7a:	400b      	ands	r3, r1
    4f7c:	431a      	orrs	r2, r3
    4f7e:	687b      	ldr	r3, [r7, #4]
    4f80:	605a      	str	r2, [r3, #4]
	hri_sercomi2cm_wait_for_sync(hw);
    4f82:	687b      	ldr	r3, [r7, #4]
    4f84:	0018      	movs	r0, r3
    4f86:	f7ff fe29 	bl	4bdc <hri_sercomi2cm_wait_for_sync>
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    4f8a:	46c0      	nop			; (mov r8, r8)
    4f8c:	46bd      	mov	sp, r7
    4f8e:	b002      	add	sp, #8
    4f90:	bd80      	pop	{r7, pc}

00004f92 <hri_sercomi2cm_write_CTRLB_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomi2cm_write_CTRLB_reg(const void *const hw, hri_sercomi2cm_ctrlb_reg_t data)
{
    4f92:	b580      	push	{r7, lr}
    4f94:	b082      	sub	sp, #8
    4f96:	af00      	add	r7, sp, #0
    4f98:	6078      	str	r0, [r7, #4]
    4f9a:	6039      	str	r1, [r7, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->I2CM.CTRLB.reg = data;
    4f9c:	687b      	ldr	r3, [r7, #4]
    4f9e:	683a      	ldr	r2, [r7, #0]
    4fa0:	605a      	str	r2, [r3, #4]
	hri_sercomi2cm_wait_for_sync(hw);
    4fa2:	687b      	ldr	r3, [r7, #4]
    4fa4:	0018      	movs	r0, r3
    4fa6:	f7ff fe19 	bl	4bdc <hri_sercomi2cm_wait_for_sync>
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    4faa:	46c0      	nop			; (mov r8, r8)
    4fac:	46bd      	mov	sp, r7
    4fae:	b002      	add	sp, #8
    4fb0:	bd80      	pop	{r7, pc}

00004fb2 <hri_sercomspi_write_CTRLB_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomspi_write_CTRLB_reg(const void *const hw, hri_sercomspi_ctrlb_reg_t data)
{
    4fb2:	b580      	push	{r7, lr}
    4fb4:	b082      	sub	sp, #8
    4fb6:	af00      	add	r7, sp, #0
    4fb8:	6078      	str	r0, [r7, #4]
    4fba:	6039      	str	r1, [r7, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->SPI.CTRLB.reg = data;
    4fbc:	687b      	ldr	r3, [r7, #4]
    4fbe:	683a      	ldr	r2, [r7, #0]
    4fc0:	605a      	str	r2, [r3, #4]
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    4fc2:	46c0      	nop			; (mov r8, r8)
    4fc4:	46bd      	mov	sp, r7
    4fc6:	b002      	add	sp, #8
    4fc8:	bd80      	pop	{r7, pc}

00004fca <hri_sercomusart_write_CTRLB_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomusart_write_CTRLB_reg(const void *const hw, hri_sercomusart_ctrlb_reg_t data)
{
    4fca:	b580      	push	{r7, lr}
    4fcc:	b082      	sub	sp, #8
    4fce:	af00      	add	r7, sp, #0
    4fd0:	6078      	str	r0, [r7, #4]
    4fd2:	6039      	str	r1, [r7, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.CTRLB.reg = data;
    4fd4:	687b      	ldr	r3, [r7, #4]
    4fd6:	683a      	ldr	r2, [r7, #0]
    4fd8:	605a      	str	r2, [r3, #4]
	hri_sercomusart_wait_for_sync(hw);
    4fda:	687b      	ldr	r3, [r7, #4]
    4fdc:	0018      	movs	r0, r3
    4fde:	f7ff fe2d 	bl	4c3c <hri_sercomusart_wait_for_sync>
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    4fe2:	46c0      	nop			; (mov r8, r8)
    4fe4:	46bd      	mov	sp, r7
    4fe6:	b002      	add	sp, #8
    4fe8:	bd80      	pop	{r7, pc}

00004fea <hri_sercomspi_write_DBGCTRL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomspi_write_DBGCTRL_reg(const void *const hw, hri_sercomspi_dbgctrl_reg_t data)
{
    4fea:	b580      	push	{r7, lr}
    4fec:	b082      	sub	sp, #8
    4fee:	af00      	add	r7, sp, #0
    4ff0:	6078      	str	r0, [r7, #4]
    4ff2:	000a      	movs	r2, r1
    4ff4:	1cfb      	adds	r3, r7, #3
    4ff6:	701a      	strb	r2, [r3, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->SPI.DBGCTRL.reg = data;
    4ff8:	687b      	ldr	r3, [r7, #4]
    4ffa:	1cfa      	adds	r2, r7, #3
    4ffc:	7812      	ldrb	r2, [r2, #0]
    4ffe:	721a      	strb	r2, [r3, #8]
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    5000:	46c0      	nop			; (mov r8, r8)
    5002:	46bd      	mov	sp, r7
    5004:	b002      	add	sp, #8
    5006:	bd80      	pop	{r7, pc}

00005008 <hri_sercomusart_write_DBGCTRL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomusart_write_DBGCTRL_reg(const void *const hw, hri_sercomusart_dbgctrl_reg_t data)
{
    5008:	b580      	push	{r7, lr}
    500a:	b082      	sub	sp, #8
    500c:	af00      	add	r7, sp, #0
    500e:	6078      	str	r0, [r7, #4]
    5010:	000a      	movs	r2, r1
    5012:	1cfb      	adds	r3, r7, #3
    5014:	701a      	strb	r2, [r3, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.DBGCTRL.reg = data;
    5016:	687b      	ldr	r3, [r7, #4]
    5018:	1cfa      	adds	r2, r7, #3
    501a:	7812      	ldrb	r2, [r2, #0]
    501c:	721a      	strb	r2, [r3, #8]
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    501e:	46c0      	nop			; (mov r8, r8)
    5020:	46bd      	mov	sp, r7
    5022:	b002      	add	sp, #8
    5024:	bd80      	pop	{r7, pc}

00005026 <hri_sercomi2cm_write_BAUD_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomi2cm_write_BAUD_reg(const void *const hw, hri_sercomi2cm_baud_reg_t data)
{
    5026:	b580      	push	{r7, lr}
    5028:	b082      	sub	sp, #8
    502a:	af00      	add	r7, sp, #0
    502c:	6078      	str	r0, [r7, #4]
    502e:	000a      	movs	r2, r1
    5030:	1cbb      	adds	r3, r7, #2
    5032:	801a      	strh	r2, [r3, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->I2CM.BAUD.reg = data;
    5034:	687b      	ldr	r3, [r7, #4]
    5036:	1cba      	adds	r2, r7, #2
    5038:	8812      	ldrh	r2, [r2, #0]
    503a:	815a      	strh	r2, [r3, #10]
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    503c:	46c0      	nop			; (mov r8, r8)
    503e:	46bd      	mov	sp, r7
    5040:	b002      	add	sp, #8
    5042:	bd80      	pop	{r7, pc}

00005044 <hri_sercomspi_write_BAUD_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomspi_write_BAUD_reg(const void *const hw, hri_sercomspi_baud_reg_t data)
{
    5044:	b580      	push	{r7, lr}
    5046:	b082      	sub	sp, #8
    5048:	af00      	add	r7, sp, #0
    504a:	6078      	str	r0, [r7, #4]
    504c:	000a      	movs	r2, r1
    504e:	1cfb      	adds	r3, r7, #3
    5050:	701a      	strb	r2, [r3, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->SPI.BAUD.reg = data;
    5052:	687b      	ldr	r3, [r7, #4]
    5054:	1cfa      	adds	r2, r7, #3
    5056:	7812      	ldrb	r2, [r2, #0]
    5058:	729a      	strb	r2, [r3, #10]
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    505a:	46c0      	nop			; (mov r8, r8)
    505c:	46bd      	mov	sp, r7
    505e:	b002      	add	sp, #8
    5060:	bd80      	pop	{r7, pc}

00005062 <hri_sercomusart_write_BAUD_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomusart_write_BAUD_reg(const void *const hw, hri_sercomusart_baud_reg_t data)
{
    5062:	b580      	push	{r7, lr}
    5064:	b082      	sub	sp, #8
    5066:	af00      	add	r7, sp, #0
    5068:	6078      	str	r0, [r7, #4]
    506a:	000a      	movs	r2, r1
    506c:	1cbb      	adds	r3, r7, #2
    506e:	801a      	strh	r2, [r3, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.BAUD.reg = data;
    5070:	687b      	ldr	r3, [r7, #4]
    5072:	1cba      	adds	r2, r7, #2
    5074:	8812      	ldrh	r2, [r2, #0]
    5076:	815a      	strh	r2, [r3, #10]
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    5078:	46c0      	nop			; (mov r8, r8)
    507a:	46bd      	mov	sp, r7
    507c:	b002      	add	sp, #8
    507e:	bd80      	pop	{r7, pc}

00005080 <hri_sercomi2cm_write_ADDR_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomi2cm_write_ADDR_reg(const void *const hw, hri_sercomi2cm_addr_reg_t data)
{
    5080:	b580      	push	{r7, lr}
    5082:	b082      	sub	sp, #8
    5084:	af00      	add	r7, sp, #0
    5086:	6078      	str	r0, [r7, #4]
    5088:	000a      	movs	r2, r1
    508a:	1cfb      	adds	r3, r7, #3
    508c:	701a      	strb	r2, [r3, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->I2CM.ADDR.reg = data;
    508e:	687b      	ldr	r3, [r7, #4]
    5090:	1cfa      	adds	r2, r7, #3
    5092:	7812      	ldrb	r2, [r2, #0]
    5094:	751a      	strb	r2, [r3, #20]
	hri_sercomi2cm_wait_for_sync(hw);
    5096:	687b      	ldr	r3, [r7, #4]
    5098:	0018      	movs	r0, r3
    509a:	f7ff fd9f 	bl	4bdc <hri_sercomi2cm_wait_for_sync>
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    509e:	46c0      	nop			; (mov r8, r8)
    50a0:	46bd      	mov	sp, r7
    50a2:	b002      	add	sp, #8
    50a4:	bd80      	pop	{r7, pc}

000050a6 <hri_sercomspi_write_ADDR_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomspi_write_ADDR_reg(const void *const hw, hri_sercomspi_addr_reg_t data)
{
    50a6:	b580      	push	{r7, lr}
    50a8:	b082      	sub	sp, #8
    50aa:	af00      	add	r7, sp, #0
    50ac:	6078      	str	r0, [r7, #4]
    50ae:	6039      	str	r1, [r7, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->SPI.ADDR.reg = data;
    50b0:	687b      	ldr	r3, [r7, #4]
    50b2:	683a      	ldr	r2, [r7, #0]
    50b4:	615a      	str	r2, [r3, #20]
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    50b6:	46c0      	nop			; (mov r8, r8)
    50b8:	46bd      	mov	sp, r7
    50ba:	b002      	add	sp, #8
    50bc:	bd80      	pop	{r7, pc}

000050be <hri_sercomi2cm_write_DATA_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomi2cm_write_DATA_reg(const void *const hw, hri_sercomi2cm_data_reg_t data)
{
    50be:	b580      	push	{r7, lr}
    50c0:	b082      	sub	sp, #8
    50c2:	af00      	add	r7, sp, #0
    50c4:	6078      	str	r0, [r7, #4]
    50c6:	000a      	movs	r2, r1
    50c8:	1cfb      	adds	r3, r7, #3
    50ca:	701a      	strb	r2, [r3, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->I2CM.DATA.reg = data;
    50cc:	687b      	ldr	r3, [r7, #4]
    50ce:	1cfa      	adds	r2, r7, #3
    50d0:	7812      	ldrb	r2, [r2, #0]
    50d2:	761a      	strb	r2, [r3, #24]
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    50d4:	46c0      	nop			; (mov r8, r8)
    50d6:	46bd      	mov	sp, r7
    50d8:	b002      	add	sp, #8
    50da:	bd80      	pop	{r7, pc}

000050dc <hri_sercomi2cm_read_DATA_reg>:
	((Sercom *)hw)->I2CM.DATA.reg ^= mask;
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline hri_sercomi2cm_data_reg_t hri_sercomi2cm_read_DATA_reg(const void *const hw)
{
    50dc:	b580      	push	{r7, lr}
    50de:	b082      	sub	sp, #8
    50e0:	af00      	add	r7, sp, #0
    50e2:	6078      	str	r0, [r7, #4]
	return ((Sercom *)hw)->I2CM.DATA.reg;
    50e4:	687b      	ldr	r3, [r7, #4]
    50e6:	7e1b      	ldrb	r3, [r3, #24]
    50e8:	b2db      	uxtb	r3, r3
}
    50ea:	0018      	movs	r0, r3
    50ec:	46bd      	mov	sp, r7
    50ee:	b002      	add	sp, #8
    50f0:	bd80      	pop	{r7, pc}

000050f2 <hri_sercomspi_write_DATA_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomspi_write_DATA_reg(const void *const hw, hri_sercomspi_data_reg_t data)
{
    50f2:	b580      	push	{r7, lr}
    50f4:	b082      	sub	sp, #8
    50f6:	af00      	add	r7, sp, #0
    50f8:	6078      	str	r0, [r7, #4]
    50fa:	000a      	movs	r2, r1
    50fc:	1cbb      	adds	r3, r7, #2
    50fe:	801a      	strh	r2, [r3, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->SPI.DATA.reg = data;
    5100:	687b      	ldr	r3, [r7, #4]
    5102:	1cba      	adds	r2, r7, #2
    5104:	8812      	ldrh	r2, [r2, #0]
    5106:	831a      	strh	r2, [r3, #24]
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    5108:	46c0      	nop			; (mov r8, r8)
    510a:	46bd      	mov	sp, r7
    510c:	b002      	add	sp, #8
    510e:	bd80      	pop	{r7, pc}

00005110 <hri_sercomspi_read_DATA_reg>:
	((Sercom *)hw)->SPI.DATA.reg ^= mask;
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline hri_sercomspi_data_reg_t hri_sercomspi_read_DATA_reg(const void *const hw)
{
    5110:	b580      	push	{r7, lr}
    5112:	b082      	sub	sp, #8
    5114:	af00      	add	r7, sp, #0
    5116:	6078      	str	r0, [r7, #4]
	return ((Sercom *)hw)->SPI.DATA.reg;
    5118:	687b      	ldr	r3, [r7, #4]
    511a:	8b1b      	ldrh	r3, [r3, #24]
    511c:	b29b      	uxth	r3, r3
}
    511e:	0018      	movs	r0, r3
    5120:	46bd      	mov	sp, r7
    5122:	b002      	add	sp, #8
    5124:	bd80      	pop	{r7, pc}

00005126 <hri_sercomusart_write_DATA_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomusart_write_DATA_reg(const void *const hw, hri_sercomusart_data_reg_t data)
{
    5126:	b580      	push	{r7, lr}
    5128:	b082      	sub	sp, #8
    512a:	af00      	add	r7, sp, #0
    512c:	6078      	str	r0, [r7, #4]
    512e:	000a      	movs	r2, r1
    5130:	1cbb      	adds	r3, r7, #2
    5132:	801a      	strh	r2, [r3, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.DATA.reg = data;
    5134:	687b      	ldr	r3, [r7, #4]
    5136:	1cba      	adds	r2, r7, #2
    5138:	8812      	ldrh	r2, [r2, #0]
    513a:	831a      	strh	r2, [r3, #24]
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    513c:	46c0      	nop			; (mov r8, r8)
    513e:	46bd      	mov	sp, r7
    5140:	b002      	add	sp, #8
    5142:	bd80      	pop	{r7, pc}

00005144 <hri_sercomusart_read_DATA_reg>:
	((Sercom *)hw)->USART.DATA.reg ^= mask;
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline hri_sercomusart_data_reg_t hri_sercomusart_read_DATA_reg(const void *const hw)
{
    5144:	b580      	push	{r7, lr}
    5146:	b082      	sub	sp, #8
    5148:	af00      	add	r7, sp, #0
    514a:	6078      	str	r0, [r7, #4]
	return ((Sercom *)hw)->USART.DATA.reg;
    514c:	687b      	ldr	r3, [r7, #4]
    514e:	8b1b      	ldrh	r3, [r3, #24]
    5150:	b29b      	uxth	r3, r3
}
    5152:	0018      	movs	r0, r3
    5154:	46bd      	mov	sp, r7
    5156:	b002      	add	sp, #8
    5158:	bd80      	pop	{r7, pc}

0000515a <hri_sercomi2cm_read_STATUS_BUSSTATE_bf>:
	hri_sercomi2cm_wait_for_sync(hw);
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline hri_sercomi2cm_status_reg_t hri_sercomi2cm_read_STATUS_BUSSTATE_bf(const void *const hw)
{
    515a:	b580      	push	{r7, lr}
    515c:	b082      	sub	sp, #8
    515e:	af00      	add	r7, sp, #0
    5160:	6078      	str	r0, [r7, #4]
	hri_sercomi2cm_wait_for_sync(hw);
    5162:	687b      	ldr	r3, [r7, #4]
    5164:	0018      	movs	r0, r3
    5166:	f7ff fd39 	bl	4bdc <hri_sercomi2cm_wait_for_sync>
	return (((Sercom *)hw)->I2CM.STATUS.reg & SERCOM_I2CM_STATUS_BUSSTATE_Msk) >> SERCOM_I2CM_STATUS_BUSSTATE_Pos;
    516a:	687b      	ldr	r3, [r7, #4]
    516c:	8a1b      	ldrh	r3, [r3, #16]
    516e:	b29b      	uxth	r3, r3
    5170:	091b      	lsrs	r3, r3, #4
    5172:	b29b      	uxth	r3, r3
    5174:	2203      	movs	r2, #3
    5176:	4013      	ands	r3, r2
    5178:	b29b      	uxth	r3, r3
}
    517a:	0018      	movs	r0, r3
    517c:	46bd      	mov	sp, r7
    517e:	b002      	add	sp, #8
    5180:	bd80      	pop	{r7, pc}

00005182 <hri_sercomi2cm_read_STATUS_reg>:
	hri_sercomi2cm_wait_for_sync(hw);
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline hri_sercomi2cm_status_reg_t hri_sercomi2cm_read_STATUS_reg(const void *const hw)
{
    5182:	b580      	push	{r7, lr}
    5184:	b082      	sub	sp, #8
    5186:	af00      	add	r7, sp, #0
    5188:	6078      	str	r0, [r7, #4]
	hri_sercomi2cm_wait_for_sync(hw);
    518a:	687b      	ldr	r3, [r7, #4]
    518c:	0018      	movs	r0, r3
    518e:	f7ff fd25 	bl	4bdc <hri_sercomi2cm_wait_for_sync>
	return ((Sercom *)hw)->I2CM.STATUS.reg;
    5192:	687b      	ldr	r3, [r7, #4]
    5194:	8a1b      	ldrh	r3, [r3, #16]
    5196:	b29b      	uxth	r3, r3
}
    5198:	0018      	movs	r0, r3
    519a:	46bd      	mov	sp, r7
    519c:	b002      	add	sp, #8
    519e:	bd80      	pop	{r7, pc}

000051a0 <_usart_sync_init>:

/**
 * \brief Initialize synchronous SERCOM USART
 */
int32_t _usart_sync_init(struct _usart_sync_device *const device, void *const hw)
{
    51a0:	b580      	push	{r7, lr}
    51a2:	b082      	sub	sp, #8
    51a4:	af00      	add	r7, sp, #0
    51a6:	6078      	str	r0, [r7, #4]
    51a8:	6039      	str	r1, [r7, #0]
	ASSERT(device);
    51aa:	687b      	ldr	r3, [r7, #4]
    51ac:	1e5a      	subs	r2, r3, #1
    51ae:	4193      	sbcs	r3, r2
    51b0:	b2db      	uxtb	r3, r3
    51b2:	4908      	ldr	r1, [pc, #32]	; (51d4 <_usart_sync_init+0x34>)
    51b4:	22a1      	movs	r2, #161	; 0xa1
    51b6:	0018      	movs	r0, r3
    51b8:	f7ff f8b2 	bl	4320 <assert>

	device->hw = hw;
    51bc:	687b      	ldr	r3, [r7, #4]
    51be:	683a      	ldr	r2, [r7, #0]
    51c0:	601a      	str	r2, [r3, #0]

	return _usart_init(hw);
    51c2:	683b      	ldr	r3, [r7, #0]
    51c4:	0018      	movs	r0, r3
    51c6:	f000 f8a3 	bl	5310 <_usart_init>
    51ca:	0003      	movs	r3, r0
}
    51cc:	0018      	movs	r0, r3
    51ce:	46bd      	mov	sp, r7
    51d0:	b002      	add	sp, #8
    51d2:	bd80      	pop	{r7, pc}
    51d4:	00008b30 	.word	0x00008b30

000051d8 <_usart_sync_write_byte>:

/**
 * \brief Write a byte to the given SERCOM USART instance
 */
void _usart_sync_write_byte(struct _usart_sync_device *const device, uint8_t data)
{
    51d8:	b580      	push	{r7, lr}
    51da:	b082      	sub	sp, #8
    51dc:	af00      	add	r7, sp, #0
    51de:	6078      	str	r0, [r7, #4]
    51e0:	000a      	movs	r2, r1
    51e2:	1cfb      	adds	r3, r7, #3
    51e4:	701a      	strb	r2, [r3, #0]
	hri_sercomusart_write_DATA_reg(device->hw, data);
    51e6:	687b      	ldr	r3, [r7, #4]
    51e8:	681a      	ldr	r2, [r3, #0]
    51ea:	1cfb      	adds	r3, r7, #3
    51ec:	781b      	ldrb	r3, [r3, #0]
    51ee:	b29b      	uxth	r3, r3
    51f0:	0019      	movs	r1, r3
    51f2:	0010      	movs	r0, r2
    51f4:	f7ff ff97 	bl	5126 <hri_sercomusart_write_DATA_reg>
}
    51f8:	46c0      	nop			; (mov r8, r8)
    51fa:	46bd      	mov	sp, r7
    51fc:	b002      	add	sp, #8
    51fe:	bd80      	pop	{r7, pc}

00005200 <_usart_sync_read_byte>:

/**
 * \brief Read a byte from the given SERCOM USART instance
 */
uint8_t _usart_sync_read_byte(const struct _usart_sync_device *const device)
{
    5200:	b580      	push	{r7, lr}
    5202:	b082      	sub	sp, #8
    5204:	af00      	add	r7, sp, #0
    5206:	6078      	str	r0, [r7, #4]
	return hri_sercomusart_read_DATA_reg(device->hw);
    5208:	687b      	ldr	r3, [r7, #4]
    520a:	681b      	ldr	r3, [r3, #0]
    520c:	0018      	movs	r0, r3
    520e:	f7ff ff99 	bl	5144 <hri_sercomusart_read_DATA_reg>
    5212:	0003      	movs	r3, r0
    5214:	b2db      	uxtb	r3, r3
}
    5216:	0018      	movs	r0, r3
    5218:	46bd      	mov	sp, r7
    521a:	b002      	add	sp, #8
    521c:	bd80      	pop	{r7, pc}

0000521e <_usart_sync_is_ready_to_send>:

/**
 * \brief Check if USART is ready to send next byte
 */
bool _usart_sync_is_ready_to_send(const struct _usart_sync_device *const device)
{
    521e:	b580      	push	{r7, lr}
    5220:	b082      	sub	sp, #8
    5222:	af00      	add	r7, sp, #0
    5224:	6078      	str	r0, [r7, #4]
	return hri_sercomusart_get_interrupt_DRE_bit(device->hw);
    5226:	687b      	ldr	r3, [r7, #4]
    5228:	681b      	ldr	r3, [r3, #0]
    522a:	0018      	movs	r0, r3
    522c:	f7ff fd6d 	bl	4d0a <hri_sercomusart_get_interrupt_DRE_bit>
    5230:	0003      	movs	r3, r0
}
    5232:	0018      	movs	r0, r3
    5234:	46bd      	mov	sp, r7
    5236:	b002      	add	sp, #8
    5238:	bd80      	pop	{r7, pc}

0000523a <_usart_sync_is_transmit_done>:

/**
 * \brief Check if USART transmission complete
 */
bool _usart_sync_is_transmit_done(const struct _usart_sync_device *const device)
{
    523a:	b580      	push	{r7, lr}
    523c:	b082      	sub	sp, #8
    523e:	af00      	add	r7, sp, #0
    5240:	6078      	str	r0, [r7, #4]
	return hri_sercomusart_get_interrupt_TXC_bit(device->hw);
    5242:	687b      	ldr	r3, [r7, #4]
    5244:	681b      	ldr	r3, [r3, #0]
    5246:	0018      	movs	r0, r3
    5248:	f7ff fd70 	bl	4d2c <hri_sercomusart_get_interrupt_TXC_bit>
    524c:	0003      	movs	r3, r0
}
    524e:	0018      	movs	r0, r3
    5250:	46bd      	mov	sp, r7
    5252:	b002      	add	sp, #8
    5254:	bd80      	pop	{r7, pc}

00005256 <_usart_sync_is_byte_received>:

/**
 * \brief Check if there is data received by USART
 */
bool _usart_sync_is_byte_received(const struct _usart_sync_device *const device)
{
    5256:	b580      	push	{r7, lr}
    5258:	b082      	sub	sp, #8
    525a:	af00      	add	r7, sp, #0
    525c:	6078      	str	r0, [r7, #4]
	return hri_sercomusart_get_interrupt_RXC_bit(device->hw);
    525e:	687b      	ldr	r3, [r7, #4]
    5260:	681b      	ldr	r3, [r3, #0]
    5262:	0018      	movs	r0, r3
    5264:	f7ff fd73 	bl	4d4e <hri_sercomusart_get_interrupt_RXC_bit>
    5268:	0003      	movs	r3, r0
}
    526a:	0018      	movs	r0, r3
    526c:	46bd      	mov	sp, r7
    526e:	b002      	add	sp, #8
    5270:	bd80      	pop	{r7, pc}
	...

00005274 <_sercom_get_hardware_index>:

/**
 * \brief Retrieve ordinal number of the given sercom hardware instance
 */
static uint8_t _sercom_get_hardware_index(const void *const hw)
{
    5274:	b580      	push	{r7, lr}
    5276:	b082      	sub	sp, #8
    5278:	af00      	add	r7, sp, #0
    527a:	6078      	str	r0, [r7, #4]
#ifdef _UNIT_TEST_
	return ((uint32_t)hw - (uint32_t)SERCOM0) / sizeof(Sercom);
#endif

	return ((uint32_t)hw - (uint32_t)SERCOM0) >> 10;
    527c:	687b      	ldr	r3, [r7, #4]
    527e:	4a04      	ldr	r2, [pc, #16]	; (5290 <_sercom_get_hardware_index+0x1c>)
    5280:	4694      	mov	ip, r2
    5282:	4463      	add	r3, ip
    5284:	0a9b      	lsrs	r3, r3, #10
    5286:	b2db      	uxtb	r3, r3
}
    5288:	0018      	movs	r0, r3
    528a:	46bd      	mov	sp, r7
    528c:	b002      	add	sp, #8
    528e:	bd80      	pop	{r7, pc}
    5290:	bdfff800 	.word	0xbdfff800

00005294 <_get_sercom_index>:
 * \param[in] hw The pointer to hardware instance

 * \return The ordinal number of the given sercom hardware instance
 */
static uint8_t _get_sercom_index(const void *const hw)
{
    5294:	b590      	push	{r4, r7, lr}
    5296:	b085      	sub	sp, #20
    5298:	af00      	add	r7, sp, #0
    529a:	6078      	str	r0, [r7, #4]
	uint8_t sercom_offset = _sercom_get_hardware_index(hw);
    529c:	230e      	movs	r3, #14
    529e:	18fc      	adds	r4, r7, r3
    52a0:	687b      	ldr	r3, [r7, #4]
    52a2:	0018      	movs	r0, r3
    52a4:	f7ff ffe6 	bl	5274 <_sercom_get_hardware_index>
    52a8:	0003      	movs	r3, r0
    52aa:	7023      	strb	r3, [r4, #0]
	uint8_t i;

	for (i = 0; i < ARRAY_SIZE(_usarts); i++) {
    52ac:	230f      	movs	r3, #15
    52ae:	18fb      	adds	r3, r7, r3
    52b0:	2200      	movs	r2, #0
    52b2:	701a      	strb	r2, [r3, #0]
    52b4:	e015      	b.n	52e2 <_get_sercom_index+0x4e>
		if (_usarts[i].number == sercom_offset) {
    52b6:	230f      	movs	r3, #15
    52b8:	18fb      	adds	r3, r7, r3
    52ba:	781a      	ldrb	r2, [r3, #0]
    52bc:	4b11      	ldr	r3, [pc, #68]	; (5304 <_get_sercom_index+0x70>)
    52be:	0112      	lsls	r2, r2, #4
    52c0:	5cd3      	ldrb	r3, [r2, r3]
    52c2:	220e      	movs	r2, #14
    52c4:	18ba      	adds	r2, r7, r2
    52c6:	7812      	ldrb	r2, [r2, #0]
    52c8:	429a      	cmp	r2, r3
    52ca:	d103      	bne.n	52d4 <_get_sercom_index+0x40>
			return i;
    52cc:	230f      	movs	r3, #15
    52ce:	18fb      	adds	r3, r7, r3
    52d0:	781b      	ldrb	r3, [r3, #0]
    52d2:	e012      	b.n	52fa <_get_sercom_index+0x66>
	for (i = 0; i < ARRAY_SIZE(_usarts); i++) {
    52d4:	230f      	movs	r3, #15
    52d6:	18fb      	adds	r3, r7, r3
    52d8:	781a      	ldrb	r2, [r3, #0]
    52da:	230f      	movs	r3, #15
    52dc:	18fb      	adds	r3, r7, r3
    52de:	3201      	adds	r2, #1
    52e0:	701a      	strb	r2, [r3, #0]
    52e2:	230f      	movs	r3, #15
    52e4:	18fb      	adds	r3, r7, r3
    52e6:	781b      	ldrb	r3, [r3, #0]
    52e8:	2b00      	cmp	r3, #0
    52ea:	d0e4      	beq.n	52b6 <_get_sercom_index+0x22>
		}
	}

	ASSERT(false);
    52ec:	4a06      	ldr	r2, [pc, #24]	; (5308 <_get_sercom_index+0x74>)
    52ee:	4b07      	ldr	r3, [pc, #28]	; (530c <_get_sercom_index+0x78>)
    52f0:	0019      	movs	r1, r3
    52f2:	2000      	movs	r0, #0
    52f4:	f7ff f814 	bl	4320 <assert>
	return 0;
    52f8:	2300      	movs	r3, #0
}
    52fa:	0018      	movs	r0, r3
    52fc:	46bd      	mov	sp, r7
    52fe:	b005      	add	sp, #20
    5300:	bd90      	pop	{r4, r7, pc}
    5302:	46c0      	nop			; (mov r8, r8)
    5304:	20000000 	.word	0x20000000
    5308:	0000022a 	.word	0x0000022a
    530c:	00008b30 	.word	0x00008b30

00005310 <_usart_init>:
 * \param[in] hw The pointer to hardware instance
 *
 * \return The status of initialization
 */
static int32_t _usart_init(void *const hw)
{
    5310:	b590      	push	{r4, r7, lr}
    5312:	b085      	sub	sp, #20
    5314:	af00      	add	r7, sp, #0
    5316:	6078      	str	r0, [r7, #4]
	uint8_t i = _get_sercom_index(hw);
    5318:	230f      	movs	r3, #15
    531a:	18fc      	adds	r4, r7, r3
    531c:	687b      	ldr	r3, [r7, #4]
    531e:	0018      	movs	r0, r3
    5320:	f7ff ffb8 	bl	5294 <_get_sercom_index>
    5324:	0003      	movs	r3, r0
    5326:	7023      	strb	r3, [r4, #0]

	hri_sercomusart_wait_for_sync(hw);
    5328:	687b      	ldr	r3, [r7, #4]
    532a:	0018      	movs	r0, r3
    532c:	f7ff fc86 	bl	4c3c <hri_sercomusart_wait_for_sync>
	if (hri_sercomusart_get_CTRLA_reg(hw, SERCOM_USART_CTRLA_ENABLE)) {
    5330:	687b      	ldr	r3, [r7, #4]
    5332:	2102      	movs	r1, #2
    5334:	0018      	movs	r0, r3
    5336:	f7ff fda1 	bl	4e7c <hri_sercomusart_get_CTRLA_reg>
    533a:	1e03      	subs	r3, r0, #0
    533c:	d008      	beq.n	5350 <_usart_init+0x40>
		hri_sercomusart_write_CTRLA_reg(hw, 0);
    533e:	687b      	ldr	r3, [r7, #4]
    5340:	2100      	movs	r1, #0
    5342:	0018      	movs	r0, r3
    5344:	f7ff fdaf 	bl	4ea6 <hri_sercomusart_write_CTRLA_reg>
		hri_sercomusart_wait_for_sync(hw);
    5348:	687b      	ldr	r3, [r7, #4]
    534a:	0018      	movs	r0, r3
    534c:	f7ff fc76 	bl	4c3c <hri_sercomusart_wait_for_sync>
	}
	hri_sercomusart_write_CTRLA_reg(hw, SERCOM_USART_CTRLA_SWRST);
    5350:	687b      	ldr	r3, [r7, #4]
    5352:	2101      	movs	r1, #1
    5354:	0018      	movs	r0, r3
    5356:	f7ff fda6 	bl	4ea6 <hri_sercomusart_write_CTRLA_reg>
	hri_sercomusart_wait_for_sync(hw);
    535a:	687b      	ldr	r3, [r7, #4]
    535c:	0018      	movs	r0, r3
    535e:	f7ff fc6d 	bl	4c3c <hri_sercomusart_wait_for_sync>

	hri_sercomusart_write_CTRLA_reg(hw, _usarts[i].ctrl_a);
    5362:	230f      	movs	r3, #15
    5364:	18fb      	adds	r3, r7, r3
    5366:	781b      	ldrb	r3, [r3, #0]
    5368:	4a1a      	ldr	r2, [pc, #104]	; (53d4 <_usart_init+0xc4>)
    536a:	011b      	lsls	r3, r3, #4
    536c:	18d3      	adds	r3, r2, r3
    536e:	3304      	adds	r3, #4
    5370:	681a      	ldr	r2, [r3, #0]
    5372:	687b      	ldr	r3, [r7, #4]
    5374:	0011      	movs	r1, r2
    5376:	0018      	movs	r0, r3
    5378:	f7ff fd95 	bl	4ea6 <hri_sercomusart_write_CTRLA_reg>
	hri_sercomusart_write_CTRLB_reg(hw, _usarts[i].ctrl_b);
    537c:	230f      	movs	r3, #15
    537e:	18fb      	adds	r3, r7, r3
    5380:	781b      	ldrb	r3, [r3, #0]
    5382:	4a14      	ldr	r2, [pc, #80]	; (53d4 <_usart_init+0xc4>)
    5384:	011b      	lsls	r3, r3, #4
    5386:	18d3      	adds	r3, r2, r3
    5388:	3308      	adds	r3, #8
    538a:	681a      	ldr	r2, [r3, #0]
    538c:	687b      	ldr	r3, [r7, #4]
    538e:	0011      	movs	r1, r2
    5390:	0018      	movs	r0, r3
    5392:	f7ff fe1a 	bl	4fca <hri_sercomusart_write_CTRLB_reg>
	hri_sercomusart_write_BAUD_reg(hw, _usarts[i].baud);
    5396:	230f      	movs	r3, #15
    5398:	18fb      	adds	r3, r7, r3
    539a:	781b      	ldrb	r3, [r3, #0]
    539c:	4a0d      	ldr	r2, [pc, #52]	; (53d4 <_usart_init+0xc4>)
    539e:	011b      	lsls	r3, r3, #4
    53a0:	18d3      	adds	r3, r2, r3
    53a2:	330c      	adds	r3, #12
    53a4:	881a      	ldrh	r2, [r3, #0]
    53a6:	687b      	ldr	r3, [r7, #4]
    53a8:	0011      	movs	r1, r2
    53aa:	0018      	movs	r0, r3
    53ac:	f7ff fe59 	bl	5062 <hri_sercomusart_write_BAUD_reg>
	hri_sercomusart_write_DBGCTRL_reg(hw, _usarts[i].debug_ctrl);
    53b0:	230f      	movs	r3, #15
    53b2:	18fb      	adds	r3, r7, r3
    53b4:	781b      	ldrb	r3, [r3, #0]
    53b6:	4a07      	ldr	r2, [pc, #28]	; (53d4 <_usart_init+0xc4>)
    53b8:	011b      	lsls	r3, r3, #4
    53ba:	18d3      	adds	r3, r2, r3
    53bc:	330e      	adds	r3, #14
    53be:	781a      	ldrb	r2, [r3, #0]
    53c0:	687b      	ldr	r3, [r7, #4]
    53c2:	0011      	movs	r1, r2
    53c4:	0018      	movs	r0, r3
    53c6:	f7ff fe1f 	bl	5008 <hri_sercomusart_write_DBGCTRL_reg>

	return ERR_NONE;
    53ca:	2300      	movs	r3, #0
}
    53cc:	0018      	movs	r0, r3
    53ce:	46bd      	mov	sp, r7
    53d0:	b005      	add	sp, #20
    53d2:	bd90      	pop	{r4, r7, pc}
    53d4:	20000000 	.word	0x20000000

000053d8 <_get_i2cm_index>:
 * \param[in] hw The pointer to hardware instance

 * \return The ordinal number of the given sercom hardware instance
 */
static uint8_t _get_i2cm_index(const void *const hw)
{
    53d8:	b590      	push	{r4, r7, lr}
    53da:	b085      	sub	sp, #20
    53dc:	af00      	add	r7, sp, #0
    53de:	6078      	str	r0, [r7, #4]
	uint8_t sercom_offset = _sercom_get_hardware_index(hw);
    53e0:	230e      	movs	r3, #14
    53e2:	18fc      	adds	r4, r7, r3
    53e4:	687b      	ldr	r3, [r7, #4]
    53e6:	0018      	movs	r0, r3
    53e8:	f7ff ff44 	bl	5274 <_sercom_get_hardware_index>
    53ec:	0003      	movs	r3, r0
    53ee:	7023      	strb	r3, [r4, #0]
	uint8_t i;

	for (i = 0; i < ARRAY_SIZE(_i2cms); i++) {
    53f0:	230f      	movs	r3, #15
    53f2:	18fb      	adds	r3, r7, r3
    53f4:	2200      	movs	r2, #0
    53f6:	701a      	strb	r2, [r3, #0]
    53f8:	e018      	b.n	542c <_get_i2cm_index+0x54>
		if (_i2cms[i].number == sercom_offset) {
    53fa:	230f      	movs	r3, #15
    53fc:	18fb      	adds	r3, r7, r3
    53fe:	781a      	ldrb	r2, [r3, #0]
    5400:	4912      	ldr	r1, [pc, #72]	; (544c <_get_i2cm_index+0x74>)
    5402:	0013      	movs	r3, r2
    5404:	005b      	lsls	r3, r3, #1
    5406:	189b      	adds	r3, r3, r2
    5408:	00db      	lsls	r3, r3, #3
    540a:	5c5b      	ldrb	r3, [r3, r1]
    540c:	220e      	movs	r2, #14
    540e:	18ba      	adds	r2, r7, r2
    5410:	7812      	ldrb	r2, [r2, #0]
    5412:	429a      	cmp	r2, r3
    5414:	d103      	bne.n	541e <_get_i2cm_index+0x46>
			return i;
    5416:	230f      	movs	r3, #15
    5418:	18fb      	adds	r3, r7, r3
    541a:	781b      	ldrb	r3, [r3, #0]
    541c:	e012      	b.n	5444 <_get_i2cm_index+0x6c>
	for (i = 0; i < ARRAY_SIZE(_i2cms); i++) {
    541e:	230f      	movs	r3, #15
    5420:	18fb      	adds	r3, r7, r3
    5422:	781a      	ldrb	r2, [r3, #0]
    5424:	230f      	movs	r3, #15
    5426:	18fb      	adds	r3, r7, r3
    5428:	3201      	adds	r2, #1
    542a:	701a      	strb	r2, [r3, #0]
    542c:	230f      	movs	r3, #15
    542e:	18fb      	adds	r3, r7, r3
    5430:	781b      	ldrb	r3, [r3, #0]
    5432:	2b00      	cmp	r3, #0
    5434:	d0e1      	beq.n	53fa <_get_i2cm_index+0x22>
		}
	}

	ASSERT(false);
    5436:	4a06      	ldr	r2, [pc, #24]	; (5450 <_get_i2cm_index+0x78>)
    5438:	4b06      	ldr	r3, [pc, #24]	; (5454 <_get_i2cm_index+0x7c>)
    543a:	0019      	movs	r1, r3
    543c:	2000      	movs	r0, #0
    543e:	f7fe ff6f 	bl	4320 <assert>
	return 0;
    5442:	2300      	movs	r3, #0
}
    5444:	0018      	movs	r0, r3
    5446:	46bd      	mov	sp, r7
    5448:	b005      	add	sp, #20
    544a:	bd90      	pop	{r4, r7, pc}
    544c:	20000010 	.word	0x20000010
    5450:	00000366 	.word	0x00000366
    5454:	00008b30 	.word	0x00008b30

00005458 <_sercom_i2c_send_stop>:

static inline void _sercom_i2c_send_stop(void *const hw)
{
    5458:	b580      	push	{r7, lr}
    545a:	b082      	sub	sp, #8
    545c:	af00      	add	r7, sp, #0
    545e:	6078      	str	r0, [r7, #4]
	hri_sercomi2cm_set_CTRLB_CMD_bf(hw, CMD_STOP);
    5460:	687b      	ldr	r3, [r7, #4]
    5462:	2103      	movs	r1, #3
    5464:	0018      	movs	r0, r3
    5466:	f7ff fd7d 	bl	4f64 <hri_sercomi2cm_set_CTRLB_CMD_bf>
}
    546a:	46c0      	nop			; (mov r8, r8)
    546c:	46bd      	mov	sp, r7
    546e:	b002      	add	sp, #8
    5470:	bd80      	pop	{r7, pc}
	...

00005474 <_sercom_i2c_sync_analyse_flags>:

/**
 * \brief SERCOM I2CM analyze hardware status and transfer next byte
 */
static inline int32_t _sercom_i2c_sync_analyse_flags(void *const hw, uint32_t flags, struct _i2c_m_msg *const msg)
{
    5474:	b590      	push	{r4, r7, lr}
    5476:	b087      	sub	sp, #28
    5478:	af00      	add	r7, sp, #0
    547a:	60f8      	str	r0, [r7, #12]
    547c:	60b9      	str	r1, [r7, #8]
    547e:	607a      	str	r2, [r7, #4]
	uint16_t status = hri_sercomi2cm_read_STATUS_reg(hw);
    5480:	2316      	movs	r3, #22
    5482:	18fc      	adds	r4, r7, r3
    5484:	68fb      	ldr	r3, [r7, #12]
    5486:	0018      	movs	r0, r3
    5488:	f7ff fe7b 	bl	5182 <hri_sercomi2cm_read_STATUS_reg>
    548c:	0003      	movs	r3, r0
    548e:	8023      	strh	r3, [r4, #0]

	if (flags & MB_FLAG) {
    5490:	68bb      	ldr	r3, [r7, #8]
    5492:	2201      	movs	r2, #1
    5494:	4013      	ands	r3, r2
    5496:	d100      	bne.n	549a <_sercom_i2c_sync_analyse_flags+0x26>
    5498:	e079      	b.n	558e <_sercom_i2c_sync_analyse_flags+0x11a>
		/* tx error */
		if (status & SERCOM_I2CM_STATUS_ARBLOST) {
    549a:	2316      	movs	r3, #22
    549c:	18fb      	adds	r3, r7, r3
    549e:	881b      	ldrh	r3, [r3, #0]
    54a0:	2202      	movs	r2, #2
    54a2:	4013      	ands	r3, r2
    54a4:	d020      	beq.n	54e8 <_sercom_i2c_sync_analyse_flags+0x74>
			hri_sercomi2cm_clear_interrupt_MB_bit(hw);
    54a6:	68fb      	ldr	r3, [r7, #12]
    54a8:	0018      	movs	r0, r3
    54aa:	f7ff fbd7 	bl	4c5c <hri_sercomi2cm_clear_interrupt_MB_bit>
			msg->flags |= I2C_M_FAIL;
    54ae:	687b      	ldr	r3, [r7, #4]
    54b0:	885b      	ldrh	r3, [r3, #2]
    54b2:	b29b      	uxth	r3, r3
    54b4:	2280      	movs	r2, #128	; 0x80
    54b6:	0152      	lsls	r2, r2, #5
    54b8:	4313      	orrs	r3, r2
    54ba:	b29a      	uxth	r2, r3
    54bc:	687b      	ldr	r3, [r7, #4]
    54be:	805a      	strh	r2, [r3, #2]
			msg->flags &= ~I2C_M_BUSY;
    54c0:	687b      	ldr	r3, [r7, #4]
    54c2:	885b      	ldrh	r3, [r3, #2]
    54c4:	b29b      	uxth	r3, r3
    54c6:	4a5a      	ldr	r2, [pc, #360]	; (5630 <_sercom_i2c_sync_analyse_flags+0x1bc>)
    54c8:	4013      	ands	r3, r2
    54ca:	b29a      	uxth	r2, r3
    54cc:	687b      	ldr	r3, [r7, #4]
    54ce:	805a      	strh	r2, [r3, #2]

			if (status & SERCOM_I2CM_STATUS_BUSERR) {
    54d0:	2316      	movs	r3, #22
    54d2:	18fb      	adds	r3, r7, r3
    54d4:	881b      	ldrh	r3, [r3, #0]
    54d6:	2201      	movs	r2, #1
    54d8:	4013      	ands	r3, r2
    54da:	d002      	beq.n	54e2 <_sercom_i2c_sync_analyse_flags+0x6e>
				return I2C_ERR_BUS;
    54dc:	2305      	movs	r3, #5
    54de:	425b      	negs	r3, r3
    54e0:	e0a2      	b.n	5628 <_sercom_i2c_sync_analyse_flags+0x1b4>
			}

			return I2C_ERR_BAD_ADDRESS;
    54e2:	2304      	movs	r3, #4
    54e4:	425b      	negs	r3, r3
    54e6:	e09f      	b.n	5628 <_sercom_i2c_sync_analyse_flags+0x1b4>
		} else {
			if (status & SERCOM_I2CM_STATUS_RXNACK) {
    54e8:	2316      	movs	r3, #22
    54ea:	18fb      	adds	r3, r7, r3
    54ec:	881b      	ldrh	r3, [r3, #0]
    54ee:	2204      	movs	r2, #4
    54f0:	4013      	ands	r3, r2
    54f2:	d021      	beq.n	5538 <_sercom_i2c_sync_analyse_flags+0xc4>

				/* Slave rejects to receive more data */
				if (msg->len > 0) {
    54f4:	687b      	ldr	r3, [r7, #4]
    54f6:	685b      	ldr	r3, [r3, #4]
    54f8:	2b00      	cmp	r3, #0
    54fa:	dd08      	ble.n	550e <_sercom_i2c_sync_analyse_flags+0x9a>
					msg->flags |= I2C_M_FAIL;
    54fc:	687b      	ldr	r3, [r7, #4]
    54fe:	885b      	ldrh	r3, [r3, #2]
    5500:	b29b      	uxth	r3, r3
    5502:	2280      	movs	r2, #128	; 0x80
    5504:	0152      	lsls	r2, r2, #5
    5506:	4313      	orrs	r3, r2
    5508:	b29a      	uxth	r2, r3
    550a:	687b      	ldr	r3, [r7, #4]
    550c:	805a      	strh	r2, [r3, #2]
				}

				if (msg->flags & I2C_M_STOP) {
    550e:	687b      	ldr	r3, [r7, #4]
    5510:	885b      	ldrh	r3, [r3, #2]
    5512:	b29b      	uxth	r3, r3
    5514:	b21b      	sxth	r3, r3
    5516:	2b00      	cmp	r3, #0
    5518:	da03      	bge.n	5522 <_sercom_i2c_sync_analyse_flags+0xae>
					_sercom_i2c_send_stop(hw);
    551a:	68fb      	ldr	r3, [r7, #12]
    551c:	0018      	movs	r0, r3
    551e:	f7ff ff9b 	bl	5458 <_sercom_i2c_send_stop>
				}

				msg->flags &= ~I2C_M_BUSY;
    5522:	687b      	ldr	r3, [r7, #4]
    5524:	885b      	ldrh	r3, [r3, #2]
    5526:	b29b      	uxth	r3, r3
    5528:	4a41      	ldr	r2, [pc, #260]	; (5630 <_sercom_i2c_sync_analyse_flags+0x1bc>)
    552a:	4013      	ands	r3, r2
    552c:	b29a      	uxth	r2, r3
    552e:	687b      	ldr	r3, [r7, #4]
    5530:	805a      	strh	r2, [r3, #2]

				return I2C_NACK;
    5532:	2302      	movs	r3, #2
    5534:	425b      	negs	r3, r3
    5536:	e077      	b.n	5628 <_sercom_i2c_sync_analyse_flags+0x1b4>
			}

			if (msg->len == 0) {
    5538:	687b      	ldr	r3, [r7, #4]
    553a:	685b      	ldr	r3, [r3, #4]
    553c:	2b00      	cmp	r3, #0
    553e:	d112      	bne.n	5566 <_sercom_i2c_sync_analyse_flags+0xf2>
				if (msg->flags & I2C_M_STOP) {
    5540:	687b      	ldr	r3, [r7, #4]
    5542:	885b      	ldrh	r3, [r3, #2]
    5544:	b29b      	uxth	r3, r3
    5546:	b21b      	sxth	r3, r3
    5548:	2b00      	cmp	r3, #0
    554a:	da03      	bge.n	5554 <_sercom_i2c_sync_analyse_flags+0xe0>
					_sercom_i2c_send_stop(hw);
    554c:	68fb      	ldr	r3, [r7, #12]
    554e:	0018      	movs	r0, r3
    5550:	f7ff ff82 	bl	5458 <_sercom_i2c_send_stop>
				}

				msg->flags &= ~I2C_M_BUSY;
    5554:	687b      	ldr	r3, [r7, #4]
    5556:	885b      	ldrh	r3, [r3, #2]
    5558:	b29b      	uxth	r3, r3
    555a:	4a35      	ldr	r2, [pc, #212]	; (5630 <_sercom_i2c_sync_analyse_flags+0x1bc>)
    555c:	4013      	ands	r3, r2
    555e:	b29a      	uxth	r2, r3
    5560:	687b      	ldr	r3, [r7, #4]
    5562:	805a      	strh	r2, [r3, #2]
    5564:	e011      	b.n	558a <_sercom_i2c_sync_analyse_flags+0x116>
			} else {
				hri_sercomi2cm_write_DATA_reg(hw, *msg->buffer);
    5566:	687b      	ldr	r3, [r7, #4]
    5568:	689b      	ldr	r3, [r3, #8]
    556a:	781a      	ldrb	r2, [r3, #0]
    556c:	68fb      	ldr	r3, [r7, #12]
    556e:	0011      	movs	r1, r2
    5570:	0018      	movs	r0, r3
    5572:	f7ff fda4 	bl	50be <hri_sercomi2cm_write_DATA_reg>
				msg->buffer++;
    5576:	687b      	ldr	r3, [r7, #4]
    5578:	689b      	ldr	r3, [r3, #8]
    557a:	1c5a      	adds	r2, r3, #1
    557c:	687b      	ldr	r3, [r7, #4]
    557e:	609a      	str	r2, [r3, #8]
				msg->len--;
    5580:	687b      	ldr	r3, [r7, #4]
    5582:	685b      	ldr	r3, [r3, #4]
    5584:	1e5a      	subs	r2, r3, #1
    5586:	687b      	ldr	r3, [r7, #4]
    5588:	605a      	str	r2, [r3, #4]
			}

			return I2C_OK;
    558a:	2300      	movs	r3, #0
    558c:	e04c      	b.n	5628 <_sercom_i2c_sync_analyse_flags+0x1b4>
		}
	} else if (flags & SB_FLAG) {
    558e:	68bb      	ldr	r3, [r7, #8]
    5590:	2202      	movs	r2, #2
    5592:	4013      	ands	r3, r2
    5594:	d047      	beq.n	5626 <_sercom_i2c_sync_analyse_flags+0x1b2>
		if ((msg->len) && !(status & SERCOM_I2CM_STATUS_RXNACK)) {
    5596:	687b      	ldr	r3, [r7, #4]
    5598:	685b      	ldr	r3, [r3, #4]
    559a:	2b00      	cmp	r3, #0
    559c:	d03c      	beq.n	5618 <_sercom_i2c_sync_analyse_flags+0x1a4>
    559e:	2316      	movs	r3, #22
    55a0:	18fb      	adds	r3, r7, r3
    55a2:	881b      	ldrh	r3, [r3, #0]
    55a4:	2204      	movs	r2, #4
    55a6:	4013      	ands	r3, r2
    55a8:	d136      	bne.n	5618 <_sercom_i2c_sync_analyse_flags+0x1a4>
			msg->len--;
    55aa:	687b      	ldr	r3, [r7, #4]
    55ac:	685b      	ldr	r3, [r3, #4]
    55ae:	1e5a      	subs	r2, r3, #1
    55b0:	687b      	ldr	r3, [r7, #4]
    55b2:	605a      	str	r2, [r3, #4]

			/* last byte, send nack */
			if (msg->len == 0) {
    55b4:	687b      	ldr	r3, [r7, #4]
    55b6:	685b      	ldr	r3, [r3, #4]
    55b8:	2b00      	cmp	r3, #0
    55ba:	d103      	bne.n	55c4 <_sercom_i2c_sync_analyse_flags+0x150>
				hri_sercomi2cm_set_CTRLB_ACKACT_bit(hw);
    55bc:	68fb      	ldr	r3, [r7, #12]
    55be:	0018      	movs	r0, r3
    55c0:	f7ff fca8 	bl	4f14 <hri_sercomi2cm_set_CTRLB_ACKACT_bit>
			}

			if (msg->len == 0) {
    55c4:	687b      	ldr	r3, [r7, #4]
    55c6:	685b      	ldr	r3, [r3, #4]
    55c8:	2b00      	cmp	r3, #0
    55ca:	d115      	bne.n	55f8 <_sercom_i2c_sync_analyse_flags+0x184>
				if (msg->flags & I2C_M_STOP) {
    55cc:	687b      	ldr	r3, [r7, #4]
    55ce:	885b      	ldrh	r3, [r3, #2]
    55d0:	b29b      	uxth	r3, r3
    55d2:	b21b      	sxth	r3, r3
    55d4:	2b00      	cmp	r3, #0
    55d6:	da07      	bge.n	55e8 <_sercom_i2c_sync_analyse_flags+0x174>
					hri_sercomi2cm_clear_CTRLB_SMEN_bit(hw);
    55d8:	68fb      	ldr	r3, [r7, #12]
    55da:	0018      	movs	r0, r3
    55dc:	f7ff fc86 	bl	4eec <hri_sercomi2cm_clear_CTRLB_SMEN_bit>
					_sercom_i2c_send_stop(hw);
    55e0:	68fb      	ldr	r3, [r7, #12]
    55e2:	0018      	movs	r0, r3
    55e4:	f7ff ff38 	bl	5458 <_sercom_i2c_send_stop>
				}

				msg->flags &= ~I2C_M_BUSY;
    55e8:	687b      	ldr	r3, [r7, #4]
    55ea:	885b      	ldrh	r3, [r3, #2]
    55ec:	b29b      	uxth	r3, r3
    55ee:	4a10      	ldr	r2, [pc, #64]	; (5630 <_sercom_i2c_sync_analyse_flags+0x1bc>)
    55f0:	4013      	ands	r3, r2
    55f2:	b29a      	uxth	r2, r3
    55f4:	687b      	ldr	r3, [r7, #4]
    55f6:	805a      	strh	r2, [r3, #2]

			/* Accessing DATA.DATA auto-triggers I2C bus operations.
			 * The operation performed depends on the state of
			 * CTRLB.ACKACT, CTRLB.SMEN
			 **/
			*msg->buffer++ = hri_sercomi2cm_read_DATA_reg(hw);
    55f8:	687b      	ldr	r3, [r7, #4]
    55fa:	689c      	ldr	r4, [r3, #8]
    55fc:	1c62      	adds	r2, r4, #1
    55fe:	687b      	ldr	r3, [r7, #4]
    5600:	609a      	str	r2, [r3, #8]
    5602:	68fb      	ldr	r3, [r7, #12]
    5604:	0018      	movs	r0, r3
    5606:	f7ff fd69 	bl	50dc <hri_sercomi2cm_read_DATA_reg>
    560a:	0003      	movs	r3, r0
    560c:	7023      	strb	r3, [r4, #0]
		} else {
			hri_sercomi2cm_clear_interrupt_SB_bit(hw);
			return I2C_NACK;
		}

		hri_sercomi2cm_clear_interrupt_SB_bit(hw);
    560e:	68fb      	ldr	r3, [r7, #12]
    5610:	0018      	movs	r0, r3
    5612:	f7ff fb2e 	bl	4c72 <hri_sercomi2cm_clear_interrupt_SB_bit>
    5616:	e006      	b.n	5626 <_sercom_i2c_sync_analyse_flags+0x1b2>
			hri_sercomi2cm_clear_interrupt_SB_bit(hw);
    5618:	68fb      	ldr	r3, [r7, #12]
    561a:	0018      	movs	r0, r3
    561c:	f7ff fb29 	bl	4c72 <hri_sercomi2cm_clear_interrupt_SB_bit>
			return I2C_NACK;
    5620:	2302      	movs	r3, #2
    5622:	425b      	negs	r3, r3
    5624:	e000      	b.n	5628 <_sercom_i2c_sync_analyse_flags+0x1b4>
	}

	return I2C_OK;
    5626:	2300      	movs	r3, #0
}
    5628:	0018      	movs	r0, r3
    562a:	46bd      	mov	sp, r7
    562c:	b007      	add	sp, #28
    562e:	bd90      	pop	{r4, r7, pc}
    5630:	fffffeff 	.word	0xfffffeff

00005634 <_i2c_m_sync_init>:
 * \brief Initialize sercom i2c module to use in sync mode
 *
 * \param[in] i2c_dev The pointer to i2c device
 */
int32_t _i2c_m_sync_init(struct _i2c_m_sync_device *const i2c_dev, void *const hw)
{
    5634:	b590      	push	{r4, r7, lr}
    5636:	b085      	sub	sp, #20
    5638:	af00      	add	r7, sp, #0
    563a:	6078      	str	r0, [r7, #4]
    563c:	6039      	str	r1, [r7, #0]
	uint8_t i = _get_i2cm_index(hw);
    563e:	230f      	movs	r3, #15
    5640:	18fc      	adds	r4, r7, r3
    5642:	683b      	ldr	r3, [r7, #0]
    5644:	0018      	movs	r0, r3
    5646:	f7ff fec7 	bl	53d8 <_get_i2cm_index>
    564a:	0003      	movs	r3, r0
    564c:	7023      	strb	r3, [r4, #0]

	ASSERT(i2c_dev);
    564e:	687b      	ldr	r3, [r7, #4]
    5650:	1e5a      	subs	r2, r3, #1
    5652:	4193      	sbcs	r3, r2
    5654:	b2db      	uxtb	r3, r3
    5656:	4a35      	ldr	r2, [pc, #212]	; (572c <_i2c_m_sync_init+0xf8>)
    5658:	4935      	ldr	r1, [pc, #212]	; (5730 <_i2c_m_sync_init+0xfc>)
    565a:	0018      	movs	r0, r3
    565c:	f7fe fe60 	bl	4320 <assert>

	i2c_dev->hw = hw;
    5660:	687b      	ldr	r3, [r7, #4]
    5662:	683a      	ldr	r2, [r7, #0]
    5664:	611a      	str	r2, [r3, #16]

	hri_sercomi2cm_wait_for_sync(hw);
    5666:	683b      	ldr	r3, [r7, #0]
    5668:	0018      	movs	r0, r3
    566a:	f7ff fab7 	bl	4bdc <hri_sercomi2cm_wait_for_sync>
	if (hri_sercomi2cm_get_CTRLA_reg(hw, SERCOM_I2CM_CTRLA_ENABLE)) {
    566e:	683b      	ldr	r3, [r7, #0]
    5670:	2102      	movs	r1, #2
    5672:	0018      	movs	r0, r3
    5674:	f7ff fb8e 	bl	4d94 <hri_sercomi2cm_get_CTRLA_reg>
    5678:	1e03      	subs	r3, r0, #0
    567a:	d008      	beq.n	568e <_i2c_m_sync_init+0x5a>
		hri_sercomi2cm_write_CTRLA_reg(hw, 0);
    567c:	683b      	ldr	r3, [r7, #0]
    567e:	2100      	movs	r1, #0
    5680:	0018      	movs	r0, r3
    5682:	f7ff fb9c 	bl	4dbe <hri_sercomi2cm_write_CTRLA_reg>
		hri_sercomi2cm_wait_for_sync(hw);
    5686:	683b      	ldr	r3, [r7, #0]
    5688:	0018      	movs	r0, r3
    568a:	f7ff faa7 	bl	4bdc <hri_sercomi2cm_wait_for_sync>
	}
	hri_sercomi2cm_write_CTRLA_reg(hw, SERCOM_I2CM_CTRLA_SWRST);
    568e:	683b      	ldr	r3, [r7, #0]
    5690:	2101      	movs	r1, #1
    5692:	0018      	movs	r0, r3
    5694:	f7ff fb93 	bl	4dbe <hri_sercomi2cm_write_CTRLA_reg>
	hri_sercomi2cm_wait_for_sync(hw);
    5698:	683b      	ldr	r3, [r7, #0]
    569a:	0018      	movs	r0, r3
    569c:	f7ff fa9e 	bl	4bdc <hri_sercomi2cm_wait_for_sync>

	hri_sercomi2cm_write_CTRLA_reg(hw, _i2cms[i].ctrl_a & ~SERCOM_I2CM_CTRLA_ENABLE);
    56a0:	230f      	movs	r3, #15
    56a2:	18fb      	adds	r3, r7, r3
    56a4:	781a      	ldrb	r2, [r3, #0]
    56a6:	4923      	ldr	r1, [pc, #140]	; (5734 <_i2c_m_sync_init+0x100>)
    56a8:	0013      	movs	r3, r2
    56aa:	005b      	lsls	r3, r3, #1
    56ac:	189b      	adds	r3, r3, r2
    56ae:	00db      	lsls	r3, r3, #3
    56b0:	18cb      	adds	r3, r1, r3
    56b2:	3304      	adds	r3, #4
    56b4:	681b      	ldr	r3, [r3, #0]
    56b6:	2202      	movs	r2, #2
    56b8:	4393      	bics	r3, r2
    56ba:	001a      	movs	r2, r3
    56bc:	683b      	ldr	r3, [r7, #0]
    56be:	0011      	movs	r1, r2
    56c0:	0018      	movs	r0, r3
    56c2:	f7ff fb7c 	bl	4dbe <hri_sercomi2cm_write_CTRLA_reg>
	hri_sercomi2cm_write_CTRLB_reg(hw, _i2cms[i].ctrl_b);
    56c6:	230f      	movs	r3, #15
    56c8:	18fb      	adds	r3, r7, r3
    56ca:	781a      	ldrb	r2, [r3, #0]
    56cc:	4919      	ldr	r1, [pc, #100]	; (5734 <_i2c_m_sync_init+0x100>)
    56ce:	0013      	movs	r3, r2
    56d0:	005b      	lsls	r3, r3, #1
    56d2:	189b      	adds	r3, r3, r2
    56d4:	00db      	lsls	r3, r3, #3
    56d6:	18cb      	adds	r3, r1, r3
    56d8:	3308      	adds	r3, #8
    56da:	681a      	ldr	r2, [r3, #0]
    56dc:	683b      	ldr	r3, [r7, #0]
    56de:	0011      	movs	r1, r2
    56e0:	0018      	movs	r0, r3
    56e2:	f7ff fc56 	bl	4f92 <hri_sercomi2cm_write_CTRLB_reg>
	hri_sercomi2cm_write_BAUD_reg(hw, _i2cms[i].baud);
    56e6:	230f      	movs	r3, #15
    56e8:	18fb      	adds	r3, r7, r3
    56ea:	781a      	ldrb	r2, [r3, #0]
    56ec:	4911      	ldr	r1, [pc, #68]	; (5734 <_i2c_m_sync_init+0x100>)
    56ee:	0013      	movs	r3, r2
    56f0:	005b      	lsls	r3, r3, #1
    56f2:	189b      	adds	r3, r3, r2
    56f4:	00db      	lsls	r3, r3, #3
    56f6:	18cb      	adds	r3, r1, r3
    56f8:	330c      	adds	r3, #12
    56fa:	881a      	ldrh	r2, [r3, #0]
    56fc:	683b      	ldr	r3, [r7, #0]
    56fe:	0011      	movs	r1, r2
    5700:	0018      	movs	r0, r3
    5702:	f7ff fc90 	bl	5026 <hri_sercomi2cm_write_BAUD_reg>

	i2c_dev->service.trise = _i2cms[i].trise;
    5706:	230f      	movs	r3, #15
    5708:	18fb      	adds	r3, r7, r3
    570a:	781a      	ldrb	r2, [r3, #0]
    570c:	4909      	ldr	r1, [pc, #36]	; (5734 <_i2c_m_sync_init+0x100>)
    570e:	0013      	movs	r3, r2
    5710:	005b      	lsls	r3, r3, #1
    5712:	189b      	adds	r3, r3, r2
    5714:	00db      	lsls	r3, r3, #3
    5716:	18cb      	adds	r3, r1, r3
    5718:	3310      	adds	r3, #16
    571a:	881a      	ldrh	r2, [r3, #0]
    571c:	687b      	ldr	r3, [r7, #4]
    571e:	81da      	strh	r2, [r3, #14]

	return ERR_NONE;
    5720:	2300      	movs	r3, #0
}
    5722:	0018      	movs	r0, r3
    5724:	46bd      	mov	sp, r7
    5726:	b005      	add	sp, #20
    5728:	bd90      	pop	{r4, r7, pc}
    572a:	46c0      	nop			; (mov r8, r8)
    572c:	000004d7 	.word	0x000004d7
    5730:	00008b30 	.word	0x00008b30
    5734:	20000010 	.word	0x20000010

00005738 <_i2c_m_sync_enable>:
 * \brief Enable the i2c master module
 *
 * \param[in] i2c_dev The pointer to i2c device
 */
int32_t _i2c_m_sync_enable(struct _i2c_m_sync_device *const i2c_dev)
{
    5738:	b580      	push	{r7, lr}
    573a:	b086      	sub	sp, #24
    573c:	af00      	add	r7, sp, #0
    573e:	6078      	str	r0, [r7, #4]
	int   timeout         = 65535;
    5740:	4b20      	ldr	r3, [pc, #128]	; (57c4 <_i2c_m_sync_enable+0x8c>)
    5742:	617b      	str	r3, [r7, #20]
	int   timeout_attempt = 4;
    5744:	2304      	movs	r3, #4
    5746:	613b      	str	r3, [r7, #16]
	void *hw              = i2c_dev->hw;
    5748:	687b      	ldr	r3, [r7, #4]
    574a:	691b      	ldr	r3, [r3, #16]
    574c:	60fb      	str	r3, [r7, #12]

	ASSERT(i2c_dev);
    574e:	687b      	ldr	r3, [r7, #4]
    5750:	1e5a      	subs	r2, r3, #1
    5752:	4193      	sbcs	r3, r2
    5754:	b2d8      	uxtb	r0, r3
    5756:	23a1      	movs	r3, #161	; 0xa1
    5758:	00da      	lsls	r2, r3, #3
    575a:	4b1b      	ldr	r3, [pc, #108]	; (57c8 <_i2c_m_sync_enable+0x90>)
    575c:	0019      	movs	r1, r3
    575e:	f7fe fddf 	bl	4320 <assert>
	ASSERT(i2c_dev->hw);
    5762:	687b      	ldr	r3, [r7, #4]
    5764:	691b      	ldr	r3, [r3, #16]
    5766:	1e5a      	subs	r2, r3, #1
    5768:	4193      	sbcs	r3, r2
    576a:	b2db      	uxtb	r3, r3
    576c:	4a17      	ldr	r2, [pc, #92]	; (57cc <_i2c_m_sync_enable+0x94>)
    576e:	4916      	ldr	r1, [pc, #88]	; (57c8 <_i2c_m_sync_enable+0x90>)
    5770:	0018      	movs	r0, r3
    5772:	f7fe fdd5 	bl	4320 <assert>

	hri_sercomi2cm_set_CTRLA_ENABLE_bit(hw);
    5776:	68fb      	ldr	r3, [r7, #12]
    5778:	0018      	movs	r0, r3
    577a:	f7ff faf9 	bl	4d70 <hri_sercomi2cm_set_CTRLA_ENABLE_bit>

	while (hri_sercomi2cm_read_STATUS_BUSSTATE_bf(hw) != I2C_IDLE) {
    577e:	e014      	b.n	57aa <_i2c_m_sync_enable+0x72>
		timeout--;
    5780:	697b      	ldr	r3, [r7, #20]
    5782:	3b01      	subs	r3, #1
    5784:	617b      	str	r3, [r7, #20]

		if (timeout <= 0) {
    5786:	697b      	ldr	r3, [r7, #20]
    5788:	2b00      	cmp	r3, #0
    578a:	dc0e      	bgt.n	57aa <_i2c_m_sync_enable+0x72>
			if (--timeout_attempt)
    578c:	693b      	ldr	r3, [r7, #16]
    578e:	3b01      	subs	r3, #1
    5790:	613b      	str	r3, [r7, #16]
    5792:	693b      	ldr	r3, [r7, #16]
    5794:	2b00      	cmp	r3, #0
    5796:	d005      	beq.n	57a4 <_i2c_m_sync_enable+0x6c>
				timeout = 65535;
    5798:	4b0a      	ldr	r3, [pc, #40]	; (57c4 <_i2c_m_sync_enable+0x8c>)
    579a:	617b      	str	r3, [r7, #20]
			else
				return I2C_ERR_BUSY;
			((Sercom *)hw)->I2CM.STATUS.reg = SERCOM_I2CM_STATUS_BUSSTATE(I2C_IDLE);
    579c:	68fb      	ldr	r3, [r7, #12]
    579e:	2210      	movs	r2, #16
    57a0:	821a      	strh	r2, [r3, #16]
    57a2:	e002      	b.n	57aa <_i2c_m_sync_enable+0x72>
				return I2C_ERR_BUSY;
    57a4:	2306      	movs	r3, #6
    57a6:	425b      	negs	r3, r3
    57a8:	e007      	b.n	57ba <_i2c_m_sync_enable+0x82>
	while (hri_sercomi2cm_read_STATUS_BUSSTATE_bf(hw) != I2C_IDLE) {
    57aa:	68fb      	ldr	r3, [r7, #12]
    57ac:	0018      	movs	r0, r3
    57ae:	f7ff fcd4 	bl	515a <hri_sercomi2cm_read_STATUS_BUSSTATE_bf>
    57b2:	0003      	movs	r3, r0
    57b4:	2b01      	cmp	r3, #1
    57b6:	d1e3      	bne.n	5780 <_i2c_m_sync_enable+0x48>
		}
	}

	return ERR_NONE;
    57b8:	2300      	movs	r3, #0
}
    57ba:	0018      	movs	r0, r3
    57bc:	46bd      	mov	sp, r7
    57be:	b006      	add	sp, #24
    57c0:	bd80      	pop	{r7, pc}
    57c2:	46c0      	nop			; (mov r8, r8)
    57c4:	0000ffff 	.word	0x0000ffff
    57c8:	00008b30 	.word	0x00008b30
    57cc:	00000509 	.word	0x00000509

000057d0 <_sercom_i2c_sync_wait_bus>:
 * \return Bus response status.
 * \retval 0 Bus response status OK
 * \retval <0 Bus response fail
 */
inline static int32_t _sercom_i2c_sync_wait_bus(struct _i2c_m_sync_device *const i2c_dev, uint32_t *flags)
{
    57d0:	b580      	push	{r7, lr}
    57d2:	b084      	sub	sp, #16
    57d4:	af00      	add	r7, sp, #0
    57d6:	6078      	str	r0, [r7, #4]
    57d8:	6039      	str	r1, [r7, #0]
	uint32_t timeout = 65535;
    57da:	4b12      	ldr	r3, [pc, #72]	; (5824 <_sercom_i2c_sync_wait_bus+0x54>)
    57dc:	60fb      	str	r3, [r7, #12]
	void *   hw      = i2c_dev->hw;
    57de:	687b      	ldr	r3, [r7, #4]
    57e0:	691b      	ldr	r3, [r3, #16]
    57e2:	60bb      	str	r3, [r7, #8]

	do {
		*flags = hri_sercomi2cm_read_INTFLAG_reg(hw);
    57e4:	68bb      	ldr	r3, [r7, #8]
    57e6:	0018      	movs	r0, r3
    57e8:	f7ff fa4e 	bl	4c88 <hri_sercomi2cm_read_INTFLAG_reg>
    57ec:	0003      	movs	r3, r0
    57ee:	001a      	movs	r2, r3
    57f0:	683b      	ldr	r3, [r7, #0]
    57f2:	601a      	str	r2, [r3, #0]

		if (timeout-- == 0) {
    57f4:	68fb      	ldr	r3, [r7, #12]
    57f6:	1e5a      	subs	r2, r3, #1
    57f8:	60fa      	str	r2, [r7, #12]
    57fa:	2b00      	cmp	r3, #0
    57fc:	d102      	bne.n	5804 <_sercom_i2c_sync_wait_bus+0x34>
			return I2C_ERR_BUS;
    57fe:	2305      	movs	r3, #5
    5800:	425b      	negs	r3, r3
    5802:	e00a      	b.n	581a <_sercom_i2c_sync_wait_bus+0x4a>
		}
	} while (!(*flags & MB_FLAG) && !(*flags & SB_FLAG));
    5804:	683b      	ldr	r3, [r7, #0]
    5806:	681b      	ldr	r3, [r3, #0]
    5808:	2201      	movs	r2, #1
    580a:	4013      	ands	r3, r2
    580c:	d104      	bne.n	5818 <_sercom_i2c_sync_wait_bus+0x48>
    580e:	683b      	ldr	r3, [r7, #0]
    5810:	681b      	ldr	r3, [r3, #0]
    5812:	2202      	movs	r2, #2
    5814:	4013      	ands	r3, r2
    5816:	d0e5      	beq.n	57e4 <_sercom_i2c_sync_wait_bus+0x14>

	return I2C_OK;
    5818:	2300      	movs	r3, #0
}
    581a:	0018      	movs	r0, r3
    581c:	46bd      	mov	sp, r7
    581e:	b004      	add	sp, #16
    5820:	bd80      	pop	{r7, pc}
    5822:	46c0      	nop			; (mov r8, r8)
    5824:	0000ffff 	.word	0x0000ffff

00005828 <_sercom_i2c_sync_send_address>:
 * \brief Send the slave address to bus, which will start the transfer
 *
 * \param[in] i2c_dev The pointer to i2c device
 */
static int32_t _sercom_i2c_sync_send_address(struct _i2c_m_sync_device *const i2c_dev)
{
    5828:	b580      	push	{r7, lr}
    582a:	b086      	sub	sp, #24
    582c:	af00      	add	r7, sp, #0
    582e:	6078      	str	r0, [r7, #4]
	void *             hw  = i2c_dev->hw;
    5830:	687b      	ldr	r3, [r7, #4]
    5832:	691b      	ldr	r3, [r3, #16]
    5834:	617b      	str	r3, [r7, #20]
	struct _i2c_m_msg *msg = &i2c_dev->service.msg;
    5836:	687b      	ldr	r3, [r7, #4]
    5838:	613b      	str	r3, [r7, #16]
	uint32_t           flags;

	ASSERT(i2c_dev);
    583a:	687b      	ldr	r3, [r7, #4]
    583c:	1e5a      	subs	r2, r3, #1
    583e:	4193      	sbcs	r3, r2
    5840:	b2db      	uxtb	r3, r3
    5842:	4a18      	ldr	r2, [pc, #96]	; (58a4 <_sercom_i2c_sync_send_address+0x7c>)
    5844:	4918      	ldr	r1, [pc, #96]	; (58a8 <_sercom_i2c_sync_send_address+0x80>)
    5846:	0018      	movs	r0, r3
    5848:	f7fe fd6a 	bl	4320 <assert>

	hri_sercomi2cm_clear_CTRLB_ACKACT_bit(hw);
    584c:	697b      	ldr	r3, [r7, #20]
    584e:	0018      	movs	r0, r3
    5850:	f7ff fb74 	bl	4f3c <hri_sercomi2cm_clear_CTRLB_ACKACT_bit>

	hri_sercomi2cm_write_ADDR_reg(hw, ((msg->addr & SEVEN_ADDR_MASK) << 1) | (msg->flags & I2C_M_RD ? I2C_M_RD : 0x0));
    5854:	693b      	ldr	r3, [r7, #16]
    5856:	881b      	ldrh	r3, [r3, #0]
    5858:	005b      	lsls	r3, r3, #1
    585a:	b25a      	sxtb	r2, r3
    585c:	693b      	ldr	r3, [r7, #16]
    585e:	885b      	ldrh	r3, [r3, #2]
    5860:	b29b      	uxth	r3, r3
    5862:	0019      	movs	r1, r3
    5864:	2301      	movs	r3, #1
    5866:	400b      	ands	r3, r1
    5868:	1e59      	subs	r1, r3, #1
    586a:	418b      	sbcs	r3, r1
    586c:	b2db      	uxtb	r3, r3
    586e:	b25b      	sxtb	r3, r3
    5870:	4313      	orrs	r3, r2
    5872:	b25b      	sxtb	r3, r3
    5874:	b2da      	uxtb	r2, r3
    5876:	697b      	ldr	r3, [r7, #20]
    5878:	0011      	movs	r1, r2
    587a:	0018      	movs	r0, r3
    587c:	f7ff fc00 	bl	5080 <hri_sercomi2cm_write_ADDR_reg>

	_sercom_i2c_sync_wait_bus(i2c_dev, &flags);
    5880:	230c      	movs	r3, #12
    5882:	18fa      	adds	r2, r7, r3
    5884:	687b      	ldr	r3, [r7, #4]
    5886:	0011      	movs	r1, r2
    5888:	0018      	movs	r0, r3
    588a:	f7ff ffa1 	bl	57d0 <_sercom_i2c_sync_wait_bus>
	return _sercom_i2c_sync_analyse_flags(hw, flags, msg);
    588e:	68f9      	ldr	r1, [r7, #12]
    5890:	693a      	ldr	r2, [r7, #16]
    5892:	697b      	ldr	r3, [r7, #20]
    5894:	0018      	movs	r0, r3
    5896:	f7ff fded 	bl	5474 <_sercom_i2c_sync_analyse_flags>
    589a:	0003      	movs	r3, r0
}
    589c:	0018      	movs	r0, r3
    589e:	46bd      	mov	sp, r7
    58a0:	b006      	add	sp, #24
    58a2:	bd80      	pop	{r7, pc}
    58a4:	00000581 	.word	0x00000581
    58a8:	00008b30 	.word	0x00008b30

000058ac <_i2c_m_sync_transfer>:
 * \return Transfer status.
 * \retval 0 Transfer success
 * \retval <0 Transfer fail or partial fail, return the error code
 */
int32_t _i2c_m_sync_transfer(struct _i2c_m_sync_device *const i2c_dev, struct _i2c_m_msg *msg)
{
    58ac:	b590      	push	{r4, r7, lr}
    58ae:	b087      	sub	sp, #28
    58b0:	af00      	add	r7, sp, #0
    58b2:	6078      	str	r0, [r7, #4]
    58b4:	6039      	str	r1, [r7, #0]
	uint32_t flags;
	int      ret;
	void *   hw = i2c_dev->hw;
    58b6:	687b      	ldr	r3, [r7, #4]
    58b8:	691b      	ldr	r3, [r3, #16]
    58ba:	613b      	str	r3, [r7, #16]

	ASSERT(i2c_dev);
    58bc:	687b      	ldr	r3, [r7, #4]
    58be:	1e5a      	subs	r2, r3, #1
    58c0:	4193      	sbcs	r3, r2
    58c2:	b2db      	uxtb	r3, r3
    58c4:	4a3d      	ldr	r2, [pc, #244]	; (59bc <_i2c_m_sync_transfer+0x110>)
    58c6:	493e      	ldr	r1, [pc, #248]	; (59c0 <_i2c_m_sync_transfer+0x114>)
    58c8:	0018      	movs	r0, r3
    58ca:	f7fe fd29 	bl	4320 <assert>
	ASSERT(i2c_dev->hw);
    58ce:	687b      	ldr	r3, [r7, #4]
    58d0:	691b      	ldr	r3, [r3, #16]
    58d2:	1e5a      	subs	r2, r3, #1
    58d4:	4193      	sbcs	r3, r2
    58d6:	b2db      	uxtb	r3, r3
    58d8:	4a3a      	ldr	r2, [pc, #232]	; (59c4 <_i2c_m_sync_transfer+0x118>)
    58da:	4939      	ldr	r1, [pc, #228]	; (59c0 <_i2c_m_sync_transfer+0x114>)
    58dc:	0018      	movs	r0, r3
    58de:	f7fe fd1f 	bl	4320 <assert>
	ASSERT(msg);
    58e2:	683b      	ldr	r3, [r7, #0]
    58e4:	1e5a      	subs	r2, r3, #1
    58e6:	4193      	sbcs	r3, r2
    58e8:	b2db      	uxtb	r3, r3
    58ea:	4a37      	ldr	r2, [pc, #220]	; (59c8 <_i2c_m_sync_transfer+0x11c>)
    58ec:	4934      	ldr	r1, [pc, #208]	; (59c0 <_i2c_m_sync_transfer+0x114>)
    58ee:	0018      	movs	r0, r3
    58f0:	f7fe fd16 	bl	4320 <assert>

	if (i2c_dev->service.msg.flags & I2C_M_BUSY) {
    58f4:	687b      	ldr	r3, [r7, #4]
    58f6:	885b      	ldrh	r3, [r3, #2]
    58f8:	b29b      	uxth	r3, r3
    58fa:	001a      	movs	r2, r3
    58fc:	2380      	movs	r3, #128	; 0x80
    58fe:	005b      	lsls	r3, r3, #1
    5900:	4013      	ands	r3, r2
    5902:	d002      	beq.n	590a <_i2c_m_sync_transfer+0x5e>
		return I2C_ERR_BUSY;
    5904:	2306      	movs	r3, #6
    5906:	425b      	negs	r3, r3
    5908:	e054      	b.n	59b4 <_i2c_m_sync_transfer+0x108>
	}

	msg->flags |= I2C_M_BUSY;
    590a:	683b      	ldr	r3, [r7, #0]
    590c:	885b      	ldrh	r3, [r3, #2]
    590e:	b29b      	uxth	r3, r3
    5910:	2280      	movs	r2, #128	; 0x80
    5912:	0052      	lsls	r2, r2, #1
    5914:	4313      	orrs	r3, r2
    5916:	b29a      	uxth	r2, r3
    5918:	683b      	ldr	r3, [r7, #0]
    591a:	805a      	strh	r2, [r3, #2]
	i2c_dev->service.msg = *msg;
    591c:	687b      	ldr	r3, [r7, #4]
    591e:	683a      	ldr	r2, [r7, #0]
    5920:	ca13      	ldmia	r2!, {r0, r1, r4}
    5922:	c313      	stmia	r3!, {r0, r1, r4}
	hri_sercomi2cm_set_CTRLB_SMEN_bit(hw);
    5924:	693b      	ldr	r3, [r7, #16]
    5926:	0018      	movs	r0, r3
    5928:	f7ff facd 	bl	4ec6 <hri_sercomi2cm_set_CTRLB_SMEN_bit>

	ret = _sercom_i2c_sync_send_address(i2c_dev);
    592c:	687b      	ldr	r3, [r7, #4]
    592e:	0018      	movs	r0, r3
    5930:	f7ff ff7a 	bl	5828 <_sercom_i2c_sync_send_address>
    5934:	0003      	movs	r3, r0
    5936:	617b      	str	r3, [r7, #20]

	if (ret) {
    5938:	697b      	ldr	r3, [r7, #20]
    593a:	2b00      	cmp	r3, #0
    593c:	d031      	beq.n	59a2 <_i2c_m_sync_transfer+0xf6>
		i2c_dev->service.msg.flags &= ~I2C_M_BUSY;
    593e:	687b      	ldr	r3, [r7, #4]
    5940:	885b      	ldrh	r3, [r3, #2]
    5942:	b29b      	uxth	r3, r3
    5944:	4a21      	ldr	r2, [pc, #132]	; (59cc <_i2c_m_sync_transfer+0x120>)
    5946:	4013      	ands	r3, r2
    5948:	b29a      	uxth	r2, r3
    594a:	687b      	ldr	r3, [r7, #4]
    594c:	805a      	strh	r2, [r3, #2]

		return ret;
    594e:	697b      	ldr	r3, [r7, #20]
    5950:	e030      	b.n	59b4 <_i2c_m_sync_transfer+0x108>
	}

	while (i2c_dev->service.msg.flags & I2C_M_BUSY) {
		ret = _sercom_i2c_sync_wait_bus(i2c_dev, &flags);
    5952:	230c      	movs	r3, #12
    5954:	18fa      	adds	r2, r7, r3
    5956:	687b      	ldr	r3, [r7, #4]
    5958:	0011      	movs	r1, r2
    595a:	0018      	movs	r0, r3
    595c:	f7ff ff38 	bl	57d0 <_sercom_i2c_sync_wait_bus>
    5960:	0003      	movs	r3, r0
    5962:	617b      	str	r3, [r7, #20]

		if (ret) {
    5964:	697b      	ldr	r3, [r7, #20]
    5966:	2b00      	cmp	r3, #0
    5968:	d013      	beq.n	5992 <_i2c_m_sync_transfer+0xe6>
			if (msg->flags & I2C_M_STOP) {
    596a:	683b      	ldr	r3, [r7, #0]
    596c:	885b      	ldrh	r3, [r3, #2]
    596e:	b29b      	uxth	r3, r3
    5970:	b21b      	sxth	r3, r3
    5972:	2b00      	cmp	r3, #0
    5974:	da03      	bge.n	597e <_i2c_m_sync_transfer+0xd2>
				_sercom_i2c_send_stop(hw);
    5976:	693b      	ldr	r3, [r7, #16]
    5978:	0018      	movs	r0, r3
    597a:	f7ff fd6d 	bl	5458 <_sercom_i2c_send_stop>
			}

			i2c_dev->service.msg.flags &= ~I2C_M_BUSY;
    597e:	687b      	ldr	r3, [r7, #4]
    5980:	885b      	ldrh	r3, [r3, #2]
    5982:	b29b      	uxth	r3, r3
    5984:	4a11      	ldr	r2, [pc, #68]	; (59cc <_i2c_m_sync_transfer+0x120>)
    5986:	4013      	ands	r3, r2
    5988:	b29a      	uxth	r2, r3
    598a:	687b      	ldr	r3, [r7, #4]
    598c:	805a      	strh	r2, [r3, #2]

			return ret;
    598e:	697b      	ldr	r3, [r7, #20]
    5990:	e010      	b.n	59b4 <_i2c_m_sync_transfer+0x108>
		}

		ret = _sercom_i2c_sync_analyse_flags(hw, flags, &i2c_dev->service.msg);
    5992:	68f9      	ldr	r1, [r7, #12]
    5994:	687a      	ldr	r2, [r7, #4]
    5996:	693b      	ldr	r3, [r7, #16]
    5998:	0018      	movs	r0, r3
    599a:	f7ff fd6b 	bl	5474 <_sercom_i2c_sync_analyse_flags>
    599e:	0003      	movs	r3, r0
    59a0:	617b      	str	r3, [r7, #20]
	while (i2c_dev->service.msg.flags & I2C_M_BUSY) {
    59a2:	687b      	ldr	r3, [r7, #4]
    59a4:	885b      	ldrh	r3, [r3, #2]
    59a6:	b29b      	uxth	r3, r3
    59a8:	001a      	movs	r2, r3
    59aa:	2380      	movs	r3, #128	; 0x80
    59ac:	005b      	lsls	r3, r3, #1
    59ae:	4013      	ands	r3, r2
    59b0:	d1cf      	bne.n	5952 <_i2c_m_sync_transfer+0xa6>
	}

	return ret;
    59b2:	697b      	ldr	r3, [r7, #20]
}
    59b4:	0018      	movs	r0, r3
    59b6:	46bd      	mov	sp, r7
    59b8:	b007      	add	sp, #28
    59ba:	bd90      	pop	{r4, r7, pc}
    59bc:	0000059b 	.word	0x0000059b
    59c0:	00008b30 	.word	0x00008b30
    59c4:	0000059c 	.word	0x0000059c
    59c8:	0000059d 	.word	0x0000059d
    59cc:	fffffeff 	.word	0xfffffeff

000059d0 <_spi_sync_enable>:
 *  \param[in] hw Pointer to the hardware register base.
 *
 * \return Enabling status
 */
static int32_t _spi_sync_enable(void *const hw)
{
    59d0:	b580      	push	{r7, lr}
    59d2:	b082      	sub	sp, #8
    59d4:	af00      	add	r7, sp, #0
    59d6:	6078      	str	r0, [r7, #4]
	if (hri_sercomspi_is_syncing(hw)) {
    59d8:	687b      	ldr	r3, [r7, #4]
    59da:	0018      	movs	r0, r3
    59dc:	f7ff f91e 	bl	4c1c <hri_sercomspi_is_syncing>
    59e0:	1e03      	subs	r3, r0, #0
    59e2:	d002      	beq.n	59ea <_spi_sync_enable+0x1a>
		return ERR_BUSY;
    59e4:	2304      	movs	r3, #4
    59e6:	425b      	negs	r3, r3
    59e8:	e004      	b.n	59f4 <_spi_sync_enable+0x24>
	}

	hri_sercomspi_set_CTRLA_ENABLE_bit(hw);
    59ea:	687b      	ldr	r3, [r7, #4]
    59ec:	0018      	movs	r0, r3
    59ee:	f7ff f9f6 	bl	4dde <hri_sercomspi_set_CTRLA_ENABLE_bit>

	return ERR_NONE;
    59f2:	2300      	movs	r3, #0
}
    59f4:	0018      	movs	r0, r3
    59f6:	46bd      	mov	sp, r7
    59f8:	b002      	add	sp, #8
    59fa:	bd80      	pop	{r7, pc}

000059fc <_spi_load_regs_master>:
 *  are ignored.
 *  \param[in, out] hw Pointer to the hardware register base.
 *  \param[in] regs Pointer to register configuration values.
 */
static inline void _spi_load_regs_master(void *const hw, const struct sercomspi_regs_cfg *regs)
{
    59fc:	b580      	push	{r7, lr}
    59fe:	b082      	sub	sp, #8
    5a00:	af00      	add	r7, sp, #0
    5a02:	6078      	str	r0, [r7, #4]
    5a04:	6039      	str	r1, [r7, #0]
	ASSERT(hw && regs);
    5a06:	687b      	ldr	r3, [r7, #4]
    5a08:	2b00      	cmp	r3, #0
    5a0a:	d004      	beq.n	5a16 <_spi_load_regs_master+0x1a>
    5a0c:	683b      	ldr	r3, [r7, #0]
    5a0e:	2b00      	cmp	r3, #0
    5a10:	d001      	beq.n	5a16 <_spi_load_regs_master+0x1a>
    5a12:	2301      	movs	r3, #1
    5a14:	e000      	b.n	5a18 <_spi_load_regs_master+0x1c>
    5a16:	2300      	movs	r3, #0
    5a18:	1c1a      	adds	r2, r3, #0
    5a1a:	2301      	movs	r3, #1
    5a1c:	4013      	ands	r3, r2
    5a1e:	b2db      	uxtb	r3, r3
    5a20:	4a1f      	ldr	r2, [pc, #124]	; (5aa0 <_spi_load_regs_master+0xa4>)
    5a22:	4920      	ldr	r1, [pc, #128]	; (5aa4 <_spi_load_regs_master+0xa8>)
    5a24:	0018      	movs	r0, r3
    5a26:	f7fe fc7b 	bl	4320 <assert>
	hri_sercomspi_write_CTRLA_reg(
	    hw, regs->ctrla & ~(SERCOM_SPI_CTRLA_IBON | SERCOM_SPI_CTRLA_ENABLE | SERCOM_SPI_CTRLA_SWRST));
    5a2a:	683b      	ldr	r3, [r7, #0]
    5a2c:	781a      	ldrb	r2, [r3, #0]
    5a2e:	7859      	ldrb	r1, [r3, #1]
    5a30:	0209      	lsls	r1, r1, #8
    5a32:	430a      	orrs	r2, r1
    5a34:	7899      	ldrb	r1, [r3, #2]
    5a36:	0409      	lsls	r1, r1, #16
    5a38:	430a      	orrs	r2, r1
    5a3a:	78db      	ldrb	r3, [r3, #3]
    5a3c:	061b      	lsls	r3, r3, #24
    5a3e:	4313      	orrs	r3, r2
    5a40:	001a      	movs	r2, r3
	hri_sercomspi_write_CTRLA_reg(
    5a42:	4b19      	ldr	r3, [pc, #100]	; (5aa8 <_spi_load_regs_master+0xac>)
    5a44:	401a      	ands	r2, r3
    5a46:	687b      	ldr	r3, [r7, #4]
    5a48:	0011      	movs	r1, r2
    5a4a:	0018      	movs	r0, r3
    5a4c:	f7ff fa06 	bl	4e5c <hri_sercomspi_write_CTRLA_reg>
	hri_sercomspi_write_CTRLB_reg(
	    hw, (regs->ctrlb & ~(SERCOM_SPI_CTRLB_AMODE_Msk | SERCOM_SPI_CTRLB_PLOADEN)) | (SERCOM_SPI_CTRLB_RXEN));
    5a50:	683b      	ldr	r3, [r7, #0]
    5a52:	791a      	ldrb	r2, [r3, #4]
    5a54:	7959      	ldrb	r1, [r3, #5]
    5a56:	0209      	lsls	r1, r1, #8
    5a58:	430a      	orrs	r2, r1
    5a5a:	7999      	ldrb	r1, [r3, #6]
    5a5c:	0409      	lsls	r1, r1, #16
    5a5e:	430a      	orrs	r2, r1
    5a60:	79db      	ldrb	r3, [r3, #7]
    5a62:	061b      	lsls	r3, r3, #24
    5a64:	4313      	orrs	r3, r2
    5a66:	001a      	movs	r2, r3
    5a68:	4b10      	ldr	r3, [pc, #64]	; (5aac <_spi_load_regs_master+0xb0>)
    5a6a:	4013      	ands	r3, r2
	hri_sercomspi_write_CTRLB_reg(
    5a6c:	2280      	movs	r2, #128	; 0x80
    5a6e:	0292      	lsls	r2, r2, #10
    5a70:	431a      	orrs	r2, r3
    5a72:	687b      	ldr	r3, [r7, #4]
    5a74:	0011      	movs	r1, r2
    5a76:	0018      	movs	r0, r3
    5a78:	f7ff fa9b 	bl	4fb2 <hri_sercomspi_write_CTRLB_reg>
	hri_sercomspi_write_BAUD_reg(hw, regs->baud);
    5a7c:	683b      	ldr	r3, [r7, #0]
    5a7e:	7b1a      	ldrb	r2, [r3, #12]
    5a80:	687b      	ldr	r3, [r7, #4]
    5a82:	0011      	movs	r1, r2
    5a84:	0018      	movs	r0, r3
    5a86:	f7ff fadd 	bl	5044 <hri_sercomspi_write_BAUD_reg>
	hri_sercomspi_write_DBGCTRL_reg(hw, regs->dbgctrl);
    5a8a:	683b      	ldr	r3, [r7, #0]
    5a8c:	7b5a      	ldrb	r2, [r3, #13]
    5a8e:	687b      	ldr	r3, [r7, #4]
    5a90:	0011      	movs	r1, r2
    5a92:	0018      	movs	r0, r3
    5a94:	f7ff faa9 	bl	4fea <hri_sercomspi_write_DBGCTRL_reg>
}
    5a98:	46c0      	nop			; (mov r8, r8)
    5a9a:	46bd      	mov	sp, r7
    5a9c:	b002      	add	sp, #8
    5a9e:	bd80      	pop	{r7, pc}
    5aa0:	00000872 	.word	0x00000872
    5aa4:	00008b30 	.word	0x00008b30
    5aa8:	fffffefc 	.word	0xfffffefc
    5aac:	fffd3fbf 	.word	0xfffd3fbf

00005ab0 <_spi_load_regs_slave>:
 *  are ignored.
 *  \param[in, out] hw Pointer to the hardware register base.
 *  \param[in] regs Pointer to register configuration values.
 */
static inline void _spi_load_regs_slave(void *const hw, const struct sercomspi_regs_cfg *regs)
{
    5ab0:	b580      	push	{r7, lr}
    5ab2:	b082      	sub	sp, #8
    5ab4:	af00      	add	r7, sp, #0
    5ab6:	6078      	str	r0, [r7, #4]
    5ab8:	6039      	str	r1, [r7, #0]
	ASSERT(hw && regs);
    5aba:	687b      	ldr	r3, [r7, #4]
    5abc:	2b00      	cmp	r3, #0
    5abe:	d004      	beq.n	5aca <_spi_load_regs_slave+0x1a>
    5ac0:	683b      	ldr	r3, [r7, #0]
    5ac2:	2b00      	cmp	r3, #0
    5ac4:	d001      	beq.n	5aca <_spi_load_regs_slave+0x1a>
    5ac6:	2301      	movs	r3, #1
    5ac8:	e000      	b.n	5acc <_spi_load_regs_slave+0x1c>
    5aca:	2300      	movs	r3, #0
    5acc:	1c1a      	adds	r2, r3, #0
    5ace:	2301      	movs	r3, #1
    5ad0:	4013      	ands	r3, r2
    5ad2:	b2db      	uxtb	r3, r3
    5ad4:	4a26      	ldr	r2, [pc, #152]	; (5b70 <_spi_load_regs_slave+0xc0>)
    5ad6:	4927      	ldr	r1, [pc, #156]	; (5b74 <_spi_load_regs_slave+0xc4>)
    5ad8:	0018      	movs	r0, r3
    5ada:	f7fe fc21 	bl	4320 <assert>
	hri_sercomspi_write_CTRLA_reg(
	    hw, regs->ctrla & ~(SERCOM_SPI_CTRLA_IBON | SERCOM_SPI_CTRLA_ENABLE | SERCOM_SPI_CTRLA_SWRST));
    5ade:	683b      	ldr	r3, [r7, #0]
    5ae0:	781a      	ldrb	r2, [r3, #0]
    5ae2:	7859      	ldrb	r1, [r3, #1]
    5ae4:	0209      	lsls	r1, r1, #8
    5ae6:	430a      	orrs	r2, r1
    5ae8:	7899      	ldrb	r1, [r3, #2]
    5aea:	0409      	lsls	r1, r1, #16
    5aec:	430a      	orrs	r2, r1
    5aee:	78db      	ldrb	r3, [r3, #3]
    5af0:	061b      	lsls	r3, r3, #24
    5af2:	4313      	orrs	r3, r2
    5af4:	001a      	movs	r2, r3
	hri_sercomspi_write_CTRLA_reg(
    5af6:	4b20      	ldr	r3, [pc, #128]	; (5b78 <_spi_load_regs_slave+0xc8>)
    5af8:	401a      	ands	r2, r3
    5afa:	687b      	ldr	r3, [r7, #4]
    5afc:	0011      	movs	r1, r2
    5afe:	0018      	movs	r0, r3
    5b00:	f7ff f9ac 	bl	4e5c <hri_sercomspi_write_CTRLA_reg>
	hri_sercomspi_write_CTRLB_reg(hw, regs->ctrlb | (SERCOM_SPI_CTRLB_RXEN | SERCOM_SPI_CTRLB_PLOADEN));
    5b04:	683b      	ldr	r3, [r7, #0]
    5b06:	791a      	ldrb	r2, [r3, #4]
    5b08:	7959      	ldrb	r1, [r3, #5]
    5b0a:	0209      	lsls	r1, r1, #8
    5b0c:	430a      	orrs	r2, r1
    5b0e:	7999      	ldrb	r1, [r3, #6]
    5b10:	0409      	lsls	r1, r1, #16
    5b12:	430a      	orrs	r2, r1
    5b14:	79db      	ldrb	r3, [r3, #7]
    5b16:	061b      	lsls	r3, r3, #24
    5b18:	4313      	orrs	r3, r2
    5b1a:	001a      	movs	r2, r3
    5b1c:	4b17      	ldr	r3, [pc, #92]	; (5b7c <_spi_load_regs_slave+0xcc>)
    5b1e:	431a      	orrs	r2, r3
    5b20:	687b      	ldr	r3, [r7, #4]
    5b22:	0011      	movs	r1, r2
    5b24:	0018      	movs	r0, r3
    5b26:	f7ff fa44 	bl	4fb2 <hri_sercomspi_write_CTRLB_reg>
	hri_sercomspi_write_ADDR_reg(hw, regs->addr);
    5b2a:	683b      	ldr	r3, [r7, #0]
    5b2c:	7a1a      	ldrb	r2, [r3, #8]
    5b2e:	7a59      	ldrb	r1, [r3, #9]
    5b30:	0209      	lsls	r1, r1, #8
    5b32:	430a      	orrs	r2, r1
    5b34:	7a99      	ldrb	r1, [r3, #10]
    5b36:	0409      	lsls	r1, r1, #16
    5b38:	430a      	orrs	r2, r1
    5b3a:	7adb      	ldrb	r3, [r3, #11]
    5b3c:	061b      	lsls	r3, r3, #24
    5b3e:	4313      	orrs	r3, r2
    5b40:	001a      	movs	r2, r3
    5b42:	687b      	ldr	r3, [r7, #4]
    5b44:	0011      	movs	r1, r2
    5b46:	0018      	movs	r0, r3
    5b48:	f7ff faad 	bl	50a6 <hri_sercomspi_write_ADDR_reg>
	hri_sercomspi_write_DBGCTRL_reg(hw, regs->dbgctrl);
    5b4c:	683b      	ldr	r3, [r7, #0]
    5b4e:	7b5a      	ldrb	r2, [r3, #13]
    5b50:	687b      	ldr	r3, [r7, #4]
    5b52:	0011      	movs	r1, r2
    5b54:	0018      	movs	r0, r3
    5b56:	f7ff fa48 	bl	4fea <hri_sercomspi_write_DBGCTRL_reg>
	while (hri_sercomspi_is_syncing(hw))
    5b5a:	46c0      	nop			; (mov r8, r8)
    5b5c:	687b      	ldr	r3, [r7, #4]
    5b5e:	0018      	movs	r0, r3
    5b60:	f7ff f85c 	bl	4c1c <hri_sercomspi_is_syncing>
    5b64:	1e03      	subs	r3, r0, #0
    5b66:	d1f9      	bne.n	5b5c <_spi_load_regs_slave+0xac>
		;
}
    5b68:	46c0      	nop			; (mov r8, r8)
    5b6a:	46bd      	mov	sp, r7
    5b6c:	b002      	add	sp, #8
    5b6e:	bd80      	pop	{r7, pc}
    5b70:	00000883 	.word	0x00000883
    5b74:	00008b30 	.word	0x00008b30
    5b78:	fffffefc 	.word	0xfffffefc
    5b7c:	00020040 	.word	0x00020040

00005b80 <_spi_get_regs>:
/** \brief Return the pointer to register settings of specific SERCOM
 *  \param[in] hw_addr The hardware register base address.
 *  \return Pointer to register settings of specific SERCOM.
 */
static inline const struct sercomspi_regs_cfg *_spi_get_regs(const uint32_t hw_addr)
{
    5b80:	b590      	push	{r4, r7, lr}
    5b82:	b085      	sub	sp, #20
    5b84:	af00      	add	r7, sp, #0
    5b86:	6078      	str	r0, [r7, #4]
	uint8_t n = _sercom_get_hardware_index((const void *)hw_addr);
    5b88:	687b      	ldr	r3, [r7, #4]
    5b8a:	220e      	movs	r2, #14
    5b8c:	18bc      	adds	r4, r7, r2
    5b8e:	0018      	movs	r0, r3
    5b90:	f7ff fb70 	bl	5274 <_sercom_get_hardware_index>
    5b94:	0003      	movs	r3, r0
    5b96:	7023      	strb	r3, [r4, #0]
	uint8_t i;

	for (i = 0; i < sizeof(sercomspi_regs) / sizeof(struct sercomspi_regs_cfg); i++) {
    5b98:	230f      	movs	r3, #15
    5b9a:	18fb      	adds	r3, r7, r3
    5b9c:	2200      	movs	r2, #0
    5b9e:	701a      	strb	r2, [r3, #0]
    5ba0:	e01a      	b.n	5bd8 <_spi_get_regs+0x58>
		if (sercomspi_regs[i].n == n) {
    5ba2:	230f      	movs	r3, #15
    5ba4:	18fb      	adds	r3, r7, r3
    5ba6:	781b      	ldrb	r3, [r3, #0]
    5ba8:	4a10      	ldr	r2, [pc, #64]	; (5bec <_spi_get_regs+0x6c>)
    5baa:	011b      	lsls	r3, r3, #4
    5bac:	18d3      	adds	r3, r2, r3
    5bae:	330f      	adds	r3, #15
    5bb0:	781b      	ldrb	r3, [r3, #0]
    5bb2:	220e      	movs	r2, #14
    5bb4:	18ba      	adds	r2, r7, r2
    5bb6:	7812      	ldrb	r2, [r2, #0]
    5bb8:	429a      	cmp	r2, r3
    5bba:	d106      	bne.n	5bca <_spi_get_regs+0x4a>
			return &sercomspi_regs[i];
    5bbc:	230f      	movs	r3, #15
    5bbe:	18fb      	adds	r3, r7, r3
    5bc0:	781b      	ldrb	r3, [r3, #0]
    5bc2:	011a      	lsls	r2, r3, #4
    5bc4:	4b09      	ldr	r3, [pc, #36]	; (5bec <_spi_get_regs+0x6c>)
    5bc6:	18d3      	adds	r3, r2, r3
    5bc8:	e00c      	b.n	5be4 <_spi_get_regs+0x64>
	for (i = 0; i < sizeof(sercomspi_regs) / sizeof(struct sercomspi_regs_cfg); i++) {
    5bca:	230f      	movs	r3, #15
    5bcc:	18fb      	adds	r3, r7, r3
    5bce:	781a      	ldrb	r2, [r3, #0]
    5bd0:	230f      	movs	r3, #15
    5bd2:	18fb      	adds	r3, r7, r3
    5bd4:	3201      	adds	r2, #1
    5bd6:	701a      	strb	r2, [r3, #0]
    5bd8:	230f      	movs	r3, #15
    5bda:	18fb      	adds	r3, r7, r3
    5bdc:	781b      	ldrb	r3, [r3, #0]
    5bde:	2b01      	cmp	r3, #1
    5be0:	d9df      	bls.n	5ba2 <_spi_get_regs+0x22>
		}
	}

	return NULL;
    5be2:	2300      	movs	r3, #0
}
    5be4:	0018      	movs	r0, r3
    5be6:	46bd      	mov	sp, r7
    5be8:	b005      	add	sp, #20
    5bea:	bd90      	pop	{r4, r7, pc}
    5bec:	00008b4c 	.word	0x00008b4c

00005bf0 <_spi_m_sync_init>:

int32_t _spi_m_sync_init(struct _spi_m_sync_dev *dev, void *const hw)
{
    5bf0:	b580      	push	{r7, lr}
    5bf2:	b084      	sub	sp, #16
    5bf4:	af00      	add	r7, sp, #0
    5bf6:	6078      	str	r0, [r7, #4]
    5bf8:	6039      	str	r1, [r7, #0]
	const struct sercomspi_regs_cfg *regs = _spi_get_regs((uint32_t)hw);
    5bfa:	683b      	ldr	r3, [r7, #0]
    5bfc:	0018      	movs	r0, r3
    5bfe:	f7ff ffbf 	bl	5b80 <_spi_get_regs>
    5c02:	0003      	movs	r3, r0
    5c04:	60fb      	str	r3, [r7, #12]

	ASSERT(dev && hw);
    5c06:	687b      	ldr	r3, [r7, #4]
    5c08:	2b00      	cmp	r3, #0
    5c0a:	d004      	beq.n	5c16 <_spi_m_sync_init+0x26>
    5c0c:	683b      	ldr	r3, [r7, #0]
    5c0e:	2b00      	cmp	r3, #0
    5c10:	d001      	beq.n	5c16 <_spi_m_sync_init+0x26>
    5c12:	2301      	movs	r3, #1
    5c14:	e000      	b.n	5c18 <_spi_m_sync_init+0x28>
    5c16:	2300      	movs	r3, #0
    5c18:	1c1a      	adds	r2, r3, #0
    5c1a:	2301      	movs	r3, #1
    5c1c:	4013      	ands	r3, r2
    5c1e:	b2db      	uxtb	r3, r3
    5c20:	4a30      	ldr	r2, [pc, #192]	; (5ce4 <_spi_m_sync_init+0xf4>)
    5c22:	4931      	ldr	r1, [pc, #196]	; (5ce8 <_spi_m_sync_init+0xf8>)
    5c24:	0018      	movs	r0, r3
    5c26:	f7fe fb7b 	bl	4320 <assert>

	if (regs == NULL) {
    5c2a:	68fb      	ldr	r3, [r7, #12]
    5c2c:	2b00      	cmp	r3, #0
    5c2e:	d102      	bne.n	5c36 <_spi_m_sync_init+0x46>
		return ERR_INVALID_ARG;
    5c30:	230d      	movs	r3, #13
    5c32:	425b      	negs	r3, r3
    5c34:	e051      	b.n	5cda <_spi_m_sync_init+0xea>
	}

	hri_sercomspi_wait_for_sync(hw);
    5c36:	683b      	ldr	r3, [r7, #0]
    5c38:	0018      	movs	r0, r3
    5c3a:	f7fe ffdf 	bl	4bfc <hri_sercomspi_wait_for_sync>
	if (hri_sercomspi_get_CTRLA_reg(hw, SERCOM_SPI_CTRLA_ENABLE)) {
    5c3e:	683b      	ldr	r3, [r7, #0]
    5c40:	2102      	movs	r1, #2
    5c42:	0018      	movs	r0, r3
    5c44:	f7ff f8f5 	bl	4e32 <hri_sercomspi_get_CTRLA_reg>
    5c48:	1e03      	subs	r3, r0, #0
    5c4a:	d008      	beq.n	5c5e <_spi_m_sync_init+0x6e>
		hri_sercomspi_write_CTRLA_reg(hw, 0);
    5c4c:	683b      	ldr	r3, [r7, #0]
    5c4e:	2100      	movs	r1, #0
    5c50:	0018      	movs	r0, r3
    5c52:	f7ff f903 	bl	4e5c <hri_sercomspi_write_CTRLA_reg>
		hri_sercomspi_wait_for_sync(hw);
    5c56:	683b      	ldr	r3, [r7, #0]
    5c58:	0018      	movs	r0, r3
    5c5a:	f7fe ffcf 	bl	4bfc <hri_sercomspi_wait_for_sync>
	}
	hri_sercomspi_write_CTRLA_reg(hw, SERCOM_SPI_CTRLA_SWRST);
    5c5e:	683b      	ldr	r3, [r7, #0]
    5c60:	2101      	movs	r1, #1
    5c62:	0018      	movs	r0, r3
    5c64:	f7ff f8fa 	bl	4e5c <hri_sercomspi_write_CTRLA_reg>
	hri_sercomspi_wait_for_sync(hw);
    5c68:	683b      	ldr	r3, [r7, #0]
    5c6a:	0018      	movs	r0, r3
    5c6c:	f7fe ffc6 	bl	4bfc <hri_sercomspi_wait_for_sync>

	dev->prvt = hw;
    5c70:	687b      	ldr	r3, [r7, #4]
    5c72:	683a      	ldr	r2, [r7, #0]
    5c74:	601a      	str	r2, [r3, #0]

	if ((regs->ctrla & SERCOM_SPI_CTRLA_MODE_Msk) == SERCOM_USART_CTRLA_MODE_SPI_SLAVE) {
    5c76:	68fb      	ldr	r3, [r7, #12]
    5c78:	781a      	ldrb	r2, [r3, #0]
    5c7a:	7859      	ldrb	r1, [r3, #1]
    5c7c:	0209      	lsls	r1, r1, #8
    5c7e:	430a      	orrs	r2, r1
    5c80:	7899      	ldrb	r1, [r3, #2]
    5c82:	0409      	lsls	r1, r1, #16
    5c84:	430a      	orrs	r2, r1
    5c86:	78db      	ldrb	r3, [r3, #3]
    5c88:	061b      	lsls	r3, r3, #24
    5c8a:	4313      	orrs	r3, r2
    5c8c:	001a      	movs	r2, r3
    5c8e:	231c      	movs	r3, #28
    5c90:	4013      	ands	r3, r2
    5c92:	2b08      	cmp	r3, #8
    5c94:	d106      	bne.n	5ca4 <_spi_m_sync_init+0xb4>
		_spi_load_regs_slave(hw, regs);
    5c96:	68fa      	ldr	r2, [r7, #12]
    5c98:	683b      	ldr	r3, [r7, #0]
    5c9a:	0011      	movs	r1, r2
    5c9c:	0018      	movs	r0, r3
    5c9e:	f7ff ff07 	bl	5ab0 <_spi_load_regs_slave>
    5ca2:	e005      	b.n	5cb0 <_spi_m_sync_init+0xc0>
	} else {
		_spi_load_regs_master(hw, regs);
    5ca4:	68fa      	ldr	r2, [r7, #12]
    5ca6:	683b      	ldr	r3, [r7, #0]
    5ca8:	0011      	movs	r1, r2
    5caa:	0018      	movs	r0, r3
    5cac:	f7ff fea6 	bl	59fc <_spi_load_regs_master>
	}

	/* Load character size from default hardware configuration */
	dev->char_size = ((regs->ctrlb & SERCOM_SPI_CTRLB_CHSIZE_Msk) == 0) ? 1 : 2;
    5cb0:	68fb      	ldr	r3, [r7, #12]
    5cb2:	791a      	ldrb	r2, [r3, #4]
    5cb4:	7959      	ldrb	r1, [r3, #5]
    5cb6:	0209      	lsls	r1, r1, #8
    5cb8:	430a      	orrs	r2, r1
    5cba:	7999      	ldrb	r1, [r3, #6]
    5cbc:	0409      	lsls	r1, r1, #16
    5cbe:	430a      	orrs	r2, r1
    5cc0:	79db      	ldrb	r3, [r3, #7]
    5cc2:	061b      	lsls	r3, r3, #24
    5cc4:	4313      	orrs	r3, r2
    5cc6:	001a      	movs	r2, r3
    5cc8:	2307      	movs	r3, #7
    5cca:	4013      	ands	r3, r2
    5ccc:	d101      	bne.n	5cd2 <_spi_m_sync_init+0xe2>
    5cce:	2201      	movs	r2, #1
    5cd0:	e000      	b.n	5cd4 <_spi_m_sync_init+0xe4>
    5cd2:	2202      	movs	r2, #2
    5cd4:	687b      	ldr	r3, [r7, #4]
    5cd6:	711a      	strb	r2, [r3, #4]

	return ERR_NONE;
    5cd8:	2300      	movs	r3, #0
}
    5cda:	0018      	movs	r0, r3
    5cdc:	46bd      	mov	sp, r7
    5cde:	b004      	add	sp, #16
    5ce0:	bd80      	pop	{r7, pc}
    5ce2:	46c0      	nop			; (mov r8, r8)
    5ce4:	000008a3 	.word	0x000008a3
    5ce8:	00008b30 	.word	0x00008b30

00005cec <_spi_m_sync_enable>:

	return _spi_deinit(hw);
}

int32_t _spi_m_sync_enable(struct _spi_m_sync_dev *dev)
{
    5cec:	b580      	push	{r7, lr}
    5cee:	b082      	sub	sp, #8
    5cf0:	af00      	add	r7, sp, #0
    5cf2:	6078      	str	r0, [r7, #4]
	ASSERT(dev && dev->prvt);
    5cf4:	687b      	ldr	r3, [r7, #4]
    5cf6:	2b00      	cmp	r3, #0
    5cf8:	d005      	beq.n	5d06 <_spi_m_sync_enable+0x1a>
    5cfa:	687b      	ldr	r3, [r7, #4]
    5cfc:	681b      	ldr	r3, [r3, #0]
    5cfe:	2b00      	cmp	r3, #0
    5d00:	d001      	beq.n	5d06 <_spi_m_sync_enable+0x1a>
    5d02:	2301      	movs	r3, #1
    5d04:	e000      	b.n	5d08 <_spi_m_sync_enable+0x1c>
    5d06:	2300      	movs	r3, #0
    5d08:	1c1a      	adds	r2, r3, #0
    5d0a:	2301      	movs	r3, #1
    5d0c:	4013      	ands	r3, r2
    5d0e:	b2db      	uxtb	r3, r3
    5d10:	4a07      	ldr	r2, [pc, #28]	; (5d30 <_spi_m_sync_enable+0x44>)
    5d12:	4908      	ldr	r1, [pc, #32]	; (5d34 <_spi_m_sync_enable+0x48>)
    5d14:	0018      	movs	r0, r3
    5d16:	f7fe fb03 	bl	4320 <assert>

	return _spi_sync_enable(dev->prvt);
    5d1a:	687b      	ldr	r3, [r7, #4]
    5d1c:	681b      	ldr	r3, [r3, #0]
    5d1e:	0018      	movs	r0, r3
    5d20:	f7ff fe56 	bl	59d0 <_spi_sync_enable>
    5d24:	0003      	movs	r3, r0
}
    5d26:	0018      	movs	r0, r3
    5d28:	46bd      	mov	sp, r7
    5d2a:	b002      	add	sp, #8
    5d2c:	bd80      	pop	{r7, pc}
    5d2e:	46c0      	nop			; (mov r8, r8)
    5d30:	0000090a 	.word	0x0000090a
    5d34:	00008b30 	.word	0x00008b30

00005d38 <_spi_wait_bus_idle>:
	return _spi_set_data_order(dev->prvt, dord);
}

/** Wait until SPI bus idle. */
static inline void _spi_wait_bus_idle(void *const hw)
{
    5d38:	b580      	push	{r7, lr}
    5d3a:	b082      	sub	sp, #8
    5d3c:	af00      	add	r7, sp, #0
    5d3e:	6078      	str	r0, [r7, #4]
	while (!(hri_sercomspi_get_INTFLAG_reg(hw, SERCOM_SPI_INTFLAG_TXC | SERCOM_SPI_INTFLAG_DRE))) {
    5d40:	46c0      	nop			; (mov r8, r8)
    5d42:	687b      	ldr	r3, [r7, #4]
    5d44:	2103      	movs	r1, #3
    5d46:	0018      	movs	r0, r3
    5d48:	f7fe ffa9 	bl	4c9e <hri_sercomspi_get_INTFLAG_reg>
    5d4c:	1e03      	subs	r3, r0, #0
    5d4e:	d0f8      	beq.n	5d42 <_spi_wait_bus_idle+0xa>
		;
	}
	hri_sercomspi_clear_INTFLAG_reg(hw, SERCOM_SPI_INTFLAG_TXC | SERCOM_SPI_INTFLAG_DRE);
    5d50:	687b      	ldr	r3, [r7, #4]
    5d52:	2103      	movs	r1, #3
    5d54:	0018      	movs	r0, r3
    5d56:	f7fe ffc9 	bl	4cec <hri_sercomspi_clear_INTFLAG_reg>
}
    5d5a:	46c0      	nop			; (mov r8, r8)
    5d5c:	46bd      	mov	sp, r7
    5d5e:	b002      	add	sp, #8
    5d60:	bd80      	pop	{r7, pc}

00005d62 <_spi_rx_check>:
	uint8_t char_size;
};

/** Check interrupt flag of RXC and update transaction runtime information. */
static inline bool _spi_rx_check(void *const hw, const uint32_t iflag, struct _spi_trans_ctrl *ctrl)
{
    5d62:	b580      	push	{r7, lr}
    5d64:	b086      	sub	sp, #24
    5d66:	af00      	add	r7, sp, #0
    5d68:	60f8      	str	r0, [r7, #12]
    5d6a:	60b9      	str	r1, [r7, #8]
    5d6c:	607a      	str	r2, [r7, #4]
	uint32_t data;

	if (!(iflag & SERCOM_SPI_INTFLAG_RXC)) {
    5d6e:	68bb      	ldr	r3, [r7, #8]
    5d70:	2204      	movs	r2, #4
    5d72:	4013      	ands	r3, r2
    5d74:	d101      	bne.n	5d7a <_spi_rx_check+0x18>
		return false;
    5d76:	2300      	movs	r3, #0
    5d78:	e024      	b.n	5dc4 <_spi_rx_check+0x62>
	}

	data = hri_sercomspi_read_DATA_reg(hw);
    5d7a:	68fb      	ldr	r3, [r7, #12]
    5d7c:	0018      	movs	r0, r3
    5d7e:	f7ff f9c7 	bl	5110 <hri_sercomspi_read_DATA_reg>
    5d82:	0003      	movs	r3, r0
    5d84:	617b      	str	r3, [r7, #20]

	if (ctrl->rxbuf) {
    5d86:	687b      	ldr	r3, [r7, #4]
    5d88:	685b      	ldr	r3, [r3, #4]
    5d8a:	2b00      	cmp	r3, #0
    5d8c:	d014      	beq.n	5db8 <_spi_rx_check+0x56>
		*ctrl->rxbuf++ = (uint8_t)data;
    5d8e:	687b      	ldr	r3, [r7, #4]
    5d90:	685b      	ldr	r3, [r3, #4]
    5d92:	1c59      	adds	r1, r3, #1
    5d94:	687a      	ldr	r2, [r7, #4]
    5d96:	6051      	str	r1, [r2, #4]
    5d98:	697a      	ldr	r2, [r7, #20]
    5d9a:	b2d2      	uxtb	r2, r2
    5d9c:	701a      	strb	r2, [r3, #0]

		if (ctrl->char_size > 1) {
    5d9e:	687b      	ldr	r3, [r7, #4]
    5da0:	7c1b      	ldrb	r3, [r3, #16]
    5da2:	2b01      	cmp	r3, #1
    5da4:	d908      	bls.n	5db8 <_spi_rx_check+0x56>
			*ctrl->rxbuf++ = (uint8_t)(data >> 8);
    5da6:	687b      	ldr	r3, [r7, #4]
    5da8:	685b      	ldr	r3, [r3, #4]
    5daa:	1c59      	adds	r1, r3, #1
    5dac:	687a      	ldr	r2, [r7, #4]
    5dae:	6051      	str	r1, [r2, #4]
    5db0:	697a      	ldr	r2, [r7, #20]
    5db2:	0a12      	lsrs	r2, r2, #8
    5db4:	b2d2      	uxtb	r2, r2
    5db6:	701a      	strb	r2, [r3, #0]
		}
	}

	ctrl->rxcnt++;
    5db8:	687b      	ldr	r3, [r7, #4]
    5dba:	68db      	ldr	r3, [r3, #12]
    5dbc:	1c5a      	adds	r2, r3, #1
    5dbe:	687b      	ldr	r3, [r7, #4]
    5dc0:	60da      	str	r2, [r3, #12]
	return true;
    5dc2:	2301      	movs	r3, #1
}
    5dc4:	0018      	movs	r0, r3
    5dc6:	46bd      	mov	sp, r7
    5dc8:	b006      	add	sp, #24
    5dca:	bd80      	pop	{r7, pc}

00005dcc <_spi_tx_check>:

/** Check interrupt flag of DRE and update transaction runtime information. */
static inline void _spi_tx_check(void *const hw, const uint32_t iflag, struct _spi_trans_ctrl *ctrl)
{
    5dcc:	b580      	push	{r7, lr}
    5dce:	b086      	sub	sp, #24
    5dd0:	af00      	add	r7, sp, #0
    5dd2:	60f8      	str	r0, [r7, #12]
    5dd4:	60b9      	str	r1, [r7, #8]
    5dd6:	607a      	str	r2, [r7, #4]
	uint32_t data;

	if (!(SERCOM_SPI_INTFLAG_DRE & iflag)) {
    5dd8:	68bb      	ldr	r3, [r7, #8]
    5dda:	2201      	movs	r2, #1
    5ddc:	4013      	ands	r3, r2
    5dde:	d02b      	beq.n	5e38 <_spi_tx_check+0x6c>
		return;
	}

	if (ctrl->txbuf) {
    5de0:	687b      	ldr	r3, [r7, #4]
    5de2:	681b      	ldr	r3, [r3, #0]
    5de4:	2b00      	cmp	r3, #0
    5de6:	d018      	beq.n	5e1a <_spi_tx_check+0x4e>
		data = *ctrl->txbuf++;
    5de8:	687b      	ldr	r3, [r7, #4]
    5dea:	681b      	ldr	r3, [r3, #0]
    5dec:	1c59      	adds	r1, r3, #1
    5dee:	687a      	ldr	r2, [r7, #4]
    5df0:	6011      	str	r1, [r2, #0]
    5df2:	781b      	ldrb	r3, [r3, #0]
    5df4:	617b      	str	r3, [r7, #20]

		if (ctrl->char_size > 1) {
    5df6:	687b      	ldr	r3, [r7, #4]
    5df8:	7c1b      	ldrb	r3, [r3, #16]
    5dfa:	2b01      	cmp	r3, #1
    5dfc:	d90f      	bls.n	5e1e <_spi_tx_check+0x52>
			data |= (*ctrl->txbuf) << 8;
    5dfe:	687b      	ldr	r3, [r7, #4]
    5e00:	681b      	ldr	r3, [r3, #0]
    5e02:	781b      	ldrb	r3, [r3, #0]
    5e04:	021b      	lsls	r3, r3, #8
    5e06:	001a      	movs	r2, r3
    5e08:	697b      	ldr	r3, [r7, #20]
    5e0a:	4313      	orrs	r3, r2
    5e0c:	617b      	str	r3, [r7, #20]
			ctrl->txbuf++;
    5e0e:	687b      	ldr	r3, [r7, #4]
    5e10:	681b      	ldr	r3, [r3, #0]
    5e12:	1c5a      	adds	r2, r3, #1
    5e14:	687b      	ldr	r3, [r7, #4]
    5e16:	601a      	str	r2, [r3, #0]
    5e18:	e001      	b.n	5e1e <_spi_tx_check+0x52>
		}
	} else {
		data = SPI_DUMMY_CHAR;
    5e1a:	4b09      	ldr	r3, [pc, #36]	; (5e40 <_spi_tx_check+0x74>)
    5e1c:	617b      	str	r3, [r7, #20]
	}

	ctrl->txcnt++;
    5e1e:	687b      	ldr	r3, [r7, #4]
    5e20:	689b      	ldr	r3, [r3, #8]
    5e22:	1c5a      	adds	r2, r3, #1
    5e24:	687b      	ldr	r3, [r7, #4]
    5e26:	609a      	str	r2, [r3, #8]
	hri_sercomspi_write_DATA_reg(hw, data);
    5e28:	697b      	ldr	r3, [r7, #20]
    5e2a:	b29a      	uxth	r2, r3
    5e2c:	68fb      	ldr	r3, [r7, #12]
    5e2e:	0011      	movs	r1, r2
    5e30:	0018      	movs	r0, r3
    5e32:	f7ff f95e 	bl	50f2 <hri_sercomspi_write_DATA_reg>
    5e36:	e000      	b.n	5e3a <_spi_tx_check+0x6e>
		return;
    5e38:	46c0      	nop			; (mov r8, r8)
}
    5e3a:	46bd      	mov	sp, r7
    5e3c:	b006      	add	sp, #24
    5e3e:	bd80      	pop	{r7, pc}
    5e40:	000001ff 	.word	0x000001ff

00005e44 <_spi_m_sync_trans>:

int32_t _spi_m_sync_trans(struct _spi_m_sync_dev *dev, const struct spi_msg *msg)
{
    5e44:	b580      	push	{r7, lr}
    5e46:	b08a      	sub	sp, #40	; 0x28
    5e48:	af00      	add	r7, sp, #0
    5e4a:	6078      	str	r0, [r7, #4]
    5e4c:	6039      	str	r1, [r7, #0]
	void *                 hw   = dev->prvt;
    5e4e:	687b      	ldr	r3, [r7, #4]
    5e50:	681b      	ldr	r3, [r3, #0]
    5e52:	627b      	str	r3, [r7, #36]	; 0x24
	int32_t                rc   = 0;
    5e54:	2300      	movs	r3, #0
    5e56:	623b      	str	r3, [r7, #32]
	struct _spi_trans_ctrl ctrl = {msg->txbuf, msg->rxbuf, 0, 0, dev->char_size};
    5e58:	683b      	ldr	r3, [r7, #0]
    5e5a:	681a      	ldr	r2, [r3, #0]
    5e5c:	2308      	movs	r3, #8
    5e5e:	18fb      	adds	r3, r7, r3
    5e60:	601a      	str	r2, [r3, #0]
    5e62:	683b      	ldr	r3, [r7, #0]
    5e64:	685a      	ldr	r2, [r3, #4]
    5e66:	2308      	movs	r3, #8
    5e68:	18fb      	adds	r3, r7, r3
    5e6a:	605a      	str	r2, [r3, #4]
    5e6c:	2308      	movs	r3, #8
    5e6e:	18fb      	adds	r3, r7, r3
    5e70:	2200      	movs	r2, #0
    5e72:	609a      	str	r2, [r3, #8]
    5e74:	2308      	movs	r3, #8
    5e76:	18fb      	adds	r3, r7, r3
    5e78:	2200      	movs	r2, #0
    5e7a:	60da      	str	r2, [r3, #12]
    5e7c:	687b      	ldr	r3, [r7, #4]
    5e7e:	791a      	ldrb	r2, [r3, #4]
    5e80:	2308      	movs	r3, #8
    5e82:	18fb      	adds	r3, r7, r3
    5e84:	741a      	strb	r2, [r3, #16]

	ASSERT(dev && hw);
    5e86:	687b      	ldr	r3, [r7, #4]
    5e88:	2b00      	cmp	r3, #0
    5e8a:	d004      	beq.n	5e96 <_spi_m_sync_trans+0x52>
    5e8c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    5e8e:	2b00      	cmp	r3, #0
    5e90:	d001      	beq.n	5e96 <_spi_m_sync_trans+0x52>
    5e92:	2301      	movs	r3, #1
    5e94:	e000      	b.n	5e98 <_spi_m_sync_trans+0x54>
    5e96:	2300      	movs	r3, #0
    5e98:	1c1a      	adds	r2, r3, #0
    5e9a:	2301      	movs	r3, #1
    5e9c:	4013      	ands	r3, r2
    5e9e:	b2db      	uxtb	r3, r3
    5ea0:	4a2d      	ldr	r2, [pc, #180]	; (5f58 <_spi_m_sync_trans+0x114>)
    5ea2:	492e      	ldr	r1, [pc, #184]	; (5f5c <_spi_m_sync_trans+0x118>)
    5ea4:	0018      	movs	r0, r3
    5ea6:	f7fe fa3b 	bl	4320 <assert>

	/* If settings are not applied (pending), we can not go on */
	if (hri_sercomspi_is_syncing(hw)) {
    5eaa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    5eac:	0018      	movs	r0, r3
    5eae:	f7fe feb5 	bl	4c1c <hri_sercomspi_is_syncing>
    5eb2:	1e03      	subs	r3, r0, #0
    5eb4:	d002      	beq.n	5ebc <_spi_m_sync_trans+0x78>
		return ERR_BUSY;
    5eb6:	2304      	movs	r3, #4
    5eb8:	425b      	negs	r3, r3
    5eba:	e048      	b.n	5f4e <_spi_m_sync_trans+0x10a>
	}

	/* SPI must be enabled to start synchronous transfer */
	if (!hri_sercomspi_get_CTRLA_ENABLE_bit(hw)) {
    5ebc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    5ebe:	0018      	movs	r0, r3
    5ec0:	f7fe ff9f 	bl	4e02 <hri_sercomspi_get_CTRLA_ENABLE_bit>
    5ec4:	0003      	movs	r3, r0
    5ec6:	001a      	movs	r2, r3
    5ec8:	2301      	movs	r3, #1
    5eca:	4053      	eors	r3, r2
    5ecc:	b2db      	uxtb	r3, r3
    5ece:	2b00      	cmp	r3, #0
    5ed0:	d002      	beq.n	5ed8 <_spi_m_sync_trans+0x94>
		return ERR_NOT_INITIALIZED;
    5ed2:	2314      	movs	r3, #20
    5ed4:	425b      	negs	r3, r3
    5ed6:	e03a      	b.n	5f4e <_spi_m_sync_trans+0x10a>
	}

	for (;;) {
		uint32_t iflag = hri_sercomspi_read_INTFLAG_reg(hw);
    5ed8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    5eda:	0018      	movs	r0, r3
    5edc:	f7fe fefb 	bl	4cd6 <hri_sercomspi_read_INTFLAG_reg>
    5ee0:	0003      	movs	r3, r0
    5ee2:	61fb      	str	r3, [r7, #28]

		if (!_spi_rx_check(hw, iflag, &ctrl)) {
    5ee4:	2308      	movs	r3, #8
    5ee6:	18fa      	adds	r2, r7, r3
    5ee8:	69f9      	ldr	r1, [r7, #28]
    5eea:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    5eec:	0018      	movs	r0, r3
    5eee:	f7ff ff38 	bl	5d62 <_spi_rx_check>
    5ef2:	0003      	movs	r3, r0
    5ef4:	001a      	movs	r2, r3
    5ef6:	2301      	movs	r3, #1
    5ef8:	4053      	eors	r3, r2
    5efa:	b2db      	uxtb	r3, r3
    5efc:	2b00      	cmp	r3, #0
    5efe:	d00e      	beq.n	5f1e <_spi_m_sync_trans+0xda>
			/* In master mode, do not start next byte before previous byte received
			 * to make better output waveform */
			if (ctrl.rxcnt >= ctrl.txcnt) {
    5f00:	2308      	movs	r3, #8
    5f02:	18fb      	adds	r3, r7, r3
    5f04:	68da      	ldr	r2, [r3, #12]
    5f06:	2308      	movs	r3, #8
    5f08:	18fb      	adds	r3, r7, r3
    5f0a:	689b      	ldr	r3, [r3, #8]
    5f0c:	429a      	cmp	r2, r3
    5f0e:	d306      	bcc.n	5f1e <_spi_m_sync_trans+0xda>
				_spi_tx_check(hw, iflag, &ctrl);
    5f10:	2308      	movs	r3, #8
    5f12:	18fa      	adds	r2, r7, r3
    5f14:	69f9      	ldr	r1, [r7, #28]
    5f16:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    5f18:	0018      	movs	r0, r3
    5f1a:	f7ff ff57 	bl	5dcc <_spi_tx_check>
			}
		}

		if (ctrl.txcnt >= msg->size && ctrl.rxcnt >= msg->size) {
    5f1e:	2308      	movs	r3, #8
    5f20:	18fb      	adds	r3, r7, r3
    5f22:	689a      	ldr	r2, [r3, #8]
    5f24:	683b      	ldr	r3, [r7, #0]
    5f26:	689b      	ldr	r3, [r3, #8]
    5f28:	429a      	cmp	r2, r3
    5f2a:	d3d5      	bcc.n	5ed8 <_spi_m_sync_trans+0x94>
    5f2c:	2308      	movs	r3, #8
    5f2e:	18fb      	adds	r3, r7, r3
    5f30:	68da      	ldr	r2, [r3, #12]
    5f32:	683b      	ldr	r3, [r7, #0]
    5f34:	689b      	ldr	r3, [r3, #8]
    5f36:	429a      	cmp	r2, r3
    5f38:	d3ce      	bcc.n	5ed8 <_spi_m_sync_trans+0x94>
			rc = ctrl.txcnt;
    5f3a:	2308      	movs	r3, #8
    5f3c:	18fb      	adds	r3, r7, r3
    5f3e:	689b      	ldr	r3, [r3, #8]
    5f40:	623b      	str	r3, [r7, #32]
			break;
    5f42:	46c0      	nop			; (mov r8, r8)
		}
	}
	/* Wait until SPI bus idle */
	_spi_wait_bus_idle(hw);
    5f44:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    5f46:	0018      	movs	r0, r3
    5f48:	f7ff fef6 	bl	5d38 <_spi_wait_bus_idle>

	return rc;
    5f4c:	6a3b      	ldr	r3, [r7, #32]
}
    5f4e:	0018      	movs	r0, r3
    5f50:	46bd      	mov	sp, r7
    5f52:	b00a      	add	sp, #40	; 0x28
    5f54:	bd80      	pop	{r7, pc}
    5f56:	46c0      	nop			; (mov r8, r8)
    5f58:	00000a01 	.word	0x00000a01
    5f5c:	00008b30 	.word	0x00008b30

00005f60 <hri_gclk_get_STATUS_SYNCBUSY_bit>:
{
    5f60:	b580      	push	{r7, lr}
    5f62:	b082      	sub	sp, #8
    5f64:	af00      	add	r7, sp, #0
    5f66:	6078      	str	r0, [r7, #4]
	return (((Gclk *)hw)->STATUS.reg & GCLK_STATUS_SYNCBUSY) >> GCLK_STATUS_SYNCBUSY_Pos;
    5f68:	687b      	ldr	r3, [r7, #4]
    5f6a:	785b      	ldrb	r3, [r3, #1]
    5f6c:	b2db      	uxtb	r3, r3
    5f6e:	09db      	lsrs	r3, r3, #7
    5f70:	2201      	movs	r2, #1
    5f72:	4013      	ands	r3, r2
    5f74:	1e5a      	subs	r2, r3, #1
    5f76:	4193      	sbcs	r3, r2
    5f78:	b2db      	uxtb	r3, r3
}
    5f7a:	0018      	movs	r0, r3
    5f7c:	46bd      	mov	sp, r7
    5f7e:	b002      	add	sp, #8
    5f80:	bd80      	pop	{r7, pc}

00005f82 <hri_sysctrl_get_PCLKSR_OSC32KRDY_bit>:
{
	return (((Sysctrl *)hw)->PCLKSR.reg & SYSCTRL_PCLKSR_XOSC32KRDY) >> SYSCTRL_PCLKSR_XOSC32KRDY_Pos;
}

static inline bool hri_sysctrl_get_PCLKSR_OSC32KRDY_bit(const void *const hw)
{
    5f82:	b580      	push	{r7, lr}
    5f84:	b082      	sub	sp, #8
    5f86:	af00      	add	r7, sp, #0
    5f88:	6078      	str	r0, [r7, #4]
	return (((Sysctrl *)hw)->PCLKSR.reg & SYSCTRL_PCLKSR_OSC32KRDY) >> SYSCTRL_PCLKSR_OSC32KRDY_Pos;
    5f8a:	687b      	ldr	r3, [r7, #4]
    5f8c:	68db      	ldr	r3, [r3, #12]
    5f8e:	089b      	lsrs	r3, r3, #2
    5f90:	2201      	movs	r2, #1
    5f92:	4013      	ands	r3, r2
    5f94:	1e5a      	subs	r2, r3, #1
    5f96:	4193      	sbcs	r3, r2
    5f98:	b2db      	uxtb	r3, r3
}
    5f9a:	0018      	movs	r0, r3
    5f9c:	46bd      	mov	sp, r7
    5f9e:	b002      	add	sp, #8
    5fa0:	bd80      	pop	{r7, pc}

00005fa2 <hri_sysctrl_get_PCLKSR_OSC8MRDY_bit>:

static inline bool hri_sysctrl_get_PCLKSR_OSC8MRDY_bit(const void *const hw)
{
    5fa2:	b580      	push	{r7, lr}
    5fa4:	b082      	sub	sp, #8
    5fa6:	af00      	add	r7, sp, #0
    5fa8:	6078      	str	r0, [r7, #4]
	return (((Sysctrl *)hw)->PCLKSR.reg & SYSCTRL_PCLKSR_OSC8MRDY) >> SYSCTRL_PCLKSR_OSC8MRDY_Pos;
    5faa:	687b      	ldr	r3, [r7, #4]
    5fac:	68db      	ldr	r3, [r3, #12]
    5fae:	08db      	lsrs	r3, r3, #3
    5fb0:	2201      	movs	r2, #1
    5fb2:	4013      	ands	r3, r2
    5fb4:	1e5a      	subs	r2, r3, #1
    5fb6:	4193      	sbcs	r3, r2
    5fb8:	b2db      	uxtb	r3, r3
}
    5fba:	0018      	movs	r0, r3
    5fbc:	46bd      	mov	sp, r7
    5fbe:	b002      	add	sp, #8
    5fc0:	bd80      	pop	{r7, pc}

00005fc2 <hri_sysctrl_get_PCLKSR_DFLLRDY_bit>:

static inline bool hri_sysctrl_get_PCLKSR_DFLLRDY_bit(const void *const hw)
{
    5fc2:	b580      	push	{r7, lr}
    5fc4:	b082      	sub	sp, #8
    5fc6:	af00      	add	r7, sp, #0
    5fc8:	6078      	str	r0, [r7, #4]
	return (((Sysctrl *)hw)->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY) >> SYSCTRL_PCLKSR_DFLLRDY_Pos;
    5fca:	687b      	ldr	r3, [r7, #4]
    5fcc:	68db      	ldr	r3, [r3, #12]
    5fce:	091b      	lsrs	r3, r3, #4
    5fd0:	2201      	movs	r2, #1
    5fd2:	4013      	ands	r3, r2
    5fd4:	1e5a      	subs	r2, r3, #1
    5fd6:	4193      	sbcs	r3, r2
    5fd8:	b2db      	uxtb	r3, r3
}
    5fda:	0018      	movs	r0, r3
    5fdc:	46bd      	mov	sp, r7
    5fde:	b002      	add	sp, #8
    5fe0:	bd80      	pop	{r7, pc}

00005fe2 <hri_sysctrl_get_PCLKSR_reg>:
{
	return (((Sysctrl *)hw)->PCLKSR.reg & SYSCTRL_PCLKSR_B33SRDY) >> SYSCTRL_PCLKSR_B33SRDY_Pos;
}

static inline hri_sysctrl_pclksr_reg_t hri_sysctrl_get_PCLKSR_reg(const void *const hw, hri_sysctrl_pclksr_reg_t mask)
{
    5fe2:	b580      	push	{r7, lr}
    5fe4:	b084      	sub	sp, #16
    5fe6:	af00      	add	r7, sp, #0
    5fe8:	6078      	str	r0, [r7, #4]
    5fea:	6039      	str	r1, [r7, #0]
	uint32_t tmp;
	tmp = ((Sysctrl *)hw)->PCLKSR.reg;
    5fec:	687b      	ldr	r3, [r7, #4]
    5fee:	68db      	ldr	r3, [r3, #12]
    5ff0:	60fb      	str	r3, [r7, #12]
	tmp &= mask;
    5ff2:	68fb      	ldr	r3, [r7, #12]
    5ff4:	683a      	ldr	r2, [r7, #0]
    5ff6:	4013      	ands	r3, r2
    5ff8:	60fb      	str	r3, [r7, #12]
	return tmp;
    5ffa:	68fb      	ldr	r3, [r7, #12]
}
    5ffc:	0018      	movs	r0, r3
    5ffe:	46bd      	mov	sp, r7
    6000:	b004      	add	sp, #16
    6002:	bd80      	pop	{r7, pc}

00006004 <hri_sysctrl_set_OSC32K_ONDEMAND_bit>:
	((Sysctrl *)hw)->OSC32K.reg ^= SYSCTRL_OSC32K_RUNSTDBY;
	SYSCTRL_CRITICAL_SECTION_LEAVE();
}

static inline void hri_sysctrl_set_OSC32K_ONDEMAND_bit(const void *const hw)
{
    6004:	b580      	push	{r7, lr}
    6006:	b082      	sub	sp, #8
    6008:	af00      	add	r7, sp, #0
    600a:	6078      	str	r0, [r7, #4]
	SYSCTRL_CRITICAL_SECTION_ENTER();
	((Sysctrl *)hw)->OSC32K.reg |= SYSCTRL_OSC32K_ONDEMAND;
    600c:	687b      	ldr	r3, [r7, #4]
    600e:	699b      	ldr	r3, [r3, #24]
    6010:	2280      	movs	r2, #128	; 0x80
    6012:	431a      	orrs	r2, r3
    6014:	687b      	ldr	r3, [r7, #4]
    6016:	619a      	str	r2, [r3, #24]
	SYSCTRL_CRITICAL_SECTION_LEAVE();
}
    6018:	46c0      	nop			; (mov r8, r8)
    601a:	46bd      	mov	sp, r7
    601c:	b002      	add	sp, #8
    601e:	bd80      	pop	{r7, pc}

00006020 <hri_sysctrl_read_OSC32K_CALIB_bf>:
	((Sysctrl *)hw)->OSC32K.reg ^= SYSCTRL_OSC32K_CALIB(mask);
	SYSCTRL_CRITICAL_SECTION_LEAVE();
}

static inline hri_sysctrl_osc32k_reg_t hri_sysctrl_read_OSC32K_CALIB_bf(const void *const hw)
{
    6020:	b580      	push	{r7, lr}
    6022:	b084      	sub	sp, #16
    6024:	af00      	add	r7, sp, #0
    6026:	6078      	str	r0, [r7, #4]
	uint32_t tmp;
	tmp = ((Sysctrl *)hw)->OSC32K.reg;
    6028:	687b      	ldr	r3, [r7, #4]
    602a:	699b      	ldr	r3, [r3, #24]
    602c:	60fb      	str	r3, [r7, #12]
	tmp = (tmp & SYSCTRL_OSC32K_CALIB_Msk) >> SYSCTRL_OSC32K_CALIB_Pos;
    602e:	68fb      	ldr	r3, [r7, #12]
    6030:	0c1b      	lsrs	r3, r3, #16
    6032:	227f      	movs	r2, #127	; 0x7f
    6034:	4013      	ands	r3, r2
    6036:	60fb      	str	r3, [r7, #12]
	return tmp;
    6038:	68fb      	ldr	r3, [r7, #12]
}
    603a:	0018      	movs	r0, r3
    603c:	46bd      	mov	sp, r7
    603e:	b004      	add	sp, #16
    6040:	bd80      	pop	{r7, pc}

00006042 <hri_sysctrl_write_OSC32K_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sysctrl_write_OSC32K_reg(const void *const hw, hri_sysctrl_osc32k_reg_t data)
{
    6042:	b580      	push	{r7, lr}
    6044:	b082      	sub	sp, #8
    6046:	af00      	add	r7, sp, #0
    6048:	6078      	str	r0, [r7, #4]
    604a:	6039      	str	r1, [r7, #0]
	SYSCTRL_CRITICAL_SECTION_ENTER();
	((Sysctrl *)hw)->OSC32K.reg = data;
    604c:	687b      	ldr	r3, [r7, #4]
    604e:	683a      	ldr	r2, [r7, #0]
    6050:	619a      	str	r2, [r3, #24]
	SYSCTRL_CRITICAL_SECTION_LEAVE();
}
    6052:	46c0      	nop			; (mov r8, r8)
    6054:	46bd      	mov	sp, r7
    6056:	b002      	add	sp, #8
    6058:	bd80      	pop	{r7, pc}

0000605a <hri_sysctrl_read_OSCULP32K_CALIB_bf>:
	((Sysctrl *)hw)->OSCULP32K.reg ^= SYSCTRL_OSCULP32K_CALIB(mask);
	SYSCTRL_CRITICAL_SECTION_LEAVE();
}

static inline hri_sysctrl_osculp32k_reg_t hri_sysctrl_read_OSCULP32K_CALIB_bf(const void *const hw)
{
    605a:	b580      	push	{r7, lr}
    605c:	b084      	sub	sp, #16
    605e:	af00      	add	r7, sp, #0
    6060:	6078      	str	r0, [r7, #4]
	uint8_t tmp;
	tmp = ((Sysctrl *)hw)->OSCULP32K.reg;
    6062:	230f      	movs	r3, #15
    6064:	18fb      	adds	r3, r7, r3
    6066:	687a      	ldr	r2, [r7, #4]
    6068:	7f12      	ldrb	r2, [r2, #28]
    606a:	701a      	strb	r2, [r3, #0]
	tmp = (tmp & SYSCTRL_OSCULP32K_CALIB_Msk) >> SYSCTRL_OSCULP32K_CALIB_Pos;
    606c:	230f      	movs	r3, #15
    606e:	18fb      	adds	r3, r7, r3
    6070:	220f      	movs	r2, #15
    6072:	18ba      	adds	r2, r7, r2
    6074:	7812      	ldrb	r2, [r2, #0]
    6076:	211f      	movs	r1, #31
    6078:	400a      	ands	r2, r1
    607a:	701a      	strb	r2, [r3, #0]
	return tmp;
    607c:	230f      	movs	r3, #15
    607e:	18fb      	adds	r3, r7, r3
    6080:	781b      	ldrb	r3, [r3, #0]
}
    6082:	0018      	movs	r0, r3
    6084:	46bd      	mov	sp, r7
    6086:	b004      	add	sp, #16
    6088:	bd80      	pop	{r7, pc}

0000608a <hri_sysctrl_write_OSCULP32K_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sysctrl_write_OSCULP32K_reg(const void *const hw, hri_sysctrl_osculp32k_reg_t data)
{
    608a:	b580      	push	{r7, lr}
    608c:	b082      	sub	sp, #8
    608e:	af00      	add	r7, sp, #0
    6090:	6078      	str	r0, [r7, #4]
    6092:	000a      	movs	r2, r1
    6094:	1cfb      	adds	r3, r7, #3
    6096:	701a      	strb	r2, [r3, #0]
	SYSCTRL_CRITICAL_SECTION_ENTER();
	((Sysctrl *)hw)->OSCULP32K.reg = data;
    6098:	687b      	ldr	r3, [r7, #4]
    609a:	1cfa      	adds	r2, r7, #3
    609c:	7812      	ldrb	r2, [r2, #0]
    609e:	771a      	strb	r2, [r3, #28]
	SYSCTRL_CRITICAL_SECTION_LEAVE();
}
    60a0:	46c0      	nop			; (mov r8, r8)
    60a2:	46bd      	mov	sp, r7
    60a4:	b002      	add	sp, #8
    60a6:	bd80      	pop	{r7, pc}

000060a8 <hri_sysctrl_set_OSC8M_ONDEMAND_bit>:
	((Sysctrl *)hw)->OSC8M.reg ^= SYSCTRL_OSC8M_RUNSTDBY;
	SYSCTRL_CRITICAL_SECTION_LEAVE();
}

static inline void hri_sysctrl_set_OSC8M_ONDEMAND_bit(const void *const hw)
{
    60a8:	b580      	push	{r7, lr}
    60aa:	b082      	sub	sp, #8
    60ac:	af00      	add	r7, sp, #0
    60ae:	6078      	str	r0, [r7, #4]
	SYSCTRL_CRITICAL_SECTION_ENTER();
	((Sysctrl *)hw)->OSC8M.reg |= SYSCTRL_OSC8M_ONDEMAND;
    60b0:	687b      	ldr	r3, [r7, #4]
    60b2:	6a1b      	ldr	r3, [r3, #32]
    60b4:	2280      	movs	r2, #128	; 0x80
    60b6:	431a      	orrs	r2, r3
    60b8:	687b      	ldr	r3, [r7, #4]
    60ba:	621a      	str	r2, [r3, #32]
	SYSCTRL_CRITICAL_SECTION_LEAVE();
}
    60bc:	46c0      	nop			; (mov r8, r8)
    60be:	46bd      	mov	sp, r7
    60c0:	b002      	add	sp, #8
    60c2:	bd80      	pop	{r7, pc}

000060c4 <hri_sysctrl_read_OSC8M_CALIB_bf>:
	((Sysctrl *)hw)->OSC8M.reg ^= SYSCTRL_OSC8M_CALIB(mask);
	SYSCTRL_CRITICAL_SECTION_LEAVE();
}

static inline hri_sysctrl_osc8m_reg_t hri_sysctrl_read_OSC8M_CALIB_bf(const void *const hw)
{
    60c4:	b580      	push	{r7, lr}
    60c6:	b084      	sub	sp, #16
    60c8:	af00      	add	r7, sp, #0
    60ca:	6078      	str	r0, [r7, #4]
	uint32_t tmp;
	tmp = ((Sysctrl *)hw)->OSC8M.reg;
    60cc:	687b      	ldr	r3, [r7, #4]
    60ce:	6a1b      	ldr	r3, [r3, #32]
    60d0:	60fb      	str	r3, [r7, #12]
	tmp = (tmp & SYSCTRL_OSC8M_CALIB_Msk) >> SYSCTRL_OSC8M_CALIB_Pos;
    60d2:	68fb      	ldr	r3, [r7, #12]
    60d4:	0c1b      	lsrs	r3, r3, #16
    60d6:	051b      	lsls	r3, r3, #20
    60d8:	0d1b      	lsrs	r3, r3, #20
    60da:	60fb      	str	r3, [r7, #12]
	return tmp;
    60dc:	68fb      	ldr	r3, [r7, #12]
}
    60de:	0018      	movs	r0, r3
    60e0:	46bd      	mov	sp, r7
    60e2:	b004      	add	sp, #16
    60e4:	bd80      	pop	{r7, pc}

000060e6 <hri_sysctrl_read_OSC8M_FRANGE_bf>:
	((Sysctrl *)hw)->OSC8M.reg ^= SYSCTRL_OSC8M_FRANGE(mask);
	SYSCTRL_CRITICAL_SECTION_LEAVE();
}

static inline hri_sysctrl_osc8m_reg_t hri_sysctrl_read_OSC8M_FRANGE_bf(const void *const hw)
{
    60e6:	b580      	push	{r7, lr}
    60e8:	b084      	sub	sp, #16
    60ea:	af00      	add	r7, sp, #0
    60ec:	6078      	str	r0, [r7, #4]
	uint32_t tmp;
	tmp = ((Sysctrl *)hw)->OSC8M.reg;
    60ee:	687b      	ldr	r3, [r7, #4]
    60f0:	6a1b      	ldr	r3, [r3, #32]
    60f2:	60fb      	str	r3, [r7, #12]
	tmp = (tmp & SYSCTRL_OSC8M_FRANGE_Msk) >> SYSCTRL_OSC8M_FRANGE_Pos;
    60f4:	68fb      	ldr	r3, [r7, #12]
    60f6:	0f9b      	lsrs	r3, r3, #30
    60f8:	60fb      	str	r3, [r7, #12]
	return tmp;
    60fa:	68fb      	ldr	r3, [r7, #12]
}
    60fc:	0018      	movs	r0, r3
    60fe:	46bd      	mov	sp, r7
    6100:	b004      	add	sp, #16
    6102:	bd80      	pop	{r7, pc}

00006104 <hri_sysctrl_write_OSC8M_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sysctrl_write_OSC8M_reg(const void *const hw, hri_sysctrl_osc8m_reg_t data)
{
    6104:	b580      	push	{r7, lr}
    6106:	b082      	sub	sp, #8
    6108:	af00      	add	r7, sp, #0
    610a:	6078      	str	r0, [r7, #4]
    610c:	6039      	str	r1, [r7, #0]
	SYSCTRL_CRITICAL_SECTION_ENTER();
	((Sysctrl *)hw)->OSC8M.reg = data;
    610e:	687b      	ldr	r3, [r7, #4]
    6110:	683a      	ldr	r2, [r7, #0]
    6112:	621a      	str	r2, [r3, #32]
	SYSCTRL_CRITICAL_SECTION_LEAVE();
}
    6114:	46c0      	nop			; (mov r8, r8)
    6116:	46bd      	mov	sp, r7
    6118:	b002      	add	sp, #8
    611a:	bd80      	pop	{r7, pc}

0000611c <hri_sysctrl_get_DFLLCTRL_MODE_bit>:
	((Sysctrl *)hw)->DFLLCTRL.reg |= SYSCTRL_DFLLCTRL_MODE;
	SYSCTRL_CRITICAL_SECTION_LEAVE();
}

static inline bool hri_sysctrl_get_DFLLCTRL_MODE_bit(const void *const hw)
{
    611c:	b580      	push	{r7, lr}
    611e:	b084      	sub	sp, #16
    6120:	af00      	add	r7, sp, #0
    6122:	6078      	str	r0, [r7, #4]
	uint16_t tmp;
	tmp = ((Sysctrl *)hw)->DFLLCTRL.reg;
    6124:	230e      	movs	r3, #14
    6126:	18fb      	adds	r3, r7, r3
    6128:	687a      	ldr	r2, [r7, #4]
    612a:	8c92      	ldrh	r2, [r2, #36]	; 0x24
    612c:	801a      	strh	r2, [r3, #0]
	tmp = (tmp & SYSCTRL_DFLLCTRL_MODE) >> SYSCTRL_DFLLCTRL_MODE_Pos;
    612e:	230e      	movs	r3, #14
    6130:	18fb      	adds	r3, r7, r3
    6132:	881b      	ldrh	r3, [r3, #0]
    6134:	089b      	lsrs	r3, r3, #2
    6136:	b29a      	uxth	r2, r3
    6138:	230e      	movs	r3, #14
    613a:	18fb      	adds	r3, r7, r3
    613c:	2101      	movs	r1, #1
    613e:	400a      	ands	r2, r1
    6140:	801a      	strh	r2, [r3, #0]
	return (bool)tmp;
    6142:	230e      	movs	r3, #14
    6144:	18fb      	adds	r3, r7, r3
    6146:	881b      	ldrh	r3, [r3, #0]
    6148:	1e5a      	subs	r2, r3, #1
    614a:	4193      	sbcs	r3, r2
    614c:	b2db      	uxtb	r3, r3
}
    614e:	0018      	movs	r0, r3
    6150:	46bd      	mov	sp, r7
    6152:	b004      	add	sp, #16
    6154:	bd80      	pop	{r7, pc}

00006156 <hri_sysctrl_set_DFLLCTRL_ONDEMAND_bit>:
	((Sysctrl *)hw)->DFLLCTRL.reg ^= SYSCTRL_DFLLCTRL_RUNSTDBY;
	SYSCTRL_CRITICAL_SECTION_LEAVE();
}

static inline void hri_sysctrl_set_DFLLCTRL_ONDEMAND_bit(const void *const hw)
{
    6156:	b580      	push	{r7, lr}
    6158:	b082      	sub	sp, #8
    615a:	af00      	add	r7, sp, #0
    615c:	6078      	str	r0, [r7, #4]
	SYSCTRL_CRITICAL_SECTION_ENTER();
	((Sysctrl *)hw)->DFLLCTRL.reg |= SYSCTRL_DFLLCTRL_ONDEMAND;
    615e:	687b      	ldr	r3, [r7, #4]
    6160:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
    6162:	b29b      	uxth	r3, r3
    6164:	2280      	movs	r2, #128	; 0x80
    6166:	4313      	orrs	r3, r2
    6168:	b29a      	uxth	r2, r3
    616a:	687b      	ldr	r3, [r7, #4]
    616c:	849a      	strh	r2, [r3, #36]	; 0x24
	SYSCTRL_CRITICAL_SECTION_LEAVE();
}
    616e:	46c0      	nop			; (mov r8, r8)
    6170:	46bd      	mov	sp, r7
    6172:	b002      	add	sp, #8
    6174:	bd80      	pop	{r7, pc}

00006176 <hri_sysctrl_write_DFLLCTRL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sysctrl_write_DFLLCTRL_reg(const void *const hw, hri_sysctrl_dfllctrl_reg_t data)
{
    6176:	b580      	push	{r7, lr}
    6178:	b082      	sub	sp, #8
    617a:	af00      	add	r7, sp, #0
    617c:	6078      	str	r0, [r7, #4]
    617e:	000a      	movs	r2, r1
    6180:	1cbb      	adds	r3, r7, #2
    6182:	801a      	strh	r2, [r3, #0]
	SYSCTRL_CRITICAL_SECTION_ENTER();
	((Sysctrl *)hw)->DFLLCTRL.reg = data;
    6184:	687b      	ldr	r3, [r7, #4]
    6186:	1cba      	adds	r2, r7, #2
    6188:	8812      	ldrh	r2, [r2, #0]
    618a:	849a      	strh	r2, [r3, #36]	; 0x24
	SYSCTRL_CRITICAL_SECTION_LEAVE();
}
    618c:	46c0      	nop			; (mov r8, r8)
    618e:	46bd      	mov	sp, r7
    6190:	b002      	add	sp, #8
    6192:	bd80      	pop	{r7, pc}

00006194 <hri_sysctrl_write_DFLLVAL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sysctrl_write_DFLLVAL_reg(const void *const hw, hri_sysctrl_dfllval_reg_t data)
{
    6194:	b580      	push	{r7, lr}
    6196:	b082      	sub	sp, #8
    6198:	af00      	add	r7, sp, #0
    619a:	6078      	str	r0, [r7, #4]
    619c:	6039      	str	r1, [r7, #0]
	SYSCTRL_CRITICAL_SECTION_ENTER();
	((Sysctrl *)hw)->DFLLVAL.reg = data;
    619e:	687b      	ldr	r3, [r7, #4]
    61a0:	683a      	ldr	r2, [r7, #0]
    61a2:	629a      	str	r2, [r3, #40]	; 0x28
	SYSCTRL_CRITICAL_SECTION_LEAVE();
}
    61a4:	46c0      	nop			; (mov r8, r8)
    61a6:	46bd      	mov	sp, r7
    61a8:	b002      	add	sp, #8
    61aa:	bd80      	pop	{r7, pc}

000061ac <hri_sysctrl_write_DFLLMUL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sysctrl_write_DFLLMUL_reg(const void *const hw, hri_sysctrl_dfllmul_reg_t data)
{
    61ac:	b580      	push	{r7, lr}
    61ae:	b082      	sub	sp, #8
    61b0:	af00      	add	r7, sp, #0
    61b2:	6078      	str	r0, [r7, #4]
    61b4:	6039      	str	r1, [r7, #0]
	SYSCTRL_CRITICAL_SECTION_ENTER();
	((Sysctrl *)hw)->DFLLMUL.reg = data;
    61b6:	687b      	ldr	r3, [r7, #4]
    61b8:	683a      	ldr	r2, [r7, #0]
    61ba:	62da      	str	r2, [r3, #44]	; 0x2c
	SYSCTRL_CRITICAL_SECTION_LEAVE();
}
    61bc:	46c0      	nop			; (mov r8, r8)
    61be:	46bd      	mov	sp, r7
    61c0:	b002      	add	sp, #8
    61c2:	bd80      	pop	{r7, pc}

000061c4 <_sysctrl_init_sources>:
 * \brief Initializes clock generators
 *
 * All GCLK generators are running when this function returns.
 */
void _sysctrl_init_sources(void)
{
    61c4:	b580      	push	{r7, lr}
    61c6:	b082      	sub	sp, #8
    61c8:	af00      	add	r7, sp, #0
	void *   hw = (void *)SYSCTRL;
    61ca:	4b34      	ldr	r3, [pc, #208]	; (629c <_sysctrl_init_sources+0xd8>)
    61cc:	607b      	str	r3, [r7, #4]
	        | (CONF_XOSC_RUNSTDBY << SYSCTRL_XOSC_RUNSTDBY_Pos) | (CONF_XOSC_XTALEN << SYSCTRL_XOSC_XTALEN_Pos)
	        | (CONF_XOSC_ENABLE << SYSCTRL_XOSC_ENABLE_Pos));
#endif

#if CONF_OSC8M_CONFIG == 1
	calib = hri_sysctrl_read_OSC8M_CALIB_bf(hw);
    61ce:	687b      	ldr	r3, [r7, #4]
    61d0:	0018      	movs	r0, r3
    61d2:	f7ff ff77 	bl	60c4 <hri_sysctrl_read_OSC8M_CALIB_bf>
    61d6:	0002      	movs	r2, r0
    61d8:	1cbb      	adds	r3, r7, #2
    61da:	801a      	strh	r2, [r3, #0]

	hri_sysctrl_write_OSC8M_reg(hw,
	                            SYSCTRL_OSC8M_FRANGE(hri_sysctrl_read_OSC8M_FRANGE_bf(hw)) |
    61dc:	687b      	ldr	r3, [r7, #4]
    61de:	0018      	movs	r0, r3
    61e0:	f7ff ff81 	bl	60e6 <hri_sysctrl_read_OSC8M_FRANGE_bf>
    61e4:	0003      	movs	r3, r0
    61e6:	079a      	lsls	r2, r3, #30
#if CONF_OSC8M_OVERWRITE_CALIBRATION == 1
	                                SYSCTRL_OSC8M_CALIB(CONF_OSC8M_CALIB) |
#else
	                                SYSCTRL_OSC8M_CALIB(calib) |
    61e8:	1cbb      	adds	r3, r7, #2
    61ea:	881b      	ldrh	r3, [r3, #0]
    61ec:	041b      	lsls	r3, r3, #16
    61ee:	0019      	movs	r1, r3
    61f0:	4b2b      	ldr	r3, [pc, #172]	; (62a0 <_sysctrl_init_sources+0xdc>)
    61f2:	400b      	ands	r3, r1
	                            SYSCTRL_OSC8M_FRANGE(hri_sysctrl_read_OSC8M_FRANGE_bf(hw)) |
    61f4:	4313      	orrs	r3, r2
	hri_sysctrl_write_OSC8M_reg(hw,
    61f6:	4a2b      	ldr	r2, [pc, #172]	; (62a4 <_sysctrl_init_sources+0xe0>)
    61f8:	431a      	orrs	r2, r3
    61fa:	687b      	ldr	r3, [r7, #4]
    61fc:	0011      	movs	r1, r2
    61fe:	0018      	movs	r0, r3
    6200:	f7ff ff80 	bl	6104 <hri_sysctrl_write_OSC8M_reg>
	                                | (CONF_OSC8M_RUNSTDBY << SYSCTRL_OSC8M_RUNSTDBY_Pos)
	                                | (CONF_OSC8M_ENABLE << SYSCTRL_OSC8M_ENABLE_Pos));
#endif

#if CONF_OSC32K_CONFIG == 1
	calib = hri_sysctrl_read_OSC32K_CALIB_bf(hw);
    6204:	687b      	ldr	r3, [r7, #4]
    6206:	0018      	movs	r0, r3
    6208:	f7ff ff0a 	bl	6020 <hri_sysctrl_read_OSC32K_CALIB_bf>
    620c:	0002      	movs	r2, r0
    620e:	1cbb      	adds	r3, r7, #2
    6210:	801a      	strh	r2, [r3, #0]
	hri_sysctrl_write_OSC32K_reg(
	    hw,
#if CONF_OSC32K_OVERWRITE_CALIBRATION == 1
	    SYSCTRL_OSC32K_CALIB(CONF_OSC32K_CALIB) |
#else
	    SYSCTRL_OSC32K_CALIB(calib) |
    6212:	1cbb      	adds	r3, r7, #2
    6214:	881b      	ldrh	r3, [r3, #0]
    6216:	041b      	lsls	r3, r3, #16
    6218:	001a      	movs	r2, r3
#endif
	        (CONF_OSC32K_WRTLOCK << SYSCTRL_OSC32K_WRTLOCK_Pos) | SYSCTRL_OSC32K_STARTUP(CONF_OSC32K_STARTUP)
	        | (CONF_OSC32K_RUNSTDBY << SYSCTRL_OSC32K_RUNSTDBY_Pos) | (CONF_OSC32K_EN1K << SYSCTRL_OSC32K_EN1K_Pos)
    621a:	23fe      	movs	r3, #254	; 0xfe
    621c:	03db      	lsls	r3, r3, #15
    621e:	4013      	ands	r3, r2
	        | (CONF_OSC32K_EN32K << SYSCTRL_OSC32K_EN32K_Pos) | (1 << SYSCTRL_OSC32K_ENABLE_Pos));
    6220:	220e      	movs	r2, #14
    6222:	431a      	orrs	r2, r3
	hri_sysctrl_write_OSC32K_reg(
    6224:	687b      	ldr	r3, [r7, #4]
    6226:	0011      	movs	r1, r2
    6228:	0018      	movs	r0, r3
    622a:	f7ff ff0a 	bl	6042 <hri_sysctrl_write_OSC32K_reg>
	/* Enable OSC32K anyway since GCLK configuration may need it to sync */
	hri_sysctrl_set_OSC32K_ENABLE_bit(hw);
#endif

#if CONF_OSCULP32K_CONFIG == 1
	calib = hri_sysctrl_read_OSCULP32K_CALIB_bf(hw);
    622e:	687b      	ldr	r3, [r7, #4]
    6230:	0018      	movs	r0, r3
    6232:	f7ff ff12 	bl	605a <hri_sysctrl_read_OSCULP32K_CALIB_bf>
    6236:	0003      	movs	r3, r0
    6238:	001a      	movs	r2, r3
    623a:	1cbb      	adds	r3, r7, #2
    623c:	801a      	strh	r2, [r3, #0]

	hri_sysctrl_write_OSCULP32K_reg(hw,
    623e:	1cbb      	adds	r3, r7, #2
    6240:	881b      	ldrh	r3, [r3, #0]
    6242:	b2db      	uxtb	r3, r3
    6244:	221f      	movs	r2, #31
    6246:	4013      	ands	r3, r2
    6248:	b2da      	uxtb	r2, r3
    624a:	687b      	ldr	r3, [r7, #4]
    624c:	0011      	movs	r1, r2
    624e:	0018      	movs	r0, r3
    6250:	f7ff ff1b 	bl	608a <hri_sysctrl_write_OSCULP32K_reg>
#endif
#endif

#if CONF_OSC32K_CONFIG == 1
#if CONF_OSC32K_ENABLE == 1
	while (!hri_sysctrl_get_PCLKSR_OSC32KRDY_bit(hw))
    6254:	46c0      	nop			; (mov r8, r8)
    6256:	687b      	ldr	r3, [r7, #4]
    6258:	0018      	movs	r0, r3
    625a:	f7ff fe92 	bl	5f82 <hri_sysctrl_get_PCLKSR_OSC32KRDY_bit>
    625e:	0003      	movs	r3, r0
    6260:	001a      	movs	r2, r3
    6262:	2301      	movs	r3, #1
    6264:	4053      	eors	r3, r2
    6266:	b2db      	uxtb	r3, r3
    6268:	2b00      	cmp	r3, #0
    626a:	d1f4      	bne.n	6256 <_sysctrl_init_sources+0x92>
		;
#endif
#if CONF_OSC32K_ONDEMAND == 1
	hri_sysctrl_set_OSC32K_ONDEMAND_bit(hw);
    626c:	687b      	ldr	r3, [r7, #4]
    626e:	0018      	movs	r0, r3
    6270:	f7ff fec8 	bl	6004 <hri_sysctrl_set_OSC32K_ONDEMAND_bit>
#endif
#endif

#if CONF_OSC8M_CONFIG == 1
#if CONF_OSC8M_ENABLE == 1
	while (!hri_sysctrl_get_PCLKSR_OSC8MRDY_bit(hw))
    6274:	46c0      	nop			; (mov r8, r8)
    6276:	687b      	ldr	r3, [r7, #4]
    6278:	0018      	movs	r0, r3
    627a:	f7ff fe92 	bl	5fa2 <hri_sysctrl_get_PCLKSR_OSC8MRDY_bit>
    627e:	0003      	movs	r3, r0
    6280:	001a      	movs	r2, r3
    6282:	2301      	movs	r3, #1
    6284:	4053      	eors	r3, r2
    6286:	b2db      	uxtb	r3, r3
    6288:	2b00      	cmp	r3, #0
    628a:	d1f4      	bne.n	6276 <_sysctrl_init_sources+0xb2>
		;
#endif
#if CONF_OSC8M_ONDEMAND == 1
	hri_sysctrl_set_OSC8M_ONDEMAND_bit(hw);
    628c:	687b      	ldr	r3, [r7, #4]
    628e:	0018      	movs	r0, r3
    6290:	f7ff ff0a 	bl	60a8 <hri_sysctrl_set_OSC8M_ONDEMAND_bit>
#endif
#endif

	(void)calib, (void)hw;
}
    6294:	46c0      	nop			; (mov r8, r8)
    6296:	46bd      	mov	sp, r7
    6298:	b002      	add	sp, #8
    629a:	bd80      	pop	{r7, pc}
    629c:	40000800 	.word	0x40000800
    62a0:	0fff0000 	.word	0x0fff0000
    62a4:	00000302 	.word	0x00000302

000062a8 <_sysctrl_init_referenced_generators>:

void _sysctrl_init_referenced_generators(void)
{
    62a8:	b580      	push	{r7, lr}
    62aa:	b084      	sub	sp, #16
    62ac:	af00      	add	r7, sp, #0
	void *hw = (void *)SYSCTRL;
    62ae:	4b35      	ldr	r3, [pc, #212]	; (6384 <_sysctrl_init_referenced_generators+0xdc>)
    62b0:	60fb      	str	r3, [r7, #12]
#if CONF_DFLL_MODE != CONF_DFLL_OPEN_LOOP_MODE
	hri_gclk_write_CLKCTRL_reg(GCLK,
	                           GCLK_CLKCTRL_ID(0) | GCLK_CLKCTRL_GEN(CONF_DFLL_GCLK) | (1 << GCLK_CLKCTRL_CLKEN_Pos));
#endif

	hri_sysctrl_write_DFLLCTRL_reg(hw, SYSCTRL_DFLLCTRL_ENABLE);
    62b2:	68fb      	ldr	r3, [r7, #12]
    62b4:	2102      	movs	r1, #2
    62b6:	0018      	movs	r0, r3
    62b8:	f7ff ff5d 	bl	6176 <hri_sysctrl_write_DFLLCTRL_reg>
	while (!hri_sysctrl_get_PCLKSR_DFLLRDY_bit(hw))
    62bc:	46c0      	nop			; (mov r8, r8)
    62be:	68fb      	ldr	r3, [r7, #12]
    62c0:	0018      	movs	r0, r3
    62c2:	f7ff fe7e 	bl	5fc2 <hri_sysctrl_get_PCLKSR_DFLLRDY_bit>
    62c6:	0003      	movs	r3, r0
    62c8:	001a      	movs	r2, r3
    62ca:	2301      	movs	r3, #1
    62cc:	4053      	eors	r3, r2
    62ce:	b2db      	uxtb	r3, r3
    62d0:	2b00      	cmp	r3, #0
    62d2:	d1f4      	bne.n	62be <_sysctrl_init_referenced_generators+0x16>
		;

	hri_sysctrl_write_DFLLMUL_reg(hw,
    62d4:	4a2c      	ldr	r2, [pc, #176]	; (6388 <_sysctrl_init_referenced_generators+0xe0>)
    62d6:	68fb      	ldr	r3, [r7, #12]
    62d8:	0011      	movs	r1, r2
    62da:	0018      	movs	r0, r3
    62dc:	f7ff ff66 	bl	61ac <hri_sysctrl_write_DFLLMUL_reg>
	                              SYSCTRL_DFLLMUL_CSTEP(CONF_DFLL_CSTEP) | SYSCTRL_DFLLMUL_FSTEP(CONF_DFLL_FSTEP)
	                                  | SYSCTRL_DFLLMUL_MUL(CONF_DFLL_MUL));
	hri_sysctrl_write_DFLLVAL_reg(hw, CONF_DFLLVAL);
    62e0:	4b2a      	ldr	r3, [pc, #168]	; (638c <_sysctrl_init_referenced_generators+0xe4>)
    62e2:	681b      	ldr	r3, [r3, #0]
    62e4:	0e9b      	lsrs	r3, r3, #26
    62e6:	2b3f      	cmp	r3, #63	; 0x3f
    62e8:	d009      	beq.n	62fe <_sysctrl_init_referenced_generators+0x56>
    62ea:	4b28      	ldr	r3, [pc, #160]	; (638c <_sysctrl_init_referenced_generators+0xe4>)
    62ec:	681b      	ldr	r3, [r3, #0]
    62ee:	0e9b      	lsrs	r3, r3, #26
    62f0:	029b      	lsls	r3, r3, #10
    62f2:	041b      	lsls	r3, r3, #16
    62f4:	0c1b      	lsrs	r3, r3, #16
    62f6:	2280      	movs	r2, #128	; 0x80
    62f8:	0092      	lsls	r2, r2, #2
    62fa:	4313      	orrs	r3, r2
    62fc:	e001      	b.n	6302 <_sysctrl_init_referenced_generators+0x5a>
    62fe:	23fc      	movs	r3, #252	; 0xfc
    6300:	01db      	lsls	r3, r3, #7
    6302:	68fa      	ldr	r2, [r7, #12]
    6304:	0019      	movs	r1, r3
    6306:	0010      	movs	r0, r2
    6308:	f7ff ff44 	bl	6194 <hri_sysctrl_write_DFLLVAL_reg>

	hri_sysctrl_dfllctrl_reg_t tmp
    630c:	230a      	movs	r3, #10
    630e:	18fb      	adds	r3, r7, r3
    6310:	2202      	movs	r2, #2
    6312:	801a      	strh	r2, [r3, #0]
	    = (CONF_DFLL_QLDIS << SYSCTRL_DFLLCTRL_QLDIS_Pos) | (CONF_DFLL_CCDIS << SYSCTRL_DFLLCTRL_CCDIS_Pos)
	      | (CONF_DFLL_RUNSTDBY << SYSCTRL_DFLLCTRL_RUNSTDBY_Pos) | (CONF_DFLL_LLAW << SYSCTRL_DFLLCTRL_LLAW_Pos)
	      | (CONF_DFLL_STABLE << SYSCTRL_DFLLCTRL_STABLE_Pos) | (CONF_DFLL_MODE << SYSCTRL_DFLLCTRL_MODE_Pos)
	      | (CONF_DFLL_ENABLE << SYSCTRL_DFLLCTRL_ENABLE_Pos);

	hri_sysctrl_write_DFLLCTRL_reg(hw, tmp);
    6314:	230a      	movs	r3, #10
    6316:	18fb      	adds	r3, r7, r3
    6318:	881a      	ldrh	r2, [r3, #0]
    631a:	68fb      	ldr	r3, [r7, #12]
    631c:	0011      	movs	r1, r2
    631e:	0018      	movs	r0, r3
    6320:	f7ff ff29 	bl	6176 <hri_sysctrl_write_DFLLCTRL_reg>
#endif

#if CONF_DFLL_CONFIG == 1
#if CONF_DFLL_ENABLE == 1
	if (hri_sysctrl_get_DFLLCTRL_MODE_bit(hw)) {
    6324:	68fb      	ldr	r3, [r7, #12]
    6326:	0018      	movs	r0, r3
    6328:	f7ff fef8 	bl	611c <hri_sysctrl_get_DFLLCTRL_MODE_bit>
    632c:	1e03      	subs	r3, r0, #0
    632e:	d00d      	beq.n	634c <_sysctrl_init_referenced_generators+0xa4>
		hri_sysctrl_pclksr_reg_t status_mask
    6330:	23d0      	movs	r3, #208	; 0xd0
    6332:	607b      	str	r3, [r7, #4]
		    = SYSCTRL_PCLKSR_DFLLRDY | SYSCTRL_PCLKSR_DFLLLCKF | SYSCTRL_PCLKSR_DFLLLCKC;

		while (hri_sysctrl_get_PCLKSR_reg(hw, status_mask) != status_mask)
    6334:	46c0      	nop			; (mov r8, r8)
    6336:	687a      	ldr	r2, [r7, #4]
    6338:	68fb      	ldr	r3, [r7, #12]
    633a:	0011      	movs	r1, r2
    633c:	0018      	movs	r0, r3
    633e:	f7ff fe50 	bl	5fe2 <hri_sysctrl_get_PCLKSR_reg>
    6342:	0002      	movs	r2, r0
    6344:	687b      	ldr	r3, [r7, #4]
    6346:	429a      	cmp	r2, r3
    6348:	d1f5      	bne.n	6336 <_sysctrl_init_referenced_generators+0x8e>
    634a:	e00b      	b.n	6364 <_sysctrl_init_referenced_generators+0xbc>
			;
	} else {
		while (!hri_sysctrl_get_PCLKSR_DFLLRDY_bit(hw))
    634c:	46c0      	nop			; (mov r8, r8)
    634e:	68fb      	ldr	r3, [r7, #12]
    6350:	0018      	movs	r0, r3
    6352:	f7ff fe36 	bl	5fc2 <hri_sysctrl_get_PCLKSR_DFLLRDY_bit>
    6356:	0003      	movs	r3, r0
    6358:	001a      	movs	r2, r3
    635a:	2301      	movs	r3, #1
    635c:	4053      	eors	r3, r2
    635e:	b2db      	uxtb	r3, r3
    6360:	2b00      	cmp	r3, #0
    6362:	d1f4      	bne.n	634e <_sysctrl_init_referenced_generators+0xa6>
			;
	}
#endif
#if CONF_DFLL_ONDEMAND == 1
	hri_sysctrl_set_DFLLCTRL_ONDEMAND_bit(hw);
    6364:	68fb      	ldr	r3, [r7, #12]
    6366:	0018      	movs	r0, r3
    6368:	f7ff fef5 	bl	6156 <hri_sysctrl_set_DFLLCTRL_ONDEMAND_bit>
#endif
#endif

#if CONF_DFLL_CONFIG == 1
	while (hri_gclk_get_STATUS_SYNCBUSY_bit(GCLK))
    636c:	46c0      	nop			; (mov r8, r8)
    636e:	4b08      	ldr	r3, [pc, #32]	; (6390 <_sysctrl_init_referenced_generators+0xe8>)
    6370:	0018      	movs	r0, r3
    6372:	f7ff fdf5 	bl	5f60 <hri_gclk_get_STATUS_SYNCBUSY_bit>
    6376:	1e03      	subs	r3, r0, #0
    6378:	d1f9      	bne.n	636e <_sysctrl_init_referenced_generators+0xc6>
	/* Disable after all possible configurations needs sync written. */
	hri_sysctrl_clear_OSC32K_ENABLE_bit(hw);
#endif

	(void)hw;
}
    637a:	46c0      	nop			; (mov r8, r8)
    637c:	46bd      	mov	sp, r7
    637e:	b004      	add	sp, #16
    6380:	bd80      	pop	{r7, pc}
    6382:	46c0      	nop			; (mov r8, r8)
    6384:	40000800 	.word	0x40000800
    6388:	04010000 	.word	0x04010000
    638c:	00806024 	.word	0x00806024
    6390:	40000c00 	.word	0x40000c00

00006394 <_system_time_init>:

/**
 * \brief Initialize system time module
 */
void _system_time_init(void *const hw)
{
    6394:	b580      	push	{r7, lr}
    6396:	b082      	sub	sp, #8
    6398:	af00      	add	r7, sp, #0
    639a:	6078      	str	r0, [r7, #4]
	(void)hw;
	SysTick->LOAD = (0xFFFFFF << SysTick_LOAD_RELOAD_Pos);
    639c:	4b04      	ldr	r3, [pc, #16]	; (63b0 <_system_time_init+0x1c>)
    639e:	4a05      	ldr	r2, [pc, #20]	; (63b4 <_system_time_init+0x20>)
    63a0:	605a      	str	r2, [r3, #4]
	SysTick->CTRL = (1 << SysTick_CTRL_ENABLE_Pos) | (CONF_SYSTICK_TICKINT << SysTick_CTRL_TICKINT_Pos)
    63a2:	4b03      	ldr	r3, [pc, #12]	; (63b0 <_system_time_init+0x1c>)
    63a4:	2205      	movs	r2, #5
    63a6:	601a      	str	r2, [r3, #0]
	                | (1 << SysTick_CTRL_CLKSOURCE_Pos);
}
    63a8:	46c0      	nop			; (mov r8, r8)
    63aa:	46bd      	mov	sp, r7
    63ac:	b002      	add	sp, #8
    63ae:	bd80      	pop	{r7, pc}
    63b0:	e000e010 	.word	0xe000e010
    63b4:	00ffffff 	.word	0x00ffffff

000063b8 <_delay_init>:
/**
 * \brief Initialize delay functionality
 */
void _delay_init(void *const hw)
{
    63b8:	b580      	push	{r7, lr}
    63ba:	b082      	sub	sp, #8
    63bc:	af00      	add	r7, sp, #0
    63be:	6078      	str	r0, [r7, #4]
	_system_time_init(hw);
    63c0:	687b      	ldr	r3, [r7, #4]
    63c2:	0018      	movs	r0, r3
    63c4:	f7ff ffe6 	bl	6394 <_system_time_init>
}
    63c8:	46c0      	nop			; (mov r8, r8)
    63ca:	46bd      	mov	sp, r7
    63cc:	b002      	add	sp, #8
    63ce:	bd80      	pop	{r7, pc}

000063d0 <_delay_cycles>:
}
/**
 * \brief Delay loop to delay n number of cycles
 */
void _delay_cycles(void *const hw, uint32_t cycles)
{
    63d0:	b580      	push	{r7, lr}
    63d2:	b084      	sub	sp, #16
    63d4:	af00      	add	r7, sp, #0
    63d6:	6078      	str	r0, [r7, #4]
    63d8:	6039      	str	r1, [r7, #0]
	(void)hw;
	uint8_t  n   = cycles >> 24;
    63da:	683b      	ldr	r3, [r7, #0]
    63dc:	0e1a      	lsrs	r2, r3, #24
    63de:	230f      	movs	r3, #15
    63e0:	18fb      	adds	r3, r7, r3
    63e2:	701a      	strb	r2, [r3, #0]
	uint32_t buf = cycles;
    63e4:	683b      	ldr	r3, [r7, #0]
    63e6:	60bb      	str	r3, [r7, #8]

	while (n--) {
    63e8:	e011      	b.n	640e <_delay_cycles+0x3e>
		SysTick->LOAD = 0xFFFFFF;
    63ea:	4b16      	ldr	r3, [pc, #88]	; (6444 <_delay_cycles+0x74>)
    63ec:	4a16      	ldr	r2, [pc, #88]	; (6448 <_delay_cycles+0x78>)
    63ee:	605a      	str	r2, [r3, #4]
		SysTick->VAL  = 0xFFFFFF;
    63f0:	4b14      	ldr	r3, [pc, #80]	; (6444 <_delay_cycles+0x74>)
    63f2:	4a15      	ldr	r2, [pc, #84]	; (6448 <_delay_cycles+0x78>)
    63f4:	609a      	str	r2, [r3, #8]
		while (!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk))
    63f6:	46c0      	nop			; (mov r8, r8)
    63f8:	4b12      	ldr	r3, [pc, #72]	; (6444 <_delay_cycles+0x74>)
    63fa:	681a      	ldr	r2, [r3, #0]
    63fc:	2380      	movs	r3, #128	; 0x80
    63fe:	025b      	lsls	r3, r3, #9
    6400:	4013      	ands	r3, r2
    6402:	d0f9      	beq.n	63f8 <_delay_cycles+0x28>
			;
		buf -= 0xFFFFFF;
    6404:	68bb      	ldr	r3, [r7, #8]
    6406:	4a11      	ldr	r2, [pc, #68]	; (644c <_delay_cycles+0x7c>)
    6408:	4694      	mov	ip, r2
    640a:	4463      	add	r3, ip
    640c:	60bb      	str	r3, [r7, #8]
	while (n--) {
    640e:	230f      	movs	r3, #15
    6410:	18fb      	adds	r3, r7, r3
    6412:	781b      	ldrb	r3, [r3, #0]
    6414:	220f      	movs	r2, #15
    6416:	18ba      	adds	r2, r7, r2
    6418:	1e59      	subs	r1, r3, #1
    641a:	7011      	strb	r1, [r2, #0]
    641c:	2b00      	cmp	r3, #0
    641e:	d1e4      	bne.n	63ea <_delay_cycles+0x1a>
	}

	SysTick->LOAD = buf;
    6420:	4b08      	ldr	r3, [pc, #32]	; (6444 <_delay_cycles+0x74>)
    6422:	68ba      	ldr	r2, [r7, #8]
    6424:	605a      	str	r2, [r3, #4]
	SysTick->VAL  = buf;
    6426:	4b07      	ldr	r3, [pc, #28]	; (6444 <_delay_cycles+0x74>)
    6428:	68ba      	ldr	r2, [r7, #8]
    642a:	609a      	str	r2, [r3, #8]
	while (!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk))
    642c:	46c0      	nop			; (mov r8, r8)
    642e:	4b05      	ldr	r3, [pc, #20]	; (6444 <_delay_cycles+0x74>)
    6430:	681a      	ldr	r2, [r3, #0]
    6432:	2380      	movs	r3, #128	; 0x80
    6434:	025b      	lsls	r3, r3, #9
    6436:	4013      	ands	r3, r2
    6438:	d0f9      	beq.n	642e <_delay_cycles+0x5e>
		;
}
    643a:	46c0      	nop			; (mov r8, r8)
    643c:	46bd      	mov	sp, r7
    643e:	b004      	add	sp, #16
    6440:	bd80      	pop	{r7, pc}
    6442:	46c0      	nop			; (mov r8, r8)
    6444:	e000e010 	.word	0xe000e010
    6448:	00ffffff 	.word	0x00ffffff
    644c:	ff000001 	.word	0xff000001

00006450 <hri_gclk_write_CLKCTRL_reg>:
{
    6450:	b580      	push	{r7, lr}
    6452:	b082      	sub	sp, #8
    6454:	af00      	add	r7, sp, #0
    6456:	6078      	str	r0, [r7, #4]
    6458:	000a      	movs	r2, r1
    645a:	1cbb      	adds	r3, r7, #2
    645c:	801a      	strh	r2, [r3, #0]
	((Gclk *)hw)->CLKCTRL.reg = data;
    645e:	687b      	ldr	r3, [r7, #4]
    6460:	1cba      	adds	r2, r7, #2
    6462:	8812      	ldrh	r2, [r2, #0]
    6464:	805a      	strh	r2, [r3, #2]
}
    6466:	46c0      	nop			; (mov r8, r8)
    6468:	46bd      	mov	sp, r7
    646a:	b002      	add	sp, #8
    646c:	bd80      	pop	{r7, pc}

0000646e <hri_port_set_DIR_reg>:
{
    646e:	b580      	push	{r7, lr}
    6470:	b084      	sub	sp, #16
    6472:	af00      	add	r7, sp, #0
    6474:	60f8      	str	r0, [r7, #12]
    6476:	607a      	str	r2, [r7, #4]
    6478:	230b      	movs	r3, #11
    647a:	18fb      	adds	r3, r7, r3
    647c:	1c0a      	adds	r2, r1, #0
    647e:	701a      	strb	r2, [r3, #0]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    6480:	230b      	movs	r3, #11
    6482:	18fb      	adds	r3, r7, r3
    6484:	781b      	ldrb	r3, [r3, #0]
    6486:	68fa      	ldr	r2, [r7, #12]
    6488:	01db      	lsls	r3, r3, #7
    648a:	18d3      	adds	r3, r2, r3
    648c:	3308      	adds	r3, #8
    648e:	687a      	ldr	r2, [r7, #4]
    6490:	601a      	str	r2, [r3, #0]
}
    6492:	46c0      	nop			; (mov r8, r8)
    6494:	46bd      	mov	sp, r7
    6496:	b004      	add	sp, #16
    6498:	bd80      	pop	{r7, pc}

0000649a <hri_port_clear_DIR_reg>:
{
    649a:	b580      	push	{r7, lr}
    649c:	b084      	sub	sp, #16
    649e:	af00      	add	r7, sp, #0
    64a0:	60f8      	str	r0, [r7, #12]
    64a2:	607a      	str	r2, [r7, #4]
    64a4:	230b      	movs	r3, #11
    64a6:	18fb      	adds	r3, r7, r3
    64a8:	1c0a      	adds	r2, r1, #0
    64aa:	701a      	strb	r2, [r3, #0]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    64ac:	230b      	movs	r3, #11
    64ae:	18fb      	adds	r3, r7, r3
    64b0:	781b      	ldrb	r3, [r3, #0]
    64b2:	68fa      	ldr	r2, [r7, #12]
    64b4:	01db      	lsls	r3, r3, #7
    64b6:	18d3      	adds	r3, r2, r3
    64b8:	3304      	adds	r3, #4
    64ba:	687a      	ldr	r2, [r7, #4]
    64bc:	601a      	str	r2, [r3, #0]
}
    64be:	46c0      	nop			; (mov r8, r8)
    64c0:	46bd      	mov	sp, r7
    64c2:	b004      	add	sp, #16
    64c4:	bd80      	pop	{r7, pc}

000064c6 <hri_port_set_OUT_reg>:
{
    64c6:	b580      	push	{r7, lr}
    64c8:	b084      	sub	sp, #16
    64ca:	af00      	add	r7, sp, #0
    64cc:	60f8      	str	r0, [r7, #12]
    64ce:	607a      	str	r2, [r7, #4]
    64d0:	230b      	movs	r3, #11
    64d2:	18fb      	adds	r3, r7, r3
    64d4:	1c0a      	adds	r2, r1, #0
    64d6:	701a      	strb	r2, [r3, #0]
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    64d8:	230b      	movs	r3, #11
    64da:	18fb      	adds	r3, r7, r3
    64dc:	781b      	ldrb	r3, [r3, #0]
    64de:	68fa      	ldr	r2, [r7, #12]
    64e0:	01db      	lsls	r3, r3, #7
    64e2:	18d3      	adds	r3, r2, r3
    64e4:	3318      	adds	r3, #24
    64e6:	687a      	ldr	r2, [r7, #4]
    64e8:	601a      	str	r2, [r3, #0]
}
    64ea:	46c0      	nop			; (mov r8, r8)
    64ec:	46bd      	mov	sp, r7
    64ee:	b004      	add	sp, #16
    64f0:	bd80      	pop	{r7, pc}

000064f2 <hri_port_clear_OUT_reg>:
{
    64f2:	b580      	push	{r7, lr}
    64f4:	b084      	sub	sp, #16
    64f6:	af00      	add	r7, sp, #0
    64f8:	60f8      	str	r0, [r7, #12]
    64fa:	607a      	str	r2, [r7, #4]
    64fc:	230b      	movs	r3, #11
    64fe:	18fb      	adds	r3, r7, r3
    6500:	1c0a      	adds	r2, r1, #0
    6502:	701a      	strb	r2, [r3, #0]
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    6504:	230b      	movs	r3, #11
    6506:	18fb      	adds	r3, r7, r3
    6508:	781b      	ldrb	r3, [r3, #0]
    650a:	68fa      	ldr	r2, [r7, #12]
    650c:	01db      	lsls	r3, r3, #7
    650e:	18d3      	adds	r3, r2, r3
    6510:	3314      	adds	r3, #20
    6512:	687a      	ldr	r2, [r7, #4]
    6514:	601a      	str	r2, [r3, #0]
}
    6516:	46c0      	nop			; (mov r8, r8)
    6518:	46bd      	mov	sp, r7
    651a:	b004      	add	sp, #16
    651c:	bd80      	pop	{r7, pc}

0000651e <hri_port_write_PMUX_PMUXE_bf>:
{
    651e:	b590      	push	{r4, r7, lr}
    6520:	b085      	sub	sp, #20
    6522:	af00      	add	r7, sp, #0
    6524:	6078      	str	r0, [r7, #4]
    6526:	000c      	movs	r4, r1
    6528:	0010      	movs	r0, r2
    652a:	0019      	movs	r1, r3
    652c:	1cfb      	adds	r3, r7, #3
    652e:	1c22      	adds	r2, r4, #0
    6530:	701a      	strb	r2, [r3, #0]
    6532:	1cbb      	adds	r3, r7, #2
    6534:	1c02      	adds	r2, r0, #0
    6536:	701a      	strb	r2, [r3, #0]
    6538:	1c7b      	adds	r3, r7, #1
    653a:	1c0a      	adds	r2, r1, #0
    653c:	701a      	strb	r2, [r3, #0]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
    653e:	1cfb      	adds	r3, r7, #3
    6540:	7819      	ldrb	r1, [r3, #0]
    6542:	1cbb      	adds	r3, r7, #2
    6544:	781a      	ldrb	r2, [r3, #0]
    6546:	230f      	movs	r3, #15
    6548:	18fb      	adds	r3, r7, r3
    654a:	6878      	ldr	r0, [r7, #4]
    654c:	2430      	movs	r4, #48	; 0x30
    654e:	01c9      	lsls	r1, r1, #7
    6550:	1841      	adds	r1, r0, r1
    6552:	188a      	adds	r2, r1, r2
    6554:	1912      	adds	r2, r2, r4
    6556:	7812      	ldrb	r2, [r2, #0]
    6558:	701a      	strb	r2, [r3, #0]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
    655a:	230f      	movs	r3, #15
    655c:	18fb      	adds	r3, r7, r3
    655e:	220f      	movs	r2, #15
    6560:	18ba      	adds	r2, r7, r2
    6562:	7812      	ldrb	r2, [r2, #0]
    6564:	210f      	movs	r1, #15
    6566:	438a      	bics	r2, r1
    6568:	701a      	strb	r2, [r3, #0]
	tmp |= PORT_PMUX_PMUXE(data);
    656a:	1c7b      	adds	r3, r7, #1
    656c:	781b      	ldrb	r3, [r3, #0]
    656e:	220f      	movs	r2, #15
    6570:	4013      	ands	r3, r2
    6572:	b2d9      	uxtb	r1, r3
    6574:	230f      	movs	r3, #15
    6576:	18fb      	adds	r3, r7, r3
    6578:	220f      	movs	r2, #15
    657a:	18ba      	adds	r2, r7, r2
    657c:	7812      	ldrb	r2, [r2, #0]
    657e:	430a      	orrs	r2, r1
    6580:	701a      	strb	r2, [r3, #0]
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
    6582:	1cfb      	adds	r3, r7, #3
    6584:	781a      	ldrb	r2, [r3, #0]
    6586:	1cbb      	adds	r3, r7, #2
    6588:	781b      	ldrb	r3, [r3, #0]
    658a:	6879      	ldr	r1, [r7, #4]
    658c:	2030      	movs	r0, #48	; 0x30
    658e:	01d2      	lsls	r2, r2, #7
    6590:	188a      	adds	r2, r1, r2
    6592:	18d3      	adds	r3, r2, r3
    6594:	181b      	adds	r3, r3, r0
    6596:	220f      	movs	r2, #15
    6598:	18ba      	adds	r2, r7, r2
    659a:	7812      	ldrb	r2, [r2, #0]
    659c:	701a      	strb	r2, [r3, #0]
}
    659e:	46c0      	nop			; (mov r8, r8)
    65a0:	46bd      	mov	sp, r7
    65a2:	b005      	add	sp, #20
    65a4:	bd90      	pop	{r4, r7, pc}

000065a6 <hri_port_write_PMUX_PMUXO_bf>:
{
    65a6:	b590      	push	{r4, r7, lr}
    65a8:	b085      	sub	sp, #20
    65aa:	af00      	add	r7, sp, #0
    65ac:	6078      	str	r0, [r7, #4]
    65ae:	000c      	movs	r4, r1
    65b0:	0010      	movs	r0, r2
    65b2:	0019      	movs	r1, r3
    65b4:	1cfb      	adds	r3, r7, #3
    65b6:	1c22      	adds	r2, r4, #0
    65b8:	701a      	strb	r2, [r3, #0]
    65ba:	1cbb      	adds	r3, r7, #2
    65bc:	1c02      	adds	r2, r0, #0
    65be:	701a      	strb	r2, [r3, #0]
    65c0:	1c7b      	adds	r3, r7, #1
    65c2:	1c0a      	adds	r2, r1, #0
    65c4:	701a      	strb	r2, [r3, #0]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
    65c6:	1cfb      	adds	r3, r7, #3
    65c8:	7819      	ldrb	r1, [r3, #0]
    65ca:	1cbb      	adds	r3, r7, #2
    65cc:	781a      	ldrb	r2, [r3, #0]
    65ce:	230f      	movs	r3, #15
    65d0:	18fb      	adds	r3, r7, r3
    65d2:	6878      	ldr	r0, [r7, #4]
    65d4:	2430      	movs	r4, #48	; 0x30
    65d6:	01c9      	lsls	r1, r1, #7
    65d8:	1841      	adds	r1, r0, r1
    65da:	188a      	adds	r2, r1, r2
    65dc:	1912      	adds	r2, r2, r4
    65de:	7812      	ldrb	r2, [r2, #0]
    65e0:	701a      	strb	r2, [r3, #0]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
    65e2:	230f      	movs	r3, #15
    65e4:	18fb      	adds	r3, r7, r3
    65e6:	220f      	movs	r2, #15
    65e8:	18ba      	adds	r2, r7, r2
    65ea:	7812      	ldrb	r2, [r2, #0]
    65ec:	210f      	movs	r1, #15
    65ee:	400a      	ands	r2, r1
    65f0:	701a      	strb	r2, [r3, #0]
	tmp |= PORT_PMUX_PMUXO(data);
    65f2:	1c7b      	adds	r3, r7, #1
    65f4:	781b      	ldrb	r3, [r3, #0]
    65f6:	011b      	lsls	r3, r3, #4
    65f8:	b2d9      	uxtb	r1, r3
    65fa:	230f      	movs	r3, #15
    65fc:	18fb      	adds	r3, r7, r3
    65fe:	220f      	movs	r2, #15
    6600:	18ba      	adds	r2, r7, r2
    6602:	7812      	ldrb	r2, [r2, #0]
    6604:	430a      	orrs	r2, r1
    6606:	701a      	strb	r2, [r3, #0]
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
    6608:	1cfb      	adds	r3, r7, #3
    660a:	781a      	ldrb	r2, [r3, #0]
    660c:	1cbb      	adds	r3, r7, #2
    660e:	781b      	ldrb	r3, [r3, #0]
    6610:	6879      	ldr	r1, [r7, #4]
    6612:	2030      	movs	r0, #48	; 0x30
    6614:	01d2      	lsls	r2, r2, #7
    6616:	188a      	adds	r2, r1, r2
    6618:	18d3      	adds	r3, r2, r3
    661a:	181b      	adds	r3, r3, r0
    661c:	220f      	movs	r2, #15
    661e:	18ba      	adds	r2, r7, r2
    6620:	7812      	ldrb	r2, [r2, #0]
    6622:	701a      	strb	r2, [r3, #0]
}
    6624:	46c0      	nop			; (mov r8, r8)
    6626:	46bd      	mov	sp, r7
    6628:	b005      	add	sp, #20
    662a:	bd90      	pop	{r4, r7, pc}

0000662c <hri_port_write_PINCFG_PMUXEN_bit>:
{
    662c:	b590      	push	{r4, r7, lr}
    662e:	b085      	sub	sp, #20
    6630:	af00      	add	r7, sp, #0
    6632:	6078      	str	r0, [r7, #4]
    6634:	000c      	movs	r4, r1
    6636:	0010      	movs	r0, r2
    6638:	0019      	movs	r1, r3
    663a:	1cfb      	adds	r3, r7, #3
    663c:	1c22      	adds	r2, r4, #0
    663e:	701a      	strb	r2, [r3, #0]
    6640:	1cbb      	adds	r3, r7, #2
    6642:	1c02      	adds	r2, r0, #0
    6644:	701a      	strb	r2, [r3, #0]
    6646:	1c7b      	adds	r3, r7, #1
    6648:	1c0a      	adds	r2, r1, #0
    664a:	701a      	strb	r2, [r3, #0]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    664c:	1cfb      	adds	r3, r7, #3
    664e:	7819      	ldrb	r1, [r3, #0]
    6650:	1cbb      	adds	r3, r7, #2
    6652:	781a      	ldrb	r2, [r3, #0]
    6654:	230f      	movs	r3, #15
    6656:	18fb      	adds	r3, r7, r3
    6658:	6878      	ldr	r0, [r7, #4]
    665a:	2440      	movs	r4, #64	; 0x40
    665c:	01c9      	lsls	r1, r1, #7
    665e:	1841      	adds	r1, r0, r1
    6660:	188a      	adds	r2, r1, r2
    6662:	1912      	adds	r2, r2, r4
    6664:	7812      	ldrb	r2, [r2, #0]
    6666:	701a      	strb	r2, [r3, #0]
	tmp &= ~PORT_PINCFG_PMUXEN;
    6668:	230f      	movs	r3, #15
    666a:	18fb      	adds	r3, r7, r3
    666c:	220f      	movs	r2, #15
    666e:	18ba      	adds	r2, r7, r2
    6670:	7812      	ldrb	r2, [r2, #0]
    6672:	2101      	movs	r1, #1
    6674:	438a      	bics	r2, r1
    6676:	701a      	strb	r2, [r3, #0]
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
    6678:	1c7b      	adds	r3, r7, #1
    667a:	7819      	ldrb	r1, [r3, #0]
    667c:	230f      	movs	r3, #15
    667e:	18fb      	adds	r3, r7, r3
    6680:	220f      	movs	r2, #15
    6682:	18ba      	adds	r2, r7, r2
    6684:	7812      	ldrb	r2, [r2, #0]
    6686:	430a      	orrs	r2, r1
    6688:	701a      	strb	r2, [r3, #0]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    668a:	1cfb      	adds	r3, r7, #3
    668c:	781a      	ldrb	r2, [r3, #0]
    668e:	1cbb      	adds	r3, r7, #2
    6690:	781b      	ldrb	r3, [r3, #0]
    6692:	6879      	ldr	r1, [r7, #4]
    6694:	2040      	movs	r0, #64	; 0x40
    6696:	01d2      	lsls	r2, r2, #7
    6698:	188a      	adds	r2, r1, r2
    669a:	18d3      	adds	r3, r2, r3
    669c:	181b      	adds	r3, r3, r0
    669e:	220f      	movs	r2, #15
    66a0:	18ba      	adds	r2, r7, r2
    66a2:	7812      	ldrb	r2, [r2, #0]
    66a4:	701a      	strb	r2, [r3, #0]
}
    66a6:	46c0      	nop			; (mov r8, r8)
    66a8:	46bd      	mov	sp, r7
    66aa:	b005      	add	sp, #20
    66ac:	bd90      	pop	{r4, r7, pc}

000066ae <hri_port_set_PINCFG_PULLEN_bit>:
{
    66ae:	b5b0      	push	{r4, r5, r7, lr}
    66b0:	b082      	sub	sp, #8
    66b2:	af00      	add	r7, sp, #0
    66b4:	6078      	str	r0, [r7, #4]
    66b6:	0008      	movs	r0, r1
    66b8:	0011      	movs	r1, r2
    66ba:	1cfb      	adds	r3, r7, #3
    66bc:	1c02      	adds	r2, r0, #0
    66be:	701a      	strb	r2, [r3, #0]
    66c0:	1cbb      	adds	r3, r7, #2
    66c2:	1c0a      	adds	r2, r1, #0
    66c4:	701a      	strb	r2, [r3, #0]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg |= PORT_PINCFG_PULLEN;
    66c6:	1cfb      	adds	r3, r7, #3
    66c8:	781a      	ldrb	r2, [r3, #0]
    66ca:	1cbb      	adds	r3, r7, #2
    66cc:	781b      	ldrb	r3, [r3, #0]
    66ce:	1cf9      	adds	r1, r7, #3
    66d0:	7808      	ldrb	r0, [r1, #0]
    66d2:	1cb9      	adds	r1, r7, #2
    66d4:	7809      	ldrb	r1, [r1, #0]
    66d6:	687c      	ldr	r4, [r7, #4]
    66d8:	2540      	movs	r5, #64	; 0x40
    66da:	01c0      	lsls	r0, r0, #7
    66dc:	1820      	adds	r0, r4, r0
    66de:	1841      	adds	r1, r0, r1
    66e0:	1949      	adds	r1, r1, r5
    66e2:	7809      	ldrb	r1, [r1, #0]
    66e4:	b2c9      	uxtb	r1, r1
    66e6:	2004      	movs	r0, #4
    66e8:	4301      	orrs	r1, r0
    66ea:	b2cc      	uxtb	r4, r1
    66ec:	6879      	ldr	r1, [r7, #4]
    66ee:	2040      	movs	r0, #64	; 0x40
    66f0:	01d2      	lsls	r2, r2, #7
    66f2:	188a      	adds	r2, r1, r2
    66f4:	18d3      	adds	r3, r2, r3
    66f6:	181b      	adds	r3, r3, r0
    66f8:	1c22      	adds	r2, r4, #0
    66fa:	701a      	strb	r2, [r3, #0]
}
    66fc:	46c0      	nop			; (mov r8, r8)
    66fe:	46bd      	mov	sp, r7
    6700:	b002      	add	sp, #8
    6702:	bdb0      	pop	{r4, r5, r7, pc}

00006704 <hri_port_clear_PINCFG_PULLEN_bit>:
{
    6704:	b5b0      	push	{r4, r5, r7, lr}
    6706:	b082      	sub	sp, #8
    6708:	af00      	add	r7, sp, #0
    670a:	6078      	str	r0, [r7, #4]
    670c:	0008      	movs	r0, r1
    670e:	0011      	movs	r1, r2
    6710:	1cfb      	adds	r3, r7, #3
    6712:	1c02      	adds	r2, r0, #0
    6714:	701a      	strb	r2, [r3, #0]
    6716:	1cbb      	adds	r3, r7, #2
    6718:	1c0a      	adds	r2, r1, #0
    671a:	701a      	strb	r2, [r3, #0]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
    671c:	1cfb      	adds	r3, r7, #3
    671e:	781a      	ldrb	r2, [r3, #0]
    6720:	1cbb      	adds	r3, r7, #2
    6722:	781b      	ldrb	r3, [r3, #0]
    6724:	1cf9      	adds	r1, r7, #3
    6726:	7808      	ldrb	r0, [r1, #0]
    6728:	1cb9      	adds	r1, r7, #2
    672a:	7809      	ldrb	r1, [r1, #0]
    672c:	687c      	ldr	r4, [r7, #4]
    672e:	2540      	movs	r5, #64	; 0x40
    6730:	01c0      	lsls	r0, r0, #7
    6732:	1820      	adds	r0, r4, r0
    6734:	1841      	adds	r1, r0, r1
    6736:	1949      	adds	r1, r1, r5
    6738:	7809      	ldrb	r1, [r1, #0]
    673a:	b2c9      	uxtb	r1, r1
    673c:	2004      	movs	r0, #4
    673e:	4381      	bics	r1, r0
    6740:	b2cc      	uxtb	r4, r1
    6742:	6879      	ldr	r1, [r7, #4]
    6744:	2040      	movs	r0, #64	; 0x40
    6746:	01d2      	lsls	r2, r2, #7
    6748:	188a      	adds	r2, r1, r2
    674a:	18d3      	adds	r3, r2, r3
    674c:	181b      	adds	r3, r3, r0
    674e:	1c22      	adds	r2, r4, #0
    6750:	701a      	strb	r2, [r3, #0]
}
    6752:	46c0      	nop			; (mov r8, r8)
    6754:	46bd      	mov	sp, r7
    6756:	b002      	add	sp, #8
    6758:	bdb0      	pop	{r4, r5, r7, pc}

0000675a <hri_port_write_WRCONFIG_reg>:
{
    675a:	b580      	push	{r7, lr}
    675c:	b084      	sub	sp, #16
    675e:	af00      	add	r7, sp, #0
    6760:	60f8      	str	r0, [r7, #12]
    6762:	607a      	str	r2, [r7, #4]
    6764:	230b      	movs	r3, #11
    6766:	18fb      	adds	r3, r7, r3
    6768:	1c0a      	adds	r2, r1, #0
    676a:	701a      	strb	r2, [r3, #0]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    676c:	230b      	movs	r3, #11
    676e:	18fb      	adds	r3, r7, r3
    6770:	781b      	ldrb	r3, [r3, #0]
    6772:	68fa      	ldr	r2, [r7, #12]
    6774:	01db      	lsls	r3, r3, #7
    6776:	18d3      	adds	r3, r2, r3
    6778:	3328      	adds	r3, #40	; 0x28
    677a:	687a      	ldr	r2, [r7, #4]
    677c:	601a      	str	r2, [r3, #0]
}
    677e:	46c0      	nop			; (mov r8, r8)
    6780:	46bd      	mov	sp, r7
    6782:	b004      	add	sp, #16
    6784:	bd80      	pop	{r7, pc}
	...

00006788 <_gpio_set_direction>:
{
    6788:	b580      	push	{r7, lr}
    678a:	b082      	sub	sp, #8
    678c:	af00      	add	r7, sp, #0
    678e:	6039      	str	r1, [r7, #0]
    6790:	0011      	movs	r1, r2
    6792:	1dfb      	adds	r3, r7, #7
    6794:	1c02      	adds	r2, r0, #0
    6796:	701a      	strb	r2, [r3, #0]
    6798:	1dbb      	adds	r3, r7, #6
    679a:	1c0a      	adds	r2, r1, #0
    679c:	701a      	strb	r2, [r3, #0]
	switch (direction) {
    679e:	1dbb      	adds	r3, r7, #6
    67a0:	781b      	ldrb	r3, [r3, #0]
    67a2:	2b01      	cmp	r3, #1
    67a4:	d023      	beq.n	67ee <_gpio_set_direction+0x66>
    67a6:	2b02      	cmp	r3, #2
    67a8:	d03f      	beq.n	682a <_gpio_set_direction+0xa2>
    67aa:	2b00      	cmp	r3, #0
    67ac:	d15d      	bne.n	686a <_gpio_set_direction+0xe2>
		hri_port_clear_DIR_reg(PORT_IOBUS, port, mask);
    67ae:	683a      	ldr	r2, [r7, #0]
    67b0:	1dfb      	adds	r3, r7, #7
    67b2:	7819      	ldrb	r1, [r3, #0]
    67b4:	23c0      	movs	r3, #192	; 0xc0
    67b6:	05db      	lsls	r3, r3, #23
    67b8:	0018      	movs	r0, r3
    67ba:	f7ff fe6e 	bl	649a <hri_port_clear_DIR_reg>
		hri_port_write_WRCONFIG_reg(PORT, port, PORT_WRCONFIG_WRPINCFG | (mask & 0xffff));
    67be:	683b      	ldr	r3, [r7, #0]
    67c0:	041b      	lsls	r3, r3, #16
    67c2:	0c1b      	lsrs	r3, r3, #16
    67c4:	2280      	movs	r2, #128	; 0x80
    67c6:	05d2      	lsls	r2, r2, #23
    67c8:	431a      	orrs	r2, r3
    67ca:	1dfb      	adds	r3, r7, #7
    67cc:	781b      	ldrb	r3, [r3, #0]
    67ce:	482c      	ldr	r0, [pc, #176]	; (6880 <_gpio_set_direction+0xf8>)
    67d0:	0019      	movs	r1, r3
    67d2:	f7ff ffc2 	bl	675a <hri_port_write_WRCONFIG_reg>
		    PORT, port, PORT_WRCONFIG_HWSEL | PORT_WRCONFIG_WRPINCFG | ((mask & 0xffff0000) >> 16));
    67d6:	683b      	ldr	r3, [r7, #0]
    67d8:	0c1b      	lsrs	r3, r3, #16
		hri_port_write_WRCONFIG_reg(
    67da:	22c0      	movs	r2, #192	; 0xc0
    67dc:	0612      	lsls	r2, r2, #24
    67de:	431a      	orrs	r2, r3
    67e0:	1dfb      	adds	r3, r7, #7
    67e2:	781b      	ldrb	r3, [r3, #0]
    67e4:	4826      	ldr	r0, [pc, #152]	; (6880 <_gpio_set_direction+0xf8>)
    67e6:	0019      	movs	r1, r3
    67e8:	f7ff ffb7 	bl	675a <hri_port_write_WRCONFIG_reg>
		break;
    67ec:	e043      	b.n	6876 <_gpio_set_direction+0xee>
		hri_port_clear_DIR_reg(PORT_IOBUS, port, mask);
    67ee:	683a      	ldr	r2, [r7, #0]
    67f0:	1dfb      	adds	r3, r7, #7
    67f2:	7819      	ldrb	r1, [r3, #0]
    67f4:	23c0      	movs	r3, #192	; 0xc0
    67f6:	05db      	lsls	r3, r3, #23
    67f8:	0018      	movs	r0, r3
    67fa:	f7ff fe4e 	bl	649a <hri_port_clear_DIR_reg>
		hri_port_write_WRCONFIG_reg(PORT, port, PORT_WRCONFIG_WRPINCFG | PORT_WRCONFIG_INEN | (mask & 0xffff));
    67fe:	683b      	ldr	r3, [r7, #0]
    6800:	041b      	lsls	r3, r3, #16
    6802:	0c1b      	lsrs	r3, r3, #16
    6804:	4a1f      	ldr	r2, [pc, #124]	; (6884 <_gpio_set_direction+0xfc>)
    6806:	431a      	orrs	r2, r3
    6808:	1dfb      	adds	r3, r7, #7
    680a:	781b      	ldrb	r3, [r3, #0]
    680c:	481c      	ldr	r0, [pc, #112]	; (6880 <_gpio_set_direction+0xf8>)
    680e:	0019      	movs	r1, r3
    6810:	f7ff ffa3 	bl	675a <hri_port_write_WRCONFIG_reg>
		                                | ((mask & 0xffff0000) >> 16));
    6814:	683b      	ldr	r3, [r7, #0]
    6816:	0c1b      	lsrs	r3, r3, #16
		hri_port_write_WRCONFIG_reg(PORT,
    6818:	4a1b      	ldr	r2, [pc, #108]	; (6888 <_gpio_set_direction+0x100>)
    681a:	431a      	orrs	r2, r3
    681c:	1dfb      	adds	r3, r7, #7
    681e:	781b      	ldrb	r3, [r3, #0]
    6820:	4817      	ldr	r0, [pc, #92]	; (6880 <_gpio_set_direction+0xf8>)
    6822:	0019      	movs	r1, r3
    6824:	f7ff ff99 	bl	675a <hri_port_write_WRCONFIG_reg>
		break;
    6828:	e025      	b.n	6876 <_gpio_set_direction+0xee>
		hri_port_set_DIR_reg(PORT_IOBUS, port, mask);
    682a:	683a      	ldr	r2, [r7, #0]
    682c:	1dfb      	adds	r3, r7, #7
    682e:	7819      	ldrb	r1, [r3, #0]
    6830:	23c0      	movs	r3, #192	; 0xc0
    6832:	05db      	lsls	r3, r3, #23
    6834:	0018      	movs	r0, r3
    6836:	f7ff fe1a 	bl	646e <hri_port_set_DIR_reg>
		hri_port_write_WRCONFIG_reg(PORT, port, PORT_WRCONFIG_WRPINCFG | (mask & 0xffff));
    683a:	683b      	ldr	r3, [r7, #0]
    683c:	041b      	lsls	r3, r3, #16
    683e:	0c1b      	lsrs	r3, r3, #16
    6840:	2280      	movs	r2, #128	; 0x80
    6842:	05d2      	lsls	r2, r2, #23
    6844:	431a      	orrs	r2, r3
    6846:	1dfb      	adds	r3, r7, #7
    6848:	781b      	ldrb	r3, [r3, #0]
    684a:	480d      	ldr	r0, [pc, #52]	; (6880 <_gpio_set_direction+0xf8>)
    684c:	0019      	movs	r1, r3
    684e:	f7ff ff84 	bl	675a <hri_port_write_WRCONFIG_reg>
		    PORT, port, PORT_WRCONFIG_HWSEL | PORT_WRCONFIG_WRPINCFG | ((mask & 0xffff0000) >> 16));
    6852:	683b      	ldr	r3, [r7, #0]
    6854:	0c1b      	lsrs	r3, r3, #16
		hri_port_write_WRCONFIG_reg(
    6856:	22c0      	movs	r2, #192	; 0xc0
    6858:	0612      	lsls	r2, r2, #24
    685a:	431a      	orrs	r2, r3
    685c:	1dfb      	adds	r3, r7, #7
    685e:	781b      	ldrb	r3, [r3, #0]
    6860:	4807      	ldr	r0, [pc, #28]	; (6880 <_gpio_set_direction+0xf8>)
    6862:	0019      	movs	r1, r3
    6864:	f7ff ff79 	bl	675a <hri_port_write_WRCONFIG_reg>
		break;
    6868:	e005      	b.n	6876 <_gpio_set_direction+0xee>
		ASSERT(false);
    686a:	4b08      	ldr	r3, [pc, #32]	; (688c <_gpio_set_direction+0x104>)
    686c:	2245      	movs	r2, #69	; 0x45
    686e:	0019      	movs	r1, r3
    6870:	2000      	movs	r0, #0
    6872:	f7fd fd55 	bl	4320 <assert>
}
    6876:	46c0      	nop			; (mov r8, r8)
    6878:	46bd      	mov	sp, r7
    687a:	b002      	add	sp, #8
    687c:	bd80      	pop	{r7, pc}
    687e:	46c0      	nop			; (mov r8, r8)
    6880:	41004400 	.word	0x41004400
    6884:	40020000 	.word	0x40020000
    6888:	c0020000 	.word	0xc0020000
    688c:	00008b6c 	.word	0x00008b6c

00006890 <_gpio_set_level>:
{
    6890:	b580      	push	{r7, lr}
    6892:	b082      	sub	sp, #8
    6894:	af00      	add	r7, sp, #0
    6896:	6039      	str	r1, [r7, #0]
    6898:	0011      	movs	r1, r2
    689a:	1dfb      	adds	r3, r7, #7
    689c:	1c02      	adds	r2, r0, #0
    689e:	701a      	strb	r2, [r3, #0]
    68a0:	1dbb      	adds	r3, r7, #6
    68a2:	1c0a      	adds	r2, r1, #0
    68a4:	701a      	strb	r2, [r3, #0]
	if (level) {
    68a6:	1dbb      	adds	r3, r7, #6
    68a8:	781b      	ldrb	r3, [r3, #0]
    68aa:	2b00      	cmp	r3, #0
    68ac:	d008      	beq.n	68c0 <_gpio_set_level+0x30>
		hri_port_set_OUT_reg(PORT_IOBUS, port, mask);
    68ae:	683a      	ldr	r2, [r7, #0]
    68b0:	1dfb      	adds	r3, r7, #7
    68b2:	7819      	ldrb	r1, [r3, #0]
    68b4:	23c0      	movs	r3, #192	; 0xc0
    68b6:	05db      	lsls	r3, r3, #23
    68b8:	0018      	movs	r0, r3
    68ba:	f7ff fe04 	bl	64c6 <hri_port_set_OUT_reg>
}
    68be:	e007      	b.n	68d0 <_gpio_set_level+0x40>
		hri_port_clear_OUT_reg(PORT_IOBUS, port, mask);
    68c0:	683a      	ldr	r2, [r7, #0]
    68c2:	1dfb      	adds	r3, r7, #7
    68c4:	7819      	ldrb	r1, [r3, #0]
    68c6:	23c0      	movs	r3, #192	; 0xc0
    68c8:	05db      	lsls	r3, r3, #23
    68ca:	0018      	movs	r0, r3
    68cc:	f7ff fe11 	bl	64f2 <hri_port_clear_OUT_reg>
}
    68d0:	46c0      	nop			; (mov r8, r8)
    68d2:	46bd      	mov	sp, r7
    68d4:	b002      	add	sp, #8
    68d6:	bd80      	pop	{r7, pc}

000068d8 <_gpio_set_pin_pull_mode>:
{
    68d8:	b590      	push	{r4, r7, lr}
    68da:	b083      	sub	sp, #12
    68dc:	af00      	add	r7, sp, #0
    68de:	0004      	movs	r4, r0
    68e0:	0008      	movs	r0, r1
    68e2:	0011      	movs	r1, r2
    68e4:	1dfb      	adds	r3, r7, #7
    68e6:	1c22      	adds	r2, r4, #0
    68e8:	701a      	strb	r2, [r3, #0]
    68ea:	1dbb      	adds	r3, r7, #6
    68ec:	1c02      	adds	r2, r0, #0
    68ee:	701a      	strb	r2, [r3, #0]
    68f0:	1d7b      	adds	r3, r7, #5
    68f2:	1c0a      	adds	r2, r1, #0
    68f4:	701a      	strb	r2, [r3, #0]
	switch (pull_mode) {
    68f6:	1d7b      	adds	r3, r7, #5
    68f8:	781b      	ldrb	r3, [r3, #0]
    68fa:	2b01      	cmp	r3, #1
    68fc:	d00c      	beq.n	6918 <_gpio_set_pin_pull_mode+0x40>
    68fe:	2b02      	cmp	r3, #2
    6900:	d029      	beq.n	6956 <_gpio_set_pin_pull_mode+0x7e>
    6902:	2b00      	cmp	r3, #0
    6904:	d146      	bne.n	6994 <_gpio_set_pin_pull_mode+0xbc>
		hri_port_clear_PINCFG_PULLEN_bit(PORT, port, pin);
    6906:	1dbb      	adds	r3, r7, #6
    6908:	781a      	ldrb	r2, [r3, #0]
    690a:	1dfb      	adds	r3, r7, #7
    690c:	781b      	ldrb	r3, [r3, #0]
    690e:	4827      	ldr	r0, [pc, #156]	; (69ac <_gpio_set_pin_pull_mode+0xd4>)
    6910:	0019      	movs	r1, r3
    6912:	f7ff fef7 	bl	6704 <hri_port_clear_PINCFG_PULLEN_bit>
		break;
    6916:	e044      	b.n	69a2 <_gpio_set_pin_pull_mode+0xca>
		hri_port_clear_DIR_reg(PORT_IOBUS, port, 1U << pin);
    6918:	1dbb      	adds	r3, r7, #6
    691a:	781b      	ldrb	r3, [r3, #0]
    691c:	2201      	movs	r2, #1
    691e:	409a      	lsls	r2, r3
    6920:	1dfb      	adds	r3, r7, #7
    6922:	7819      	ldrb	r1, [r3, #0]
    6924:	23c0      	movs	r3, #192	; 0xc0
    6926:	05db      	lsls	r3, r3, #23
    6928:	0018      	movs	r0, r3
    692a:	f7ff fdb6 	bl	649a <hri_port_clear_DIR_reg>
		hri_port_set_PINCFG_PULLEN_bit(PORT, port, pin);
    692e:	1dbb      	adds	r3, r7, #6
    6930:	781a      	ldrb	r2, [r3, #0]
    6932:	1dfb      	adds	r3, r7, #7
    6934:	781b      	ldrb	r3, [r3, #0]
    6936:	481d      	ldr	r0, [pc, #116]	; (69ac <_gpio_set_pin_pull_mode+0xd4>)
    6938:	0019      	movs	r1, r3
    693a:	f7ff feb8 	bl	66ae <hri_port_set_PINCFG_PULLEN_bit>
		hri_port_set_OUT_reg(PORT_IOBUS, port, 1U << pin);
    693e:	1dbb      	adds	r3, r7, #6
    6940:	781b      	ldrb	r3, [r3, #0]
    6942:	2201      	movs	r2, #1
    6944:	409a      	lsls	r2, r3
    6946:	1dfb      	adds	r3, r7, #7
    6948:	7819      	ldrb	r1, [r3, #0]
    694a:	23c0      	movs	r3, #192	; 0xc0
    694c:	05db      	lsls	r3, r3, #23
    694e:	0018      	movs	r0, r3
    6950:	f7ff fdb9 	bl	64c6 <hri_port_set_OUT_reg>
		break;
    6954:	e025      	b.n	69a2 <_gpio_set_pin_pull_mode+0xca>
		hri_port_clear_DIR_reg(PORT_IOBUS, port, 1U << pin);
    6956:	1dbb      	adds	r3, r7, #6
    6958:	781b      	ldrb	r3, [r3, #0]
    695a:	2201      	movs	r2, #1
    695c:	409a      	lsls	r2, r3
    695e:	1dfb      	adds	r3, r7, #7
    6960:	7819      	ldrb	r1, [r3, #0]
    6962:	23c0      	movs	r3, #192	; 0xc0
    6964:	05db      	lsls	r3, r3, #23
    6966:	0018      	movs	r0, r3
    6968:	f7ff fd97 	bl	649a <hri_port_clear_DIR_reg>
		hri_port_set_PINCFG_PULLEN_bit(PORT, port, pin);
    696c:	1dbb      	adds	r3, r7, #6
    696e:	781a      	ldrb	r2, [r3, #0]
    6970:	1dfb      	adds	r3, r7, #7
    6972:	781b      	ldrb	r3, [r3, #0]
    6974:	480d      	ldr	r0, [pc, #52]	; (69ac <_gpio_set_pin_pull_mode+0xd4>)
    6976:	0019      	movs	r1, r3
    6978:	f7ff fe99 	bl	66ae <hri_port_set_PINCFG_PULLEN_bit>
		hri_port_clear_OUT_reg(PORT_IOBUS, port, 1U << pin);
    697c:	1dbb      	adds	r3, r7, #6
    697e:	781b      	ldrb	r3, [r3, #0]
    6980:	2201      	movs	r2, #1
    6982:	409a      	lsls	r2, r3
    6984:	1dfb      	adds	r3, r7, #7
    6986:	7819      	ldrb	r1, [r3, #0]
    6988:	23c0      	movs	r3, #192	; 0xc0
    698a:	05db      	lsls	r3, r3, #23
    698c:	0018      	movs	r0, r3
    698e:	f7ff fdb0 	bl	64f2 <hri_port_clear_OUT_reg>
		break;
    6992:	e006      	b.n	69a2 <_gpio_set_pin_pull_mode+0xca>
		ASSERT(false);
    6994:	4b06      	ldr	r3, [pc, #24]	; (69b0 <_gpio_set_pin_pull_mode+0xd8>)
    6996:	2288      	movs	r2, #136	; 0x88
    6998:	0019      	movs	r1, r3
    699a:	2000      	movs	r0, #0
    699c:	f7fd fcc0 	bl	4320 <assert>
		break;
    69a0:	46c0      	nop			; (mov r8, r8)
}
    69a2:	46c0      	nop			; (mov r8, r8)
    69a4:	46bd      	mov	sp, r7
    69a6:	b003      	add	sp, #12
    69a8:	bd90      	pop	{r4, r7, pc}
    69aa:	46c0      	nop			; (mov r8, r8)
    69ac:	41004400 	.word	0x41004400
    69b0:	00008b6c 	.word	0x00008b6c

000069b4 <_gpio_set_pin_function>:
{
    69b4:	b590      	push	{r4, r7, lr}
    69b6:	b085      	sub	sp, #20
    69b8:	af00      	add	r7, sp, #0
    69ba:	6078      	str	r0, [r7, #4]
    69bc:	6039      	str	r1, [r7, #0]
	uint8_t port = GPIO_PORT(gpio);
    69be:	687b      	ldr	r3, [r7, #4]
    69c0:	095a      	lsrs	r2, r3, #5
    69c2:	230f      	movs	r3, #15
    69c4:	18fb      	adds	r3, r7, r3
    69c6:	701a      	strb	r2, [r3, #0]
	uint8_t pin  = GPIO_PIN(gpio);
    69c8:	687b      	ldr	r3, [r7, #4]
    69ca:	b2da      	uxtb	r2, r3
    69cc:	230e      	movs	r3, #14
    69ce:	18fb      	adds	r3, r7, r3
    69d0:	211f      	movs	r1, #31
    69d2:	400a      	ands	r2, r1
    69d4:	701a      	strb	r2, [r3, #0]
	if (function == GPIO_PIN_FUNCTION_OFF) {
    69d6:	683b      	ldr	r3, [r7, #0]
    69d8:	3301      	adds	r3, #1
    69da:	d10a      	bne.n	69f2 <_gpio_set_pin_function+0x3e>
		hri_port_write_PINCFG_PMUXEN_bit(PORT, port, pin, false);
    69dc:	230e      	movs	r3, #14
    69de:	18fb      	adds	r3, r7, r3
    69e0:	781a      	ldrb	r2, [r3, #0]
    69e2:	230f      	movs	r3, #15
    69e4:	18fb      	adds	r3, r7, r3
    69e6:	7819      	ldrb	r1, [r3, #0]
    69e8:	481b      	ldr	r0, [pc, #108]	; (6a58 <_gpio_set_pin_function+0xa4>)
    69ea:	2300      	movs	r3, #0
    69ec:	f7ff fe1e 	bl	662c <hri_port_write_PINCFG_PMUXEN_bit>
}
    69f0:	e02e      	b.n	6a50 <_gpio_set_pin_function+0x9c>
		hri_port_write_PINCFG_PMUXEN_bit(PORT, port, pin, true);
    69f2:	230e      	movs	r3, #14
    69f4:	18fb      	adds	r3, r7, r3
    69f6:	781a      	ldrb	r2, [r3, #0]
    69f8:	230f      	movs	r3, #15
    69fa:	18fb      	adds	r3, r7, r3
    69fc:	7819      	ldrb	r1, [r3, #0]
    69fe:	4816      	ldr	r0, [pc, #88]	; (6a58 <_gpio_set_pin_function+0xa4>)
    6a00:	2301      	movs	r3, #1
    6a02:	f7ff fe13 	bl	662c <hri_port_write_PINCFG_PMUXEN_bit>
		if (pin & 1) {
    6a06:	230e      	movs	r3, #14
    6a08:	18fb      	adds	r3, r7, r3
    6a0a:	781b      	ldrb	r3, [r3, #0]
    6a0c:	2201      	movs	r2, #1
    6a0e:	4013      	ands	r3, r2
    6a10:	d00f      	beq.n	6a32 <_gpio_set_pin_function+0x7e>
			hri_port_write_PMUX_PMUXO_bf(PORT, port, pin >> 1, function & 0xffff);
    6a12:	230e      	movs	r3, #14
    6a14:	18fb      	adds	r3, r7, r3
    6a16:	781b      	ldrb	r3, [r3, #0]
    6a18:	085b      	lsrs	r3, r3, #1
    6a1a:	b2da      	uxtb	r2, r3
    6a1c:	683b      	ldr	r3, [r7, #0]
    6a1e:	b2d8      	uxtb	r0, r3
    6a20:	230f      	movs	r3, #15
    6a22:	18fb      	adds	r3, r7, r3
    6a24:	7819      	ldrb	r1, [r3, #0]
    6a26:	4c0c      	ldr	r4, [pc, #48]	; (6a58 <_gpio_set_pin_function+0xa4>)
    6a28:	0003      	movs	r3, r0
    6a2a:	0020      	movs	r0, r4
    6a2c:	f7ff fdbb 	bl	65a6 <hri_port_write_PMUX_PMUXO_bf>
}
    6a30:	e00e      	b.n	6a50 <_gpio_set_pin_function+0x9c>
			hri_port_write_PMUX_PMUXE_bf(PORT, port, pin >> 1, function & 0xffff);
    6a32:	230e      	movs	r3, #14
    6a34:	18fb      	adds	r3, r7, r3
    6a36:	781b      	ldrb	r3, [r3, #0]
    6a38:	085b      	lsrs	r3, r3, #1
    6a3a:	b2da      	uxtb	r2, r3
    6a3c:	683b      	ldr	r3, [r7, #0]
    6a3e:	b2d8      	uxtb	r0, r3
    6a40:	230f      	movs	r3, #15
    6a42:	18fb      	adds	r3, r7, r3
    6a44:	7819      	ldrb	r1, [r3, #0]
    6a46:	4c04      	ldr	r4, [pc, #16]	; (6a58 <_gpio_set_pin_function+0xa4>)
    6a48:	0003      	movs	r3, r0
    6a4a:	0020      	movs	r0, r4
    6a4c:	f7ff fd67 	bl	651e <hri_port_write_PMUX_PMUXE_bf>
}
    6a50:	46c0      	nop			; (mov r8, r8)
    6a52:	46bd      	mov	sp, r7
    6a54:	b005      	add	sp, #20
    6a56:	bd90      	pop	{r4, r7, pc}
    6a58:	41004400 	.word	0x41004400

00006a5c <gpio_set_pin_pull_mode>:
{
    6a5c:	b580      	push	{r7, lr}
    6a5e:	b082      	sub	sp, #8
    6a60:	af00      	add	r7, sp, #0
    6a62:	0002      	movs	r2, r0
    6a64:	1dfb      	adds	r3, r7, #7
    6a66:	701a      	strb	r2, [r3, #0]
    6a68:	1dbb      	adds	r3, r7, #6
    6a6a:	1c0a      	adds	r2, r1, #0
    6a6c:	701a      	strb	r2, [r3, #0]
	_gpio_set_pin_pull_mode((enum gpio_port)GPIO_PORT(pin), pin & 0x1F, pull_mode);
    6a6e:	1dfb      	adds	r3, r7, #7
    6a70:	781b      	ldrb	r3, [r3, #0]
    6a72:	095b      	lsrs	r3, r3, #5
    6a74:	b2d8      	uxtb	r0, r3
    6a76:	1dfb      	adds	r3, r7, #7
    6a78:	781b      	ldrb	r3, [r3, #0]
    6a7a:	221f      	movs	r2, #31
    6a7c:	4013      	ands	r3, r2
    6a7e:	b2d9      	uxtb	r1, r3
    6a80:	1dbb      	adds	r3, r7, #6
    6a82:	781b      	ldrb	r3, [r3, #0]
    6a84:	001a      	movs	r2, r3
    6a86:	f7ff ff27 	bl	68d8 <_gpio_set_pin_pull_mode>
}
    6a8a:	46c0      	nop			; (mov r8, r8)
    6a8c:	46bd      	mov	sp, r7
    6a8e:	b002      	add	sp, #8
    6a90:	bd80      	pop	{r7, pc}

00006a92 <gpio_set_pin_function>:
{
    6a92:	b580      	push	{r7, lr}
    6a94:	b082      	sub	sp, #8
    6a96:	af00      	add	r7, sp, #0
    6a98:	6078      	str	r0, [r7, #4]
    6a9a:	6039      	str	r1, [r7, #0]
	_gpio_set_pin_function(pin, function);
    6a9c:	683a      	ldr	r2, [r7, #0]
    6a9e:	687b      	ldr	r3, [r7, #4]
    6aa0:	0011      	movs	r1, r2
    6aa2:	0018      	movs	r0, r3
    6aa4:	f7ff ff86 	bl	69b4 <_gpio_set_pin_function>
}
    6aa8:	46c0      	nop			; (mov r8, r8)
    6aaa:	46bd      	mov	sp, r7
    6aac:	b002      	add	sp, #8
    6aae:	bd80      	pop	{r7, pc}

00006ab0 <gpio_set_pin_direction>:
{
    6ab0:	b580      	push	{r7, lr}
    6ab2:	b082      	sub	sp, #8
    6ab4:	af00      	add	r7, sp, #0
    6ab6:	0002      	movs	r2, r0
    6ab8:	1dfb      	adds	r3, r7, #7
    6aba:	701a      	strb	r2, [r3, #0]
    6abc:	1dbb      	adds	r3, r7, #6
    6abe:	1c0a      	adds	r2, r1, #0
    6ac0:	701a      	strb	r2, [r3, #0]
	_gpio_set_direction((enum gpio_port)GPIO_PORT(pin), 1U << GPIO_PIN(pin), direction);
    6ac2:	1dfb      	adds	r3, r7, #7
    6ac4:	781b      	ldrb	r3, [r3, #0]
    6ac6:	095b      	lsrs	r3, r3, #5
    6ac8:	b2d8      	uxtb	r0, r3
    6aca:	1dfb      	adds	r3, r7, #7
    6acc:	781b      	ldrb	r3, [r3, #0]
    6ace:	221f      	movs	r2, #31
    6ad0:	4013      	ands	r3, r2
    6ad2:	2201      	movs	r2, #1
    6ad4:	409a      	lsls	r2, r3
    6ad6:	0011      	movs	r1, r2
    6ad8:	1dbb      	adds	r3, r7, #6
    6ada:	781b      	ldrb	r3, [r3, #0]
    6adc:	001a      	movs	r2, r3
    6ade:	f7ff fe53 	bl	6788 <_gpio_set_direction>
}
    6ae2:	46c0      	nop			; (mov r8, r8)
    6ae4:	46bd      	mov	sp, r7
    6ae6:	b002      	add	sp, #8
    6ae8:	bd80      	pop	{r7, pc}

00006aea <gpio_set_pin_level>:
{
    6aea:	b580      	push	{r7, lr}
    6aec:	b082      	sub	sp, #8
    6aee:	af00      	add	r7, sp, #0
    6af0:	0002      	movs	r2, r0
    6af2:	1dfb      	adds	r3, r7, #7
    6af4:	701a      	strb	r2, [r3, #0]
    6af6:	1dbb      	adds	r3, r7, #6
    6af8:	1c0a      	adds	r2, r1, #0
    6afa:	701a      	strb	r2, [r3, #0]
	_gpio_set_level((enum gpio_port)GPIO_PORT(pin), 1U << GPIO_PIN(pin), level);
    6afc:	1dfb      	adds	r3, r7, #7
    6afe:	781b      	ldrb	r3, [r3, #0]
    6b00:	095b      	lsrs	r3, r3, #5
    6b02:	b2d8      	uxtb	r0, r3
    6b04:	1dfb      	adds	r3, r7, #7
    6b06:	781b      	ldrb	r3, [r3, #0]
    6b08:	221f      	movs	r2, #31
    6b0a:	4013      	ands	r3, r2
    6b0c:	2201      	movs	r2, #1
    6b0e:	409a      	lsls	r2, r3
    6b10:	0011      	movs	r1, r2
    6b12:	1dbb      	adds	r3, r7, #6
    6b14:	781b      	ldrb	r3, [r3, #0]
    6b16:	001a      	movs	r2, r3
    6b18:	f7ff feba 	bl	6890 <_gpio_set_level>
}
    6b1c:	46c0      	nop			; (mov r8, r8)
    6b1e:	46bd      	mov	sp, r7
    6b20:	b002      	add	sp, #8
    6b22:	bd80      	pop	{r7, pc}

00006b24 <_gclk_enable_channel>:
{
    6b24:	b580      	push	{r7, lr}
    6b26:	b082      	sub	sp, #8
    6b28:	af00      	add	r7, sp, #0
    6b2a:	0002      	movs	r2, r0
    6b2c:	1dfb      	adds	r3, r7, #7
    6b2e:	701a      	strb	r2, [r3, #0]
    6b30:	1dbb      	adds	r3, r7, #6
    6b32:	1c0a      	adds	r2, r1, #0
    6b34:	701a      	strb	r2, [r3, #0]
	                           GCLK_CLKCTRL_ID(channel) | GCLK_CLKCTRL_GEN(source) | (1 << GCLK_CLKCTRL_CLKEN_Pos));
    6b36:	1dfb      	adds	r3, r7, #7
    6b38:	781b      	ldrb	r3, [r3, #0]
    6b3a:	b29b      	uxth	r3, r3
    6b3c:	223f      	movs	r2, #63	; 0x3f
    6b3e:	4013      	ands	r3, r2
    6b40:	b29a      	uxth	r2, r3
    6b42:	1dbb      	adds	r3, r7, #6
    6b44:	781b      	ldrb	r3, [r3, #0]
    6b46:	b29b      	uxth	r3, r3
    6b48:	021b      	lsls	r3, r3, #8
    6b4a:	b299      	uxth	r1, r3
    6b4c:	23f0      	movs	r3, #240	; 0xf0
    6b4e:	011b      	lsls	r3, r3, #4
    6b50:	400b      	ands	r3, r1
    6b52:	b29b      	uxth	r3, r3
    6b54:	4313      	orrs	r3, r2
    6b56:	b29b      	uxth	r3, r3
	hri_gclk_write_CLKCTRL_reg(GCLK,
    6b58:	2280      	movs	r2, #128	; 0x80
    6b5a:	01d2      	lsls	r2, r2, #7
    6b5c:	4313      	orrs	r3, r2
    6b5e:	b29b      	uxth	r3, r3
    6b60:	4a04      	ldr	r2, [pc, #16]	; (6b74 <_gclk_enable_channel+0x50>)
    6b62:	0019      	movs	r1, r3
    6b64:	0010      	movs	r0, r2
    6b66:	f7ff fc73 	bl	6450 <hri_gclk_write_CLKCTRL_reg>
}
    6b6a:	46c0      	nop			; (mov r8, r8)
    6b6c:	46bd      	mov	sp, r7
    6b6e:	b002      	add	sp, #8
    6b70:	bd80      	pop	{r7, pc}
    6b72:	46c0      	nop			; (mov r8, r8)
    6b74:	40000c00 	.word	0x40000c00

00006b78 <_pm_get_ahb_index>:
{
    6b78:	b580      	push	{r7, lr}
    6b7a:	b082      	sub	sp, #8
    6b7c:	af00      	add	r7, sp, #0
    6b7e:	6078      	str	r0, [r7, #4]
	if ((uint32_t)module == (uint32_t)PM_BUS_APBA) {
    6b80:	687b      	ldr	r3, [r7, #4]
    6b82:	2b01      	cmp	r3, #1
    6b84:	d101      	bne.n	6b8a <_pm_get_ahb_index+0x12>
		return 0;
    6b86:	2300      	movs	r3, #0
    6b88:	e017      	b.n	6bba <_pm_get_ahb_index+0x42>
	} else if ((uint32_t)module == (uint32_t)PM_BUS_APBB) {
    6b8a:	687b      	ldr	r3, [r7, #4]
    6b8c:	2b02      	cmp	r3, #2
    6b8e:	d101      	bne.n	6b94 <_pm_get_ahb_index+0x1c>
		return 1;
    6b90:	2301      	movs	r3, #1
    6b92:	e012      	b.n	6bba <_pm_get_ahb_index+0x42>
	} else if ((uint32_t)module == (uint32_t)PM_BUS_APBC) {
    6b94:	687b      	ldr	r3, [r7, #4]
    6b96:	2b03      	cmp	r3, #3
    6b98:	d101      	bne.n	6b9e <_pm_get_ahb_index+0x26>
		return 2;
    6b9a:	2302      	movs	r3, #2
    6b9c:	e00d      	b.n	6bba <_pm_get_ahb_index+0x42>
	if ((uint32_t)module == (uint32_t)DSU) {
    6b9e:	687b      	ldr	r3, [r7, #4]
    6ba0:	4a08      	ldr	r2, [pc, #32]	; (6bc4 <_pm_get_ahb_index+0x4c>)
    6ba2:	4293      	cmp	r3, r2
    6ba4:	d101      	bne.n	6baa <_pm_get_ahb_index+0x32>
		return 3;
    6ba6:	2303      	movs	r3, #3
    6ba8:	e007      	b.n	6bba <_pm_get_ahb_index+0x42>
	} else if ((uint32_t)module == (uint32_t)NVMCTRL) {
    6baa:	687b      	ldr	r3, [r7, #4]
    6bac:	4a06      	ldr	r2, [pc, #24]	; (6bc8 <_pm_get_ahb_index+0x50>)
    6bae:	4293      	cmp	r3, r2
    6bb0:	d101      	bne.n	6bb6 <_pm_get_ahb_index+0x3e>
		return 4;
    6bb2:	2304      	movs	r3, #4
    6bb4:	e001      	b.n	6bba <_pm_get_ahb_index+0x42>
	return ERR_INVALID_ARG;
    6bb6:	230d      	movs	r3, #13
    6bb8:	425b      	negs	r3, r3
}
    6bba:	0018      	movs	r0, r3
    6bbc:	46bd      	mov	sp, r7
    6bbe:	b002      	add	sp, #8
    6bc0:	bd80      	pop	{r7, pc}
    6bc2:	46c0      	nop			; (mov r8, r8)
    6bc4:	41002000 	.word	0x41002000
    6bc8:	41004000 	.word	0x41004000

00006bcc <_pm_get_apbb_index>:
{
    6bcc:	b580      	push	{r7, lr}
    6bce:	b082      	sub	sp, #8
    6bd0:	af00      	add	r7, sp, #0
    6bd2:	6078      	str	r0, [r7, #4]
	if ((uint32_t)module == (uint32_t)PAC1) {
    6bd4:	687a      	ldr	r2, [r7, #4]
    6bd6:	2382      	movs	r3, #130	; 0x82
    6bd8:	05db      	lsls	r3, r3, #23
    6bda:	429a      	cmp	r2, r3
    6bdc:	d101      	bne.n	6be2 <_pm_get_apbb_index+0x16>
		return 0;
    6bde:	2300      	movs	r3, #0
    6be0:	e013      	b.n	6c0a <_pm_get_apbb_index+0x3e>
	} else if ((uint32_t)module == (uint32_t)DSU) {
    6be2:	687b      	ldr	r3, [r7, #4]
    6be4:	4a0b      	ldr	r2, [pc, #44]	; (6c14 <_pm_get_apbb_index+0x48>)
    6be6:	4293      	cmp	r3, r2
    6be8:	d101      	bne.n	6bee <_pm_get_apbb_index+0x22>
		return 1;
    6bea:	2301      	movs	r3, #1
    6bec:	e00d      	b.n	6c0a <_pm_get_apbb_index+0x3e>
	} else if ((uint32_t)module == (uint32_t)NVMCTRL) {
    6bee:	687b      	ldr	r3, [r7, #4]
    6bf0:	4a09      	ldr	r2, [pc, #36]	; (6c18 <_pm_get_apbb_index+0x4c>)
    6bf2:	4293      	cmp	r3, r2
    6bf4:	d101      	bne.n	6bfa <_pm_get_apbb_index+0x2e>
		return 2;
    6bf6:	2302      	movs	r3, #2
    6bf8:	e007      	b.n	6c0a <_pm_get_apbb_index+0x3e>
	if ((uint32_t)module == (uint32_t)PORT) {
    6bfa:	687b      	ldr	r3, [r7, #4]
    6bfc:	4a07      	ldr	r2, [pc, #28]	; (6c1c <_pm_get_apbb_index+0x50>)
    6bfe:	4293      	cmp	r3, r2
    6c00:	d101      	bne.n	6c06 <_pm_get_apbb_index+0x3a>
		return 3;
    6c02:	2303      	movs	r3, #3
    6c04:	e001      	b.n	6c0a <_pm_get_apbb_index+0x3e>
	return ERR_INVALID_ARG;
    6c06:	230d      	movs	r3, #13
    6c08:	425b      	negs	r3, r3
}
    6c0a:	0018      	movs	r0, r3
    6c0c:	46bd      	mov	sp, r7
    6c0e:	b002      	add	sp, #8
    6c10:	bd80      	pop	{r7, pc}
    6c12:	46c0      	nop			; (mov r8, r8)
    6c14:	41002000 	.word	0x41002000
    6c18:	41004000 	.word	0x41004000
    6c1c:	41004400 	.word	0x41004400

00006c20 <_pm_enable_bus_clock>:
{
    6c20:	b580      	push	{r7, lr}
    6c22:	b084      	sub	sp, #16
    6c24:	af00      	add	r7, sp, #0
    6c26:	0002      	movs	r2, r0
    6c28:	6039      	str	r1, [r7, #0]
    6c2a:	1dfb      	adds	r3, r7, #7
    6c2c:	701a      	strb	r2, [r3, #0]
	uint32_t peripheral = ((uint32_t)module & 0x0000ff00) >> 10;
    6c2e:	683b      	ldr	r3, [r7, #0]
    6c30:	0a9b      	lsrs	r3, r3, #10
    6c32:	223f      	movs	r2, #63	; 0x3f
    6c34:	4013      	ands	r3, r2
    6c36:	60fb      	str	r3, [r7, #12]
	switch (bus) {
    6c38:	1dfb      	adds	r3, r7, #7
    6c3a:	781b      	ldrb	r3, [r3, #0]
    6c3c:	2b01      	cmp	r3, #1
    6c3e:	d01e      	beq.n	6c7e <_pm_enable_bus_clock+0x5e>
    6c40:	dc02      	bgt.n	6c48 <_pm_enable_bus_clock+0x28>
    6c42:	2b00      	cmp	r3, #0
    6c44:	d005      	beq.n	6c52 <_pm_enable_bus_clock+0x32>
    6c46:	e044      	b.n	6cd2 <_pm_enable_bus_clock+0xb2>
    6c48:	2b02      	cmp	r3, #2
    6c4a:	d022      	beq.n	6c92 <_pm_enable_bus_clock+0x72>
    6c4c:	2b03      	cmp	r3, #3
    6c4e:	d036      	beq.n	6cbe <_pm_enable_bus_clock+0x9e>
    6c50:	e03f      	b.n	6cd2 <_pm_enable_bus_clock+0xb2>
		if (_pm_get_ahb_index(module) >= 0) {
    6c52:	683b      	ldr	r3, [r7, #0]
    6c54:	0018      	movs	r0, r3
    6c56:	f7ff ff8f 	bl	6b78 <_pm_get_ahb_index>
    6c5a:	1e03      	subs	r3, r0, #0
    6c5c:	db40      	blt.n	6ce0 <_pm_enable_bus_clock+0xc0>
			peripheral = (uint32_t)_pm_get_ahb_index(module);
    6c5e:	683b      	ldr	r3, [r7, #0]
    6c60:	0018      	movs	r0, r3
    6c62:	f7ff ff89 	bl	6b78 <_pm_get_ahb_index>
    6c66:	0003      	movs	r3, r0
    6c68:	60fb      	str	r3, [r7, #12]
			PM->AHBMASK.reg |= 1 << peripheral;
    6c6a:	4b21      	ldr	r3, [pc, #132]	; (6cf0 <_pm_enable_bus_clock+0xd0>)
    6c6c:	4a20      	ldr	r2, [pc, #128]	; (6cf0 <_pm_enable_bus_clock+0xd0>)
    6c6e:	6952      	ldr	r2, [r2, #20]
    6c70:	2001      	movs	r0, #1
    6c72:	68f9      	ldr	r1, [r7, #12]
    6c74:	4088      	lsls	r0, r1
    6c76:	0001      	movs	r1, r0
    6c78:	430a      	orrs	r2, r1
    6c7a:	615a      	str	r2, [r3, #20]
		break;
    6c7c:	e030      	b.n	6ce0 <_pm_enable_bus_clock+0xc0>
		PM->APBAMASK.reg |= 1 << peripheral;
    6c7e:	4b1c      	ldr	r3, [pc, #112]	; (6cf0 <_pm_enable_bus_clock+0xd0>)
    6c80:	4a1b      	ldr	r2, [pc, #108]	; (6cf0 <_pm_enable_bus_clock+0xd0>)
    6c82:	6992      	ldr	r2, [r2, #24]
    6c84:	2001      	movs	r0, #1
    6c86:	68f9      	ldr	r1, [r7, #12]
    6c88:	4088      	lsls	r0, r1
    6c8a:	0001      	movs	r1, r0
    6c8c:	430a      	orrs	r2, r1
    6c8e:	619a      	str	r2, [r3, #24]
		break;
    6c90:	e029      	b.n	6ce6 <_pm_enable_bus_clock+0xc6>
		if (_pm_get_apbb_index(module) >= 0) {
    6c92:	683b      	ldr	r3, [r7, #0]
    6c94:	0018      	movs	r0, r3
    6c96:	f7ff ff99 	bl	6bcc <_pm_get_apbb_index>
    6c9a:	1e03      	subs	r3, r0, #0
    6c9c:	db22      	blt.n	6ce4 <_pm_enable_bus_clock+0xc4>
			peripheral = (uint32_t)_pm_get_apbb_index(module);
    6c9e:	683b      	ldr	r3, [r7, #0]
    6ca0:	0018      	movs	r0, r3
    6ca2:	f7ff ff93 	bl	6bcc <_pm_get_apbb_index>
    6ca6:	0003      	movs	r3, r0
    6ca8:	60fb      	str	r3, [r7, #12]
			PM->APBBMASK.reg |= 1 << peripheral;
    6caa:	4b11      	ldr	r3, [pc, #68]	; (6cf0 <_pm_enable_bus_clock+0xd0>)
    6cac:	4a10      	ldr	r2, [pc, #64]	; (6cf0 <_pm_enable_bus_clock+0xd0>)
    6cae:	69d2      	ldr	r2, [r2, #28]
    6cb0:	2001      	movs	r0, #1
    6cb2:	68f9      	ldr	r1, [r7, #12]
    6cb4:	4088      	lsls	r0, r1
    6cb6:	0001      	movs	r1, r0
    6cb8:	430a      	orrs	r2, r1
    6cba:	61da      	str	r2, [r3, #28]
		break;
    6cbc:	e012      	b.n	6ce4 <_pm_enable_bus_clock+0xc4>
		PM->APBCMASK.reg |= 1 << peripheral;
    6cbe:	4b0c      	ldr	r3, [pc, #48]	; (6cf0 <_pm_enable_bus_clock+0xd0>)
    6cc0:	4a0b      	ldr	r2, [pc, #44]	; (6cf0 <_pm_enable_bus_clock+0xd0>)
    6cc2:	6a12      	ldr	r2, [r2, #32]
    6cc4:	2001      	movs	r0, #1
    6cc6:	68f9      	ldr	r1, [r7, #12]
    6cc8:	4088      	lsls	r0, r1
    6cca:	0001      	movs	r1, r0
    6ccc:	430a      	orrs	r2, r1
    6cce:	621a      	str	r2, [r3, #32]
		break;
    6cd0:	e009      	b.n	6ce6 <_pm_enable_bus_clock+0xc6>
		ASSERT(false);
    6cd2:	4b08      	ldr	r3, [pc, #32]	; (6cf4 <_pm_enable_bus_clock+0xd4>)
    6cd4:	228d      	movs	r2, #141	; 0x8d
    6cd6:	0019      	movs	r1, r3
    6cd8:	2000      	movs	r0, #0
    6cda:	f7fd fb21 	bl	4320 <assert>
		break;
    6cde:	e002      	b.n	6ce6 <_pm_enable_bus_clock+0xc6>
		break;
    6ce0:	46c0      	nop			; (mov r8, r8)
    6ce2:	e000      	b.n	6ce6 <_pm_enable_bus_clock+0xc6>
		break;
    6ce4:	46c0      	nop			; (mov r8, r8)
}
    6ce6:	46c0      	nop			; (mov r8, r8)
    6ce8:	46bd      	mov	sp, r7
    6cea:	b004      	add	sp, #16
    6cec:	bd80      	pop	{r7, pc}
    6cee:	46c0      	nop			; (mov r8, r8)
    6cf0:	40000400 	.word	0x40000400
    6cf4:	00008b88 	.word	0x00008b88

00006cf8 <RF_IRQ_Enable>:

struct io_descriptor *io;
struct io_descriptor *I2C_io;


void RF_IRQ_Enable(void){
    6cf8:	b580      	push	{r7, lr}
    6cfa:	af00      	add	r7, sp, #0
	ext_irq_register(RF_IRQ, RF_int_Handler);
    6cfc:	4b05      	ldr	r3, [pc, #20]	; (6d14 <RF_IRQ_Enable+0x1c>)
    6cfe:	0019      	movs	r1, r3
    6d00:	203e      	movs	r0, #62	; 0x3e
    6d02:	f7fc fea7 	bl	3a54 <ext_irq_register>
	//ext_irq_register(RF_IRQ, NULL);
	//gpio_toggle_pin_level(LED_G);
	//spi_m_sync_get_io_descriptor(&VFD_SPI, &iospi);
	spi_m_sync_enable(&RF_SPI);
    6d06:	4b04      	ldr	r3, [pc, #16]	; (6d18 <RF_IRQ_Enable+0x20>)
    6d08:	0018      	movs	r0, r3
    6d0a:	f7fd f959 	bl	3fc0 <spi_m_sync_enable>
	
	
}
    6d0e:	46c0      	nop			; (mov r8, r8)
    6d10:	46bd      	mov	sp, r7
    6d12:	bd80      	pop	{r7, pc}
    6d14:	00006d31 	.word	0x00006d31
    6d18:	200007e8 	.word	0x200007e8

00006d1c <rf_isReady>:


uint8_t int_count = 0;
uint8_t rf_isReady(){
    6d1c:	b580      	push	{r7, lr}
    6d1e:	af00      	add	r7, sp, #0
	return int_count;
    6d20:	4b02      	ldr	r3, [pc, #8]	; (6d2c <rf_isReady+0x10>)
    6d22:	781b      	ldrb	r3, [r3, #0]
}
    6d24:	0018      	movs	r0, r3
    6d26:	46bd      	mov	sp, r7
    6d28:	bd80      	pop	{r7, pc}
    6d2a:	46c0      	nop			; (mov r8, r8)
    6d2c:	200007d0 	.word	0x200007d0

00006d30 <RF_int_Handler>:

void RF_int_Handler(void){
    6d30:	b580      	push	{r7, lr}
    6d32:	af00      	add	r7, sp, #0
	int_count++;
    6d34:	4b05      	ldr	r3, [pc, #20]	; (6d4c <RF_int_Handler+0x1c>)
    6d36:	781b      	ldrb	r3, [r3, #0]
    6d38:	3301      	adds	r3, #1
    6d3a:	b2da      	uxtb	r2, r3
    6d3c:	4b03      	ldr	r3, [pc, #12]	; (6d4c <RF_int_Handler+0x1c>)
    6d3e:	701a      	strb	r2, [r3, #0]
	//gpio_toggle_pin_level(LED);
	data_ready();
    6d40:	f000 fbec 	bl	751c <data_ready>
}
    6d44:	46c0      	nop			; (mov r8, r8)
    6d46:	46bd      	mov	sp, r7
    6d48:	bd80      	pop	{r7, pc}
    6d4a:	46c0      	nop			; (mov r8, r8)
    6d4c:	200007d0 	.word	0x200007d0

00006d50 <RFM69_ReadBuff>:
	io_write(io, &addr, 1);
	io_read(io,&addr,1);
	return addr;
}

void RFM69_ReadBuff(uint8_t* buff, uint16_t len){
    6d50:	b580      	push	{r7, lr}
    6d52:	b082      	sub	sp, #8
    6d54:	af00      	add	r7, sp, #0
    6d56:	6078      	str	r0, [r7, #4]
    6d58:	000a      	movs	r2, r1
    6d5a:	1cbb      	adds	r3, r7, #2
    6d5c:	801a      	strh	r2, [r3, #0]
	spi_m_sync_get_io_descriptor(&RF_SPI, &io);
    6d5e:	4a09      	ldr	r2, [pc, #36]	; (6d84 <RFM69_ReadBuff+0x34>)
    6d60:	4b09      	ldr	r3, [pc, #36]	; (6d88 <RFM69_ReadBuff+0x38>)
    6d62:	0011      	movs	r1, r2
    6d64:	0018      	movs	r0, r3
    6d66:	f7fd f9d5 	bl	4114 <spi_m_sync_get_io_descriptor>
	//spi_m_sync_enable(&VFD_SPI);
	io_read(io,buff,len);
    6d6a:	4b06      	ldr	r3, [pc, #24]	; (6d84 <RFM69_ReadBuff+0x34>)
    6d6c:	6818      	ldr	r0, [r3, #0]
    6d6e:	1cbb      	adds	r3, r7, #2
    6d70:	881a      	ldrh	r2, [r3, #0]
    6d72:	687b      	ldr	r3, [r7, #4]
    6d74:	0019      	movs	r1, r3
    6d76:	f7fd f8bb 	bl	3ef0 <io_read>
}
    6d7a:	46c0      	nop			; (mov r8, r8)
    6d7c:	46bd      	mov	sp, r7
    6d7e:	b002      	add	sp, #8
    6d80:	bd80      	pop	{r7, pc}
    6d82:	46c0      	nop			; (mov r8, r8)
    6d84:	2000083c 	.word	0x2000083c
    6d88:	200007e8 	.word	0x200007e8

00006d8c <RFM_69_sel>:



void RFM_69_sel(bool arg){
    6d8c:	b580      	push	{r7, lr}
    6d8e:	b082      	sub	sp, #8
    6d90:	af00      	add	r7, sp, #0
    6d92:	0002      	movs	r2, r0
    6d94:	1dfb      	adds	r3, r7, #7
    6d96:	701a      	strb	r2, [r3, #0]
	gpio_set_pin_level(RF_CS , arg);
    6d98:	1dfb      	adds	r3, r7, #7
    6d9a:	781b      	ldrb	r3, [r3, #0]
    6d9c:	0019      	movs	r1, r3
    6d9e:	201c      	movs	r0, #28
    6da0:	f7ff fea3 	bl	6aea <gpio_set_pin_level>
}
    6da4:	46c0      	nop			; (mov r8, r8)
    6da6:	46bd      	mov	sp, r7
    6da8:	b002      	add	sp, #8
    6daa:	bd80      	pop	{r7, pc}

00006dac <SPI_write>:

void SPI_write(uint8_t arg){
    6dac:	b580      	push	{r7, lr}
    6dae:	b084      	sub	sp, #16
    6db0:	af00      	add	r7, sp, #0
    6db2:	0002      	movs	r2, r0
    6db4:	1dfb      	adds	r3, r7, #7
    6db6:	701a      	strb	r2, [r3, #0]
	uint8_t *addr_ptr = &arg;
    6db8:	1dfb      	adds	r3, r7, #7
    6dba:	60fb      	str	r3, [r7, #12]
	struct io_descriptor *io;
	spi_m_sync_get_io_descriptor(&RF_SPI, &io); ///<<< EXP
    6dbc:	2308      	movs	r3, #8
    6dbe:	18fa      	adds	r2, r7, r3
    6dc0:	4b09      	ldr	r3, [pc, #36]	; (6de8 <SPI_write+0x3c>)
    6dc2:	0011      	movs	r1, r2
    6dc4:	0018      	movs	r0, r3
    6dc6:	f7fd f9a5 	bl	4114 <spi_m_sync_get_io_descriptor>
	spi_m_sync_enable(&RF_SPI);
    6dca:	4b07      	ldr	r3, [pc, #28]	; (6de8 <SPI_write+0x3c>)
    6dcc:	0018      	movs	r0, r3
    6dce:	f7fd f8f7 	bl	3fc0 <spi_m_sync_enable>
	io_write(io, &arg, 1);	
    6dd2:	68bb      	ldr	r3, [r7, #8]
    6dd4:	1df9      	adds	r1, r7, #7
    6dd6:	2201      	movs	r2, #1
    6dd8:	0018      	movs	r0, r3
    6dda:	f7fd f861 	bl	3ea0 <io_write>
}
    6dde:	46c0      	nop			; (mov r8, r8)
    6de0:	46bd      	mov	sp, r7
    6de2:	b004      	add	sp, #16
    6de4:	bd80      	pop	{r7, pc}
    6de6:	46c0      	nop			; (mov r8, r8)
    6de8:	200007e8 	.word	0x200007e8

00006dec <SPI_read>:


uint8_t SPI_read(){
    6dec:	b580      	push	{r7, lr}
    6dee:	b082      	sub	sp, #8
    6df0:	af00      	add	r7, sp, #0
	uint8_t data_byte = 0;
    6df2:	1dfb      	adds	r3, r7, #7
    6df4:	2200      	movs	r2, #0
    6df6:	701a      	strb	r2, [r3, #0]
	spi_m_sync_get_io_descriptor(&RF_SPI, &io); ///<<< EXP
    6df8:	4a09      	ldr	r2, [pc, #36]	; (6e20 <SPI_read+0x34>)
    6dfa:	4b0a      	ldr	r3, [pc, #40]	; (6e24 <SPI_read+0x38>)
    6dfc:	0011      	movs	r1, r2
    6dfe:	0018      	movs	r0, r3
    6e00:	f7fd f988 	bl	4114 <spi_m_sync_get_io_descriptor>
	io_read(io,&data_byte,1);
    6e04:	4b06      	ldr	r3, [pc, #24]	; (6e20 <SPI_read+0x34>)
    6e06:	681b      	ldr	r3, [r3, #0]
    6e08:	1df9      	adds	r1, r7, #7
    6e0a:	2201      	movs	r2, #1
    6e0c:	0018      	movs	r0, r3
    6e0e:	f7fd f86f 	bl	3ef0 <io_read>
	return data_byte;
    6e12:	1dfb      	adds	r3, r7, #7
    6e14:	781b      	ldrb	r3, [r3, #0]
}
    6e16:	0018      	movs	r0, r3
    6e18:	46bd      	mov	sp, r7
    6e1a:	b002      	add	sp, #8
    6e1c:	bd80      	pop	{r7, pc}
    6e1e:	46c0      	nop			; (mov r8, r8)
    6e20:	2000083c 	.word	0x2000083c
    6e24:	200007e8 	.word	0x200007e8

00006e28 <set_led>:
}
void toggle_led(){
	gpio_toggle_pin_level(LED_G);
}

void set_led(){
    6e28:	b580      	push	{r7, lr}
    6e2a:	af00      	add	r7, sp, #0
	gpio_set_pin_level(LED_G, false);
    6e2c:	2100      	movs	r1, #0
    6e2e:	2020      	movs	r0, #32
    6e30:	f7ff fe5b 	bl	6aea <gpio_set_pin_level>
}
    6e34:	46c0      	nop			; (mov r8, r8)
    6e36:	46bd      	mov	sp, r7
    6e38:	bd80      	pop	{r7, pc}

00006e3a <reset_led>:
void reset_led(){
    6e3a:	b580      	push	{r7, lr}
    6e3c:	af00      	add	r7, sp, #0
	gpio_set_pin_level(LED_G, true);
    6e3e:	2101      	movs	r1, #1
    6e40:	2020      	movs	r0, #32
    6e42:	f7ff fe52 	bl	6aea <gpio_set_pin_level>
}
    6e46:	46c0      	nop			; (mov r8, r8)
    6e48:	46bd      	mov	sp, r7
    6e4a:	bd80      	pop	{r7, pc}

00006e4c <EXT_SPI_init>:

//Display section
void EXT_SPI_init(void)
{
    6e4c:	b580      	push	{r7, lr}
    6e4e:	af00      	add	r7, sp, #0
	_pm_enable_bus_clock(PM_BUS_APBC, SERCOM0);
    6e50:	4b38      	ldr	r3, [pc, #224]	; (6f34 <EXT_SPI_init+0xe8>)
    6e52:	0019      	movs	r1, r3
    6e54:	2003      	movs	r0, #3
    6e56:	f7ff fee3 	bl	6c20 <_pm_enable_bus_clock>
	_gclk_enable_channel(SERCOM0_GCLK_ID_CORE, CONF_GCLK_SERCOM0_CORE_SRC);
    6e5a:	2100      	movs	r1, #0
    6e5c:	200d      	movs	r0, #13
    6e5e:	f7ff fe61 	bl	6b24 <_gclk_enable_channel>
	
	
	spi_m_sync_init(&EXT_SPI, SERCOM0);
    6e62:	4a34      	ldr	r2, [pc, #208]	; (6f34 <EXT_SPI_init+0xe8>)
    6e64:	4b34      	ldr	r3, [pc, #208]	; (6f38 <EXT_SPI_init+0xec>)
    6e66:	0011      	movs	r1, r2
    6e68:	0018      	movs	r0, r3
    6e6a:	f7fd f869 	bl	3f40 <spi_m_sync_init>
	spi_m_sync_get_io_descriptor(&EXT_SPI, &io);
    6e6e:	4a33      	ldr	r2, [pc, #204]	; (6f3c <EXT_SPI_init+0xf0>)
    6e70:	4b31      	ldr	r3, [pc, #196]	; (6f38 <EXT_SPI_init+0xec>)
    6e72:	0011      	movs	r1, r2
    6e74:	0018      	movs	r0, r3
    6e76:	f7fd f94d 	bl	4114 <spi_m_sync_get_io_descriptor>
	
	gpio_set_pin_level(PA04, false);
    6e7a:	2100      	movs	r1, #0
    6e7c:	2004      	movs	r0, #4
    6e7e:	f7ff fe34 	bl	6aea <gpio_set_pin_level>
	gpio_set_pin_direction(PA04, GPIO_DIRECTION_OUT);
    6e82:	2102      	movs	r1, #2
    6e84:	2004      	movs	r0, #4
    6e86:	f7ff fe13 	bl	6ab0 <gpio_set_pin_direction>
	gpio_set_pin_function(PA04, PINMUX_PA04D_SERCOM0_PAD0);
    6e8a:	4b2d      	ldr	r3, [pc, #180]	; (6f40 <EXT_SPI_init+0xf4>)
    6e8c:	0019      	movs	r1, r3
    6e8e:	2004      	movs	r0, #4
    6e90:	f7ff fdff 	bl	6a92 <gpio_set_pin_function>
	gpio_set_pin_level(PA05, false);
    6e94:	2100      	movs	r1, #0
    6e96:	2005      	movs	r0, #5
    6e98:	f7ff fe27 	bl	6aea <gpio_set_pin_level>
	gpio_set_pin_direction(PA05, GPIO_DIRECTION_OUT);
    6e9c:	2102      	movs	r1, #2
    6e9e:	2005      	movs	r0, #5
    6ea0:	f7ff fe06 	bl	6ab0 <gpio_set_pin_direction>
	gpio_set_pin_function(PA05, PINMUX_PA05D_SERCOM0_PAD1);
    6ea4:	4b27      	ldr	r3, [pc, #156]	; (6f44 <EXT_SPI_init+0xf8>)
    6ea6:	0019      	movs	r1, r3
    6ea8:	2005      	movs	r0, #5
    6eaa:	f7ff fdf2 	bl	6a92 <gpio_set_pin_function>
	gpio_set_pin_direction(PA06, GPIO_DIRECTION_IN);
    6eae:	2101      	movs	r1, #1
    6eb0:	2006      	movs	r0, #6
    6eb2:	f7ff fdfd 	bl	6ab0 <gpio_set_pin_direction>
	gpio_set_pin_pull_mode(PA06, GPIO_PULL_OFF);
    6eb6:	2100      	movs	r1, #0
    6eb8:	2006      	movs	r0, #6
    6eba:	f7ff fdcf 	bl	6a5c <gpio_set_pin_pull_mode>
	gpio_set_pin_function(PA06, PINMUX_PA06D_SERCOM0_PAD2);
    6ebe:	4b22      	ldr	r3, [pc, #136]	; (6f48 <EXT_SPI_init+0xfc>)
    6ec0:	0019      	movs	r1, r3
    6ec2:	2006      	movs	r0, #6
    6ec4:	f7ff fde5 	bl	6a92 <gpio_set_pin_function>
	gpio_set_pin_level(VFD_RST, true);
    6ec8:	2101      	movs	r1, #1
    6eca:	2007      	movs	r0, #7
    6ecc:	f7ff fe0d 	bl	6aea <gpio_set_pin_level>
	gpio_set_pin_level(FILAMENT_EN, true);
    6ed0:	2101      	movs	r1, #1
    6ed2:	2026      	movs	r0, #38	; 0x26
    6ed4:	f7ff fe09 	bl	6aea <gpio_set_pin_level>
	
	//io_write(io, example_VFD_SPI, 12);

	//VFD additional IO setup
	gpio_set_pin_level(VFD_RST, true);
    6ed8:	2101      	movs	r1, #1
    6eda:	2007      	movs	r0, #7
    6edc:	f7ff fe05 	bl	6aea <gpio_set_pin_level>
	gpio_set_pin_direction(VFD_RST, GPIO_DIRECTION_OUT);
    6ee0:	2102      	movs	r1, #2
    6ee2:	2007      	movs	r0, #7
    6ee4:	f7ff fde4 	bl	6ab0 <gpio_set_pin_direction>
	gpio_set_pin_function(VFD_RST, GPIO_PIN_FUNCTION_OFF);
    6ee8:	2301      	movs	r3, #1
    6eea:	425b      	negs	r3, r3
    6eec:	0019      	movs	r1, r3
    6eee:	2007      	movs	r0, #7
    6ef0:	f7ff fdcf 	bl	6a92 <gpio_set_pin_function>
	
	gpio_set_pin_level(FILAMENT_EN, true);
    6ef4:	2101      	movs	r1, #1
    6ef6:	2026      	movs	r0, #38	; 0x26
    6ef8:	f7ff fdf7 	bl	6aea <gpio_set_pin_level>
	gpio_set_pin_direction(FILAMENT_EN, GPIO_DIRECTION_OUT);
    6efc:	2102      	movs	r1, #2
    6efe:	2026      	movs	r0, #38	; 0x26
    6f00:	f7ff fdd6 	bl	6ab0 <gpio_set_pin_direction>
	gpio_set_pin_function(FILAMENT_EN, GPIO_PIN_FUNCTION_OFF);	
    6f04:	2301      	movs	r3, #1
    6f06:	425b      	negs	r3, r3
    6f08:	0019      	movs	r1, r3
    6f0a:	2026      	movs	r0, #38	; 0x26
    6f0c:	f7ff fdc1 	bl	6a92 <gpio_set_pin_function>
	
	gpio_set_pin_level(VFD_CS, true);
    6f10:	2101      	movs	r1, #1
    6f12:	2029      	movs	r0, #41	; 0x29
    6f14:	f7ff fde9 	bl	6aea <gpio_set_pin_level>
	gpio_set_pin_direction(VFD_CS, GPIO_DIRECTION_OUT);
    6f18:	2102      	movs	r1, #2
    6f1a:	2029      	movs	r0, #41	; 0x29
    6f1c:	f7ff fdc8 	bl	6ab0 <gpio_set_pin_direction>
	gpio_set_pin_function(VFD_CS, GPIO_PIN_FUNCTION_OFF);
    6f20:	2301      	movs	r3, #1
    6f22:	425b      	negs	r3, r3
    6f24:	0019      	movs	r1, r3
    6f26:	2029      	movs	r0, #41	; 0x29
    6f28:	f7ff fdb3 	bl	6a92 <gpio_set_pin_function>
	
		
}
    6f2c:	46c0      	nop			; (mov r8, r8)
    6f2e:	46bd      	mov	sp, r7
    6f30:	bd80      	pop	{r7, pc}
    6f32:	46c0      	nop			; (mov r8, r8)
    6f34:	42000800 	.word	0x42000800
    6f38:	20000820 	.word	0x20000820
    6f3c:	2000083c 	.word	0x2000083c
    6f40:	00040003 	.word	0x00040003
    6f44:	00050003 	.word	0x00050003
    6f48:	00060003 	.word	0x00060003

00006f4c <vfd_write_data>:
void vfd_write_data(uint8_t* buff, uint16_t len){
    6f4c:	b580      	push	{r7, lr}
    6f4e:	b082      	sub	sp, #8
    6f50:	af00      	add	r7, sp, #0
    6f52:	6078      	str	r0, [r7, #4]
    6f54:	000a      	movs	r2, r1
    6f56:	1cbb      	adds	r3, r7, #2
    6f58:	801a      	strh	r2, [r3, #0]
	//struct io_descriptor *io;
	spi_m_sync_get_io_descriptor(&EXT_SPI, &io);
    6f5a:	4a0b      	ldr	r2, [pc, #44]	; (6f88 <vfd_write_data+0x3c>)
    6f5c:	4b0b      	ldr	r3, [pc, #44]	; (6f8c <vfd_write_data+0x40>)
    6f5e:	0011      	movs	r1, r2
    6f60:	0018      	movs	r0, r3
    6f62:	f7fd f8d7 	bl	4114 <spi_m_sync_get_io_descriptor>
	spi_m_sync_enable(&EXT_SPI);
    6f66:	4b09      	ldr	r3, [pc, #36]	; (6f8c <vfd_write_data+0x40>)
    6f68:	0018      	movs	r0, r3
    6f6a:	f7fd f829 	bl	3fc0 <spi_m_sync_enable>
	io_write(io, buff, len);
    6f6e:	4b06      	ldr	r3, [pc, #24]	; (6f88 <vfd_write_data+0x3c>)
    6f70:	6818      	ldr	r0, [r3, #0]
    6f72:	1cbb      	adds	r3, r7, #2
    6f74:	881a      	ldrh	r2, [r3, #0]
    6f76:	687b      	ldr	r3, [r7, #4]
    6f78:	0019      	movs	r1, r3
    6f7a:	f7fc ff91 	bl	3ea0 <io_write>
	
}
    6f7e:	46c0      	nop			; (mov r8, r8)
    6f80:	46bd      	mov	sp, r7
    6f82:	b002      	add	sp, #8
    6f84:	bd80      	pop	{r7, pc}
    6f86:	46c0      	nop			; (mov r8, r8)
    6f88:	2000083c 	.word	0x2000083c
    6f8c:	20000820 	.word	0x20000820

00006f90 <vfd_cs_set>:

void vfd_cs_set(bool state){
    6f90:	b580      	push	{r7, lr}
    6f92:	b082      	sub	sp, #8
    6f94:	af00      	add	r7, sp, #0
    6f96:	0002      	movs	r2, r0
    6f98:	1dfb      	adds	r3, r7, #7
    6f9a:	701a      	strb	r2, [r3, #0]
	gpio_set_pin_level(VFD_CS, !state);
    6f9c:	1dfb      	adds	r3, r7, #7
    6f9e:	781b      	ldrb	r3, [r3, #0]
    6fa0:	1e5a      	subs	r2, r3, #1
    6fa2:	4193      	sbcs	r3, r2
    6fa4:	b2db      	uxtb	r3, r3
    6fa6:	2201      	movs	r2, #1
    6fa8:	4053      	eors	r3, r2
    6faa:	b2db      	uxtb	r3, r3
    6fac:	1c1a      	adds	r2, r3, #0
    6fae:	2301      	movs	r3, #1
    6fb0:	4013      	ands	r3, r2
    6fb2:	b2db      	uxtb	r3, r3
    6fb4:	0019      	movs	r1, r3
    6fb6:	2029      	movs	r0, #41	; 0x29
    6fb8:	f7ff fd97 	bl	6aea <gpio_set_pin_level>
}
    6fbc:	46c0      	nop			; (mov r8, r8)
    6fbe:	46bd      	mov	sp, r7
    6fc0:	b002      	add	sp, #8
    6fc2:	bd80      	pop	{r7, pc}

00006fc4 <u8x8_avr_gpio_and_delay>:

uint8_t u8x8_avr_gpio_and_delay(u8x8_t *u8x8, uint8_t msg, uint8_t arg_int, void *arg_ptr){
    6fc4:	b580      	push	{r7, lr}
    6fc6:	b084      	sub	sp, #16
    6fc8:	af00      	add	r7, sp, #0
    6fca:	60f8      	str	r0, [r7, #12]
    6fcc:	0008      	movs	r0, r1
    6fce:	0011      	movs	r1, r2
    6fd0:	607b      	str	r3, [r7, #4]
    6fd2:	230b      	movs	r3, #11
    6fd4:	18fb      	adds	r3, r7, r3
    6fd6:	1c02      	adds	r2, r0, #0
    6fd8:	701a      	strb	r2, [r3, #0]
    6fda:	230a      	movs	r3, #10
    6fdc:	18fb      	adds	r3, r7, r3
    6fde:	1c0a      	adds	r2, r1, #0
    6fe0:	701a      	strb	r2, [r3, #0]
	//uint8_t cycles;

	switch(msg)
    6fe2:	230b      	movs	r3, #11
    6fe4:	18fb      	adds	r3, r7, r3
    6fe6:	781b      	ldrb	r3, [r3, #0]
    6fe8:	2b2a      	cmp	r3, #42	; 0x2a
    6fea:	d009      	beq.n	7000 <u8x8_avr_gpio_and_delay+0x3c>
    6fec:	dc02      	bgt.n	6ff4 <u8x8_avr_gpio_and_delay+0x30>
    6fee:	2b29      	cmp	r3, #41	; 0x29
    6ff0:	d008      	beq.n	7004 <u8x8_avr_gpio_and_delay+0x40>
    6ff2:	e003      	b.n	6ffc <u8x8_avr_gpio_and_delay+0x38>
    6ff4:	2b2b      	cmp	r3, #43	; 0x2b
    6ff6:	d007      	beq.n	7008 <u8x8_avr_gpio_and_delay+0x44>
    6ff8:	2b2c      	cmp	r3, #44	; 0x2c
    6ffa:	d007      	beq.n	700c <u8x8_avr_gpio_and_delay+0x48>
		case U8X8_MSG_DELAY_10MICRO:    // delay arg_int * 10 micro seconds
		break;
		case U8X8_MSG_DELAY_MILLI:      // delay arg_int * 1 milli second
		break;
		default:
		return 0;
    6ffc:	2300      	movs	r3, #0
    6ffe:	e007      	b.n	7010 <u8x8_avr_gpio_and_delay+0x4c>
		break;
    7000:	46c0      	nop			; (mov r8, r8)
    7002:	e004      	b.n	700e <u8x8_avr_gpio_and_delay+0x4a>
		break;
    7004:	46c0      	nop			; (mov r8, r8)
    7006:	e002      	b.n	700e <u8x8_avr_gpio_and_delay+0x4a>
		break;
    7008:	46c0      	nop			; (mov r8, r8)
    700a:	e000      	b.n	700e <u8x8_avr_gpio_and_delay+0x4a>
		break;
    700c:	46c0      	nop			; (mov r8, r8)
	}
	return 0;
    700e:	2300      	movs	r3, #0
}
    7010:	0018      	movs	r0, r3
    7012:	46bd      	mov	sp, r7
    7014:	b004      	add	sp, #16
    7016:	bd80      	pop	{r7, pc}

00007018 <vfd_spi>:
uint8_t vfd_spi(u8x8_t *u8x8, uint8_t msg, uint8_t arg_int, void *arg_ptr)
{
    7018:	b580      	push	{r7, lr}
    701a:	b084      	sub	sp, #16
    701c:	af00      	add	r7, sp, #0
    701e:	60f8      	str	r0, [r7, #12]
    7020:	0008      	movs	r0, r1
    7022:	0011      	movs	r1, r2
    7024:	607b      	str	r3, [r7, #4]
    7026:	230b      	movs	r3, #11
    7028:	18fb      	adds	r3, r7, r3
    702a:	1c02      	adds	r2, r0, #0
    702c:	701a      	strb	r2, [r3, #0]
    702e:	230a      	movs	r3, #10
    7030:	18fb      	adds	r3, r7, r3
    7032:	1c0a      	adds	r2, r1, #0
    7034:	701a      	strb	r2, [r3, #0]
	
	switch(msg)
    7036:	230b      	movs	r3, #11
    7038:	18fb      	adds	r3, r7, r3
    703a:	781b      	ldrb	r3, [r3, #0]
    703c:	3b14      	subs	r3, #20
    703e:	2b0c      	cmp	r3, #12
    7040:	d823      	bhi.n	708a <vfd_spi+0x72>
    7042:	009a      	lsls	r2, r3, #2
    7044:	4b14      	ldr	r3, [pc, #80]	; (7098 <vfd_spi+0x80>)
    7046:	18d3      	adds	r3, r2, r3
    7048:	681b      	ldr	r3, [r3, #0]
    704a:	469f      	mov	pc, r3
	{
		case U8X8_MSG_BYTE_SEND:
		vfd_write_data(arg_ptr, arg_int);
    704c:	230a      	movs	r3, #10
    704e:	18fb      	adds	r3, r7, r3
    7050:	781b      	ldrb	r3, [r3, #0]
    7052:	b29a      	uxth	r2, r3
    7054:	687b      	ldr	r3, [r7, #4]
    7056:	0011      	movs	r1, r2
    7058:	0018      	movs	r0, r3
    705a:	f7ff ff77 	bl	6f4c <vfd_write_data>
		break;
    705e:	e016      	b.n	708e <vfd_spi+0x76>
		case U8X8_MSG_BYTE_INIT:
		/* disable chipselect */
		vfd_cs_set(false);
    7060:	2000      	movs	r0, #0
    7062:	f7ff ff95 	bl	6f90 <vfd_cs_set>
		break;
    7066:	e012      	b.n	708e <vfd_spi+0x76>
		case U8X8_MSG_BYTE_SET_DC:
		u8x8_gpio_SetDC(u8x8, arg_int);
    7068:	230a      	movs	r3, #10
    706a:	18fb      	adds	r3, r7, r3
    706c:	781a      	ldrb	r2, [r3, #0]
    706e:	68fb      	ldr	r3, [r7, #12]
    7070:	214a      	movs	r1, #74	; 0x4a
    7072:	0018      	movs	r0, r3
    7074:	f7fb fec8 	bl	2e08 <u8x8_gpio_call>
		break;
    7078:	e009      	b.n	708e <vfd_spi+0x76>
		case U8X8_MSG_BYTE_START_TRANSFER:
		vfd_cs_set(true);
    707a:	2001      	movs	r0, #1
    707c:	f7ff ff88 	bl	6f90 <vfd_cs_set>
		break;
    7080:	e005      	b.n	708e <vfd_spi+0x76>
		case U8X8_MSG_BYTE_END_TRANSFER:
		vfd_cs_set(false);
    7082:	2000      	movs	r0, #0
    7084:	f7ff ff84 	bl	6f90 <vfd_cs_set>
		break;
    7088:	e001      	b.n	708e <vfd_spi+0x76>
		default:
		return 0;
    708a:	2300      	movs	r3, #0
    708c:	e000      	b.n	7090 <vfd_spi+0x78>
	}
	return 1;
    708e:	2301      	movs	r3, #1
}
    7090:	0018      	movs	r0, r3
    7092:	46bd      	mov	sp, r7
    7094:	b004      	add	sp, #16
    7096:	bd80      	pop	{r7, pc}
    7098:	00008ba0 	.word	0x00008ba0

0000709c <RF_SPI_init>:

//RF_Section
void RF_SPI_init(void){
    709c:	b580      	push	{r7, lr}
    709e:	af00      	add	r7, sp, #0
	_pm_enable_bus_clock(PM_BUS_APBC, SERCOM1);
    70a0:	4b56      	ldr	r3, [pc, #344]	; (71fc <RF_SPI_init+0x160>)
    70a2:	0019      	movs	r1, r3
    70a4:	2003      	movs	r0, #3
    70a6:	f7ff fdbb 	bl	6c20 <_pm_enable_bus_clock>
	_gclk_enable_channel(SERCOM1_GCLK_ID_CORE, CONF_GCLK_SERCOM1_CORE_SRC);
    70aa:	2100      	movs	r1, #0
    70ac:	200e      	movs	r0, #14
    70ae:	f7ff fd39 	bl	6b24 <_gclk_enable_channel>
	
	spi_m_sync_init(&RF_SPI, SERCOM1);
    70b2:	4a52      	ldr	r2, [pc, #328]	; (71fc <RF_SPI_init+0x160>)
    70b4:	4b52      	ldr	r3, [pc, #328]	; (7200 <RF_SPI_init+0x164>)
    70b6:	0011      	movs	r1, r2
    70b8:	0018      	movs	r0, r3
    70ba:	f7fc ff41 	bl	3f40 <spi_m_sync_init>
	spi_m_sync_get_io_descriptor(&RF_SPI, &io);
    70be:	4a51      	ldr	r2, [pc, #324]	; (7204 <RF_SPI_init+0x168>)
    70c0:	4b4f      	ldr	r3, [pc, #316]	; (7200 <RF_SPI_init+0x164>)
    70c2:	0011      	movs	r1, r2
    70c4:	0018      	movs	r0, r3
    70c6:	f7fd f825 	bl	4114 <spi_m_sync_get_io_descriptor>
	
	gpio_set_pin_level(PA00, false);
    70ca:	2100      	movs	r1, #0
    70cc:	2000      	movs	r0, #0
    70ce:	f7ff fd0c 	bl	6aea <gpio_set_pin_level>
	gpio_set_pin_direction(PA00, GPIO_DIRECTION_OUT);
    70d2:	2102      	movs	r1, #2
    70d4:	2000      	movs	r0, #0
    70d6:	f7ff fceb 	bl	6ab0 <gpio_set_pin_direction>
	gpio_set_pin_function(PA00, PINMUX_PA00D_SERCOM1_PAD0);
    70da:	2103      	movs	r1, #3
    70dc:	2000      	movs	r0, #0
    70de:	f7ff fcd8 	bl	6a92 <gpio_set_pin_function>
	gpio_set_pin_level(PA01, false);
    70e2:	2100      	movs	r1, #0
    70e4:	2001      	movs	r0, #1
    70e6:	f7ff fd00 	bl	6aea <gpio_set_pin_level>
	gpio_set_pin_direction(PA01, GPIO_DIRECTION_OUT);
    70ea:	2102      	movs	r1, #2
    70ec:	2001      	movs	r0, #1
    70ee:	f7ff fcdf 	bl	6ab0 <gpio_set_pin_direction>
	gpio_set_pin_function(PA01, PINMUX_PA01D_SERCOM1_PAD1);
    70f2:	4b45      	ldr	r3, [pc, #276]	; (7208 <RF_SPI_init+0x16c>)
    70f4:	0019      	movs	r1, r3
    70f6:	2001      	movs	r0, #1
    70f8:	f7ff fccb 	bl	6a92 <gpio_set_pin_function>
	gpio_set_pin_direction(PA18, GPIO_DIRECTION_IN);
    70fc:	2101      	movs	r1, #1
    70fe:	2012      	movs	r0, #18
    7100:	f7ff fcd6 	bl	6ab0 <gpio_set_pin_direction>

	gpio_set_pin_pull_mode(PA18, GPIO_PULL_OFF);
    7104:	2100      	movs	r1, #0
    7106:	2012      	movs	r0, #18
    7108:	f7ff fca8 	bl	6a5c <gpio_set_pin_pull_mode>
	gpio_set_pin_function(PA18, PINMUX_PA18C_SERCOM1_PAD2);
    710c:	4b3f      	ldr	r3, [pc, #252]	; (720c <RF_SPI_init+0x170>)
    710e:	0019      	movs	r1, r3
    7110:	2012      	movs	r0, #18
    7112:	f7ff fcbe 	bl	6a92 <gpio_set_pin_function>
	//Gpio setup
	
	gpio_set_pin_level(RF_RST, false);
    7116:	2100      	movs	r1, #0
    7118:	2002      	movs	r0, #2
    711a:	f7ff fce6 	bl	6aea <gpio_set_pin_level>
	gpio_set_pin_direction(RF_RST, GPIO_DIRECTION_OUT);
    711e:	2102      	movs	r1, #2
    7120:	2002      	movs	r0, #2
    7122:	f7ff fcc5 	bl	6ab0 <gpio_set_pin_direction>
	gpio_set_pin_function(RF_RST, GPIO_PIN_FUNCTION_OFF);
    7126:	2301      	movs	r3, #1
    7128:	425b      	negs	r3, r3
    712a:	0019      	movs	r1, r3
    712c:	2002      	movs	r0, #2
    712e:	f7ff fcb0 	bl	6a92 <gpio_set_pin_function>
	gpio_set_pin_level(RF_RST, true);
    7132:	2101      	movs	r1, #1
    7134:	2002      	movs	r0, #2
    7136:	f7ff fcd8 	bl	6aea <gpio_set_pin_level>
	delay_ms(10);
    713a:	200a      	movs	r0, #10
    713c:	f7fc fc46 	bl	39cc <delay_ms>
	gpio_set_pin_level(RF_RST, false);
    7140:	2100      	movs	r1, #0
    7142:	2002      	movs	r0, #2
    7144:	f7ff fcd1 	bl	6aea <gpio_set_pin_level>
	
	//Radio additional IO setup
	gpio_set_pin_level(RF_CS, true);
    7148:	2101      	movs	r1, #1
    714a:	201c      	movs	r0, #28
    714c:	f7ff fccd 	bl	6aea <gpio_set_pin_level>
	gpio_set_pin_direction(RF_CS, GPIO_DIRECTION_OUT);
    7150:	2102      	movs	r1, #2
    7152:	201c      	movs	r0, #28
    7154:	f7ff fcac 	bl	6ab0 <gpio_set_pin_direction>
	gpio_set_pin_function(RF_CS, GPIO_PIN_FUNCTION_OFF);
    7158:	2301      	movs	r3, #1
    715a:	425b      	negs	r3, r3
    715c:	0019      	movs	r1, r3
    715e:	201c      	movs	r0, #28
    7160:	f7ff fc97 	bl	6a92 <gpio_set_pin_function>
	
	//SPI Flash additional IO setup
	gpio_set_pin_level(ROM_CS, true);
    7164:	2101      	movs	r1, #1
    7166:	2017      	movs	r0, #23
    7168:	f7ff fcbf 	bl	6aea <gpio_set_pin_level>
	gpio_set_pin_direction(ROM_CS, GPIO_DIRECTION_OUT);
    716c:	2102      	movs	r1, #2
    716e:	2017      	movs	r0, #23
    7170:	f7ff fc9e 	bl	6ab0 <gpio_set_pin_direction>
	gpio_set_pin_function(ROM_CS, GPIO_PIN_FUNCTION_OFF);
    7174:	2301      	movs	r3, #1
    7176:	425b      	negs	r3, r3
    7178:	0019      	movs	r1, r3
    717a:	2017      	movs	r0, #23
    717c:	f7ff fc89 	bl	6a92 <gpio_set_pin_function>
	
	//MicroSD Flash additional IO setup
	gpio_set_pin_level(LED_SD, false);
    7180:	2100      	movs	r1, #0
    7182:	2003      	movs	r0, #3
    7184:	f7ff fcb1 	bl	6aea <gpio_set_pin_level>
	gpio_set_pin_direction(LED_SD, GPIO_DIRECTION_OUT);
    7188:	2102      	movs	r1, #2
    718a:	2003      	movs	r0, #3
    718c:	f7ff fc90 	bl	6ab0 <gpio_set_pin_direction>
	gpio_set_pin_function(LED_SD, GPIO_PIN_FUNCTION_OFF);
    7190:	2301      	movs	r3, #1
    7192:	425b      	negs	r3, r3
    7194:	0019      	movs	r1, r3
    7196:	2003      	movs	r0, #3
    7198:	f7ff fc7b 	bl	6a92 <gpio_set_pin_function>
	
	gpio_set_pin_level(SD_CS, true);
    719c:	2101      	movs	r1, #1
    719e:	2024      	movs	r0, #36	; 0x24
    71a0:	f7ff fca3 	bl	6aea <gpio_set_pin_level>
	gpio_set_pin_direction(SD_CS, GPIO_DIRECTION_OUT);
    71a4:	2102      	movs	r1, #2
    71a6:	2024      	movs	r0, #36	; 0x24
    71a8:	f7ff fc82 	bl	6ab0 <gpio_set_pin_direction>
	gpio_set_pin_function(SD_CS, GPIO_PIN_FUNCTION_OFF);
    71ac:	2301      	movs	r3, #1
    71ae:	425b      	negs	r3, r3
    71b0:	0019      	movs	r1, r3
    71b2:	2024      	movs	r0, #36	; 0x24
    71b4:	f7ff fc6d 	bl	6a92 <gpio_set_pin_function>

	gpio_set_pin_direction(SD_DETECT, GPIO_DIRECTION_IN);
    71b8:	2101      	movs	r1, #1
    71ba:	2025      	movs	r0, #37	; 0x25
    71bc:	f7ff fc78 	bl	6ab0 <gpio_set_pin_direction>
	gpio_set_pin_pull_mode(SD_DETECT, GPIO_PULL_OFF);
    71c0:	2100      	movs	r1, #0
    71c2:	2025      	movs	r0, #37	; 0x25
    71c4:	f7ff fc4a 	bl	6a5c <gpio_set_pin_pull_mode>
	gpio_set_pin_function(SD_DETECT, GPIO_PIN_FUNCTION_OFF);
    71c8:	2301      	movs	r3, #1
    71ca:	425b      	negs	r3, r3
    71cc:	0019      	movs	r1, r3
    71ce:	2025      	movs	r0, #37	; 0x25
    71d0:	f7ff fc5f 	bl	6a92 <gpio_set_pin_function>

	gpio_set_pin_direction(RF_IRQ, GPIO_DIRECTION_IN);
    71d4:	2101      	movs	r1, #1
    71d6:	203e      	movs	r0, #62	; 0x3e
    71d8:	f7ff fc6a 	bl	6ab0 <gpio_set_pin_direction>
	gpio_set_pin_pull_mode(RF_IRQ, GPIO_PULL_DOWN);
    71dc:	2102      	movs	r1, #2
    71de:	203e      	movs	r0, #62	; 0x3e
    71e0:	f7ff fc3c 	bl	6a5c <gpio_set_pin_pull_mode>
	gpio_set_pin_function(RF_IRQ, PINMUX_PB30A_EIC_EXTINT14);
    71e4:	23f8      	movs	r3, #248	; 0xf8
    71e6:	039b      	lsls	r3, r3, #14
    71e8:	0019      	movs	r1, r3
    71ea:	203e      	movs	r0, #62	; 0x3e
    71ec:	f7ff fc51 	bl	6a92 <gpio_set_pin_function>
	RF_IRQ_Enable();
    71f0:	f7ff fd82 	bl	6cf8 <RF_IRQ_Enable>
	
}
    71f4:	46c0      	nop			; (mov r8, r8)
    71f6:	46bd      	mov	sp, r7
    71f8:	bd80      	pop	{r7, pc}
    71fa:	46c0      	nop			; (mov r8, r8)
    71fc:	42000c00 	.word	0x42000c00
    7200:	200007e8 	.word	0x200007e8
    7204:	2000083c 	.word	0x2000083c
    7208:	00010003 	.word	0x00010003
    720c:	00120002 	.word	0x00120002

00007210 <EXT_I2C_init>:

//External I2C port


void EXT_I2C_init(void)
{
    7210:	b580      	push	{r7, lr}
    7212:	af00      	add	r7, sp, #0
	_pm_enable_bus_clock(PM_BUS_APBC, SERCOM4);
    7214:	4b18      	ldr	r3, [pc, #96]	; (7278 <EXT_I2C_init+0x68>)
    7216:	0019      	movs	r1, r3
    7218:	2003      	movs	r0, #3
    721a:	f7ff fd01 	bl	6c20 <_pm_enable_bus_clock>
	_gclk_enable_channel(SERCOM4_GCLK_ID_CORE, CONF_GCLK_SERCOM4_CORE_SRC);
    721e:	2100      	movs	r1, #0
    7220:	2011      	movs	r0, #17
    7222:	f7ff fc7f 	bl	6b24 <_gclk_enable_channel>
	_gclk_enable_channel(SERCOM4_GCLK_ID_SLOW, CONF_GCLK_SERCOM4_SLOW_SRC);
    7226:	2103      	movs	r1, #3
    7228:	200c      	movs	r0, #12
    722a:	f7ff fc7b 	bl	6b24 <_gclk_enable_channel>
	
	i2c_m_sync_init(&EXT_I2C, SERCOM4);
    722e:	4a12      	ldr	r2, [pc, #72]	; (7278 <EXT_I2C_init+0x68>)
    7230:	4b12      	ldr	r3, [pc, #72]	; (727c <EXT_I2C_init+0x6c>)
    7232:	0011      	movs	r1, r2
    7234:	0018      	movs	r0, r3
    7236:	f7fc fdcb 	bl	3dd0 <i2c_m_sync_init>
	
	gpio_set_pin_pull_mode(PB12, GPIO_PULL_OFF);
    723a:	2100      	movs	r1, #0
    723c:	202c      	movs	r0, #44	; 0x2c
    723e:	f7ff fc0d 	bl	6a5c <gpio_set_pin_pull_mode>
	gpio_set_pin_function(PB12, PINMUX_PB12C_SERCOM4_PAD0);
    7242:	4b0f      	ldr	r3, [pc, #60]	; (7280 <EXT_I2C_init+0x70>)
    7244:	0019      	movs	r1, r3
    7246:	202c      	movs	r0, #44	; 0x2c
    7248:	f7ff fc23 	bl	6a92 <gpio_set_pin_function>
	gpio_set_pin_pull_mode(PB13, GPIO_PULL_OFF);
    724c:	2100      	movs	r1, #0
    724e:	202d      	movs	r0, #45	; 0x2d
    7250:	f7ff fc04 	bl	6a5c <gpio_set_pin_pull_mode>
	gpio_set_pin_function(PB13, PINMUX_PB13C_SERCOM4_PAD1);
    7254:	4b0b      	ldr	r3, [pc, #44]	; (7284 <EXT_I2C_init+0x74>)
    7256:	0019      	movs	r1, r3
    7258:	202d      	movs	r0, #45	; 0x2d
    725a:	f7ff fc1a 	bl	6a92 <gpio_set_pin_function>
	
	i2c_m_sync_get_io_descriptor(&EXT_I2C, &I2C_io);
    725e:	4a0a      	ldr	r2, [pc, #40]	; (7288 <EXT_I2C_init+0x78>)
    7260:	4b06      	ldr	r3, [pc, #24]	; (727c <EXT_I2C_init+0x6c>)
    7262:	0011      	movs	r1, r2
    7264:	0018      	movs	r0, r3
    7266:	f7fc fe0c 	bl	3e82 <i2c_m_sync_get_io_descriptor>
	i2c_m_sync_enable(&EXT_I2C);
    726a:	4b04      	ldr	r3, [pc, #16]	; (727c <EXT_I2C_init+0x6c>)
    726c:	0018      	movs	r0, r3
    726e:	f7fc fddb 	bl	3e28 <i2c_m_sync_enable>
}
    7272:	46c0      	nop			; (mov r8, r8)
    7274:	46bd      	mov	sp, r7
    7276:	bd80      	pop	{r7, pc}
    7278:	42001800 	.word	0x42001800
    727c:	20000800 	.word	0x20000800
    7280:	002c0002 	.word	0x002c0002
    7284:	002d0002 	.word	0x002d0002
    7288:	20000838 	.word	0x20000838

0000728c <I2C_write_batch>:


bool I2C_write_batch(uint8_t addres , uint8_t *data, uint8_t data_len)
{
    728c:	b580      	push	{r7, lr}
    728e:	b082      	sub	sp, #8
    7290:	af00      	add	r7, sp, #0
    7292:	6039      	str	r1, [r7, #0]
    7294:	0011      	movs	r1, r2
    7296:	1dfb      	adds	r3, r7, #7
    7298:	1c02      	adds	r2, r0, #0
    729a:	701a      	strb	r2, [r3, #0]
    729c:	1dbb      	adds	r3, r7, #6
    729e:	1c0a      	adds	r2, r1, #0
    72a0:	701a      	strb	r2, [r3, #0]
	i2c_m_sync_set_slaveaddr(&EXT_I2C, addres, I2C_M_SEVEN);
    72a2:	1dfb      	adds	r3, r7, #7
    72a4:	781b      	ldrb	r3, [r3, #0]
    72a6:	b219      	sxth	r1, r3
    72a8:	2380      	movs	r3, #128	; 0x80
    72aa:	011a      	lsls	r2, r3, #4
    72ac:	4b0a      	ldr	r3, [pc, #40]	; (72d8 <I2C_write_batch+0x4c>)
    72ae:	0018      	movs	r0, r3
    72b0:	f7fc fdc7 	bl	3e42 <i2c_m_sync_set_slaveaddr>
	return (io_write(I2C_io, (uint8_t *)data, data_len) >= 0) ? true : false ;  
    72b4:	4b09      	ldr	r3, [pc, #36]	; (72dc <I2C_write_batch+0x50>)
    72b6:	6818      	ldr	r0, [r3, #0]
    72b8:	1dbb      	adds	r3, r7, #6
    72ba:	781b      	ldrb	r3, [r3, #0]
    72bc:	b29a      	uxth	r2, r3
    72be:	683b      	ldr	r3, [r7, #0]
    72c0:	0019      	movs	r1, r3
    72c2:	f7fc fded 	bl	3ea0 <io_write>
    72c6:	0003      	movs	r3, r0
    72c8:	43db      	mvns	r3, r3
    72ca:	0fdb      	lsrs	r3, r3, #31
    72cc:	b2db      	uxtb	r3, r3
    72ce:	0018      	movs	r0, r3
    72d0:	46bd      	mov	sp, r7
    72d2:	b002      	add	sp, #8
    72d4:	bd80      	pop	{r7, pc}
    72d6:	46c0      	nop			; (mov r8, r8)
    72d8:	20000800 	.word	0x20000800
    72dc:	20000838 	.word	0x20000838

000072e0 <rfm69_init>:
uint8_t promiscuousMode = 0;
unsigned long millis_current;

// freqBand must be selected from 315, 433, 868, 915
void rfm69_init(uint16_t freqBand, uint8_t nodeID, uint8_t networkID)
{
    72e0:	b590      	push	{r4, r7, lr}
    72e2:	b085      	sub	sp, #20
    72e4:	af00      	add	r7, sp, #0
    72e6:	0004      	movs	r4, r0
    72e8:	0008      	movs	r0, r1
    72ea:	0011      	movs	r1, r2
    72ec:	1dbb      	adds	r3, r7, #6
    72ee:	1c22      	adds	r2, r4, #0
    72f0:	801a      	strh	r2, [r3, #0]
    72f2:	1d7b      	adds	r3, r7, #5
    72f4:	1c02      	adds	r2, r0, #0
    72f6:	701a      	strb	r2, [r3, #0]
    72f8:	1d3b      	adds	r3, r7, #4
    72fa:	1c0a      	adds	r2, r1, #0
    72fc:	701a      	strb	r2, [r3, #0]

	uint8_t tmp_data = readReg(REG_VERSION);
    72fe:	230f      	movs	r3, #15
    7300:	18fc      	adds	r4, r7, r3
    7302:	2010      	movs	r0, #16
    7304:	f000 f87f 	bl	7406 <readReg>
    7308:	0003      	movs	r3, r0
    730a:	7023      	strb	r3, [r4, #0]
	//tmp_data = readReg(REG_OPMODE);
	
	writeReg(REG_OPMODE, RF_OPMODE_STANDBY);
    730c:	2104      	movs	r1, #4
    730e:	2001      	movs	r0, #1
    7310:	f000 f898 	bl	7444 <writeReg>
	
	tmp_data = readReg(REG_IRQFLAGS1);
    7314:	230f      	movs	r3, #15
    7316:	18fc      	adds	r4, r7, r3
    7318:	2027      	movs	r0, #39	; 0x27
    731a:	f000 f874 	bl	7406 <readReg>
    731e:	0003      	movs	r3, r0
    7320:	7023      	strb	r3, [r4, #0]
	
	writeReg(REG_FIFOTHRESH, 0x8f);
    7322:	218f      	movs	r1, #143	; 0x8f
    7324:	203c      	movs	r0, #60	; 0x3c
    7326:	f000 f88d 	bl	7444 <writeReg>
	writeReg(REG_TESTDAGC, 0x30);
    732a:	2130      	movs	r1, #48	; 0x30
    732c:	206f      	movs	r0, #111	; 0x6f
    732e:	f000 f889 	bl	7444 <writeReg>
	writeReg(REG_TESTPA1, 0x55); //only for HW
    7332:	2155      	movs	r1, #85	; 0x55
    7334:	205a      	movs	r0, #90	; 0x5a
    7336:	f000 f885 	bl	7444 <writeReg>
	writeReg(REG_TESTPA2, 0x70); //only for HW
    733a:	2170      	movs	r1, #112	; 0x70
    733c:	205c      	movs	r0, #92	; 0x5c
    733e:	f000 f881 	bl	7444 <writeReg>
	
	tmp_data = readReg(REG_SYNCCONFIG);
    7342:	230f      	movs	r3, #15
    7344:	18fc      	adds	r4, r7, r3
    7346:	202e      	movs	r0, #46	; 0x2e
    7348:	f000 f85d 	bl	7406 <readReg>
    734c:	0003      	movs	r3, r0
    734e:	7023      	strb	r3, [r4, #0]
	writeReg(REG_SYNCVALUE1, 0x2d);
    7350:	212d      	movs	r1, #45	; 0x2d
    7352:	202f      	movs	r0, #47	; 0x2f
    7354:	f000 f876 	bl	7444 <writeReg>
	writeReg(REG_SYNCVALUE2, 0xd4);
    7358:	21d4      	movs	r1, #212	; 0xd4
    735a:	2030      	movs	r0, #48	; 0x30
    735c:	f000 f872 	bl	7444 <writeReg>
	writeReg(REG_SYNCCONFIG, 0x88);
    7360:	2188      	movs	r1, #136	; 0x88
    7362:	202e      	movs	r0, #46	; 0x2e
    7364:	f000 f86e 	bl	7444 <writeReg>
	
	writeReg(REG_DATAMODUL, RF_DATAMODUL_MODULATIONSHAPING_01);
    7368:	2101      	movs	r1, #1
    736a:	2002      	movs	r0, #2
    736c:	f000 f86a 	bl	7444 <writeReg>
	writeReg(REG_BITRATEMSB, 0x00);
    7370:	2100      	movs	r1, #0
    7372:	2003      	movs	r0, #3
    7374:	f000 f866 	bl	7444 <writeReg>
	writeReg(REG_BITRATELSB, 0x80);
    7378:	2180      	movs	r1, #128	; 0x80
    737a:	2004      	movs	r0, #4
    737c:	f000 f862 	bl	7444 <writeReg>
	writeReg(REG_FDEVMSB, 0x10);
    7380:	2110      	movs	r1, #16
    7382:	2005      	movs	r0, #5
    7384:	f000 f85e 	bl	7444 <writeReg>
	writeReg(REG_FDEVLSB, 0x00);
    7388:	2100      	movs	r1, #0
    738a:	2006      	movs	r0, #6
    738c:	f000 f85a 	bl	7444 <writeReg>
	
	writeReg(REG_RXBW, RF_RXBW_DCCFREQ_111);
    7390:	21e0      	movs	r1, #224	; 0xe0
    7392:	2019      	movs	r0, #25
    7394:	f000 f856 	bl	7444 <writeReg>
	writeReg(REG_AFCBW, RF_AFCBW_DCCFREQAFC_111);
    7398:	21e0      	movs	r1, #224	; 0xe0
    739a:	201a      	movs	r0, #26
    739c:	f000 f852 	bl	7444 <writeReg>
	writeReg(REG_PACKETCONFIG1, 0xD0);
    73a0:	21d0      	movs	r1, #208	; 0xd0
    73a2:	2037      	movs	r0, #55	; 0x37
    73a4:	f000 f84e 	bl	7444 <writeReg>
	
	writeReg(REG_PREAMBLEMSB, 0x00);
    73a8:	2100      	movs	r1, #0
    73aa:	202c      	movs	r0, #44	; 0x2c
    73ac:	f000 f84a 	bl	7444 <writeReg>
	writeReg(REG_PREAMBLELSB , 0x04);
    73b0:	2104      	movs	r1, #4
    73b2:	202d      	movs	r0, #45	; 0x2d
    73b4:	f000 f846 	bl	7444 <writeReg>
	
	writeReg(REG_FRFMSB, RF_FRFMSB_868);
    73b8:	21d9      	movs	r1, #217	; 0xd9
    73ba:	2007      	movs	r0, #7
    73bc:	f000 f842 	bl	7444 <writeReg>
	writeReg(REG_FRFMID, RF_FRFMID_868);
    73c0:	2100      	movs	r1, #0
    73c2:	2008      	movs	r0, #8
    73c4:	f000 f83e 	bl	7444 <writeReg>
	writeReg(REG_FRFLSB, RF_FRFLSB_868);
    73c8:	2100      	movs	r1, #0
    73ca:	2009      	movs	r0, #9
    73cc:	f000 f83a 	bl	7444 <writeReg>
	
	tmp_data = readReg(REG_PACKETCONFIG2); //2
    73d0:	230f      	movs	r3, #15
    73d2:	18fc      	adds	r4, r7, r3
    73d4:	203d      	movs	r0, #61	; 0x3d
    73d6:	f000 f816 	bl	7406 <readReg>
    73da:	0003      	movs	r3, r0
    73dc:	7023      	strb	r3, [r4, #0]
	writeReg(REG_PACKETCONFIG2, RF_PACKET2_AUTORXRESTART_ON);
    73de:	2102      	movs	r1, #2
    73e0:	203d      	movs	r0, #61	; 0x3d
    73e2:	f000 f82f 	bl	7444 <writeReg>

	writeReg(REG_PALEVEL, RF_PALEVEL_OUTPUTPOWER_11111);
    73e6:	211f      	movs	r1, #31
    73e8:	2011      	movs	r0, #17
    73ea:	f000 f82b 	bl	7444 <writeReg>
	writeReg(REG_DIOMAPPING1 , RF_DIOMAPPING1_DIO0_01);
    73ee:	2140      	movs	r1, #64	; 0x40
    73f0:	2025      	movs	r0, #37	; 0x25
    73f2:	f000 f827 	bl	7444 <writeReg>
	
	//tmp_data = readReg(REG_OPMODE);
	writeReg(REG_OPMODE, RF_OPMODE_RECEIVER);
    73f6:	2110      	movs	r1, #16
    73f8:	2001      	movs	r0, #1
    73fa:	f000 f823 	bl	7444 <writeReg>
    //while ((readReg(REG_IRQFLAGS1) & RF_IRQFLAGS1_MODEREADY) == 0x00);

    //address = nodeID;
    //setAddress(address);            // setting this node id
    //setNetwork(networkID);
}
    73fe:	46c0      	nop			; (mov r8, r8)
    7400:	46bd      	mov	sp, r7
    7402:	b005      	add	sp, #20
    7404:	bd90      	pop	{r4, r7, pc}

00007406 <readReg>:
    setMode(oldMode);
}

// Read byte from register
uint8_t readReg(uint8_t addr)
{
    7406:	b590      	push	{r4, r7, lr}
    7408:	b085      	sub	sp, #20
    740a:	af00      	add	r7, sp, #0
    740c:	0002      	movs	r2, r0
    740e:	1dfb      	adds	r3, r7, #7
    7410:	701a      	strb	r2, [r3, #0]
    RF_select();
    7412:	f000 f873 	bl	74fc <RF_select>
    SPI_write(addr & 0x7F);
    7416:	1dfb      	adds	r3, r7, #7
    7418:	781b      	ldrb	r3, [r3, #0]
    741a:	227f      	movs	r2, #127	; 0x7f
    741c:	4013      	ands	r3, r2
    741e:	b2db      	uxtb	r3, r3
    7420:	0018      	movs	r0, r3
    7422:	f7ff fcc3 	bl	6dac <SPI_write>
    uint8_t regval = SPI_read();
    7426:	230f      	movs	r3, #15
    7428:	18fc      	adds	r4, r7, r3
    742a:	f7ff fcdf 	bl	6dec <SPI_read>
    742e:	0003      	movs	r3, r0
    7430:	7023      	strb	r3, [r4, #0]
    RF_unselect();
    7432:	f000 f86b 	bl	750c <RF_unselect>
    return regval;
    7436:	230f      	movs	r3, #15
    7438:	18fb      	adds	r3, r7, r3
    743a:	781b      	ldrb	r3, [r3, #0]
}
    743c:	0018      	movs	r0, r3
    743e:	46bd      	mov	sp, r7
    7440:	b005      	add	sp, #20
    7442:	bd90      	pop	{r4, r7, pc}

00007444 <writeReg>:

// Write byte to register
void writeReg(uint8_t addr, uint8_t value)
{
    7444:	b580      	push	{r7, lr}
    7446:	b082      	sub	sp, #8
    7448:	af00      	add	r7, sp, #0
    744a:	0002      	movs	r2, r0
    744c:	1dfb      	adds	r3, r7, #7
    744e:	701a      	strb	r2, [r3, #0]
    7450:	1dbb      	adds	r3, r7, #6
    7452:	1c0a      	adds	r2, r1, #0
    7454:	701a      	strb	r2, [r3, #0]
    RF_select();
    7456:	f000 f851 	bl	74fc <RF_select>
    SPI_write(addr | 0x80);
    745a:	1dfb      	adds	r3, r7, #7
    745c:	781b      	ldrb	r3, [r3, #0]
    745e:	2280      	movs	r2, #128	; 0x80
    7460:	4252      	negs	r2, r2
    7462:	4313      	orrs	r3, r2
    7464:	b2db      	uxtb	r3, r3
    7466:	0018      	movs	r0, r3
    7468:	f7ff fca0 	bl	6dac <SPI_write>
    SPI_write(value);
    746c:	1dbb      	adds	r3, r7, #6
    746e:	781b      	ldrb	r3, [r3, #0]
    7470:	0018      	movs	r0, r3
    7472:	f7ff fc9b 	bl	6dac <SPI_write>
    RF_unselect();
    7476:	f000 f849 	bl	750c <RF_unselect>
}
    747a:	46c0      	nop			; (mov r8, r8)
    747c:	46bd      	mov	sp, r7
    747e:	b002      	add	sp, #8
    7480:	bd80      	pop	{r7, pc}
	...

00007484 <setHighPower>:
    }
}
    
// for RFM69HW only: you must call setHighPower(1) after rfm69_init() or else transmission won't work
void setHighPower(uint8_t onOff) 
{
    7484:	b580      	push	{r7, lr}
    7486:	b082      	sub	sp, #8
    7488:	af00      	add	r7, sp, #0
    748a:	0002      	movs	r2, r0
    748c:	1dfb      	adds	r3, r7, #7
    748e:	701a      	strb	r2, [r3, #0]
    isRFM69HW = onOff;
    7490:	4b18      	ldr	r3, [pc, #96]	; (74f4 <setHighPower+0x70>)
    7492:	1dfa      	adds	r2, r7, #7
    7494:	7812      	ldrb	r2, [r2, #0]
    7496:	701a      	strb	r2, [r3, #0]
    writeReg(REG_OCP, isRFM69HW ? RF_OCP_OFF : RF_OCP_ON);
    7498:	4b16      	ldr	r3, [pc, #88]	; (74f4 <setHighPower+0x70>)
    749a:	781b      	ldrb	r3, [r3, #0]
    749c:	2b00      	cmp	r3, #0
    749e:	d001      	beq.n	74a4 <setHighPower+0x20>
    74a0:	230f      	movs	r3, #15
    74a2:	e000      	b.n	74a6 <setHighPower+0x22>
    74a4:	231a      	movs	r3, #26
    74a6:	0019      	movs	r1, r3
    74a8:	2013      	movs	r0, #19
    74aa:	f7ff ffcb 	bl	7444 <writeReg>

    if (isRFM69HW == 1) // turning ON
    74ae:	4b11      	ldr	r3, [pc, #68]	; (74f4 <setHighPower+0x70>)
    74b0:	781b      	ldrb	r3, [r3, #0]
    74b2:	2b01      	cmp	r3, #1
    74b4:	d110      	bne.n	74d8 <setHighPower+0x54>
        writeReg(REG_PALEVEL, (readReg(REG_PALEVEL) & 0x1F) | RF_PALEVEL_PA1_ON | RF_PALEVEL_PA2_ON); // enable P1 & P2 amplifier stages
    74b6:	2011      	movs	r0, #17
    74b8:	f7ff ffa5 	bl	7406 <readReg>
    74bc:	0003      	movs	r3, r0
    74be:	b25b      	sxtb	r3, r3
    74c0:	221f      	movs	r2, #31
    74c2:	4013      	ands	r3, r2
    74c4:	b25b      	sxtb	r3, r3
    74c6:	2260      	movs	r2, #96	; 0x60
    74c8:	4313      	orrs	r3, r2
    74ca:	b25b      	sxtb	r3, r3
    74cc:	b2db      	uxtb	r3, r3
    74ce:	0019      	movs	r1, r3
    74d0:	2011      	movs	r0, #17
    74d2:	f7ff ffb7 	bl	7444 <writeReg>
    else
        writeReg(REG_PALEVEL, RF_PALEVEL_PA0_ON | RF_PALEVEL_PA1_OFF | RF_PALEVEL_PA2_OFF | powerLevel); // enable P0 only
}
    74d6:	e009      	b.n	74ec <setHighPower+0x68>
        writeReg(REG_PALEVEL, RF_PALEVEL_PA0_ON | RF_PALEVEL_PA1_OFF | RF_PALEVEL_PA2_OFF | powerLevel); // enable P0 only
    74d8:	4b07      	ldr	r3, [pc, #28]	; (74f8 <setHighPower+0x74>)
    74da:	781b      	ldrb	r3, [r3, #0]
    74dc:	2280      	movs	r2, #128	; 0x80
    74de:	4252      	negs	r2, r2
    74e0:	4313      	orrs	r3, r2
    74e2:	b2db      	uxtb	r3, r3
    74e4:	0019      	movs	r1, r3
    74e6:	2011      	movs	r0, #17
    74e8:	f7ff ffac 	bl	7444 <writeReg>
}
    74ec:	46c0      	nop			; (mov r8, r8)
    74ee:	46bd      	mov	sp, r7
    74f0:	b002      	add	sp, #8
    74f2:	bd80      	pop	{r7, pc}
    74f4:	20000028 	.word	0x20000028
    74f8:	20000029 	.word	0x20000029

000074fc <RF_select>:
    //if (!inISR) sei();
}

// Enable SPI transfer
void RF_select()
{
    74fc:	b580      	push	{r7, lr}
    74fe:	af00      	add	r7, sp, #0
    RFM_69_sel(false);
    7500:	2000      	movs	r0, #0
    7502:	f7ff fc43 	bl	6d8c <RFM_69_sel>
}
    7506:	46c0      	nop			; (mov r8, r8)
    7508:	46bd      	mov	sp, r7
    750a:	bd80      	pop	{r7, pc}

0000750c <RF_unselect>:

// Disable SPI transfer
void RF_unselect()
{
    750c:	b580      	push	{r7, lr}
    750e:	af00      	add	r7, sp, #0
     RFM_69_sel(true);
    7510:	2001      	movs	r0, #1
    7512:	f7ff fc3b 	bl	6d8c <RFM_69_sel>
}
    7516:	46c0      	nop			; (mov r8, r8)
    7518:	46bd      	mov	sp, r7
    751a:	bd80      	pop	{r7, pc}

0000751c <data_ready>:

// Interrupt Service Routine

void data_ready()
{
    751c:	b590      	push	{r4, r7, lr}
    751e:	b083      	sub	sp, #12
    7520:	af00      	add	r7, sp, #0
	set_led();
    7522:	f7ff fc81 	bl	6e28 <set_led>
	//delay_ms(10);
	uint8_t read_data = readReg(REG_IRQFLAGS2);
    7526:	1dfc      	adds	r4, r7, #7
    7528:	2028      	movs	r0, #40	; 0x28
    752a:	f7ff ff6c 	bl	7406 <readReg>
    752e:	0003      	movs	r3, r0
    7530:	7023      	strb	r3, [r4, #0]
	read_data = readReg(REG_RSSIVALUE);
    7532:	1dfc      	adds	r4, r7, #7
    7534:	2024      	movs	r0, #36	; 0x24
    7536:	f7ff ff66 	bl	7406 <readReg>
    753a:	0003      	movs	r3, r0
    753c:	7023      	strb	r3, [r4, #0]
	read_data = readReg(REG_OPMODE);
    753e:	1dfc      	adds	r4, r7, #7
    7540:	2001      	movs	r0, #1
    7542:	f7ff ff60 	bl	7406 <readReg>
    7546:	0003      	movs	r3, r0
    7548:	7023      	strb	r3, [r4, #0]
	writeReg(REG_OPMODE , RF69_MODE_TX);
    754a:	2104      	movs	r1, #4
    754c:	2001      	movs	r0, #1
    754e:	f7ff ff79 	bl	7444 <writeReg>
	read_data = readReg(REG_IRQFLAGS1);
    7552:	1dfc      	adds	r4, r7, #7
    7554:	2027      	movs	r0, #39	; 0x27
    7556:	f7ff ff56 	bl	7406 <readReg>
    755a:	0003      	movs	r3, r0
    755c:	7023      	strb	r3, [r4, #0]
	
	
	RF_select();
    755e:	f7ff ffcd 	bl	74fc <RF_select>
	SPI_write(REG_FIFO);
    7562:	2000      	movs	r0, #0
    7564:	f7ff fc22 	bl	6dac <SPI_write>
	
	RFM69_ReadBuff(&rx_header, 5);
    7568:	4b16      	ldr	r3, [pc, #88]	; (75c4 <data_ready+0xa8>)
    756a:	2105      	movs	r1, #5
    756c:	0018      	movs	r0, r3
    756e:	f7ff fbef 	bl	6d50 <RFM69_ReadBuff>
	RFM69_ReadBuff(&DATA, rx_header[0]);
    7572:	4b14      	ldr	r3, [pc, #80]	; (75c4 <data_ready+0xa8>)
    7574:	781b      	ldrb	r3, [r3, #0]
    7576:	b2db      	uxtb	r3, r3
    7578:	b29a      	uxth	r2, r3
    757a:	4b13      	ldr	r3, [pc, #76]	; (75c8 <data_ready+0xac>)
    757c:	0011      	movs	r1, r2
    757e:	0018      	movs	r0, r3
    7580:	f7ff fbe6 	bl	6d50 <RFM69_ReadBuff>
	//for (uint8_t i = 0; i < 37; i++)
	//{
	//DATA[i] = SPI_read();
	//}
	//if (DATALEN < RF69_MAX_DATA_LEN) DATA[DATALEN] = 0; // add null at end of string
	RF_unselect();
    7584:	f7ff ffc2 	bl	750c <RF_unselect>
	rx_ready = 1;
    7588:	4b10      	ldr	r3, [pc, #64]	; (75cc <data_ready+0xb0>)
    758a:	2201      	movs	r2, #1
    758c:	701a      	strb	r2, [r3, #0]
	//Треба перевірити перший байт, там довжина посилки
	
	
	
	writeReg(REG_DIOMAPPING1 , 0x40);
    758e:	2140      	movs	r1, #64	; 0x40
    7590:	2025      	movs	r0, #37	; 0x25
    7592:	f7ff ff57 	bl	7444 <writeReg>
	read_data = readReg(REG_OPMODE);
    7596:	1dfc      	adds	r4, r7, #7
    7598:	2001      	movs	r0, #1
    759a:	f7ff ff34 	bl	7406 <readReg>
    759e:	0003      	movs	r3, r0
    75a0:	7023      	strb	r3, [r4, #0]
	writeReg(REG_OPMODE , 0x10);
    75a2:	2110      	movs	r1, #16
    75a4:	2001      	movs	r0, #1
    75a6:	f7ff ff4d 	bl	7444 <writeReg>
	while (readReg(REG_IRQFLAGS1) == 0xD9);
    75aa:	46c0      	nop			; (mov r8, r8)
    75ac:	2027      	movs	r0, #39	; 0x27
    75ae:	f7ff ff2a 	bl	7406 <readReg>
    75b2:	0003      	movs	r3, r0
    75b4:	2bd9      	cmp	r3, #217	; 0xd9
    75b6:	d0f9      	beq.n	75ac <data_ready+0x90>
        //RF_unselect();
        //setMode(RF69_MODE_STANDBY);
    //}
    //RSSI = readRSSI(0);
    //inISR = 0;
	reset_led();
    75b8:	f7ff fc3f 	bl	6e3a <reset_led>
}
    75bc:	46c0      	nop			; (mov r8, r8)
    75be:	46bd      	mov	sp, r7
    75c0:	b003      	add	sp, #12
    75c2:	bd90      	pop	{r4, r7, pc}
    75c4:	2000088c 	.word	0x2000088c
    75c8:	20000844 	.word	0x20000844
    75cc:	20000883 	.word	0x20000883

000075d0 <hri_port_set_OUT_reg>:
{
    75d0:	b580      	push	{r7, lr}
    75d2:	b084      	sub	sp, #16
    75d4:	af00      	add	r7, sp, #0
    75d6:	60f8      	str	r0, [r7, #12]
    75d8:	607a      	str	r2, [r7, #4]
    75da:	230b      	movs	r3, #11
    75dc:	18fb      	adds	r3, r7, r3
    75de:	1c0a      	adds	r2, r1, #0
    75e0:	701a      	strb	r2, [r3, #0]
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    75e2:	230b      	movs	r3, #11
    75e4:	18fb      	adds	r3, r7, r3
    75e6:	781b      	ldrb	r3, [r3, #0]
    75e8:	68fa      	ldr	r2, [r7, #12]
    75ea:	01db      	lsls	r3, r3, #7
    75ec:	18d3      	adds	r3, r2, r3
    75ee:	3318      	adds	r3, #24
    75f0:	687a      	ldr	r2, [r7, #4]
    75f2:	601a      	str	r2, [r3, #0]
}
    75f4:	46c0      	nop			; (mov r8, r8)
    75f6:	46bd      	mov	sp, r7
    75f8:	b004      	add	sp, #16
    75fa:	bd80      	pop	{r7, pc}

000075fc <hri_port_clear_OUT_reg>:
{
    75fc:	b580      	push	{r7, lr}
    75fe:	b084      	sub	sp, #16
    7600:	af00      	add	r7, sp, #0
    7602:	60f8      	str	r0, [r7, #12]
    7604:	607a      	str	r2, [r7, #4]
    7606:	230b      	movs	r3, #11
    7608:	18fb      	adds	r3, r7, r3
    760a:	1c0a      	adds	r2, r1, #0
    760c:	701a      	strb	r2, [r3, #0]
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    760e:	230b      	movs	r3, #11
    7610:	18fb      	adds	r3, r7, r3
    7612:	781b      	ldrb	r3, [r3, #0]
    7614:	68fa      	ldr	r2, [r7, #12]
    7616:	01db      	lsls	r3, r3, #7
    7618:	18d3      	adds	r3, r2, r3
    761a:	3314      	adds	r3, #20
    761c:	687a      	ldr	r2, [r7, #4]
    761e:	601a      	str	r2, [r3, #0]
}
    7620:	46c0      	nop			; (mov r8, r8)
    7622:	46bd      	mov	sp, r7
    7624:	b004      	add	sp, #16
    7626:	bd80      	pop	{r7, pc}

00007628 <hri_port_toggle_OUT_reg>:
{
    7628:	b580      	push	{r7, lr}
    762a:	b084      	sub	sp, #16
    762c:	af00      	add	r7, sp, #0
    762e:	60f8      	str	r0, [r7, #12]
    7630:	607a      	str	r2, [r7, #4]
    7632:	230b      	movs	r3, #11
    7634:	18fb      	adds	r3, r7, r3
    7636:	1c0a      	adds	r2, r1, #0
    7638:	701a      	strb	r2, [r3, #0]
	((Port *)hw)->Group[submodule_index].OUTTGL.reg = mask;
    763a:	230b      	movs	r3, #11
    763c:	18fb      	adds	r3, r7, r3
    763e:	781b      	ldrb	r3, [r3, #0]
    7640:	68fa      	ldr	r2, [r7, #12]
    7642:	01db      	lsls	r3, r3, #7
    7644:	18d3      	adds	r3, r2, r3
    7646:	331c      	adds	r3, #28
    7648:	687a      	ldr	r2, [r7, #4]
    764a:	601a      	str	r2, [r3, #0]
}
    764c:	46c0      	nop			; (mov r8, r8)
    764e:	46bd      	mov	sp, r7
    7650:	b004      	add	sp, #16
    7652:	bd80      	pop	{r7, pc}

00007654 <_gpio_set_level>:
{
    7654:	b580      	push	{r7, lr}
    7656:	b082      	sub	sp, #8
    7658:	af00      	add	r7, sp, #0
    765a:	6039      	str	r1, [r7, #0]
    765c:	0011      	movs	r1, r2
    765e:	1dfb      	adds	r3, r7, #7
    7660:	1c02      	adds	r2, r0, #0
    7662:	701a      	strb	r2, [r3, #0]
    7664:	1dbb      	adds	r3, r7, #6
    7666:	1c0a      	adds	r2, r1, #0
    7668:	701a      	strb	r2, [r3, #0]
	if (level) {
    766a:	1dbb      	adds	r3, r7, #6
    766c:	781b      	ldrb	r3, [r3, #0]
    766e:	2b00      	cmp	r3, #0
    7670:	d008      	beq.n	7684 <_gpio_set_level+0x30>
		hri_port_set_OUT_reg(PORT_IOBUS, port, mask);
    7672:	683a      	ldr	r2, [r7, #0]
    7674:	1dfb      	adds	r3, r7, #7
    7676:	7819      	ldrb	r1, [r3, #0]
    7678:	23c0      	movs	r3, #192	; 0xc0
    767a:	05db      	lsls	r3, r3, #23
    767c:	0018      	movs	r0, r3
    767e:	f7ff ffa7 	bl	75d0 <hri_port_set_OUT_reg>
}
    7682:	e007      	b.n	7694 <_gpio_set_level+0x40>
		hri_port_clear_OUT_reg(PORT_IOBUS, port, mask);
    7684:	683a      	ldr	r2, [r7, #0]
    7686:	1dfb      	adds	r3, r7, #7
    7688:	7819      	ldrb	r1, [r3, #0]
    768a:	23c0      	movs	r3, #192	; 0xc0
    768c:	05db      	lsls	r3, r3, #23
    768e:	0018      	movs	r0, r3
    7690:	f7ff ffb4 	bl	75fc <hri_port_clear_OUT_reg>
}
    7694:	46c0      	nop			; (mov r8, r8)
    7696:	46bd      	mov	sp, r7
    7698:	b002      	add	sp, #8
    769a:	bd80      	pop	{r7, pc}

0000769c <_gpio_toggle_level>:
{
    769c:	b580      	push	{r7, lr}
    769e:	b082      	sub	sp, #8
    76a0:	af00      	add	r7, sp, #0
    76a2:	0002      	movs	r2, r0
    76a4:	6039      	str	r1, [r7, #0]
    76a6:	1dfb      	adds	r3, r7, #7
    76a8:	701a      	strb	r2, [r3, #0]
	hri_port_toggle_OUT_reg(PORT_IOBUS, port, mask);
    76aa:	683a      	ldr	r2, [r7, #0]
    76ac:	1dfb      	adds	r3, r7, #7
    76ae:	7819      	ldrb	r1, [r3, #0]
    76b0:	23c0      	movs	r3, #192	; 0xc0
    76b2:	05db      	lsls	r3, r3, #23
    76b4:	0018      	movs	r0, r3
    76b6:	f7ff ffb7 	bl	7628 <hri_port_toggle_OUT_reg>
}
    76ba:	46c0      	nop			; (mov r8, r8)
    76bc:	46bd      	mov	sp, r7
    76be:	b002      	add	sp, #8
    76c0:	bd80      	pop	{r7, pc}

000076c2 <gpio_set_pin_level>:
{
    76c2:	b580      	push	{r7, lr}
    76c4:	b082      	sub	sp, #8
    76c6:	af00      	add	r7, sp, #0
    76c8:	0002      	movs	r2, r0
    76ca:	1dfb      	adds	r3, r7, #7
    76cc:	701a      	strb	r2, [r3, #0]
    76ce:	1dbb      	adds	r3, r7, #6
    76d0:	1c0a      	adds	r2, r1, #0
    76d2:	701a      	strb	r2, [r3, #0]
	_gpio_set_level((enum gpio_port)GPIO_PORT(pin), 1U << GPIO_PIN(pin), level);
    76d4:	1dfb      	adds	r3, r7, #7
    76d6:	781b      	ldrb	r3, [r3, #0]
    76d8:	095b      	lsrs	r3, r3, #5
    76da:	b2d8      	uxtb	r0, r3
    76dc:	1dfb      	adds	r3, r7, #7
    76de:	781b      	ldrb	r3, [r3, #0]
    76e0:	221f      	movs	r2, #31
    76e2:	4013      	ands	r3, r2
    76e4:	2201      	movs	r2, #1
    76e6:	409a      	lsls	r2, r3
    76e8:	0011      	movs	r1, r2
    76ea:	1dbb      	adds	r3, r7, #6
    76ec:	781b      	ldrb	r3, [r3, #0]
    76ee:	001a      	movs	r2, r3
    76f0:	f7ff ffb0 	bl	7654 <_gpio_set_level>
}
    76f4:	46c0      	nop			; (mov r8, r8)
    76f6:	46bd      	mov	sp, r7
    76f8:	b002      	add	sp, #8
    76fa:	bd80      	pop	{r7, pc}

000076fc <gpio_toggle_pin_level>:
 * Toggle the pin levels on pins defined by bit mask
 *
 * \param[in] pin       The pin number for device
 */
static inline void gpio_toggle_pin_level(const uint8_t pin)
{
    76fc:	b580      	push	{r7, lr}
    76fe:	b082      	sub	sp, #8
    7700:	af00      	add	r7, sp, #0
    7702:	0002      	movs	r2, r0
    7704:	1dfb      	adds	r3, r7, #7
    7706:	701a      	strb	r2, [r3, #0]
	_gpio_toggle_level((enum gpio_port)GPIO_PORT(pin), 1U << GPIO_PIN(pin));
    7708:	1dfb      	adds	r3, r7, #7
    770a:	781b      	ldrb	r3, [r3, #0]
    770c:	095b      	lsrs	r3, r3, #5
    770e:	b2d8      	uxtb	r0, r3
    7710:	1dfb      	adds	r3, r7, #7
    7712:	781b      	ldrb	r3, [r3, #0]
    7714:	221f      	movs	r2, #31
    7716:	4013      	ands	r3, r2
    7718:	2201      	movs	r2, #1
    771a:	409a      	lsls	r2, r3
    771c:	0013      	movs	r3, r2
    771e:	0019      	movs	r1, r3
    7720:	f7ff ffbc 	bl	769c <_gpio_toggle_level>
}
    7724:	46c0      	nop			; (mov r8, r8)
    7726:	46bd      	mov	sp, r7
    7728:	b002      	add	sp, #8
    772a:	bd80      	pop	{r7, pc}

0000772c <main>:
u8g2_t u8g2;

uint16_t seco, mine, hour;

int main(void)
{
    772c:	b5f0      	push	{r4, r5, r6, r7, lr}
    772e:	b0a5      	sub	sp, #148	; 0x94
    7730:	af04      	add	r7, sp, #16
	/* Initializes MCU, drivers and middleware */
	atmel_start_init();
    7732:	f7f8 fce7 	bl	104 <atmel_start_init>
	
	EXT_SPI_init();
    7736:	f7ff fb89 	bl	6e4c <EXT_SPI_init>
	
	RF_SPI_init();
    773a:	f7ff fcaf 	bl	709c <RF_SPI_init>
	
	rfm69_init(868, NODEID, NETWORKID);
    773e:	23d9      	movs	r3, #217	; 0xd9
    7740:	009b      	lsls	r3, r3, #2
    7742:	2221      	movs	r2, #33	; 0x21
    7744:	2103      	movs	r1, #3
    7746:	0018      	movs	r0, r3
    7748:	f7ff fdca 	bl	72e0 <rfm69_init>
	setHighPower(true);
    774c:	2001      	movs	r0, #1
    774e:	f7ff fe99 	bl	7484 <setHighPower>
	
	
	
	//EXTERNAL_IRQ_0_example();
	
	uint8_t debug_str[] = "                    \n\r";
    7752:	2364      	movs	r3, #100	; 0x64
    7754:	18fb      	adds	r3, r7, r3
    7756:	4adf      	ldr	r2, [pc, #892]	; (7ad4 <main+0x3a8>)
    7758:	ca13      	ldmia	r2!, {r0, r1, r4}
    775a:	c313      	stmia	r3!, {r0, r1, r4}
    775c:	ca03      	ldmia	r2!, {r0, r1}
    775e:	c303      	stmia	r3!, {r0, r1}
    7760:	8811      	ldrh	r1, [r2, #0]
    7762:	8019      	strh	r1, [r3, #0]
    7764:	7892      	ldrb	r2, [r2, #2]
    7766:	709a      	strb	r2, [r3, #2]
	uint8_t rf_str[] =    "                    \n\r";
    7768:	234c      	movs	r3, #76	; 0x4c
    776a:	18fb      	adds	r3, r7, r3
    776c:	4ad9      	ldr	r2, [pc, #868]	; (7ad4 <main+0x3a8>)
    776e:	ca13      	ldmia	r2!, {r0, r1, r4}
    7770:	c313      	stmia	r3!, {r0, r1, r4}
    7772:	ca03      	ldmia	r2!, {r0, r1}
    7774:	c303      	stmia	r3!, {r0, r1}
    7776:	8811      	ldrh	r1, [r2, #0]
    7778:	8019      	strh	r1, [r3, #0]
    777a:	7892      	ldrb	r2, [r2, #2]
    777c:	709a      	strb	r2, [r3, #2]
	
	
	
	//LED_Panel
		uint8_t led_val;
		uint8_t panel_addr = 0x64;
    777e:	237f      	movs	r3, #127	; 0x7f
    7780:	18fb      	adds	r3, r7, r3
    7782:	2264      	movs	r2, #100	; 0x64
    7784:	701a      	strb	r2, [r3, #0]
		#define  r_part 2
		#define  g_part 1
		#define  b_part 3
		
		uint8_t reset_cmd[] = {0xa5, 0x5a};
    7786:	2348      	movs	r3, #72	; 0x48
    7788:	18fb      	adds	r3, r7, r3
    778a:	4ad3      	ldr	r2, [pc, #844]	; (7ad8 <main+0x3ac>)
    778c:	8812      	ldrh	r2, [r2, #0]
    778e:	801a      	strh	r2, [r3, #0]
		uint8_t init_cmd[] = {0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0xAA, 0xAA, 0xAA, 0xAA};
    7790:	232c      	movs	r3, #44	; 0x2c
    7792:	18fb      	adds	r3, r7, r3
    7794:	4ad1      	ldr	r2, [pc, #836]	; (7adc <main+0x3b0>)
    7796:	ca13      	ldmia	r2!, {r0, r1, r4}
    7798:	c313      	stmia	r3!, {r0, r1, r4}
    779a:	ca13      	ldmia	r2!, {r0, r1, r4}
    779c:	c313      	stmia	r3!, {r0, r1, r4}
    779e:	7812      	ldrb	r2, [r2, #0]
    77a0:	701a      	strb	r2, [r3, #0]
		uint8_t led_data[] = {0xa2, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f};
    77a2:	2318      	movs	r3, #24
    77a4:	18fb      	adds	r3, r7, r3
    77a6:	4ace      	ldr	r2, [pc, #824]	; (7ae0 <main+0x3b4>)
    77a8:	ca13      	ldmia	r2!, {r0, r1, r4}
    77aa:	c313      	stmia	r3!, {r0, r1, r4}
    77ac:	6811      	ldr	r1, [r2, #0]
    77ae:	6019      	str	r1, [r3, #0]
    77b0:	7912      	ldrb	r2, [r2, #4]
    77b2:	711a      	strb	r2, [r3, #4]
		
		uint8_t led1[]= {0xa2, 0, 0, 0};
    77b4:	2314      	movs	r3, #20
    77b6:	18fb      	adds	r3, r7, r3
    77b8:	22a2      	movs	r2, #162	; 0xa2
    77ba:	701a      	strb	r2, [r3, #0]
    77bc:	2314      	movs	r3, #20
    77be:	18fb      	adds	r3, r7, r3
    77c0:	2200      	movs	r2, #0
    77c2:	705a      	strb	r2, [r3, #1]
    77c4:	2314      	movs	r3, #20
    77c6:	18fb      	adds	r3, r7, r3
    77c8:	2200      	movs	r2, #0
    77ca:	709a      	strb	r2, [r3, #2]
    77cc:	2314      	movs	r3, #20
    77ce:	18fb      	adds	r3, r7, r3
    77d0:	2200      	movs	r2, #0
    77d2:	70da      	strb	r2, [r3, #3]
		uint8_t led2[]= {0xa5, 0, 0, 0};
    77d4:	2310      	movs	r3, #16
    77d6:	18fb      	adds	r3, r7, r3
    77d8:	22a5      	movs	r2, #165	; 0xa5
    77da:	701a      	strb	r2, [r3, #0]
    77dc:	2310      	movs	r3, #16
    77de:	18fb      	adds	r3, r7, r3
    77e0:	2200      	movs	r2, #0
    77e2:	705a      	strb	r2, [r3, #1]
    77e4:	2310      	movs	r3, #16
    77e6:	18fb      	adds	r3, r7, r3
    77e8:	2200      	movs	r2, #0
    77ea:	709a      	strb	r2, [r3, #2]
    77ec:	2310      	movs	r3, #16
    77ee:	18fb      	adds	r3, r7, r3
    77f0:	2200      	movs	r2, #0
    77f2:	70da      	strb	r2, [r3, #3]
		
		uint8_t led3[]= {0xa8, 0, 0, 0};
    77f4:	230c      	movs	r3, #12
    77f6:	18fb      	adds	r3, r7, r3
    77f8:	22a8      	movs	r2, #168	; 0xa8
    77fa:	701a      	strb	r2, [r3, #0]
    77fc:	230c      	movs	r3, #12
    77fe:	18fb      	adds	r3, r7, r3
    7800:	2200      	movs	r2, #0
    7802:	705a      	strb	r2, [r3, #1]
    7804:	230c      	movs	r3, #12
    7806:	18fb      	adds	r3, r7, r3
    7808:	2200      	movs	r2, #0
    780a:	709a      	strb	r2, [r3, #2]
    780c:	230c      	movs	r3, #12
    780e:	18fb      	adds	r3, r7, r3
    7810:	2200      	movs	r2, #0
    7812:	70da      	strb	r2, [r3, #3]
		uint8_t led4[]= {0xab, 0, 25, 0};
    7814:	2308      	movs	r3, #8
    7816:	18fb      	adds	r3, r7, r3
    7818:	4ab2      	ldr	r2, [pc, #712]	; (7ae4 <main+0x3b8>)
    781a:	6812      	ldr	r2, [r2, #0]
    781c:	601a      	str	r2, [r3, #0]
		uint8_t led5[]= {0xae, 0, 25, 0};
    781e:	1d3b      	adds	r3, r7, #4
    7820:	4ab1      	ldr	r2, [pc, #708]	; (7ae8 <main+0x3bc>)
    7822:	6812      	ldr	r2, [r2, #0]
    7824:	601a      	str	r2, [r3, #0]
		uint8_t ext_led[] = {0xb1, 64};
    7826:	003b      	movs	r3, r7
    7828:	4ab0      	ldr	r2, [pc, #704]	; (7aec <main+0x3c0>)
    782a:	8812      	ldrh	r2, [r2, #0]
    782c:	801a      	strh	r2, [r3, #0]
	//End LED Panel
	
	
	
	u8g2_Setup_gp1287ai_256x50_f(&u8g2, U8G2_R0, vfd_spi, u8x8_avr_gpio_and_delay);
    782e:	4bb0      	ldr	r3, [pc, #704]	; (7af0 <main+0x3c4>)
    7830:	4ab0      	ldr	r2, [pc, #704]	; (7af4 <main+0x3c8>)
    7832:	49b1      	ldr	r1, [pc, #708]	; (7af8 <main+0x3cc>)
    7834:	48b1      	ldr	r0, [pc, #708]	; (7afc <main+0x3d0>)
    7836:	f7f9 f86d 	bl	914 <u8g2_Setup_gp1287ai_256x50_f>
	u8g2_InitDisplay(&u8g2);
    783a:	4bb0      	ldr	r3, [pc, #704]	; (7afc <main+0x3d0>)
    783c:	0018      	movs	r0, r3
    783e:	f7fb f83a 	bl	28b6 <u8x8_InitDisplay>
	
	u8g2_SetPowerSave(&u8g2, 0);
    7842:	4bae      	ldr	r3, [pc, #696]	; (7afc <main+0x3d0>)
    7844:	2100      	movs	r1, #0
    7846:	0018      	movs	r0, r3
    7848:	f7fb f844 	bl	28d4 <u8x8_SetPowerSave>
	u8g2_SetContrast(&u8g2, 5);
    784c:	4bab      	ldr	r3, [pc, #684]	; (7afc <main+0x3d0>)
    784e:	2105      	movs	r1, #5
    7850:	0018      	movs	r0, r3
    7852:	f7fb f852 	bl	28fa <u8x8_SetContrast>
	//WDT_CLEAR_CLEAR(0x5a);
	
	u8g2_ClearBuffer(&u8g2);
    7856:	4ba9      	ldr	r3, [pc, #676]	; (7afc <main+0x3d0>)
    7858:	0018      	movs	r0, r3
    785a:	f7f8 fdce 	bl	3fa <u8g2_ClearBuffer>
	//WDT->CLEAR.reg=0x5a;
	//u8g2_SetFont(&u8g2, u8g2_font_ncenB14_tr);
	//u8g2_SetFont(&u8g2, u8g2_font_courR08_tr);
	//u8g2_SetFont(&u8g2, u8g2_font_cu12_t_symbols);
	u8g2_SetFont(&u8g2, u8g2_font_Terminal_tr);
    785e:	4aa8      	ldr	r2, [pc, #672]	; (7b00 <main+0x3d4>)
    7860:	4ba6      	ldr	r3, [pc, #664]	; (7afc <main+0x3d0>)
    7862:	0011      	movs	r1, r2
    7864:	0018      	movs	r0, r3
    7866:	f7f9 fff1 	bl	184c <u8g2_SetFont>
	//u8g2_SetFont(&u8g2, u8g2_font_battery19_tn); //battery icons
	
	/* Replace with your application code */
	 EXT_I2C_init();
    786a:	f7ff fcd1 	bl	7210 <EXT_I2C_init>
		
	 GCLK->CLKCTRL.reg = GCLK_CLKCTRL_ID_WDT |
    786e:	4ba5      	ldr	r3, [pc, #660]	; (7b04 <main+0x3d8>)
    7870:	4aa5      	ldr	r2, [pc, #660]	; (7b08 <main+0x3dc>)
    7872:	805a      	strh	r2, [r3, #2]
	 GCLK_CLKCTRL_CLKEN |
	 GCLK_CLKCTRL_GEN_GCLK3;	
	//WDT->INTENSET.bit.EW  = 0;      // Enable early warning interrupt
	//WDT->EWCTRL.bit.EWOFFSET = 0x0B;  // Early Warning Interrupt Time Offset 0xA
	//WDT->CONFIG.bit.PER    = 0xB;  // Set period for chip reset 0xB 16384 clock cycles
	WDT->CLEAR.bit.CLEAR = 0xA5;
    7874:	4ba5      	ldr	r3, [pc, #660]	; (7b0c <main+0x3e0>)
    7876:	22a5      	movs	r2, #165	; 0xa5
    7878:	721a      	strb	r2, [r3, #8]
	//WDT->CTRL.bit.WEN      = 0;      // Disable window mode
	//while(WDT->STATUS.bit.SYNCBUSY); // Sync CTRL write
	//WDT->CTRL.bit.ENABLE = 1; // Start watchdog now!
	//while(WDT->STATUS.bit.SYNCBUSY);

	I2C_write_batch(panel_addr, reset_cmd, sizeof(reset_cmd));
    787a:	2348      	movs	r3, #72	; 0x48
    787c:	18f9      	adds	r1, r7, r3
    787e:	237f      	movs	r3, #127	; 0x7f
    7880:	18fb      	adds	r3, r7, r3
    7882:	781b      	ldrb	r3, [r3, #0]
    7884:	2202      	movs	r2, #2
    7886:	0018      	movs	r0, r3
    7888:	f7ff fd00 	bl	728c <I2C_write_batch>
	delay_ms(10);
    788c:	200a      	movs	r0, #10
    788e:	f7fc f89d 	bl	39cc <delay_ms>
	I2C_write_batch(panel_addr, init_cmd, sizeof(init_cmd));
    7892:	232c      	movs	r3, #44	; 0x2c
    7894:	18f9      	adds	r1, r7, r3
    7896:	237f      	movs	r3, #127	; 0x7f
    7898:	18fb      	adds	r3, r7, r3
    789a:	781b      	ldrb	r3, [r3, #0]
    789c:	2219      	movs	r2, #25
    789e:	0018      	movs	r0, r3
    78a0:	f7ff fcf4 	bl	728c <I2C_write_batch>
	delay_ms(10);
    78a4:	200a      	movs	r0, #10
    78a6:	f7fc f891 	bl	39cc <delay_ms>
	
	while (1) {
	
		WDT->CLEAR.bit.CLEAR = 0xA5;
    78aa:	4b98      	ldr	r3, [pc, #608]	; (7b0c <main+0x3e0>)
    78ac:	22a5      	movs	r2, #165	; 0xa5
    78ae:	721a      	strb	r2, [r3, #8]
		while(WDT->STATUS.bit.SYNCBUSY);
    78b0:	46c0      	nop			; (mov r8, r8)
    78b2:	4b96      	ldr	r3, [pc, #600]	; (7b0c <main+0x3e0>)
    78b4:	79db      	ldrb	r3, [r3, #7]
    78b6:	061b      	lsls	r3, r3, #24
    78b8:	0fdb      	lsrs	r3, r3, #31
    78ba:	b2db      	uxtb	r3, r3
    78bc:	2b00      	cmp	r3, #0
    78be:	d1f8      	bne.n	78b2 <main+0x186>
		gpio_toggle_pin_level(LED_G);		
    78c0:	2020      	movs	r0, #32
    78c2:	f7ff ff1b 	bl	76fc <gpio_toggle_pin_level>
		
		led_val = rf_isReady();
    78c6:	237e      	movs	r3, #126	; 0x7e
    78c8:	18fc      	adds	r4, r7, r3
    78ca:	f7ff fa27 	bl	6d1c <rf_isReady>
    78ce:	0003      	movs	r3, r0
    78d0:	7023      	strb	r3, [r4, #0]
		led1[g_part] = led_val;
    78d2:	2314      	movs	r3, #20
    78d4:	18fb      	adds	r3, r7, r3
    78d6:	227e      	movs	r2, #126	; 0x7e
    78d8:	18ba      	adds	r2, r7, r2
    78da:	7812      	ldrb	r2, [r2, #0]
    78dc:	705a      	strb	r2, [r3, #1]
		led1[b_part] = 255-led_val;
    78de:	237e      	movs	r3, #126	; 0x7e
    78e0:	18fb      	adds	r3, r7, r3
    78e2:	781b      	ldrb	r3, [r3, #0]
    78e4:	43db      	mvns	r3, r3
    78e6:	b2da      	uxtb	r2, r3
    78e8:	2314      	movs	r3, #20
    78ea:	18fb      	adds	r3, r7, r3
    78ec:	70da      	strb	r2, [r3, #3]
		led2[g_part] = led_val;
    78ee:	2310      	movs	r3, #16
    78f0:	18fb      	adds	r3, r7, r3
    78f2:	227e      	movs	r2, #126	; 0x7e
    78f4:	18ba      	adds	r2, r7, r2
    78f6:	7812      	ldrb	r2, [r2, #0]
    78f8:	705a      	strb	r2, [r3, #1]
		led2[b_part] = 255-led_val;
    78fa:	237e      	movs	r3, #126	; 0x7e
    78fc:	18fb      	adds	r3, r7, r3
    78fe:	781b      	ldrb	r3, [r3, #0]
    7900:	43db      	mvns	r3, r3
    7902:	b2da      	uxtb	r2, r3
    7904:	2310      	movs	r3, #16
    7906:	18fb      	adds	r3, r7, r3
    7908:	70da      	strb	r2, [r3, #3]
		led3[g_part] = led_val;
    790a:	230c      	movs	r3, #12
    790c:	18fb      	adds	r3, r7, r3
    790e:	227e      	movs	r2, #126	; 0x7e
    7910:	18ba      	adds	r2, r7, r2
    7912:	7812      	ldrb	r2, [r2, #0]
    7914:	705a      	strb	r2, [r3, #1]
		led3[b_part] = 255-led_val;
    7916:	237e      	movs	r3, #126	; 0x7e
    7918:	18fb      	adds	r3, r7, r3
    791a:	781b      	ldrb	r3, [r3, #0]
    791c:	43db      	mvns	r3, r3
    791e:	b2da      	uxtb	r2, r3
    7920:	230c      	movs	r3, #12
    7922:	18fb      	adds	r3, r7, r3
    7924:	70da      	strb	r2, [r3, #3]
		
		led4[g_part] = led_val;
    7926:	2308      	movs	r3, #8
    7928:	18fb      	adds	r3, r7, r3
    792a:	227e      	movs	r2, #126	; 0x7e
    792c:	18ba      	adds	r2, r7, r2
    792e:	7812      	ldrb	r2, [r2, #0]
    7930:	705a      	strb	r2, [r3, #1]
		led4[b_part] = 255-led_val;
    7932:	237e      	movs	r3, #126	; 0x7e
    7934:	18fb      	adds	r3, r7, r3
    7936:	781b      	ldrb	r3, [r3, #0]
    7938:	43db      	mvns	r3, r3
    793a:	b2da      	uxtb	r2, r3
    793c:	2308      	movs	r3, #8
    793e:	18fb      	adds	r3, r7, r3
    7940:	70da      	strb	r2, [r3, #3]
		
		led5[g_part] = led_val;
    7942:	1d3b      	adds	r3, r7, #4
    7944:	227e      	movs	r2, #126	; 0x7e
    7946:	18ba      	adds	r2, r7, r2
    7948:	7812      	ldrb	r2, [r2, #0]
    794a:	705a      	strb	r2, [r3, #1]
		led5[b_part] = 255-led_val;
    794c:	237e      	movs	r3, #126	; 0x7e
    794e:	18fb      	adds	r3, r7, r3
    7950:	781b      	ldrb	r3, [r3, #0]
    7952:	43db      	mvns	r3, r3
    7954:	b2da      	uxtb	r2, r3
    7956:	1d3b      	adds	r3, r7, #4
    7958:	70da      	strb	r2, [r3, #3]

		
		if(I2C_write_batch(panel_addr, led1, sizeof(led1))){
    795a:	2314      	movs	r3, #20
    795c:	18f9      	adds	r1, r7, r3
    795e:	237f      	movs	r3, #127	; 0x7f
    7960:	18fb      	adds	r3, r7, r3
    7962:	781b      	ldrb	r3, [r3, #0]
    7964:	2204      	movs	r2, #4
    7966:	0018      	movs	r0, r3
    7968:	f7ff fc90 	bl	728c <I2C_write_batch>
    796c:	1e03      	subs	r3, r0, #0
    796e:	d004      	beq.n	797a <main+0x24e>
			gpio_set_pin_level(LED_R, false);
    7970:	2100      	movs	r1, #0
    7972:	203f      	movs	r0, #63	; 0x3f
    7974:	f7ff fea5 	bl	76c2 <gpio_set_pin_level>
    7978:	e003      	b.n	7982 <main+0x256>
		}else{
			gpio_set_pin_level(LED_R, true);
    797a:	2101      	movs	r1, #1
    797c:	203f      	movs	r0, #63	; 0x3f
    797e:	f7ff fea0 	bl	76c2 <gpio_set_pin_level>
		}
		I2C_write_batch(panel_addr, led2, sizeof(led2));
    7982:	2310      	movs	r3, #16
    7984:	18f9      	adds	r1, r7, r3
    7986:	237f      	movs	r3, #127	; 0x7f
    7988:	18fb      	adds	r3, r7, r3
    798a:	781b      	ldrb	r3, [r3, #0]
    798c:	2204      	movs	r2, #4
    798e:	0018      	movs	r0, r3
    7990:	f7ff fc7c 	bl	728c <I2C_write_batch>
		//
		//gpio_toggle_pin_level(LED_G);
		//gpio_toggle_pin_level(LED_SD);
		//gpio_toggle_pin_level(LED_R);
		
		u8g2_ClearBuffer(&u8g2);
    7994:	4b59      	ldr	r3, [pc, #356]	; (7afc <main+0x3d0>)
    7996:	0018      	movs	r0, r3
    7998:	f7f8 fd2f 	bl	3fa <u8g2_ClearBuffer>
		u8g2_DrawRFrame(&u8g2, 0, 0, 256 ,48, 5);
    799c:	2380      	movs	r3, #128	; 0x80
    799e:	005a      	lsls	r2, r3, #1
    79a0:	4856      	ldr	r0, [pc, #344]	; (7afc <main+0x3d0>)
    79a2:	2305      	movs	r3, #5
    79a4:	9301      	str	r3, [sp, #4]
    79a6:	2330      	movs	r3, #48	; 0x30
    79a8:	9300      	str	r3, [sp, #0]
    79aa:	0013      	movs	r3, r2
    79ac:	2200      	movs	r2, #0
    79ae:	2100      	movs	r1, #0
    79b0:	f7f8 fbaf 	bl	112 <u8g2_DrawRFrame>
		u8g2_DrawStr(&u8g2, 60, 11, (char *)"ATMEL SAMD20 (48MHz)");
    79b4:	4b56      	ldr	r3, [pc, #344]	; (7b10 <main+0x3e4>)
    79b6:	4851      	ldr	r0, [pc, #324]	; (7afc <main+0x3d0>)
    79b8:	220b      	movs	r2, #11
    79ba:	213c      	movs	r1, #60	; 0x3c
    79bc:	f7f9 fea0 	bl	1700 <u8g2_DrawStr>
		u8g2_DrawLine(&u8g2, 3,12, 252,12);
    79c0:	484e      	ldr	r0, [pc, #312]	; (7afc <main+0x3d0>)
    79c2:	230c      	movs	r3, #12
    79c4:	9300      	str	r3, [sp, #0]
    79c6:	23fc      	movs	r3, #252	; 0xfc
    79c8:	220c      	movs	r2, #12
    79ca:	2103      	movs	r1, #3
    79cc:	f7fa f9c4 	bl	1d58 <u8g2_DrawLine>
		
		
		sprintf(debug_str, "INT:%04d; tim:%03d:%02d:%02d " , rf_isReady(), hour,mine,seco);
    79d0:	f7ff f9a4 	bl	6d1c <rf_isReady>
    79d4:	0003      	movs	r3, r0
    79d6:	001c      	movs	r4, r3
    79d8:	4b4e      	ldr	r3, [pc, #312]	; (7b14 <main+0x3e8>)
    79da:	881b      	ldrh	r3, [r3, #0]
    79dc:	001d      	movs	r5, r3
    79de:	4b4e      	ldr	r3, [pc, #312]	; (7b18 <main+0x3ec>)
    79e0:	881b      	ldrh	r3, [r3, #0]
    79e2:	001a      	movs	r2, r3
    79e4:	4b4d      	ldr	r3, [pc, #308]	; (7b1c <main+0x3f0>)
    79e6:	881b      	ldrh	r3, [r3, #0]
    79e8:	494d      	ldr	r1, [pc, #308]	; (7b20 <main+0x3f4>)
    79ea:	2064      	movs	r0, #100	; 0x64
    79ec:	1838      	adds	r0, r7, r0
    79ee:	9301      	str	r3, [sp, #4]
    79f0:	9200      	str	r2, [sp, #0]
    79f2:	002b      	movs	r3, r5
    79f4:	0022      	movs	r2, r4
    79f6:	f000 f963 	bl	7cc0 <siprintf>
		u8g2_DrawStr(&u8g2, 3, 23, (char *)debug_str);
    79fa:	2364      	movs	r3, #100	; 0x64
    79fc:	18fb      	adds	r3, r7, r3
    79fe:	483f      	ldr	r0, [pc, #252]	; (7afc <main+0x3d0>)
    7a00:	2217      	movs	r2, #23
    7a02:	2103      	movs	r1, #3
    7a04:	f7f9 fe7c 	bl	1700 <u8g2_DrawStr>
		u8g2_DrawStr(&u8g2, 3, 34, (char *)rf_str);
    7a08:	234c      	movs	r3, #76	; 0x4c
    7a0a:	18fb      	adds	r3, r7, r3
    7a0c:	483b      	ldr	r0, [pc, #236]	; (7afc <main+0x3d0>)
    7a0e:	2222      	movs	r2, #34	; 0x22
    7a10:	2103      	movs	r1, #3
    7a12:	f7f9 fe75 	bl	1700 <u8g2_DrawStr>
		u8g2_DrawStr(&u8g2, 3, 44, (char *)DATA);
    7a16:	4b43      	ldr	r3, [pc, #268]	; (7b24 <main+0x3f8>)
    7a18:	4838      	ldr	r0, [pc, #224]	; (7afc <main+0x3d0>)
    7a1a:	222c      	movs	r2, #44	; 0x2c
    7a1c:	2103      	movs	r1, #3
    7a1e:	f7f9 fe6f 	bl	1700 <u8g2_DrawStr>
		u8g2_SendBuffer(&u8g2);
    7a22:	4b36      	ldr	r3, [pc, #216]	; (7afc <main+0x3d0>)
    7a24:	0018      	movs	r0, r3
    7a26:	f7f8 fd8d 	bl	544 <u8g2_SendBuffer>
		
		//seco == 999 ? seco=0 : seco++;
		seco++;
    7a2a:	4b3c      	ldr	r3, [pc, #240]	; (7b1c <main+0x3f0>)
    7a2c:	881b      	ldrh	r3, [r3, #0]
    7a2e:	3301      	adds	r3, #1
    7a30:	b29a      	uxth	r2, r3
    7a32:	4b3a      	ldr	r3, [pc, #232]	; (7b1c <main+0x3f0>)
    7a34:	801a      	strh	r2, [r3, #0]
		if(seco==60){
    7a36:	4b39      	ldr	r3, [pc, #228]	; (7b1c <main+0x3f0>)
    7a38:	881b      	ldrh	r3, [r3, #0]
    7a3a:	2b3c      	cmp	r3, #60	; 0x3c
    7a3c:	d116      	bne.n	7a6c <main+0x340>
			u8g2_InitDisplay(&u8g2);
    7a3e:	4b2f      	ldr	r3, [pc, #188]	; (7afc <main+0x3d0>)
    7a40:	0018      	movs	r0, r3
    7a42:	f7fa ff38 	bl	28b6 <u8x8_InitDisplay>
			u8g2_SetPowerSave(&u8g2, 0);
    7a46:	4b2d      	ldr	r3, [pc, #180]	; (7afc <main+0x3d0>)
    7a48:	2100      	movs	r1, #0
    7a4a:	0018      	movs	r0, r3
    7a4c:	f7fa ff42 	bl	28d4 <u8x8_SetPowerSave>
			u8g2_SetContrast(&u8g2, 5);
    7a50:	4b2a      	ldr	r3, [pc, #168]	; (7afc <main+0x3d0>)
    7a52:	2105      	movs	r1, #5
    7a54:	0018      	movs	r0, r3
    7a56:	f7fa ff50 	bl	28fa <u8x8_SetContrast>
			
			mine++;
    7a5a:	4b2f      	ldr	r3, [pc, #188]	; (7b18 <main+0x3ec>)
    7a5c:	881b      	ldrh	r3, [r3, #0]
    7a5e:	3301      	adds	r3, #1
    7a60:	b29a      	uxth	r2, r3
    7a62:	4b2d      	ldr	r3, [pc, #180]	; (7b18 <main+0x3ec>)
    7a64:	801a      	strh	r2, [r3, #0]
			seco=0;
    7a66:	4b2d      	ldr	r3, [pc, #180]	; (7b1c <main+0x3f0>)
    7a68:	2200      	movs	r2, #0
    7a6a:	801a      	strh	r2, [r3, #0]
		}
		if(mine==60){
    7a6c:	4b2a      	ldr	r3, [pc, #168]	; (7b18 <main+0x3ec>)
    7a6e:	881b      	ldrh	r3, [r3, #0]
    7a70:	2b3c      	cmp	r3, #60	; 0x3c
    7a72:	d108      	bne.n	7a86 <main+0x35a>
			hour++;
    7a74:	4b27      	ldr	r3, [pc, #156]	; (7b14 <main+0x3e8>)
    7a76:	881b      	ldrh	r3, [r3, #0]
    7a78:	3301      	adds	r3, #1
    7a7a:	b29a      	uxth	r2, r3
    7a7c:	4b25      	ldr	r3, [pc, #148]	; (7b14 <main+0x3e8>)
    7a7e:	801a      	strh	r2, [r3, #0]
			mine=0;
    7a80:	4b25      	ldr	r3, [pc, #148]	; (7b18 <main+0x3ec>)
    7a82:	2200      	movs	r2, #0
    7a84:	801a      	strh	r2, [r3, #0]
		}
		if (rx_ready) {
    7a86:	4b28      	ldr	r3, [pc, #160]	; (7b28 <main+0x3fc>)
    7a88:	781b      	ldrb	r3, [r3, #0]
    7a8a:	b2db      	uxtb	r3, r3
    7a8c:	2b00      	cmp	r3, #0
    7a8e:	d100      	bne.n	7a92 <main+0x366>
    7a90:	e70b      	b.n	78aa <main+0x17e>
			sprintf((char *)rf_str , "%02d/%02d/%02d/%02d/%02d    ",  rx_header[0], rx_header[1], rx_header[2],  rx_header[3],  rx_header[4]);
    7a92:	4b26      	ldr	r3, [pc, #152]	; (7b2c <main+0x400>)
    7a94:	781b      	ldrb	r3, [r3, #0]
    7a96:	b2db      	uxtb	r3, r3
    7a98:	001d      	movs	r5, r3
    7a9a:	4b24      	ldr	r3, [pc, #144]	; (7b2c <main+0x400>)
    7a9c:	785b      	ldrb	r3, [r3, #1]
    7a9e:	b2db      	uxtb	r3, r3
    7aa0:	001e      	movs	r6, r3
    7aa2:	4b22      	ldr	r3, [pc, #136]	; (7b2c <main+0x400>)
    7aa4:	789b      	ldrb	r3, [r3, #2]
    7aa6:	b2db      	uxtb	r3, r3
    7aa8:	001a      	movs	r2, r3
    7aaa:	4b20      	ldr	r3, [pc, #128]	; (7b2c <main+0x400>)
    7aac:	78db      	ldrb	r3, [r3, #3]
    7aae:	b2db      	uxtb	r3, r3
    7ab0:	001c      	movs	r4, r3
    7ab2:	4b1e      	ldr	r3, [pc, #120]	; (7b2c <main+0x400>)
    7ab4:	791b      	ldrb	r3, [r3, #4]
    7ab6:	b2db      	uxtb	r3, r3
    7ab8:	491d      	ldr	r1, [pc, #116]	; (7b30 <main+0x404>)
    7aba:	204c      	movs	r0, #76	; 0x4c
    7abc:	1838      	adds	r0, r7, r0
    7abe:	9302      	str	r3, [sp, #8]
    7ac0:	9401      	str	r4, [sp, #4]
    7ac2:	9200      	str	r2, [sp, #0]
    7ac4:	0033      	movs	r3, r6
    7ac6:	002a      	movs	r2, r5
    7ac8:	f000 f8fa 	bl	7cc0 <siprintf>
			//u8g2_DrawRFrame(&u8g2, 200, 4, 40 ,40, 5);
			//u8g2_DrawStr(&u8g2, 3, 34, (char *)debug_str);
			//u8g2_DrawStr(&u8g2, 3, 44, (char *)DATA);
			
			//u8g2_SendBuffer(&u8g2);
			rx_ready = 0;
    7acc:	4b16      	ldr	r3, [pc, #88]	; (7b28 <main+0x3fc>)
    7ace:	2200      	movs	r2, #0
    7ad0:	701a      	strb	r2, [r3, #0]
		WDT->CLEAR.bit.CLEAR = 0xA5;
    7ad2:	e6ea      	b.n	78aa <main+0x17e>
    7ad4:	00008c2c 	.word	0x00008c2c
    7ad8:	00008c44 	.word	0x00008c44
    7adc:	00008c48 	.word	0x00008c48
    7ae0:	00008c64 	.word	0x00008c64
    7ae4:	00008c78 	.word	0x00008c78
    7ae8:	00008c7c 	.word	0x00008c7c
    7aec:	00008c80 	.word	0x00008c80
    7af0:	00006fc5 	.word	0x00006fc5
    7af4:	00007019 	.word	0x00007019
    7af8:	00008994 	.word	0x00008994
    7afc:	2000089c 	.word	0x2000089c
    7b00:	00008500 	.word	0x00008500
    7b04:	40000c00 	.word	0x40000c00
    7b08:	00004301 	.word	0x00004301
    7b0c:	40001000 	.word	0x40001000
    7b10:	00008bd4 	.word	0x00008bd4
    7b14:	20000930 	.word	0x20000930
    7b18:	20000898 	.word	0x20000898
    7b1c:	20000932 	.word	0x20000932
    7b20:	00008bec 	.word	0x00008bec
    7b24:	20000844 	.word	0x20000844
    7b28:	20000883 	.word	0x20000883
    7b2c:	2000088c 	.word	0x2000088c
    7b30:	00008c0c 	.word	0x00008c0c

00007b34 <__udivsi3>:
    7b34:	2200      	movs	r2, #0
    7b36:	0843      	lsrs	r3, r0, #1
    7b38:	428b      	cmp	r3, r1
    7b3a:	d374      	bcc.n	7c26 <__udivsi3+0xf2>
    7b3c:	0903      	lsrs	r3, r0, #4
    7b3e:	428b      	cmp	r3, r1
    7b40:	d35f      	bcc.n	7c02 <__udivsi3+0xce>
    7b42:	0a03      	lsrs	r3, r0, #8
    7b44:	428b      	cmp	r3, r1
    7b46:	d344      	bcc.n	7bd2 <__udivsi3+0x9e>
    7b48:	0b03      	lsrs	r3, r0, #12
    7b4a:	428b      	cmp	r3, r1
    7b4c:	d328      	bcc.n	7ba0 <__udivsi3+0x6c>
    7b4e:	0c03      	lsrs	r3, r0, #16
    7b50:	428b      	cmp	r3, r1
    7b52:	d30d      	bcc.n	7b70 <__udivsi3+0x3c>
    7b54:	22ff      	movs	r2, #255	; 0xff
    7b56:	0209      	lsls	r1, r1, #8
    7b58:	ba12      	rev	r2, r2
    7b5a:	0c03      	lsrs	r3, r0, #16
    7b5c:	428b      	cmp	r3, r1
    7b5e:	d302      	bcc.n	7b66 <__udivsi3+0x32>
    7b60:	1212      	asrs	r2, r2, #8
    7b62:	0209      	lsls	r1, r1, #8
    7b64:	d065      	beq.n	7c32 <__udivsi3+0xfe>
    7b66:	0b03      	lsrs	r3, r0, #12
    7b68:	428b      	cmp	r3, r1
    7b6a:	d319      	bcc.n	7ba0 <__udivsi3+0x6c>
    7b6c:	e000      	b.n	7b70 <__udivsi3+0x3c>
    7b6e:	0a09      	lsrs	r1, r1, #8
    7b70:	0bc3      	lsrs	r3, r0, #15
    7b72:	428b      	cmp	r3, r1
    7b74:	d301      	bcc.n	7b7a <__udivsi3+0x46>
    7b76:	03cb      	lsls	r3, r1, #15
    7b78:	1ac0      	subs	r0, r0, r3
    7b7a:	4152      	adcs	r2, r2
    7b7c:	0b83      	lsrs	r3, r0, #14
    7b7e:	428b      	cmp	r3, r1
    7b80:	d301      	bcc.n	7b86 <__udivsi3+0x52>
    7b82:	038b      	lsls	r3, r1, #14
    7b84:	1ac0      	subs	r0, r0, r3
    7b86:	4152      	adcs	r2, r2
    7b88:	0b43      	lsrs	r3, r0, #13
    7b8a:	428b      	cmp	r3, r1
    7b8c:	d301      	bcc.n	7b92 <__udivsi3+0x5e>
    7b8e:	034b      	lsls	r3, r1, #13
    7b90:	1ac0      	subs	r0, r0, r3
    7b92:	4152      	adcs	r2, r2
    7b94:	0b03      	lsrs	r3, r0, #12
    7b96:	428b      	cmp	r3, r1
    7b98:	d301      	bcc.n	7b9e <__udivsi3+0x6a>
    7b9a:	030b      	lsls	r3, r1, #12
    7b9c:	1ac0      	subs	r0, r0, r3
    7b9e:	4152      	adcs	r2, r2
    7ba0:	0ac3      	lsrs	r3, r0, #11
    7ba2:	428b      	cmp	r3, r1
    7ba4:	d301      	bcc.n	7baa <__udivsi3+0x76>
    7ba6:	02cb      	lsls	r3, r1, #11
    7ba8:	1ac0      	subs	r0, r0, r3
    7baa:	4152      	adcs	r2, r2
    7bac:	0a83      	lsrs	r3, r0, #10
    7bae:	428b      	cmp	r3, r1
    7bb0:	d301      	bcc.n	7bb6 <__udivsi3+0x82>
    7bb2:	028b      	lsls	r3, r1, #10
    7bb4:	1ac0      	subs	r0, r0, r3
    7bb6:	4152      	adcs	r2, r2
    7bb8:	0a43      	lsrs	r3, r0, #9
    7bba:	428b      	cmp	r3, r1
    7bbc:	d301      	bcc.n	7bc2 <__udivsi3+0x8e>
    7bbe:	024b      	lsls	r3, r1, #9
    7bc0:	1ac0      	subs	r0, r0, r3
    7bc2:	4152      	adcs	r2, r2
    7bc4:	0a03      	lsrs	r3, r0, #8
    7bc6:	428b      	cmp	r3, r1
    7bc8:	d301      	bcc.n	7bce <__udivsi3+0x9a>
    7bca:	020b      	lsls	r3, r1, #8
    7bcc:	1ac0      	subs	r0, r0, r3
    7bce:	4152      	adcs	r2, r2
    7bd0:	d2cd      	bcs.n	7b6e <__udivsi3+0x3a>
    7bd2:	09c3      	lsrs	r3, r0, #7
    7bd4:	428b      	cmp	r3, r1
    7bd6:	d301      	bcc.n	7bdc <__udivsi3+0xa8>
    7bd8:	01cb      	lsls	r3, r1, #7
    7bda:	1ac0      	subs	r0, r0, r3
    7bdc:	4152      	adcs	r2, r2
    7bde:	0983      	lsrs	r3, r0, #6
    7be0:	428b      	cmp	r3, r1
    7be2:	d301      	bcc.n	7be8 <__udivsi3+0xb4>
    7be4:	018b      	lsls	r3, r1, #6
    7be6:	1ac0      	subs	r0, r0, r3
    7be8:	4152      	adcs	r2, r2
    7bea:	0943      	lsrs	r3, r0, #5
    7bec:	428b      	cmp	r3, r1
    7bee:	d301      	bcc.n	7bf4 <__udivsi3+0xc0>
    7bf0:	014b      	lsls	r3, r1, #5
    7bf2:	1ac0      	subs	r0, r0, r3
    7bf4:	4152      	adcs	r2, r2
    7bf6:	0903      	lsrs	r3, r0, #4
    7bf8:	428b      	cmp	r3, r1
    7bfa:	d301      	bcc.n	7c00 <__udivsi3+0xcc>
    7bfc:	010b      	lsls	r3, r1, #4
    7bfe:	1ac0      	subs	r0, r0, r3
    7c00:	4152      	adcs	r2, r2
    7c02:	08c3      	lsrs	r3, r0, #3
    7c04:	428b      	cmp	r3, r1
    7c06:	d301      	bcc.n	7c0c <__udivsi3+0xd8>
    7c08:	00cb      	lsls	r3, r1, #3
    7c0a:	1ac0      	subs	r0, r0, r3
    7c0c:	4152      	adcs	r2, r2
    7c0e:	0883      	lsrs	r3, r0, #2
    7c10:	428b      	cmp	r3, r1
    7c12:	d301      	bcc.n	7c18 <__udivsi3+0xe4>
    7c14:	008b      	lsls	r3, r1, #2
    7c16:	1ac0      	subs	r0, r0, r3
    7c18:	4152      	adcs	r2, r2
    7c1a:	0843      	lsrs	r3, r0, #1
    7c1c:	428b      	cmp	r3, r1
    7c1e:	d301      	bcc.n	7c24 <__udivsi3+0xf0>
    7c20:	004b      	lsls	r3, r1, #1
    7c22:	1ac0      	subs	r0, r0, r3
    7c24:	4152      	adcs	r2, r2
    7c26:	1a41      	subs	r1, r0, r1
    7c28:	d200      	bcs.n	7c2c <__udivsi3+0xf8>
    7c2a:	4601      	mov	r1, r0
    7c2c:	4152      	adcs	r2, r2
    7c2e:	4610      	mov	r0, r2
    7c30:	4770      	bx	lr
    7c32:	e7ff      	b.n	7c34 <__udivsi3+0x100>
    7c34:	b501      	push	{r0, lr}
    7c36:	2000      	movs	r0, #0
    7c38:	f000 f806 	bl	7c48 <__aeabi_idiv0>
    7c3c:	bd02      	pop	{r1, pc}
    7c3e:	46c0      	nop			; (mov r8, r8)

00007c40 <__aeabi_uidivmod>:
    7c40:	2900      	cmp	r1, #0
    7c42:	d0f7      	beq.n	7c34 <__udivsi3+0x100>
    7c44:	e776      	b.n	7b34 <__udivsi3>
    7c46:	4770      	bx	lr

00007c48 <__aeabi_idiv0>:
    7c48:	4770      	bx	lr
    7c4a:	46c0      	nop			; (mov r8, r8)

00007c4c <ffs>:
    7c4c:	2300      	movs	r3, #0
    7c4e:	b510      	push	{r4, lr}
    7c50:	4298      	cmp	r0, r3
    7c52:	d007      	beq.n	7c64 <ffs+0x18>
    7c54:	001a      	movs	r2, r3
    7c56:	2101      	movs	r1, #1
    7c58:	0004      	movs	r4, r0
    7c5a:	4114      	asrs	r4, r2
    7c5c:	1c53      	adds	r3, r2, #1
    7c5e:	001a      	movs	r2, r3
    7c60:	420c      	tst	r4, r1
    7c62:	d0f9      	beq.n	7c58 <ffs+0xc>
    7c64:	0018      	movs	r0, r3
    7c66:	bd10      	pop	{r4, pc}

00007c68 <__libc_init_array>:
    7c68:	b570      	push	{r4, r5, r6, lr}
    7c6a:	2600      	movs	r6, #0
    7c6c:	4d0c      	ldr	r5, [pc, #48]	; (7ca0 <__libc_init_array+0x38>)
    7c6e:	4c0d      	ldr	r4, [pc, #52]	; (7ca4 <__libc_init_array+0x3c>)
    7c70:	1b64      	subs	r4, r4, r5
    7c72:	10a4      	asrs	r4, r4, #2
    7c74:	42a6      	cmp	r6, r4
    7c76:	d109      	bne.n	7c8c <__libc_init_array+0x24>
    7c78:	2600      	movs	r6, #0
    7c7a:	f001 f84d 	bl	8d18 <_init>
    7c7e:	4d0a      	ldr	r5, [pc, #40]	; (7ca8 <__libc_init_array+0x40>)
    7c80:	4c0a      	ldr	r4, [pc, #40]	; (7cac <__libc_init_array+0x44>)
    7c82:	1b64      	subs	r4, r4, r5
    7c84:	10a4      	asrs	r4, r4, #2
    7c86:	42a6      	cmp	r6, r4
    7c88:	d105      	bne.n	7c96 <__libc_init_array+0x2e>
    7c8a:	bd70      	pop	{r4, r5, r6, pc}
    7c8c:	00b3      	lsls	r3, r6, #2
    7c8e:	58eb      	ldr	r3, [r5, r3]
    7c90:	4798      	blx	r3
    7c92:	3601      	adds	r6, #1
    7c94:	e7ee      	b.n	7c74 <__libc_init_array+0xc>
    7c96:	00b3      	lsls	r3, r6, #2
    7c98:	58eb      	ldr	r3, [r5, r3]
    7c9a:	4798      	blx	r3
    7c9c:	3601      	adds	r6, #1
    7c9e:	e7f2      	b.n	7c86 <__libc_init_array+0x1e>
    7ca0:	00008d24 	.word	0x00008d24
    7ca4:	00008d24 	.word	0x00008d24
    7ca8:	00008d24 	.word	0x00008d24
    7cac:	00008d28 	.word	0x00008d28

00007cb0 <memset>:
    7cb0:	0003      	movs	r3, r0
    7cb2:	1882      	adds	r2, r0, r2
    7cb4:	4293      	cmp	r3, r2
    7cb6:	d100      	bne.n	7cba <memset+0xa>
    7cb8:	4770      	bx	lr
    7cba:	7019      	strb	r1, [r3, #0]
    7cbc:	3301      	adds	r3, #1
    7cbe:	e7f9      	b.n	7cb4 <memset+0x4>

00007cc0 <siprintf>:
    7cc0:	b40e      	push	{r1, r2, r3}
    7cc2:	b510      	push	{r4, lr}
    7cc4:	b09d      	sub	sp, #116	; 0x74
    7cc6:	a902      	add	r1, sp, #8
    7cc8:	9002      	str	r0, [sp, #8]
    7cca:	6108      	str	r0, [r1, #16]
    7ccc:	480b      	ldr	r0, [pc, #44]	; (7cfc <siprintf+0x3c>)
    7cce:	2482      	movs	r4, #130	; 0x82
    7cd0:	6088      	str	r0, [r1, #8]
    7cd2:	6148      	str	r0, [r1, #20]
    7cd4:	2001      	movs	r0, #1
    7cd6:	4240      	negs	r0, r0
    7cd8:	ab1f      	add	r3, sp, #124	; 0x7c
    7cda:	81c8      	strh	r0, [r1, #14]
    7cdc:	4808      	ldr	r0, [pc, #32]	; (7d00 <siprintf+0x40>)
    7cde:	cb04      	ldmia	r3!, {r2}
    7ce0:	00a4      	lsls	r4, r4, #2
    7ce2:	6800      	ldr	r0, [r0, #0]
    7ce4:	9301      	str	r3, [sp, #4]
    7ce6:	818c      	strh	r4, [r1, #12]
    7ce8:	f000 f8cc 	bl	7e84 <_svfiprintf_r>
    7cec:	2300      	movs	r3, #0
    7cee:	9a02      	ldr	r2, [sp, #8]
    7cf0:	7013      	strb	r3, [r2, #0]
    7cf2:	b01d      	add	sp, #116	; 0x74
    7cf4:	bc10      	pop	{r4}
    7cf6:	bc08      	pop	{r3}
    7cf8:	b003      	add	sp, #12
    7cfa:	4718      	bx	r3
    7cfc:	7fffffff 	.word	0x7fffffff
    7d00:	2000002c 	.word	0x2000002c

00007d04 <_malloc_r>:
    7d04:	2303      	movs	r3, #3
    7d06:	b570      	push	{r4, r5, r6, lr}
    7d08:	1ccd      	adds	r5, r1, #3
    7d0a:	439d      	bics	r5, r3
    7d0c:	3508      	adds	r5, #8
    7d0e:	0006      	movs	r6, r0
    7d10:	2d0c      	cmp	r5, #12
    7d12:	d21e      	bcs.n	7d52 <_malloc_r+0x4e>
    7d14:	250c      	movs	r5, #12
    7d16:	42a9      	cmp	r1, r5
    7d18:	d81d      	bhi.n	7d56 <_malloc_r+0x52>
    7d1a:	0030      	movs	r0, r6
    7d1c:	f000 fb76 	bl	840c <__malloc_lock>
    7d20:	4a25      	ldr	r2, [pc, #148]	; (7db8 <_malloc_r+0xb4>)
    7d22:	6814      	ldr	r4, [r2, #0]
    7d24:	0021      	movs	r1, r4
    7d26:	2900      	cmp	r1, #0
    7d28:	d119      	bne.n	7d5e <_malloc_r+0x5a>
    7d2a:	4c24      	ldr	r4, [pc, #144]	; (7dbc <_malloc_r+0xb8>)
    7d2c:	6823      	ldr	r3, [r4, #0]
    7d2e:	2b00      	cmp	r3, #0
    7d30:	d103      	bne.n	7d3a <_malloc_r+0x36>
    7d32:	0030      	movs	r0, r6
    7d34:	f000 fb32 	bl	839c <_sbrk_r>
    7d38:	6020      	str	r0, [r4, #0]
    7d3a:	0029      	movs	r1, r5
    7d3c:	0030      	movs	r0, r6
    7d3e:	f000 fb2d 	bl	839c <_sbrk_r>
    7d42:	1c43      	adds	r3, r0, #1
    7d44:	d12c      	bne.n	7da0 <_malloc_r+0x9c>
    7d46:	230c      	movs	r3, #12
    7d48:	0030      	movs	r0, r6
    7d4a:	6033      	str	r3, [r6, #0]
    7d4c:	f000 fb5f 	bl	840e <__malloc_unlock>
    7d50:	e003      	b.n	7d5a <_malloc_r+0x56>
    7d52:	2d00      	cmp	r5, #0
    7d54:	dadf      	bge.n	7d16 <_malloc_r+0x12>
    7d56:	230c      	movs	r3, #12
    7d58:	6033      	str	r3, [r6, #0]
    7d5a:	2000      	movs	r0, #0
    7d5c:	bd70      	pop	{r4, r5, r6, pc}
    7d5e:	680b      	ldr	r3, [r1, #0]
    7d60:	1b5b      	subs	r3, r3, r5
    7d62:	d41a      	bmi.n	7d9a <_malloc_r+0x96>
    7d64:	2b0b      	cmp	r3, #11
    7d66:	d903      	bls.n	7d70 <_malloc_r+0x6c>
    7d68:	600b      	str	r3, [r1, #0]
    7d6a:	18cc      	adds	r4, r1, r3
    7d6c:	6025      	str	r5, [r4, #0]
    7d6e:	e003      	b.n	7d78 <_malloc_r+0x74>
    7d70:	428c      	cmp	r4, r1
    7d72:	d10e      	bne.n	7d92 <_malloc_r+0x8e>
    7d74:	6863      	ldr	r3, [r4, #4]
    7d76:	6013      	str	r3, [r2, #0]
    7d78:	0030      	movs	r0, r6
    7d7a:	f000 fb48 	bl	840e <__malloc_unlock>
    7d7e:	0020      	movs	r0, r4
    7d80:	2207      	movs	r2, #7
    7d82:	300b      	adds	r0, #11
    7d84:	1d23      	adds	r3, r4, #4
    7d86:	4390      	bics	r0, r2
    7d88:	1ac3      	subs	r3, r0, r3
    7d8a:	d0e7      	beq.n	7d5c <_malloc_r+0x58>
    7d8c:	425a      	negs	r2, r3
    7d8e:	50e2      	str	r2, [r4, r3]
    7d90:	e7e4      	b.n	7d5c <_malloc_r+0x58>
    7d92:	684b      	ldr	r3, [r1, #4]
    7d94:	6063      	str	r3, [r4, #4]
    7d96:	000c      	movs	r4, r1
    7d98:	e7ee      	b.n	7d78 <_malloc_r+0x74>
    7d9a:	000c      	movs	r4, r1
    7d9c:	6849      	ldr	r1, [r1, #4]
    7d9e:	e7c2      	b.n	7d26 <_malloc_r+0x22>
    7da0:	2303      	movs	r3, #3
    7da2:	1cc4      	adds	r4, r0, #3
    7da4:	439c      	bics	r4, r3
    7da6:	42a0      	cmp	r0, r4
    7da8:	d0e0      	beq.n	7d6c <_malloc_r+0x68>
    7daa:	1a21      	subs	r1, r4, r0
    7dac:	0030      	movs	r0, r6
    7dae:	f000 faf5 	bl	839c <_sbrk_r>
    7db2:	1c43      	adds	r3, r0, #1
    7db4:	d1da      	bne.n	7d6c <_malloc_r+0x68>
    7db6:	e7c6      	b.n	7d46 <_malloc_r+0x42>
    7db8:	200007d4 	.word	0x200007d4
    7dbc:	200007d8 	.word	0x200007d8

00007dc0 <__ssputs_r>:
    7dc0:	b5f0      	push	{r4, r5, r6, r7, lr}
    7dc2:	688e      	ldr	r6, [r1, #8]
    7dc4:	b085      	sub	sp, #20
    7dc6:	0007      	movs	r7, r0
    7dc8:	000c      	movs	r4, r1
    7dca:	9203      	str	r2, [sp, #12]
    7dcc:	9301      	str	r3, [sp, #4]
    7dce:	429e      	cmp	r6, r3
    7dd0:	d839      	bhi.n	7e46 <__ssputs_r+0x86>
    7dd2:	2390      	movs	r3, #144	; 0x90
    7dd4:	898a      	ldrh	r2, [r1, #12]
    7dd6:	00db      	lsls	r3, r3, #3
    7dd8:	421a      	tst	r2, r3
    7dda:	d034      	beq.n	7e46 <__ssputs_r+0x86>
    7ddc:	2503      	movs	r5, #3
    7dde:	6909      	ldr	r1, [r1, #16]
    7de0:	6823      	ldr	r3, [r4, #0]
    7de2:	1a5b      	subs	r3, r3, r1
    7de4:	9302      	str	r3, [sp, #8]
    7de6:	6963      	ldr	r3, [r4, #20]
    7de8:	9802      	ldr	r0, [sp, #8]
    7dea:	435d      	muls	r5, r3
    7dec:	0feb      	lsrs	r3, r5, #31
    7dee:	195d      	adds	r5, r3, r5
    7df0:	9b01      	ldr	r3, [sp, #4]
    7df2:	106d      	asrs	r5, r5, #1
    7df4:	3301      	adds	r3, #1
    7df6:	181b      	adds	r3, r3, r0
    7df8:	42ab      	cmp	r3, r5
    7dfa:	d900      	bls.n	7dfe <__ssputs_r+0x3e>
    7dfc:	001d      	movs	r5, r3
    7dfe:	0553      	lsls	r3, r2, #21
    7e00:	d532      	bpl.n	7e68 <__ssputs_r+0xa8>
    7e02:	0029      	movs	r1, r5
    7e04:	0038      	movs	r0, r7
    7e06:	f7ff ff7d 	bl	7d04 <_malloc_r>
    7e0a:	1e06      	subs	r6, r0, #0
    7e0c:	d109      	bne.n	7e22 <__ssputs_r+0x62>
    7e0e:	230c      	movs	r3, #12
    7e10:	603b      	str	r3, [r7, #0]
    7e12:	2340      	movs	r3, #64	; 0x40
    7e14:	2001      	movs	r0, #1
    7e16:	89a2      	ldrh	r2, [r4, #12]
    7e18:	4240      	negs	r0, r0
    7e1a:	4313      	orrs	r3, r2
    7e1c:	81a3      	strh	r3, [r4, #12]
    7e1e:	b005      	add	sp, #20
    7e20:	bdf0      	pop	{r4, r5, r6, r7, pc}
    7e22:	9a02      	ldr	r2, [sp, #8]
    7e24:	6921      	ldr	r1, [r4, #16]
    7e26:	f000 fad6 	bl	83d6 <memcpy>
    7e2a:	89a3      	ldrh	r3, [r4, #12]
    7e2c:	4a14      	ldr	r2, [pc, #80]	; (7e80 <__ssputs_r+0xc0>)
    7e2e:	401a      	ands	r2, r3
    7e30:	2380      	movs	r3, #128	; 0x80
    7e32:	4313      	orrs	r3, r2
    7e34:	81a3      	strh	r3, [r4, #12]
    7e36:	9b02      	ldr	r3, [sp, #8]
    7e38:	6126      	str	r6, [r4, #16]
    7e3a:	18f6      	adds	r6, r6, r3
    7e3c:	6026      	str	r6, [r4, #0]
    7e3e:	6165      	str	r5, [r4, #20]
    7e40:	9e01      	ldr	r6, [sp, #4]
    7e42:	1aed      	subs	r5, r5, r3
    7e44:	60a5      	str	r5, [r4, #8]
    7e46:	9b01      	ldr	r3, [sp, #4]
    7e48:	42b3      	cmp	r3, r6
    7e4a:	d200      	bcs.n	7e4e <__ssputs_r+0x8e>
    7e4c:	001e      	movs	r6, r3
    7e4e:	0032      	movs	r2, r6
    7e50:	9903      	ldr	r1, [sp, #12]
    7e52:	6820      	ldr	r0, [r4, #0]
    7e54:	f000 fac8 	bl	83e8 <memmove>
    7e58:	68a3      	ldr	r3, [r4, #8]
    7e5a:	2000      	movs	r0, #0
    7e5c:	1b9b      	subs	r3, r3, r6
    7e5e:	60a3      	str	r3, [r4, #8]
    7e60:	6823      	ldr	r3, [r4, #0]
    7e62:	199e      	adds	r6, r3, r6
    7e64:	6026      	str	r6, [r4, #0]
    7e66:	e7da      	b.n	7e1e <__ssputs_r+0x5e>
    7e68:	002a      	movs	r2, r5
    7e6a:	0038      	movs	r0, r7
    7e6c:	f000 fb1a 	bl	84a4 <_realloc_r>
    7e70:	1e06      	subs	r6, r0, #0
    7e72:	d1e0      	bne.n	7e36 <__ssputs_r+0x76>
    7e74:	6921      	ldr	r1, [r4, #16]
    7e76:	0038      	movs	r0, r7
    7e78:	f000 faca 	bl	8410 <_free_r>
    7e7c:	e7c7      	b.n	7e0e <__ssputs_r+0x4e>
    7e7e:	46c0      	nop			; (mov r8, r8)
    7e80:	fffffb7f 	.word	0xfffffb7f

00007e84 <_svfiprintf_r>:
    7e84:	b5f0      	push	{r4, r5, r6, r7, lr}
    7e86:	b09f      	sub	sp, #124	; 0x7c
    7e88:	9002      	str	r0, [sp, #8]
    7e8a:	9305      	str	r3, [sp, #20]
    7e8c:	898b      	ldrh	r3, [r1, #12]
    7e8e:	000f      	movs	r7, r1
    7e90:	0016      	movs	r6, r2
    7e92:	061b      	lsls	r3, r3, #24
    7e94:	d511      	bpl.n	7eba <_svfiprintf_r+0x36>
    7e96:	690b      	ldr	r3, [r1, #16]
    7e98:	2b00      	cmp	r3, #0
    7e9a:	d10e      	bne.n	7eba <_svfiprintf_r+0x36>
    7e9c:	2140      	movs	r1, #64	; 0x40
    7e9e:	f7ff ff31 	bl	7d04 <_malloc_r>
    7ea2:	6038      	str	r0, [r7, #0]
    7ea4:	6138      	str	r0, [r7, #16]
    7ea6:	2800      	cmp	r0, #0
    7ea8:	d105      	bne.n	7eb6 <_svfiprintf_r+0x32>
    7eaa:	230c      	movs	r3, #12
    7eac:	9a02      	ldr	r2, [sp, #8]
    7eae:	3801      	subs	r0, #1
    7eb0:	6013      	str	r3, [r2, #0]
    7eb2:	b01f      	add	sp, #124	; 0x7c
    7eb4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    7eb6:	2340      	movs	r3, #64	; 0x40
    7eb8:	617b      	str	r3, [r7, #20]
    7eba:	2300      	movs	r3, #0
    7ebc:	ad06      	add	r5, sp, #24
    7ebe:	616b      	str	r3, [r5, #20]
    7ec0:	3320      	adds	r3, #32
    7ec2:	766b      	strb	r3, [r5, #25]
    7ec4:	3310      	adds	r3, #16
    7ec6:	76ab      	strb	r3, [r5, #26]
    7ec8:	0034      	movs	r4, r6
    7eca:	7823      	ldrb	r3, [r4, #0]
    7ecc:	2b00      	cmp	r3, #0
    7ece:	d147      	bne.n	7f60 <_svfiprintf_r+0xdc>
    7ed0:	1ba3      	subs	r3, r4, r6
    7ed2:	9304      	str	r3, [sp, #16]
    7ed4:	d00d      	beq.n	7ef2 <_svfiprintf_r+0x6e>
    7ed6:	1ba3      	subs	r3, r4, r6
    7ed8:	0032      	movs	r2, r6
    7eda:	0039      	movs	r1, r7
    7edc:	9802      	ldr	r0, [sp, #8]
    7ede:	f7ff ff6f 	bl	7dc0 <__ssputs_r>
    7ee2:	1c43      	adds	r3, r0, #1
    7ee4:	d100      	bne.n	7ee8 <_svfiprintf_r+0x64>
    7ee6:	e0b5      	b.n	8054 <_svfiprintf_r+0x1d0>
    7ee8:	696a      	ldr	r2, [r5, #20]
    7eea:	9b04      	ldr	r3, [sp, #16]
    7eec:	4694      	mov	ip, r2
    7eee:	4463      	add	r3, ip
    7ef0:	616b      	str	r3, [r5, #20]
    7ef2:	7823      	ldrb	r3, [r4, #0]
    7ef4:	2b00      	cmp	r3, #0
    7ef6:	d100      	bne.n	7efa <_svfiprintf_r+0x76>
    7ef8:	e0ac      	b.n	8054 <_svfiprintf_r+0x1d0>
    7efa:	2201      	movs	r2, #1
    7efc:	2300      	movs	r3, #0
    7efe:	4252      	negs	r2, r2
    7f00:	606a      	str	r2, [r5, #4]
    7f02:	a902      	add	r1, sp, #8
    7f04:	3254      	adds	r2, #84	; 0x54
    7f06:	1852      	adds	r2, r2, r1
    7f08:	3401      	adds	r4, #1
    7f0a:	602b      	str	r3, [r5, #0]
    7f0c:	60eb      	str	r3, [r5, #12]
    7f0e:	60ab      	str	r3, [r5, #8]
    7f10:	7013      	strb	r3, [r2, #0]
    7f12:	65ab      	str	r3, [r5, #88]	; 0x58
    7f14:	4e58      	ldr	r6, [pc, #352]	; (8078 <_svfiprintf_r+0x1f4>)
    7f16:	2205      	movs	r2, #5
    7f18:	7821      	ldrb	r1, [r4, #0]
    7f1a:	0030      	movs	r0, r6
    7f1c:	f000 fa50 	bl	83c0 <memchr>
    7f20:	1c62      	adds	r2, r4, #1
    7f22:	2800      	cmp	r0, #0
    7f24:	d120      	bne.n	7f68 <_svfiprintf_r+0xe4>
    7f26:	6829      	ldr	r1, [r5, #0]
    7f28:	06cb      	lsls	r3, r1, #27
    7f2a:	d504      	bpl.n	7f36 <_svfiprintf_r+0xb2>
    7f2c:	2353      	movs	r3, #83	; 0x53
    7f2e:	ae02      	add	r6, sp, #8
    7f30:	3020      	adds	r0, #32
    7f32:	199b      	adds	r3, r3, r6
    7f34:	7018      	strb	r0, [r3, #0]
    7f36:	070b      	lsls	r3, r1, #28
    7f38:	d504      	bpl.n	7f44 <_svfiprintf_r+0xc0>
    7f3a:	2353      	movs	r3, #83	; 0x53
    7f3c:	202b      	movs	r0, #43	; 0x2b
    7f3e:	ae02      	add	r6, sp, #8
    7f40:	199b      	adds	r3, r3, r6
    7f42:	7018      	strb	r0, [r3, #0]
    7f44:	7823      	ldrb	r3, [r4, #0]
    7f46:	2b2a      	cmp	r3, #42	; 0x2a
    7f48:	d016      	beq.n	7f78 <_svfiprintf_r+0xf4>
    7f4a:	2000      	movs	r0, #0
    7f4c:	210a      	movs	r1, #10
    7f4e:	9b09      	ldr	r3, [sp, #36]	; 0x24
    7f50:	7822      	ldrb	r2, [r4, #0]
    7f52:	3a30      	subs	r2, #48	; 0x30
    7f54:	2a09      	cmp	r2, #9
    7f56:	d955      	bls.n	8004 <_svfiprintf_r+0x180>
    7f58:	2800      	cmp	r0, #0
    7f5a:	d015      	beq.n	7f88 <_svfiprintf_r+0x104>
    7f5c:	9309      	str	r3, [sp, #36]	; 0x24
    7f5e:	e013      	b.n	7f88 <_svfiprintf_r+0x104>
    7f60:	2b25      	cmp	r3, #37	; 0x25
    7f62:	d0b5      	beq.n	7ed0 <_svfiprintf_r+0x4c>
    7f64:	3401      	adds	r4, #1
    7f66:	e7b0      	b.n	7eca <_svfiprintf_r+0x46>
    7f68:	2301      	movs	r3, #1
    7f6a:	1b80      	subs	r0, r0, r6
    7f6c:	4083      	lsls	r3, r0
    7f6e:	6829      	ldr	r1, [r5, #0]
    7f70:	0014      	movs	r4, r2
    7f72:	430b      	orrs	r3, r1
    7f74:	602b      	str	r3, [r5, #0]
    7f76:	e7cd      	b.n	7f14 <_svfiprintf_r+0x90>
    7f78:	9b05      	ldr	r3, [sp, #20]
    7f7a:	1d18      	adds	r0, r3, #4
    7f7c:	681b      	ldr	r3, [r3, #0]
    7f7e:	9005      	str	r0, [sp, #20]
    7f80:	2b00      	cmp	r3, #0
    7f82:	db39      	blt.n	7ff8 <_svfiprintf_r+0x174>
    7f84:	9309      	str	r3, [sp, #36]	; 0x24
    7f86:	0014      	movs	r4, r2
    7f88:	7823      	ldrb	r3, [r4, #0]
    7f8a:	2b2e      	cmp	r3, #46	; 0x2e
    7f8c:	d10b      	bne.n	7fa6 <_svfiprintf_r+0x122>
    7f8e:	7863      	ldrb	r3, [r4, #1]
    7f90:	1c62      	adds	r2, r4, #1
    7f92:	2b2a      	cmp	r3, #42	; 0x2a
    7f94:	d13e      	bne.n	8014 <_svfiprintf_r+0x190>
    7f96:	9b05      	ldr	r3, [sp, #20]
    7f98:	3402      	adds	r4, #2
    7f9a:	1d1a      	adds	r2, r3, #4
    7f9c:	681b      	ldr	r3, [r3, #0]
    7f9e:	9205      	str	r2, [sp, #20]
    7fa0:	2b00      	cmp	r3, #0
    7fa2:	db34      	blt.n	800e <_svfiprintf_r+0x18a>
    7fa4:	9307      	str	r3, [sp, #28]
    7fa6:	4e35      	ldr	r6, [pc, #212]	; (807c <_svfiprintf_r+0x1f8>)
    7fa8:	7821      	ldrb	r1, [r4, #0]
    7faa:	2203      	movs	r2, #3
    7fac:	0030      	movs	r0, r6
    7fae:	f000 fa07 	bl	83c0 <memchr>
    7fb2:	2800      	cmp	r0, #0
    7fb4:	d006      	beq.n	7fc4 <_svfiprintf_r+0x140>
    7fb6:	2340      	movs	r3, #64	; 0x40
    7fb8:	1b80      	subs	r0, r0, r6
    7fba:	4083      	lsls	r3, r0
    7fbc:	682a      	ldr	r2, [r5, #0]
    7fbe:	3401      	adds	r4, #1
    7fc0:	4313      	orrs	r3, r2
    7fc2:	602b      	str	r3, [r5, #0]
    7fc4:	7821      	ldrb	r1, [r4, #0]
    7fc6:	2206      	movs	r2, #6
    7fc8:	482d      	ldr	r0, [pc, #180]	; (8080 <_svfiprintf_r+0x1fc>)
    7fca:	1c66      	adds	r6, r4, #1
    7fcc:	7629      	strb	r1, [r5, #24]
    7fce:	f000 f9f7 	bl	83c0 <memchr>
    7fd2:	2800      	cmp	r0, #0
    7fd4:	d046      	beq.n	8064 <_svfiprintf_r+0x1e0>
    7fd6:	4b2b      	ldr	r3, [pc, #172]	; (8084 <_svfiprintf_r+0x200>)
    7fd8:	2b00      	cmp	r3, #0
    7fda:	d12f      	bne.n	803c <_svfiprintf_r+0x1b8>
    7fdc:	6829      	ldr	r1, [r5, #0]
    7fde:	9b05      	ldr	r3, [sp, #20]
    7fe0:	2207      	movs	r2, #7
    7fe2:	05c9      	lsls	r1, r1, #23
    7fe4:	d528      	bpl.n	8038 <_svfiprintf_r+0x1b4>
    7fe6:	189b      	adds	r3, r3, r2
    7fe8:	4393      	bics	r3, r2
    7fea:	3308      	adds	r3, #8
    7fec:	9305      	str	r3, [sp, #20]
    7fee:	696b      	ldr	r3, [r5, #20]
    7ff0:	9a03      	ldr	r2, [sp, #12]
    7ff2:	189b      	adds	r3, r3, r2
    7ff4:	616b      	str	r3, [r5, #20]
    7ff6:	e767      	b.n	7ec8 <_svfiprintf_r+0x44>
    7ff8:	425b      	negs	r3, r3
    7ffa:	60eb      	str	r3, [r5, #12]
    7ffc:	2302      	movs	r3, #2
    7ffe:	430b      	orrs	r3, r1
    8000:	602b      	str	r3, [r5, #0]
    8002:	e7c0      	b.n	7f86 <_svfiprintf_r+0x102>
    8004:	434b      	muls	r3, r1
    8006:	3401      	adds	r4, #1
    8008:	189b      	adds	r3, r3, r2
    800a:	2001      	movs	r0, #1
    800c:	e7a0      	b.n	7f50 <_svfiprintf_r+0xcc>
    800e:	2301      	movs	r3, #1
    8010:	425b      	negs	r3, r3
    8012:	e7c7      	b.n	7fa4 <_svfiprintf_r+0x120>
    8014:	2300      	movs	r3, #0
    8016:	0014      	movs	r4, r2
    8018:	200a      	movs	r0, #10
    801a:	001a      	movs	r2, r3
    801c:	606b      	str	r3, [r5, #4]
    801e:	7821      	ldrb	r1, [r4, #0]
    8020:	3930      	subs	r1, #48	; 0x30
    8022:	2909      	cmp	r1, #9
    8024:	d903      	bls.n	802e <_svfiprintf_r+0x1aa>
    8026:	2b00      	cmp	r3, #0
    8028:	d0bd      	beq.n	7fa6 <_svfiprintf_r+0x122>
    802a:	9207      	str	r2, [sp, #28]
    802c:	e7bb      	b.n	7fa6 <_svfiprintf_r+0x122>
    802e:	4342      	muls	r2, r0
    8030:	3401      	adds	r4, #1
    8032:	1852      	adds	r2, r2, r1
    8034:	2301      	movs	r3, #1
    8036:	e7f2      	b.n	801e <_svfiprintf_r+0x19a>
    8038:	3307      	adds	r3, #7
    803a:	e7d5      	b.n	7fe8 <_svfiprintf_r+0x164>
    803c:	ab05      	add	r3, sp, #20
    803e:	9300      	str	r3, [sp, #0]
    8040:	003a      	movs	r2, r7
    8042:	4b11      	ldr	r3, [pc, #68]	; (8088 <_svfiprintf_r+0x204>)
    8044:	0029      	movs	r1, r5
    8046:	9802      	ldr	r0, [sp, #8]
    8048:	e000      	b.n	804c <_svfiprintf_r+0x1c8>
    804a:	bf00      	nop
    804c:	9003      	str	r0, [sp, #12]
    804e:	9b03      	ldr	r3, [sp, #12]
    8050:	3301      	adds	r3, #1
    8052:	d1cc      	bne.n	7fee <_svfiprintf_r+0x16a>
    8054:	89bb      	ldrh	r3, [r7, #12]
    8056:	980b      	ldr	r0, [sp, #44]	; 0x2c
    8058:	065b      	lsls	r3, r3, #25
    805a:	d400      	bmi.n	805e <_svfiprintf_r+0x1da>
    805c:	e729      	b.n	7eb2 <_svfiprintf_r+0x2e>
    805e:	2001      	movs	r0, #1
    8060:	4240      	negs	r0, r0
    8062:	e726      	b.n	7eb2 <_svfiprintf_r+0x2e>
    8064:	ab05      	add	r3, sp, #20
    8066:	9300      	str	r3, [sp, #0]
    8068:	003a      	movs	r2, r7
    806a:	4b07      	ldr	r3, [pc, #28]	; (8088 <_svfiprintf_r+0x204>)
    806c:	0029      	movs	r1, r5
    806e:	9802      	ldr	r0, [sp, #8]
    8070:	f000 f87a 	bl	8168 <_printf_i>
    8074:	e7ea      	b.n	804c <_svfiprintf_r+0x1c8>
    8076:	46c0      	nop			; (mov r8, r8)
    8078:	00008ce4 	.word	0x00008ce4
    807c:	00008cea 	.word	0x00008cea
    8080:	00008cee 	.word	0x00008cee
    8084:	00000000 	.word	0x00000000
    8088:	00007dc1 	.word	0x00007dc1

0000808c <_printf_common>:
    808c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    808e:	0015      	movs	r5, r2
    8090:	9301      	str	r3, [sp, #4]
    8092:	688a      	ldr	r2, [r1, #8]
    8094:	690b      	ldr	r3, [r1, #16]
    8096:	9000      	str	r0, [sp, #0]
    8098:	000c      	movs	r4, r1
    809a:	4293      	cmp	r3, r2
    809c:	da00      	bge.n	80a0 <_printf_common+0x14>
    809e:	0013      	movs	r3, r2
    80a0:	0022      	movs	r2, r4
    80a2:	602b      	str	r3, [r5, #0]
    80a4:	3243      	adds	r2, #67	; 0x43
    80a6:	7812      	ldrb	r2, [r2, #0]
    80a8:	2a00      	cmp	r2, #0
    80aa:	d001      	beq.n	80b0 <_printf_common+0x24>
    80ac:	3301      	adds	r3, #1
    80ae:	602b      	str	r3, [r5, #0]
    80b0:	6823      	ldr	r3, [r4, #0]
    80b2:	069b      	lsls	r3, r3, #26
    80b4:	d502      	bpl.n	80bc <_printf_common+0x30>
    80b6:	682b      	ldr	r3, [r5, #0]
    80b8:	3302      	adds	r3, #2
    80ba:	602b      	str	r3, [r5, #0]
    80bc:	2706      	movs	r7, #6
    80be:	6823      	ldr	r3, [r4, #0]
    80c0:	401f      	ands	r7, r3
    80c2:	d027      	beq.n	8114 <_printf_common+0x88>
    80c4:	0023      	movs	r3, r4
    80c6:	3343      	adds	r3, #67	; 0x43
    80c8:	781b      	ldrb	r3, [r3, #0]
    80ca:	1e5a      	subs	r2, r3, #1
    80cc:	4193      	sbcs	r3, r2
    80ce:	6822      	ldr	r2, [r4, #0]
    80d0:	0692      	lsls	r2, r2, #26
    80d2:	d430      	bmi.n	8136 <_printf_common+0xaa>
    80d4:	0022      	movs	r2, r4
    80d6:	9901      	ldr	r1, [sp, #4]
    80d8:	3243      	adds	r2, #67	; 0x43
    80da:	9800      	ldr	r0, [sp, #0]
    80dc:	9e08      	ldr	r6, [sp, #32]
    80de:	47b0      	blx	r6
    80e0:	1c43      	adds	r3, r0, #1
    80e2:	d025      	beq.n	8130 <_printf_common+0xa4>
    80e4:	2306      	movs	r3, #6
    80e6:	6820      	ldr	r0, [r4, #0]
    80e8:	682a      	ldr	r2, [r5, #0]
    80ea:	68e1      	ldr	r1, [r4, #12]
    80ec:	4003      	ands	r3, r0
    80ee:	2500      	movs	r5, #0
    80f0:	2b04      	cmp	r3, #4
    80f2:	d103      	bne.n	80fc <_printf_common+0x70>
    80f4:	1a8d      	subs	r5, r1, r2
    80f6:	43eb      	mvns	r3, r5
    80f8:	17db      	asrs	r3, r3, #31
    80fa:	401d      	ands	r5, r3
    80fc:	68a3      	ldr	r3, [r4, #8]
    80fe:	6922      	ldr	r2, [r4, #16]
    8100:	4293      	cmp	r3, r2
    8102:	dd01      	ble.n	8108 <_printf_common+0x7c>
    8104:	1a9b      	subs	r3, r3, r2
    8106:	18ed      	adds	r5, r5, r3
    8108:	2700      	movs	r7, #0
    810a:	42bd      	cmp	r5, r7
    810c:	d120      	bne.n	8150 <_printf_common+0xc4>
    810e:	2000      	movs	r0, #0
    8110:	e010      	b.n	8134 <_printf_common+0xa8>
    8112:	3701      	adds	r7, #1
    8114:	68e3      	ldr	r3, [r4, #12]
    8116:	682a      	ldr	r2, [r5, #0]
    8118:	1a9b      	subs	r3, r3, r2
    811a:	429f      	cmp	r7, r3
    811c:	dad2      	bge.n	80c4 <_printf_common+0x38>
    811e:	0022      	movs	r2, r4
    8120:	2301      	movs	r3, #1
    8122:	3219      	adds	r2, #25
    8124:	9901      	ldr	r1, [sp, #4]
    8126:	9800      	ldr	r0, [sp, #0]
    8128:	9e08      	ldr	r6, [sp, #32]
    812a:	47b0      	blx	r6
    812c:	1c43      	adds	r3, r0, #1
    812e:	d1f0      	bne.n	8112 <_printf_common+0x86>
    8130:	2001      	movs	r0, #1
    8132:	4240      	negs	r0, r0
    8134:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    8136:	2030      	movs	r0, #48	; 0x30
    8138:	18e1      	adds	r1, r4, r3
    813a:	3143      	adds	r1, #67	; 0x43
    813c:	7008      	strb	r0, [r1, #0]
    813e:	0021      	movs	r1, r4
    8140:	1c5a      	adds	r2, r3, #1
    8142:	3145      	adds	r1, #69	; 0x45
    8144:	7809      	ldrb	r1, [r1, #0]
    8146:	18a2      	adds	r2, r4, r2
    8148:	3243      	adds	r2, #67	; 0x43
    814a:	3302      	adds	r3, #2
    814c:	7011      	strb	r1, [r2, #0]
    814e:	e7c1      	b.n	80d4 <_printf_common+0x48>
    8150:	0022      	movs	r2, r4
    8152:	2301      	movs	r3, #1
    8154:	321a      	adds	r2, #26
    8156:	9901      	ldr	r1, [sp, #4]
    8158:	9800      	ldr	r0, [sp, #0]
    815a:	9e08      	ldr	r6, [sp, #32]
    815c:	47b0      	blx	r6
    815e:	1c43      	adds	r3, r0, #1
    8160:	d0e6      	beq.n	8130 <_printf_common+0xa4>
    8162:	3701      	adds	r7, #1
    8164:	e7d1      	b.n	810a <_printf_common+0x7e>
	...

00008168 <_printf_i>:
    8168:	b5f0      	push	{r4, r5, r6, r7, lr}
    816a:	b08b      	sub	sp, #44	; 0x2c
    816c:	9206      	str	r2, [sp, #24]
    816e:	000a      	movs	r2, r1
    8170:	3243      	adds	r2, #67	; 0x43
    8172:	9307      	str	r3, [sp, #28]
    8174:	9005      	str	r0, [sp, #20]
    8176:	9204      	str	r2, [sp, #16]
    8178:	7e0a      	ldrb	r2, [r1, #24]
    817a:	000c      	movs	r4, r1
    817c:	9b10      	ldr	r3, [sp, #64]	; 0x40
    817e:	2a6e      	cmp	r2, #110	; 0x6e
    8180:	d100      	bne.n	8184 <_printf_i+0x1c>
    8182:	e08f      	b.n	82a4 <_printf_i+0x13c>
    8184:	d817      	bhi.n	81b6 <_printf_i+0x4e>
    8186:	2a63      	cmp	r2, #99	; 0x63
    8188:	d02c      	beq.n	81e4 <_printf_i+0x7c>
    818a:	d808      	bhi.n	819e <_printf_i+0x36>
    818c:	2a00      	cmp	r2, #0
    818e:	d100      	bne.n	8192 <_printf_i+0x2a>
    8190:	e099      	b.n	82c6 <_printf_i+0x15e>
    8192:	2a58      	cmp	r2, #88	; 0x58
    8194:	d054      	beq.n	8240 <_printf_i+0xd8>
    8196:	0026      	movs	r6, r4
    8198:	3642      	adds	r6, #66	; 0x42
    819a:	7032      	strb	r2, [r6, #0]
    819c:	e029      	b.n	81f2 <_printf_i+0x8a>
    819e:	2a64      	cmp	r2, #100	; 0x64
    81a0:	d001      	beq.n	81a6 <_printf_i+0x3e>
    81a2:	2a69      	cmp	r2, #105	; 0x69
    81a4:	d1f7      	bne.n	8196 <_printf_i+0x2e>
    81a6:	6821      	ldr	r1, [r4, #0]
    81a8:	681a      	ldr	r2, [r3, #0]
    81aa:	0608      	lsls	r0, r1, #24
    81ac:	d523      	bpl.n	81f6 <_printf_i+0x8e>
    81ae:	1d11      	adds	r1, r2, #4
    81b0:	6019      	str	r1, [r3, #0]
    81b2:	6815      	ldr	r5, [r2, #0]
    81b4:	e025      	b.n	8202 <_printf_i+0x9a>
    81b6:	2a73      	cmp	r2, #115	; 0x73
    81b8:	d100      	bne.n	81bc <_printf_i+0x54>
    81ba:	e088      	b.n	82ce <_printf_i+0x166>
    81bc:	d808      	bhi.n	81d0 <_printf_i+0x68>
    81be:	2a6f      	cmp	r2, #111	; 0x6f
    81c0:	d029      	beq.n	8216 <_printf_i+0xae>
    81c2:	2a70      	cmp	r2, #112	; 0x70
    81c4:	d1e7      	bne.n	8196 <_printf_i+0x2e>
    81c6:	2220      	movs	r2, #32
    81c8:	6809      	ldr	r1, [r1, #0]
    81ca:	430a      	orrs	r2, r1
    81cc:	6022      	str	r2, [r4, #0]
    81ce:	e003      	b.n	81d8 <_printf_i+0x70>
    81d0:	2a75      	cmp	r2, #117	; 0x75
    81d2:	d020      	beq.n	8216 <_printf_i+0xae>
    81d4:	2a78      	cmp	r2, #120	; 0x78
    81d6:	d1de      	bne.n	8196 <_printf_i+0x2e>
    81d8:	0022      	movs	r2, r4
    81da:	2178      	movs	r1, #120	; 0x78
    81dc:	3245      	adds	r2, #69	; 0x45
    81de:	7011      	strb	r1, [r2, #0]
    81e0:	4a6c      	ldr	r2, [pc, #432]	; (8394 <_printf_i+0x22c>)
    81e2:	e030      	b.n	8246 <_printf_i+0xde>
    81e4:	000e      	movs	r6, r1
    81e6:	681a      	ldr	r2, [r3, #0]
    81e8:	3642      	adds	r6, #66	; 0x42
    81ea:	1d11      	adds	r1, r2, #4
    81ec:	6019      	str	r1, [r3, #0]
    81ee:	6813      	ldr	r3, [r2, #0]
    81f0:	7033      	strb	r3, [r6, #0]
    81f2:	2301      	movs	r3, #1
    81f4:	e079      	b.n	82ea <_printf_i+0x182>
    81f6:	0649      	lsls	r1, r1, #25
    81f8:	d5d9      	bpl.n	81ae <_printf_i+0x46>
    81fa:	1d11      	adds	r1, r2, #4
    81fc:	6019      	str	r1, [r3, #0]
    81fe:	2300      	movs	r3, #0
    8200:	5ed5      	ldrsh	r5, [r2, r3]
    8202:	2d00      	cmp	r5, #0
    8204:	da03      	bge.n	820e <_printf_i+0xa6>
    8206:	232d      	movs	r3, #45	; 0x2d
    8208:	9a04      	ldr	r2, [sp, #16]
    820a:	426d      	negs	r5, r5
    820c:	7013      	strb	r3, [r2, #0]
    820e:	4b62      	ldr	r3, [pc, #392]	; (8398 <_printf_i+0x230>)
    8210:	270a      	movs	r7, #10
    8212:	9303      	str	r3, [sp, #12]
    8214:	e02f      	b.n	8276 <_printf_i+0x10e>
    8216:	6820      	ldr	r0, [r4, #0]
    8218:	6819      	ldr	r1, [r3, #0]
    821a:	0605      	lsls	r5, r0, #24
    821c:	d503      	bpl.n	8226 <_printf_i+0xbe>
    821e:	1d08      	adds	r0, r1, #4
    8220:	6018      	str	r0, [r3, #0]
    8222:	680d      	ldr	r5, [r1, #0]
    8224:	e005      	b.n	8232 <_printf_i+0xca>
    8226:	0640      	lsls	r0, r0, #25
    8228:	d5f9      	bpl.n	821e <_printf_i+0xb6>
    822a:	680d      	ldr	r5, [r1, #0]
    822c:	1d08      	adds	r0, r1, #4
    822e:	6018      	str	r0, [r3, #0]
    8230:	b2ad      	uxth	r5, r5
    8232:	4b59      	ldr	r3, [pc, #356]	; (8398 <_printf_i+0x230>)
    8234:	2708      	movs	r7, #8
    8236:	9303      	str	r3, [sp, #12]
    8238:	2a6f      	cmp	r2, #111	; 0x6f
    823a:	d018      	beq.n	826e <_printf_i+0x106>
    823c:	270a      	movs	r7, #10
    823e:	e016      	b.n	826e <_printf_i+0x106>
    8240:	3145      	adds	r1, #69	; 0x45
    8242:	700a      	strb	r2, [r1, #0]
    8244:	4a54      	ldr	r2, [pc, #336]	; (8398 <_printf_i+0x230>)
    8246:	9203      	str	r2, [sp, #12]
    8248:	681a      	ldr	r2, [r3, #0]
    824a:	6821      	ldr	r1, [r4, #0]
    824c:	1d10      	adds	r0, r2, #4
    824e:	6018      	str	r0, [r3, #0]
    8250:	6815      	ldr	r5, [r2, #0]
    8252:	0608      	lsls	r0, r1, #24
    8254:	d522      	bpl.n	829c <_printf_i+0x134>
    8256:	07cb      	lsls	r3, r1, #31
    8258:	d502      	bpl.n	8260 <_printf_i+0xf8>
    825a:	2320      	movs	r3, #32
    825c:	4319      	orrs	r1, r3
    825e:	6021      	str	r1, [r4, #0]
    8260:	2710      	movs	r7, #16
    8262:	2d00      	cmp	r5, #0
    8264:	d103      	bne.n	826e <_printf_i+0x106>
    8266:	2320      	movs	r3, #32
    8268:	6822      	ldr	r2, [r4, #0]
    826a:	439a      	bics	r2, r3
    826c:	6022      	str	r2, [r4, #0]
    826e:	0023      	movs	r3, r4
    8270:	2200      	movs	r2, #0
    8272:	3343      	adds	r3, #67	; 0x43
    8274:	701a      	strb	r2, [r3, #0]
    8276:	6863      	ldr	r3, [r4, #4]
    8278:	60a3      	str	r3, [r4, #8]
    827a:	2b00      	cmp	r3, #0
    827c:	db5c      	blt.n	8338 <_printf_i+0x1d0>
    827e:	2204      	movs	r2, #4
    8280:	6821      	ldr	r1, [r4, #0]
    8282:	4391      	bics	r1, r2
    8284:	6021      	str	r1, [r4, #0]
    8286:	2d00      	cmp	r5, #0
    8288:	d158      	bne.n	833c <_printf_i+0x1d4>
    828a:	9e04      	ldr	r6, [sp, #16]
    828c:	2b00      	cmp	r3, #0
    828e:	d064      	beq.n	835a <_printf_i+0x1f2>
    8290:	0026      	movs	r6, r4
    8292:	9b03      	ldr	r3, [sp, #12]
    8294:	3642      	adds	r6, #66	; 0x42
    8296:	781b      	ldrb	r3, [r3, #0]
    8298:	7033      	strb	r3, [r6, #0]
    829a:	e05e      	b.n	835a <_printf_i+0x1f2>
    829c:	0648      	lsls	r0, r1, #25
    829e:	d5da      	bpl.n	8256 <_printf_i+0xee>
    82a0:	b2ad      	uxth	r5, r5
    82a2:	e7d8      	b.n	8256 <_printf_i+0xee>
    82a4:	6809      	ldr	r1, [r1, #0]
    82a6:	681a      	ldr	r2, [r3, #0]
    82a8:	0608      	lsls	r0, r1, #24
    82aa:	d505      	bpl.n	82b8 <_printf_i+0x150>
    82ac:	1d11      	adds	r1, r2, #4
    82ae:	6019      	str	r1, [r3, #0]
    82b0:	6813      	ldr	r3, [r2, #0]
    82b2:	6962      	ldr	r2, [r4, #20]
    82b4:	601a      	str	r2, [r3, #0]
    82b6:	e006      	b.n	82c6 <_printf_i+0x15e>
    82b8:	0649      	lsls	r1, r1, #25
    82ba:	d5f7      	bpl.n	82ac <_printf_i+0x144>
    82bc:	1d11      	adds	r1, r2, #4
    82be:	6019      	str	r1, [r3, #0]
    82c0:	6813      	ldr	r3, [r2, #0]
    82c2:	8aa2      	ldrh	r2, [r4, #20]
    82c4:	801a      	strh	r2, [r3, #0]
    82c6:	2300      	movs	r3, #0
    82c8:	9e04      	ldr	r6, [sp, #16]
    82ca:	6123      	str	r3, [r4, #16]
    82cc:	e054      	b.n	8378 <_printf_i+0x210>
    82ce:	681a      	ldr	r2, [r3, #0]
    82d0:	1d11      	adds	r1, r2, #4
    82d2:	6019      	str	r1, [r3, #0]
    82d4:	6816      	ldr	r6, [r2, #0]
    82d6:	2100      	movs	r1, #0
    82d8:	6862      	ldr	r2, [r4, #4]
    82da:	0030      	movs	r0, r6
    82dc:	f000 f870 	bl	83c0 <memchr>
    82e0:	2800      	cmp	r0, #0
    82e2:	d001      	beq.n	82e8 <_printf_i+0x180>
    82e4:	1b80      	subs	r0, r0, r6
    82e6:	6060      	str	r0, [r4, #4]
    82e8:	6863      	ldr	r3, [r4, #4]
    82ea:	6123      	str	r3, [r4, #16]
    82ec:	2300      	movs	r3, #0
    82ee:	9a04      	ldr	r2, [sp, #16]
    82f0:	7013      	strb	r3, [r2, #0]
    82f2:	e041      	b.n	8378 <_printf_i+0x210>
    82f4:	6923      	ldr	r3, [r4, #16]
    82f6:	0032      	movs	r2, r6
    82f8:	9906      	ldr	r1, [sp, #24]
    82fa:	9805      	ldr	r0, [sp, #20]
    82fc:	9d07      	ldr	r5, [sp, #28]
    82fe:	47a8      	blx	r5
    8300:	1c43      	adds	r3, r0, #1
    8302:	d043      	beq.n	838c <_printf_i+0x224>
    8304:	6823      	ldr	r3, [r4, #0]
    8306:	2500      	movs	r5, #0
    8308:	079b      	lsls	r3, r3, #30
    830a:	d40f      	bmi.n	832c <_printf_i+0x1c4>
    830c:	9b09      	ldr	r3, [sp, #36]	; 0x24
    830e:	68e0      	ldr	r0, [r4, #12]
    8310:	4298      	cmp	r0, r3
    8312:	da3d      	bge.n	8390 <_printf_i+0x228>
    8314:	0018      	movs	r0, r3
    8316:	e03b      	b.n	8390 <_printf_i+0x228>
    8318:	0022      	movs	r2, r4
    831a:	2301      	movs	r3, #1
    831c:	3219      	adds	r2, #25
    831e:	9906      	ldr	r1, [sp, #24]
    8320:	9805      	ldr	r0, [sp, #20]
    8322:	9e07      	ldr	r6, [sp, #28]
    8324:	47b0      	blx	r6
    8326:	1c43      	adds	r3, r0, #1
    8328:	d030      	beq.n	838c <_printf_i+0x224>
    832a:	3501      	adds	r5, #1
    832c:	68e3      	ldr	r3, [r4, #12]
    832e:	9a09      	ldr	r2, [sp, #36]	; 0x24
    8330:	1a9b      	subs	r3, r3, r2
    8332:	429d      	cmp	r5, r3
    8334:	dbf0      	blt.n	8318 <_printf_i+0x1b0>
    8336:	e7e9      	b.n	830c <_printf_i+0x1a4>
    8338:	2d00      	cmp	r5, #0
    833a:	d0a9      	beq.n	8290 <_printf_i+0x128>
    833c:	9e04      	ldr	r6, [sp, #16]
    833e:	0028      	movs	r0, r5
    8340:	0039      	movs	r1, r7
    8342:	f7ff fc7d 	bl	7c40 <__aeabi_uidivmod>
    8346:	9b03      	ldr	r3, [sp, #12]
    8348:	3e01      	subs	r6, #1
    834a:	5c5b      	ldrb	r3, [r3, r1]
    834c:	0028      	movs	r0, r5
    834e:	7033      	strb	r3, [r6, #0]
    8350:	0039      	movs	r1, r7
    8352:	f7ff fbef 	bl	7b34 <__udivsi3>
    8356:	1e05      	subs	r5, r0, #0
    8358:	d1f1      	bne.n	833e <_printf_i+0x1d6>
    835a:	2f08      	cmp	r7, #8
    835c:	d109      	bne.n	8372 <_printf_i+0x20a>
    835e:	6823      	ldr	r3, [r4, #0]
    8360:	07db      	lsls	r3, r3, #31
    8362:	d506      	bpl.n	8372 <_printf_i+0x20a>
    8364:	6863      	ldr	r3, [r4, #4]
    8366:	6922      	ldr	r2, [r4, #16]
    8368:	4293      	cmp	r3, r2
    836a:	dc02      	bgt.n	8372 <_printf_i+0x20a>
    836c:	2330      	movs	r3, #48	; 0x30
    836e:	3e01      	subs	r6, #1
    8370:	7033      	strb	r3, [r6, #0]
    8372:	9b04      	ldr	r3, [sp, #16]
    8374:	1b9b      	subs	r3, r3, r6
    8376:	6123      	str	r3, [r4, #16]
    8378:	9b07      	ldr	r3, [sp, #28]
    837a:	aa09      	add	r2, sp, #36	; 0x24
    837c:	9300      	str	r3, [sp, #0]
    837e:	0021      	movs	r1, r4
    8380:	9b06      	ldr	r3, [sp, #24]
    8382:	9805      	ldr	r0, [sp, #20]
    8384:	f7ff fe82 	bl	808c <_printf_common>
    8388:	1c43      	adds	r3, r0, #1
    838a:	d1b3      	bne.n	82f4 <_printf_i+0x18c>
    838c:	2001      	movs	r0, #1
    838e:	4240      	negs	r0, r0
    8390:	b00b      	add	sp, #44	; 0x2c
    8392:	bdf0      	pop	{r4, r5, r6, r7, pc}
    8394:	00008d06 	.word	0x00008d06
    8398:	00008cf5 	.word	0x00008cf5

0000839c <_sbrk_r>:
    839c:	2300      	movs	r3, #0
    839e:	b570      	push	{r4, r5, r6, lr}
    83a0:	4c06      	ldr	r4, [pc, #24]	; (83bc <_sbrk_r+0x20>)
    83a2:	0005      	movs	r5, r0
    83a4:	0008      	movs	r0, r1
    83a6:	6023      	str	r3, [r4, #0]
    83a8:	f7fb ffd0 	bl	434c <_sbrk>
    83ac:	1c43      	adds	r3, r0, #1
    83ae:	d103      	bne.n	83b8 <_sbrk_r+0x1c>
    83b0:	6823      	ldr	r3, [r4, #0]
    83b2:	2b00      	cmp	r3, #0
    83b4:	d000      	beq.n	83b8 <_sbrk_r+0x1c>
    83b6:	602b      	str	r3, [r5, #0]
    83b8:	bd70      	pop	{r4, r5, r6, pc}
    83ba:	46c0      	nop			; (mov r8, r8)
    83bc:	20000934 	.word	0x20000934

000083c0 <memchr>:
    83c0:	b2c9      	uxtb	r1, r1
    83c2:	1882      	adds	r2, r0, r2
    83c4:	4290      	cmp	r0, r2
    83c6:	d101      	bne.n	83cc <memchr+0xc>
    83c8:	2000      	movs	r0, #0
    83ca:	4770      	bx	lr
    83cc:	7803      	ldrb	r3, [r0, #0]
    83ce:	428b      	cmp	r3, r1
    83d0:	d0fb      	beq.n	83ca <memchr+0xa>
    83d2:	3001      	adds	r0, #1
    83d4:	e7f6      	b.n	83c4 <memchr+0x4>

000083d6 <memcpy>:
    83d6:	2300      	movs	r3, #0
    83d8:	b510      	push	{r4, lr}
    83da:	429a      	cmp	r2, r3
    83dc:	d100      	bne.n	83e0 <memcpy+0xa>
    83de:	bd10      	pop	{r4, pc}
    83e0:	5ccc      	ldrb	r4, [r1, r3]
    83e2:	54c4      	strb	r4, [r0, r3]
    83e4:	3301      	adds	r3, #1
    83e6:	e7f8      	b.n	83da <memcpy+0x4>

000083e8 <memmove>:
    83e8:	b510      	push	{r4, lr}
    83ea:	4288      	cmp	r0, r1
    83ec:	d902      	bls.n	83f4 <memmove+0xc>
    83ee:	188b      	adds	r3, r1, r2
    83f0:	4298      	cmp	r0, r3
    83f2:	d308      	bcc.n	8406 <memmove+0x1e>
    83f4:	2300      	movs	r3, #0
    83f6:	429a      	cmp	r2, r3
    83f8:	d007      	beq.n	840a <memmove+0x22>
    83fa:	5ccc      	ldrb	r4, [r1, r3]
    83fc:	54c4      	strb	r4, [r0, r3]
    83fe:	3301      	adds	r3, #1
    8400:	e7f9      	b.n	83f6 <memmove+0xe>
    8402:	5c8b      	ldrb	r3, [r1, r2]
    8404:	5483      	strb	r3, [r0, r2]
    8406:	3a01      	subs	r2, #1
    8408:	d2fb      	bcs.n	8402 <memmove+0x1a>
    840a:	bd10      	pop	{r4, pc}

0000840c <__malloc_lock>:
    840c:	4770      	bx	lr

0000840e <__malloc_unlock>:
    840e:	4770      	bx	lr

00008410 <_free_r>:
    8410:	b570      	push	{r4, r5, r6, lr}
    8412:	0005      	movs	r5, r0
    8414:	2900      	cmp	r1, #0
    8416:	d010      	beq.n	843a <_free_r+0x2a>
    8418:	1f0c      	subs	r4, r1, #4
    841a:	6823      	ldr	r3, [r4, #0]
    841c:	2b00      	cmp	r3, #0
    841e:	da00      	bge.n	8422 <_free_r+0x12>
    8420:	18e4      	adds	r4, r4, r3
    8422:	0028      	movs	r0, r5
    8424:	f7ff fff2 	bl	840c <__malloc_lock>
    8428:	4a1d      	ldr	r2, [pc, #116]	; (84a0 <_free_r+0x90>)
    842a:	6813      	ldr	r3, [r2, #0]
    842c:	2b00      	cmp	r3, #0
    842e:	d105      	bne.n	843c <_free_r+0x2c>
    8430:	6063      	str	r3, [r4, #4]
    8432:	6014      	str	r4, [r2, #0]
    8434:	0028      	movs	r0, r5
    8436:	f7ff ffea 	bl	840e <__malloc_unlock>
    843a:	bd70      	pop	{r4, r5, r6, pc}
    843c:	42a3      	cmp	r3, r4
    843e:	d909      	bls.n	8454 <_free_r+0x44>
    8440:	6821      	ldr	r1, [r4, #0]
    8442:	1860      	adds	r0, r4, r1
    8444:	4283      	cmp	r3, r0
    8446:	d1f3      	bne.n	8430 <_free_r+0x20>
    8448:	6818      	ldr	r0, [r3, #0]
    844a:	685b      	ldr	r3, [r3, #4]
    844c:	1841      	adds	r1, r0, r1
    844e:	6021      	str	r1, [r4, #0]
    8450:	e7ee      	b.n	8430 <_free_r+0x20>
    8452:	0013      	movs	r3, r2
    8454:	685a      	ldr	r2, [r3, #4]
    8456:	2a00      	cmp	r2, #0
    8458:	d001      	beq.n	845e <_free_r+0x4e>
    845a:	42a2      	cmp	r2, r4
    845c:	d9f9      	bls.n	8452 <_free_r+0x42>
    845e:	6819      	ldr	r1, [r3, #0]
    8460:	1858      	adds	r0, r3, r1
    8462:	42a0      	cmp	r0, r4
    8464:	d10b      	bne.n	847e <_free_r+0x6e>
    8466:	6820      	ldr	r0, [r4, #0]
    8468:	1809      	adds	r1, r1, r0
    846a:	1858      	adds	r0, r3, r1
    846c:	6019      	str	r1, [r3, #0]
    846e:	4282      	cmp	r2, r0
    8470:	d1e0      	bne.n	8434 <_free_r+0x24>
    8472:	6810      	ldr	r0, [r2, #0]
    8474:	6852      	ldr	r2, [r2, #4]
    8476:	1841      	adds	r1, r0, r1
    8478:	6019      	str	r1, [r3, #0]
    847a:	605a      	str	r2, [r3, #4]
    847c:	e7da      	b.n	8434 <_free_r+0x24>
    847e:	42a0      	cmp	r0, r4
    8480:	d902      	bls.n	8488 <_free_r+0x78>
    8482:	230c      	movs	r3, #12
    8484:	602b      	str	r3, [r5, #0]
    8486:	e7d5      	b.n	8434 <_free_r+0x24>
    8488:	6821      	ldr	r1, [r4, #0]
    848a:	1860      	adds	r0, r4, r1
    848c:	4282      	cmp	r2, r0
    848e:	d103      	bne.n	8498 <_free_r+0x88>
    8490:	6810      	ldr	r0, [r2, #0]
    8492:	6852      	ldr	r2, [r2, #4]
    8494:	1841      	adds	r1, r0, r1
    8496:	6021      	str	r1, [r4, #0]
    8498:	6062      	str	r2, [r4, #4]
    849a:	605c      	str	r4, [r3, #4]
    849c:	e7ca      	b.n	8434 <_free_r+0x24>
    849e:	46c0      	nop			; (mov r8, r8)
    84a0:	200007d4 	.word	0x200007d4

000084a4 <_realloc_r>:
    84a4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    84a6:	0007      	movs	r7, r0
    84a8:	000d      	movs	r5, r1
    84aa:	0016      	movs	r6, r2
    84ac:	2900      	cmp	r1, #0
    84ae:	d105      	bne.n	84bc <_realloc_r+0x18>
    84b0:	0011      	movs	r1, r2
    84b2:	f7ff fc27 	bl	7d04 <_malloc_r>
    84b6:	0004      	movs	r4, r0
    84b8:	0020      	movs	r0, r4
    84ba:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    84bc:	2a00      	cmp	r2, #0
    84be:	d103      	bne.n	84c8 <_realloc_r+0x24>
    84c0:	f7ff ffa6 	bl	8410 <_free_r>
    84c4:	0034      	movs	r4, r6
    84c6:	e7f7      	b.n	84b8 <_realloc_r+0x14>
    84c8:	f000 f812 	bl	84f0 <_malloc_usable_size_r>
    84cc:	002c      	movs	r4, r5
    84ce:	4286      	cmp	r6, r0
    84d0:	d9f2      	bls.n	84b8 <_realloc_r+0x14>
    84d2:	0031      	movs	r1, r6
    84d4:	0038      	movs	r0, r7
    84d6:	f7ff fc15 	bl	7d04 <_malloc_r>
    84da:	1e04      	subs	r4, r0, #0
    84dc:	d0ec      	beq.n	84b8 <_realloc_r+0x14>
    84de:	0029      	movs	r1, r5
    84e0:	0032      	movs	r2, r6
    84e2:	f7ff ff78 	bl	83d6 <memcpy>
    84e6:	0029      	movs	r1, r5
    84e8:	0038      	movs	r0, r7
    84ea:	f7ff ff91 	bl	8410 <_free_r>
    84ee:	e7e3      	b.n	84b8 <_realloc_r+0x14>

000084f0 <_malloc_usable_size_r>:
    84f0:	1f0b      	subs	r3, r1, #4
    84f2:	681b      	ldr	r3, [r3, #0]
    84f4:	1f18      	subs	r0, r3, #4
    84f6:	2b00      	cmp	r3, #0
    84f8:	da01      	bge.n	84fe <_malloc_usable_size_r+0xe>
    84fa:	580b      	ldr	r3, [r1, r0]
    84fc:	18c0      	adds	r0, r0, r3
    84fe:	4770      	bx	lr

00008500 <u8g2_font_Terminal_tr>:
    8500:	005f 0303 0404 0401 0c05 000c 09fe 09fe     _...............
    8510:	0100 036d 0402 2077 0005 02b1 0c21 b194     ..m...w ....!...
    8520:	7246 4838 22c4 0009 0722 dd35 c242 2322     Fr8H."..".5.B."#
    8530:	9b17 4391 32a4 8491 a12e 48c9 9222 248a     ...C.2.....H"..$
    8540:	9076 241c 0107 0f24 efb6 464a b111 254e     v..$..$...JF..N%
    8550:	9222 2684 2502 b813 272f a11c c485 b152     "..&.%../'....R.
    8560:	2c54 8595 e12a 0008 0d26 b16c 1887 74d2     T,..*...&.l....t
    8570:	8b38 11b4 2707 3206 c27d 2800 9409 4ab1     8....'.2}..(...J
    8580:	a4a2 029b 0a29 b194 a642 8ba4 0012 072a     ....)...B.....*.
    8590:	9d33 9222 2b03 560a 4af7 3228 4509 2c00     3."..+.V.J(2.E.,
    85a0:	3407 66af 0252 062d fb16 00c2 062e 9123     .4.fR.-.......#.
    85b0:	00c2 0c2f d185 494e 9226 6489 0032 0f30     ../...NI&..d2.0.
    85c0:	1197 22a7 5523 112c 894b a926 3100 9609     ..."#U,.K.&..1..
    85d0:	2ef1 d444 0327 0c32 f196 2286 0922 3a65     ..D.'.2...."".e:
    85e0:	021d 0e33 f196 2286 2a12 854d 0924 0005     ..3....".*M.$...
    85f0:	0e34 1197 3853 4923 2494 a947 0090 0d35     4...S8#I.$G...5.
    8600:	f196 10e2 ac54 490a 0a12 3600 960d 4af1     ....T..I...6...J
    8610:	28a6 88ac 2498 0014 0c37 1197 20e3 49a3     .(...$..7.... .I
    8620:	5a85 00d5 0e38 f196 2286 9262 4450 124c     .Z..8...."b.PDL.
    8630:	000a 0e39 f196 2286 9262 84d4 d932 0008     ..9...."b...2...
    8640:	063a 9163 6cc2 093b af74 1d66 2934 3c01     :.c..l;.t.f.4).<
    8650:	7409 2eb1 5124 0b53 073d f546 0ec2 3e35     .t..$QS.=.F...5>
    8660:	7409 22b1 45a6 0629 0e3f f196 2286 ca12     .t.".E).?...."..
    8670:	e514 a130 0008 0e40 b16c 1887 c916 260e     ..0...@.l......&
    8680:	4dbd 0344 0c41 f196 464a 3111 461d 024c     .MD.A...JF.1.FL.
    8690:	1142 1197 a4c3 9222 2488 1525 4491 8874     B....."..$%..Dt.
    86a0:	4300 970e 8b11 a224 b551 4449 0a22 4400     .C....$.Q.ID"..D
    86b0:	9713 c311 22a4 8892 2224 4889 9222 0e88     ....."..$".H"...
    86c0:	0011 1245 1197 22e3 c892 9222 4d18 9312     ..E....".."..M..
    86d0:	4445 0107 1146 1197 22e3 c892 9222 4d18     ED..F....".."..M
    86e0:	9312 690a 4700 970e 8b11 a224 9551 126a     ...i.G....$.Q.j.
    86f0:	a891 4800 960a 42f1 e9c4 e230 4924 9409     ...H...B..0.$I..
    8700:	82b1 d222 0217 0f4a 1197 288f 22d5 8892     .."...J....(."..
    8710:	2224 0911 4b00 9712 6311 1124 9449 2224     $"...K...c$.I.$"
    8720:	449a 1124 4a89 4c02 970b 8311 d528 445b     .D$..J.L....(.[D
    8730:	1074 0d4d 1197 5643 1c39 112a 371a 4e01     t.M...CV9.*..7.N
    8740:	970d 4311 2b46 2859 1aa6 009b 0c4f 1197     ...CF+Y(....O...
    8750:	266b e351 a24d 0236 0f50 1197 a4c3 9222     k&Q.M.6.P.....".
    8760:	2488 a925 0d22 5100 b70d 6b0d 5126 69e3     .$%."..Q...k&Q.i
    8770:	a352 090a 1052 1197 a4c3 9222 2488 8925     R...R....."..$%.
    8780:	4548 1254 0e53 f196 2286 9d62 444a 0924     HET.S...."b.JD$.
    8790:	0005 0b54 f196 22e2 0909 46f5 5501 960a     ..T...."...F.U..
    87a0:	42f1 9fc4 1424 5600 960b 42f1 4fc4 9a12     .B..$..V...B.O..
    87b0:	0008 0f57 1197 c643 844b d112 1124 2449     ..W...C.K...$.I$
    87c0:	5800 970d 4311 26c6 9b51 d449 04d8 0c59     .X...C.&Q.I...Y.
    87d0:	f196 c442 4249 aa13 0051 0e5a 1197 20e3     ..B.IB..Q.Z.... 
    87e0:	4922 aa85 d9b2 0041 085b b194 a4c2 044f     "I....A.[.....O.
    87f0:	0c5c d185 2642 0994 4265 0099 085d b194     \...B&..eB..]...
    8800:	a482 064f 095e 1b47 3a2f a893 5f09 1606     ..O.^.G./:..._..
    8810:	c2ed 6000 3206 c27d 6100 670d 8711 aa2c     ...`.2}..a.g..,.
    8820:	2488 d122 0044 0f62 1197 aa63 525a 4911     .$".D.b...c.ZR.I
    8830:	1244 6511 6302 660b 86f1 2222 492a 0028     D..e.c.f..""*I(.
    8840:	1064 1197 aa6f 1154 4449 9112 2444 089a     d...o.T.ID..D$..
    8850:	0c65 f166 2286 0c3a 1245 000a 0d66 f196     e.f..":.E...f...
    8860:	246a 9451 8495 246a 6700 8710 670d 9242     j$Q...j$.g...gB.
    8870:	2488 5122 2255 9112 6800 970f 6311 45aa     .$"QU"...h...c.E
    8880:	5134 8892 a224 0092 0969 b194 2446 e91d     4Q..$...i...F$..
    8890:	6a42 b60d 52ed 341d 48d4 4922 0028 0f6b     Bj...R.4.H"I(.k.
    88a0:	1197 aa63 5124 49a2 2a44 92a2 6c00 9408     ..c.$Q.ID*...l..
    88b0:	62b1 5fa4 6d08 670e c311 8922 2250 0894     .b._.m.g..".P"..
    88c0:	4225 6e13 6609 a2f1 e222 0049 0a6f f166     %B.n.f..".I.o.f.
    88d0:	2286 24e2 00a1 1070 0d87 3243 1152 4449     .".$..p...C2R.ID
    88e0:	9112 24a4 01a4 0f71 0d87 4267 8892 2224     ...$..q...gB..$"
    88f0:	4889 1554 7212 670c 6311 9222 a8ac 690a     .HT..r.g.c"....i
    8900:	7300 660d 86f1 9222 2588 0922 0005 0c74     .s.f.."..%"...t.
    8910:	f186 282a 08b3 88b5 0026 0f75 1167 2443     ..*(....&.u.g.C$
    8920:	4911 1244 4491 9a24 7608 660a 42f1 49c4     .ID..D$..v.f.B.I
    8930:	1342 7701 670d 4311 12c6 44a1 4934 0024     B..w.g.C...D4I$.
    8940:	0c78 1167 2643 1b51 24ce 026a 0f79 0d87     x.g.C&Q..$j.y...
    8950:	2447 4911 1244 a891 44a8 7a03 6609 e2f1     G$.ID....D.z.f..
    8960:	24a6 1d93 0b7b d195 a44e 1226 84ca 7c0a     .$..{...N.&....|
    8970:	9207 e271 0081 0c7d d195 a842 1426 44c9     ..q...}...B.&..D
    8980:	006a 0a7e 3738 4467 9091 0026 0000 0400     j.~.87gD..&.....
    8990:	ffff 0000                                   ....

00008994 <u8g2_cb_r0>:
    8994:	2443 0000 245b 0000 249f 0000 2764 0000     C$..[$...$..d'..
    89a4:	2740 0000 2752 0000 2764 0000 2764 0000     @'..R'..d'..d'..
    89b4:	2764 0000                                   d'..

000089b8 <u8x8_gp1287ai_display_info>:
    89b8:	0100 78f0 0101 783c 0900 003d 0403 783c     ...x..<x..=...<x
    89c8:	0720 0000 0100 0032                          .....2.

000089d0 <u8x8_d_gp1287ai_init_seq>:
    89d0:	1518 1955 01fe 1518 161e 1910 1518 1633     ..U...........3.
    89e0:	1640 1900 1518 1607 16ff 168c 1600 1604     @...............
    89f0:	1600 1600 1901 1518 168d 1604 16fc 1600     ................
    8a00:	1980 1518 1605 1600 1914 1518 19aa 0ffe     ................
    8a10:	1518 1603 1600 1920 1518 160b 1600 193c     ...... .......<.
    8a20:	1518 1609 1900 1518 1610 1900 1518 1601     ................
    8a30:	1900 1518 1986 00ff                         ........

00008a38 <u8x8_d_gp1287ai_standby_seq>:
    8a38:	1518 1986 00ff 0000                         ........

00008a40 <u8x8_d_gp1287ai_wakeup_seq>:
    8a40:	1518 19b6 01fe 1518 1601 1900 00ff 0000     ................
    8a50:	2e2e 682f 6c70 702f 726f 2f74 7068 5f6c     ../hpl/port/hpl_
    8a60:	7067 6f69 625f 7361 2e65 0068 2e2e 682f     gpio_base.h.../h
    8a70:	6c70 702f 2f6d 7068 5f6c 6d70 625f 7361     pl/pm/hpl_pm_bas
    8a80:	2e65 0068 2e2e 682f 6c61 732f 6372 682f     e.h.../hal/src/h
    8a90:	6c61 695f 6332 6d5f 735f 6e79 2e63 0063     al_i2c_m_sync.c.
    8aa0:	2e2e 682f 6c61 732f 6372 682f 6c61 695f     ../hal/src/hal_i
    8ab0:	2e6f 0063 2e2e 682f 6c61 732f 6372 682f     o.c.../hal/src/h
    8ac0:	6c61 735f 6970 6d5f 735f 6e79 2e63 0063     al_spi_m_sync.c.
    8ad0:	2e2e 682f 6c61 732f 6372 682f 6c61 755f     ../hal/src/hal_u
    8ae0:	6173 7472 735f 6e79 2e63 0063 4420 0000     sart_sync.c. D..
    8af0:	43fe 0000 43e8 0000 43ca 0000 43b2 0000     .C...C...C...C..

00008b00 <_map>:
    8b00:	0001 0000 0021 0000 000a 0000 000a 0000     ....!...........
    8b10:	000e 0000 003e 0000 2e2e 682f 6c70 652f     ....>...../hpl/e
    8b20:	6369 682f 6c70 655f 6369 632e 0000 0000     ic/hpl_eic.c....
    8b30:	2e2e 682f 6c70 732f 7265 6f63 2f6d 7068     ../hpl/sercom/hp
    8b40:	5f6c 6573 6372 6d6f 632e 0000               l_sercom.c..

00008b4c <sercomspi_regs>:
    8b4c:	000c 0020 0000 0002 0000 0000 00fe 0000     .. .............
    8b5c:	000c 0020 0000 0002 0000 0000 00ef 0100     .. .............
    8b6c:	2e2e 682f 6c70 702f 726f 2f74 7068 5f6c     ../hpl/port/hpl_
    8b7c:	7067 6f69 625f 7361 2e65 0068 2e2e 682f     gpio_base.h.../h
    8b8c:	6c70 702f 2f6d 7068 5f6c 6d70 625f 7361     pl/pm/hpl_pm_bas
    8b9c:	2e65 0068 7060 0000 708a 0000 708a 0000     e.h.`p...p...p..
    8bac:	704c 0000 707a 0000 7082 0000 708a 0000     Lp..zp...p...p..
    8bbc:	708a 0000 708a 0000 708a 0000 708a 0000     .p...p...p...p..
    8bcc:	708a 0000 7068 0000 5441 454d 204c 4153     .p..hp..ATMEL SA
    8bdc:	444d 3032 2820 3834 484d 297a 0000 0000     MD20 (48MHz)....
    8bec:	4e49 3a54 3025 6434 203b 6974 3a6d 3025     INT:%04d; tim:%0
    8bfc:	6433 253a 3230 3a64 3025 6432 0020 0000     3d:%02d:%02d ...
    8c0c:	3025 6432 252f 3230 2f64 3025 6432 252f     %02d/%02d/%02d/%
    8c1c:	3230 2f64 3025 6432 2020 2020 0000 0000     02d/%02d    ....
    8c2c:	2020 2020 2020 2020 2020 2020 2020 2020                     
    8c3c:	2020 2020 0d0a 0000 5aa5 0000 0180 0000         .....Z......
	...
    8c58:	0000 ff00 aa00 aaaa 00aa 0000 0fa2 0f0f     ................
    8c68:	0f0f 0f0f 0f0f 0f0f 0f0f 0f0f 000f 0000     ................
    8c78:	00ab 0019 00ae 0019 40b1 0000               .........@..

00008c84 <__sf_fake_stderr>:
	...

00008ca4 <__sf_fake_stdin>:
	...

00008cc4 <__sf_fake_stdout>:
	...
    8ce4:	2d23 2b30 0020 6c68 004c 6665 4567 4746     #-0+ .hlL.efgEFG
    8cf4:	3000 3231 3433 3635 3837 4139 4342 4544     .0123456789ABCDE
    8d04:	0046 3130 3332 3534 3736 3938 6261 6463     F.0123456789abcd
    8d14:	6665 0000                                   ef..

00008d18 <_init>:
    8d18:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    8d1a:	46c0      	nop			; (mov r8, r8)
    8d1c:	bcf8      	pop	{r3, r4, r5, r6, r7}
    8d1e:	bc08      	pop	{r3}
    8d20:	469e      	mov	lr, r3
    8d22:	4770      	bx	lr

00008d24 <__init_array_start>:
    8d24:	000000cd 	.word	0x000000cd

00008d28 <_fini>:
    8d28:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    8d2a:	46c0      	nop			; (mov r8, r8)
    8d2c:	bcf8      	pop	{r3, r4, r5, r6, r7}
    8d2e:	bc08      	pop	{r3}
    8d30:	469e      	mov	lr, r3
    8d32:	4770      	bx	lr

00008d34 <__fini_array_start>:
    8d34:	000000a5 	.word	0x000000a5
