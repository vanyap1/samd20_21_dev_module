
samd20_21_dev_module.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00008044  00000000  00000000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     00000078  20000000  00008044  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000884  20000078  000080bc  00020078  2**2
                  ALLOC
  3 .stack        00002004  200008fc  00008940  00020078  2**0
                  ALLOC
  4 .ARM.attributes 00000028  00000000  00000000  00020078  2**0
                  CONTENTS, READONLY
  5 .comment      00000059  00000000  00000000  000200a0  2**0
                  CONTENTS, READONLY
  6 .debug_info   000ba79d  00000000  00000000  000200f9  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000497f  00000000  00000000  000da896  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    00018b50  00000000  00000000  000df215  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_aranges 00003c80  00000000  00000000  000f7d65  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00003a10  00000000  00000000  000fb9e5  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_macro  000149cc  00000000  00000000  000ff3f5  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   000198f5  00000000  00000000  00113dc1  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    00075f23  00000000  00000000  0012d6b6  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  0000ea08  00000000  00000000  001a35dc  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <exception_table>:
       0:	00 29 00 20 fd 2e 00 00 89 2f 00 00 89 2f 00 00     .). ...../.../..
	...
      2c:	89 2f 00 00 00 00 00 00 00 00 00 00 89 2f 00 00     ./.........../..
      3c:	89 2f 00 00 89 2f 00 00 89 2f 00 00 89 2f 00 00     ./.../.../.../..
      4c:	89 2f 00 00 21 47 00 00 89 2f 00 00 89 2f 00 00     ./..!G.../.../..
      5c:	89 2f 00 00 89 2f 00 00 89 2f 00 00 89 2f 00 00     ./.../.../.../..
      6c:	89 2f 00 00 89 2f 00 00 89 2f 00 00 89 2f 00 00     ./.../.../.../..
      7c:	89 2f 00 00 89 2f 00 00 89 2f 00 00 89 2f 00 00     ./.../.../.../..
      8c:	89 2f 00 00 89 2f 00 00 89 2f 00 00 89 2f 00 00     ./.../.../.../..
      9c:	89 2f 00 00 89 2f 00 00                             ./.../..

000000a4 <__do_global_dtors_aux>:
      a4:	b510      	push	{r4, lr}
      a6:	4c06      	ldr	r4, [pc, #24]	; (c0 <__do_global_dtors_aux+0x1c>)
      a8:	7823      	ldrb	r3, [r4, #0]
      aa:	2b00      	cmp	r3, #0
      ac:	d107      	bne.n	be <__do_global_dtors_aux+0x1a>
      ae:	4b05      	ldr	r3, [pc, #20]	; (c4 <__do_global_dtors_aux+0x20>)
      b0:	2b00      	cmp	r3, #0
      b2:	d002      	beq.n	ba <__do_global_dtors_aux+0x16>
      b4:	4804      	ldr	r0, [pc, #16]	; (c8 <__do_global_dtors_aux+0x24>)
      b6:	e000      	b.n	ba <__do_global_dtors_aux+0x16>
      b8:	bf00      	nop
      ba:	2301      	movs	r3, #1
      bc:	7023      	strb	r3, [r4, #0]
      be:	bd10      	pop	{r4, pc}
      c0:	20000078 	.word	0x20000078
      c4:	00000000 	.word	0x00000000
      c8:	00008044 	.word	0x00008044

000000cc <frame_dummy>:
      cc:	4b08      	ldr	r3, [pc, #32]	; (f0 <frame_dummy+0x24>)
      ce:	b510      	push	{r4, lr}
      d0:	2b00      	cmp	r3, #0
      d2:	d003      	beq.n	dc <frame_dummy+0x10>
      d4:	4907      	ldr	r1, [pc, #28]	; (f4 <frame_dummy+0x28>)
      d6:	4808      	ldr	r0, [pc, #32]	; (f8 <frame_dummy+0x2c>)
      d8:	e000      	b.n	dc <frame_dummy+0x10>
      da:	bf00      	nop
      dc:	4807      	ldr	r0, [pc, #28]	; (fc <frame_dummy+0x30>)
      de:	6803      	ldr	r3, [r0, #0]
      e0:	2b00      	cmp	r3, #0
      e2:	d100      	bne.n	e6 <frame_dummy+0x1a>
      e4:	bd10      	pop	{r4, pc}
      e6:	4b06      	ldr	r3, [pc, #24]	; (100 <frame_dummy+0x34>)
      e8:	2b00      	cmp	r3, #0
      ea:	d0fb      	beq.n	e4 <frame_dummy+0x18>
      ec:	4798      	blx	r3
      ee:	e7f9      	b.n	e4 <frame_dummy+0x18>
      f0:	00000000 	.word	0x00000000
      f4:	2000007c 	.word	0x2000007c
      f8:	00008044 	.word	0x00008044
      fc:	00008044 	.word	0x00008044
     100:	00000000 	.word	0x00000000

00000104 <atmel_start_init>:

/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
     104:	b580      	push	{r7, lr}
     106:	af00      	add	r7, sp, #0
	system_init();
     108:	f003 fc08 	bl	391c <system_init>
}
     10c:	46c0      	nop			; (mov r8, r8)
     10e:	46bd      	mov	sp, r7
     110:	bd80      	pop	{r7, pc}

00000112 <u8g2_DrawRFrame>:
  xr -= r;
  xr -= 1;
  
  yl = y;
  yl += h;
  yl -= r; 
     112:	b5b0      	push	{r4, r5, r7, lr}
  yl -= 1;
     114:	b08a      	sub	sp, #40	; 0x28
     116:	af02      	add	r7, sp, #8
     118:	60f8      	str	r0, [r7, #12]
     11a:	000c      	movs	r4, r1
     11c:	0010      	movs	r0, r2
     11e:	0019      	movs	r1, r3
     120:	230a      	movs	r3, #10

  u8g2_DrawDisc(u8g2, xl, yu, r, U8G2_DRAW_UPPER_LEFT);
     122:	18fb      	adds	r3, r7, r3
     124:	1c22      	adds	r2, r4, #0
     126:	801a      	strh	r2, [r3, #0]
     128:	2308      	movs	r3, #8
     12a:	18fb      	adds	r3, r7, r3
     12c:	1c02      	adds	r2, r0, #0
     12e:	801a      	strh	r2, [r3, #0]
     130:	1dbb      	adds	r3, r7, #6
     132:	1c0a      	adds	r2, r1, #0
     134:	801a      	strh	r2, [r3, #0]
     136:	230a      	movs	r3, #10
     138:	18fa      	adds	r2, r7, r3
     13a:	1dbb      	adds	r3, r7, #6
     13c:	8812      	ldrh	r2, [r2, #0]
     13e:	881b      	ldrh	r3, [r3, #0]
  u8g2_DrawDisc(u8g2, xr, yu, r, U8G2_DRAW_UPPER_RIGHT);
     140:	18d3      	adds	r3, r2, r3
     142:	b29d      	uxth	r5, r3
     144:	2308      	movs	r3, #8
     146:	18fb      	adds	r3, r7, r3
     148:	2230      	movs	r2, #48	; 0x30
     14a:	18b9      	adds	r1, r7, r2
     14c:	881a      	ldrh	r2, [r3, #0]
     14e:	880b      	ldrh	r3, [r1, #0]
     150:	18d3      	adds	r3, r2, r3
     152:	b29b      	uxth	r3, r3
     154:	2208      	movs	r2, #8
     156:	18ba      	adds	r2, r7, r2
     158:	8814      	ldrh	r4, [r2, #0]
     15a:	220a      	movs	r2, #10
     15c:	18ba      	adds	r2, r7, r2
  u8g2_DrawDisc(u8g2, xl, yl, r, U8G2_DRAW_LOWER_LEFT);
     15e:	8811      	ldrh	r1, [r2, #0]
     160:	68f8      	ldr	r0, [r7, #12]
     162:	9300      	str	r3, [sp, #0]
     164:	002b      	movs	r3, r5
     166:	0022      	movs	r2, r4
     168:	f001 fdbd 	bl	1ce6 <u8g2_IsIntersection>
     16c:	1e03      	subs	r3, r0, #0
     16e:	d100      	bne.n	172 <u8g2_DrawRFrame+0x60>
     170:	e13f      	b.n	3f2 <u8g2_DrawRFrame+0x2e0>
     172:	231e      	movs	r3, #30
     174:	18fb      	adds	r3, r7, r3
     176:	220a      	movs	r2, #10
     178:	18ba      	adds	r2, r7, r2
     17a:	8812      	ldrh	r2, [r2, #0]
  u8g2_DrawDisc(u8g2, xr, yl, r, U8G2_DRAW_LOWER_RIGHT);
     17c:	801a      	strh	r2, [r3, #0]
     17e:	231e      	movs	r3, #30
     180:	18fb      	adds	r3, r7, r3
     182:	221e      	movs	r2, #30
     184:	18b9      	adds	r1, r7, r2
     186:	2234      	movs	r2, #52	; 0x34
     188:	18ba      	adds	r2, r7, r2
     18a:	8809      	ldrh	r1, [r1, #0]
     18c:	8812      	ldrh	r2, [r2, #0]
     18e:	188a      	adds	r2, r1, r2
     190:	801a      	strh	r2, [r3, #0]
     192:	231c      	movs	r3, #28
     194:	18fb      	adds	r3, r7, r3
     196:	2208      	movs	r2, #8
     198:	18ba      	adds	r2, r7, r2

  {
    u8g2_uint_t ww, hh;

    ww = w;
     19a:	8812      	ldrh	r2, [r2, #0]
     19c:	801a      	strh	r2, [r3, #0]
     19e:	231c      	movs	r3, #28
     1a0:	18fb      	adds	r3, r7, r3
     1a2:	221c      	movs	r2, #28
    ww -= r;
     1a4:	18b9      	adds	r1, r7, r2
     1a6:	2234      	movs	r2, #52	; 0x34
     1a8:	18ba      	adds	r2, r7, r2
     1aa:	8809      	ldrh	r1, [r1, #0]
     1ac:	8812      	ldrh	r2, [r2, #0]
     1ae:	188a      	adds	r2, r1, r2
     1b0:	801a      	strh	r2, [r3, #0]
     1b2:	231a      	movs	r3, #26
     1b4:	18fb      	adds	r3, r7, r3
     1b6:	220a      	movs	r2, #10
    ww -= r;
     1b8:	18ba      	adds	r2, r7, r2
     1ba:	8812      	ldrh	r2, [r2, #0]
     1bc:	801a      	strh	r2, [r3, #0]
     1be:	231a      	movs	r3, #26
     1c0:	18fb      	adds	r3, r7, r3
     1c2:	221a      	movs	r2, #26
     1c4:	18b9      	adds	r1, r7, r2
     1c6:	1dba      	adds	r2, r7, #6
     1c8:	8809      	ldrh	r1, [r1, #0]
     1ca:	8812      	ldrh	r2, [r2, #0]
    xl++;
     1cc:	188a      	adds	r2, r1, r2
     1ce:	801a      	strh	r2, [r3, #0]
     1d0:	231a      	movs	r3, #26
     1d2:	18fb      	adds	r3, r7, r3
     1d4:	221a      	movs	r2, #26
     1d6:	18b9      	adds	r1, r7, r2
     1d8:	2234      	movs	r2, #52	; 0x34
    yu++;
     1da:	18ba      	adds	r2, r7, r2
     1dc:	8809      	ldrh	r1, [r1, #0]
     1de:	8812      	ldrh	r2, [r2, #0]
     1e0:	1a8a      	subs	r2, r1, r2
     1e2:	801a      	strh	r2, [r3, #0]
     1e4:	231a      	movs	r3, #26
     1e6:	18fb      	adds	r3, r7, r3
    
    if ( ww >= 3 )
     1e8:	221a      	movs	r2, #26
     1ea:	18ba      	adds	r2, r7, r2
     1ec:	8812      	ldrh	r2, [r2, #0]
     1ee:	3a01      	subs	r2, #1
     1f0:	801a      	strh	r2, [r3, #0]
    {
      ww -= 2;
     1f2:	2318      	movs	r3, #24
     1f4:	18fb      	adds	r3, r7, r3
     1f6:	2208      	movs	r2, #8
     1f8:	18ba      	adds	r2, r7, r2
     1fa:	8812      	ldrh	r2, [r2, #0]
     1fc:	801a      	strh	r2, [r3, #0]
     1fe:	2318      	movs	r3, #24
      u8g2_DrawBox(u8g2, xl, y, ww, r+1);
     200:	18fb      	adds	r3, r7, r3
     202:	2218      	movs	r2, #24
     204:	18ba      	adds	r2, r7, r2
     206:	2130      	movs	r1, #48	; 0x30
     208:	1878      	adds	r0, r7, r1
     20a:	8811      	ldrh	r1, [r2, #0]
     20c:	8802      	ldrh	r2, [r0, #0]
     20e:	188a      	adds	r2, r1, r2
     210:	801a      	strh	r2, [r3, #0]
     212:	2318      	movs	r3, #24
     214:	18fb      	adds	r3, r7, r3
     216:	2218      	movs	r2, #24
     218:	18b9      	adds	r1, r7, r2
     21a:	2234      	movs	r2, #52	; 0x34
     21c:	18ba      	adds	r2, r7, r2
     21e:	8809      	ldrh	r1, [r1, #0]
     220:	8812      	ldrh	r2, [r2, #0]
     222:	1a8a      	subs	r2, r1, r2
     224:	801a      	strh	r2, [r3, #0]
     226:	2318      	movs	r3, #24
      u8g2_DrawBox(u8g2, xl, yl, ww, r+1);
     228:	18fb      	adds	r3, r7, r3
     22a:	2218      	movs	r2, #24
     22c:	18ba      	adds	r2, r7, r2
     22e:	8812      	ldrh	r2, [r2, #0]
     230:	3a01      	subs	r2, #1
     232:	801a      	strh	r2, [r3, #0]
     234:	2334      	movs	r3, #52	; 0x34
     236:	18fb      	adds	r3, r7, r3
     238:	881c      	ldrh	r4, [r3, #0]
     23a:	231c      	movs	r3, #28
     23c:	18fb      	adds	r3, r7, r3
     23e:	881a      	ldrh	r2, [r3, #0]
     240:	231e      	movs	r3, #30
     242:	18fb      	adds	r3, r7, r3
     244:	8819      	ldrh	r1, [r3, #0]
     246:	68f8      	ldr	r0, [r7, #12]
     248:	2302      	movs	r3, #2
     24a:	9300      	str	r3, [sp, #0]
     24c:	0023      	movs	r3, r4
     24e:	f000 fb03 	bl	858 <u8g2_DrawCircle>
    }
    
    hh = h;
     252:	2334      	movs	r3, #52	; 0x34
     254:	18fb      	adds	r3, r7, r3
     256:	881c      	ldrh	r4, [r3, #0]
     258:	231c      	movs	r3, #28
     25a:	18fb      	adds	r3, r7, r3
    hh -= r;
     25c:	881a      	ldrh	r2, [r3, #0]
     25e:	231a      	movs	r3, #26
     260:	18fb      	adds	r3, r7, r3
     262:	8819      	ldrh	r1, [r3, #0]
     264:	68f8      	ldr	r0, [r7, #12]
     266:	2301      	movs	r3, #1
     268:	9300      	str	r3, [sp, #0]
     26a:	0023      	movs	r3, r4
     26c:	f000 faf4 	bl	858 <u8g2_DrawCircle>
    hh -= r;
     270:	2334      	movs	r3, #52	; 0x34
     272:	18fb      	adds	r3, r7, r3
     274:	881c      	ldrh	r4, [r3, #0]
     276:	2318      	movs	r3, #24
     278:	18fb      	adds	r3, r7, r3
     27a:	881a      	ldrh	r2, [r3, #0]
     27c:	231e      	movs	r3, #30
     27e:	18fb      	adds	r3, r7, r3
     280:	8819      	ldrh	r1, [r3, #0]
     282:	68f8      	ldr	r0, [r7, #12]
    //h--;
    if ( hh >= 3 )
     284:	2304      	movs	r3, #4
     286:	9300      	str	r3, [sp, #0]
     288:	0023      	movs	r3, r4
     28a:	f000 fae5 	bl	858 <u8g2_DrawCircle>
    {
      hh -= 2;
     28e:	2334      	movs	r3, #52	; 0x34
     290:	18fb      	adds	r3, r7, r3
     292:	881c      	ldrh	r4, [r3, #0]
     294:	2318      	movs	r3, #24
     296:	18fb      	adds	r3, r7, r3
     298:	881a      	ldrh	r2, [r3, #0]
     29a:	231a      	movs	r3, #26
      u8g2_DrawBox(u8g2, x, yu, w, hh);
     29c:	18fb      	adds	r3, r7, r3
     29e:	8819      	ldrh	r1, [r3, #0]
     2a0:	68f8      	ldr	r0, [r7, #12]
     2a2:	2308      	movs	r3, #8
     2a4:	9300      	str	r3, [sp, #0]
     2a6:	0023      	movs	r3, r4
     2a8:	f000 fad6 	bl	858 <u8g2_DrawCircle>
     2ac:	2316      	movs	r3, #22
     2ae:	18fb      	adds	r3, r7, r3
     2b0:	1dba      	adds	r2, r7, #6
     2b2:	8812      	ldrh	r2, [r2, #0]
     2b4:	801a      	strh	r2, [r3, #0]
     2b6:	2316      	movs	r3, #22
     2b8:	18fb      	adds	r3, r7, r3
     2ba:	2216      	movs	r2, #22
     2bc:	18b9      	adds	r1, r7, r2
    return;
     2be:	2234      	movs	r2, #52	; 0x34
    }
  }
}
     2c0:	18ba      	adds	r2, r7, r2
     2c2:	8809      	ldrh	r1, [r1, #0]
     2c4:	8812      	ldrh	r2, [r2, #0]

  {
    u8g2_uint_t ww, hh;

    ww = w;
    ww -= r;
     2c6:	1a8a      	subs	r2, r1, r2
     2c8:	801a      	strh	r2, [r3, #0]
    ww -= r;
     2ca:	2316      	movs	r3, #22
     2cc:	18fb      	adds	r3, r7, r3
     2ce:	2216      	movs	r2, #22
     2d0:	18b9      	adds	r1, r7, r2
     2d2:	2234      	movs	r2, #52	; 0x34
     2d4:	18ba      	adds	r2, r7, r2
     2d6:	8809      	ldrh	r1, [r1, #0]
     2d8:	8812      	ldrh	r2, [r2, #0]
     2da:	1a8a      	subs	r2, r1, r2
     2dc:	801a      	strh	r2, [r3, #0]
    hh = h;
     2de:	2314      	movs	r3, #20
     2e0:	18fb      	adds	r3, r7, r3
     2e2:	2230      	movs	r2, #48	; 0x30
     2e4:	18ba      	adds	r2, r7, r2
     2e6:	8812      	ldrh	r2, [r2, #0]
     2e8:	801a      	strh	r2, [r3, #0]
    hh -= r;
     2ea:	2314      	movs	r3, #20
     2ec:	18fb      	adds	r3, r7, r3
     2ee:	2214      	movs	r2, #20
     2f0:	18b9      	adds	r1, r7, r2
     2f2:	2234      	movs	r2, #52	; 0x34
     2f4:	18ba      	adds	r2, r7, r2
     2f6:	8809      	ldrh	r1, [r1, #0]
     2f8:	8812      	ldrh	r2, [r2, #0]
     2fa:	1a8a      	subs	r2, r1, r2
     2fc:	801a      	strh	r2, [r3, #0]
    hh -= r;
     2fe:	2314      	movs	r3, #20
     300:	18fb      	adds	r3, r7, r3
     302:	2214      	movs	r2, #20
     304:	18b9      	adds	r1, r7, r2
     306:	2234      	movs	r2, #52	; 0x34
     308:	18ba      	adds	r2, r7, r2
     30a:	8809      	ldrh	r1, [r1, #0]
     30c:	8812      	ldrh	r2, [r2, #0]
     30e:	1a8a      	subs	r2, r1, r2
     310:	801a      	strh	r2, [r3, #0]
    
    xl++;
     312:	231e      	movs	r3, #30
     314:	18fb      	adds	r3, r7, r3
     316:	881a      	ldrh	r2, [r3, #0]
     318:	231e      	movs	r3, #30
     31a:	18fb      	adds	r3, r7, r3
     31c:	3201      	adds	r2, #1
     31e:	801a      	strh	r2, [r3, #0]
    yu++;
     320:	231c      	movs	r3, #28
     322:	18fb      	adds	r3, r7, r3
     324:	881a      	ldrh	r2, [r3, #0]
     326:	231c      	movs	r3, #28
     328:	18fb      	adds	r3, r7, r3
     32a:	3201      	adds	r2, #1
     32c:	801a      	strh	r2, [r3, #0]
    
    if ( ww >= 3 )
     32e:	2316      	movs	r3, #22
     330:	18fb      	adds	r3, r7, r3
     332:	881b      	ldrh	r3, [r3, #0]
     334:	2b02      	cmp	r3, #2
     336:	d92c      	bls.n	392 <u8g2_DrawRFrame+0x280>
    {
      ww -= 2;
     338:	2316      	movs	r3, #22
     33a:	18fb      	adds	r3, r7, r3
     33c:	2216      	movs	r2, #22
     33e:	18ba      	adds	r2, r7, r2
     340:	8812      	ldrh	r2, [r2, #0]
     342:	3a02      	subs	r2, #2
     344:	801a      	strh	r2, [r3, #0]
      h--;
     346:	2330      	movs	r3, #48	; 0x30
     348:	18fb      	adds	r3, r7, r3
     34a:	881b      	ldrh	r3, [r3, #0]
     34c:	2230      	movs	r2, #48	; 0x30
     34e:	18ba      	adds	r2, r7, r2
     350:	3b01      	subs	r3, #1
     352:	8013      	strh	r3, [r2, #0]
      u8g2_DrawHLine(u8g2, xl, y, ww);
     354:	2316      	movs	r3, #22
     356:	18fb      	adds	r3, r7, r3
     358:	881c      	ldrh	r4, [r3, #0]
     35a:	2308      	movs	r3, #8
     35c:	18fb      	adds	r3, r7, r3
     35e:	881a      	ldrh	r2, [r3, #0]
     360:	231e      	movs	r3, #30
     362:	18fb      	adds	r3, r7, r3
     364:	8819      	ldrh	r1, [r3, #0]
     366:	68f8      	ldr	r0, [r7, #12]
     368:	0023      	movs	r3, r4
     36a:	f001 fbf7 	bl	1b5c <u8g2_DrawHLine>
      u8g2_DrawHLine(u8g2, xl, y+h, ww);
     36e:	2308      	movs	r3, #8
     370:	18fb      	adds	r3, r7, r3
     372:	2230      	movs	r2, #48	; 0x30
     374:	18b9      	adds	r1, r7, r2
     376:	881a      	ldrh	r2, [r3, #0]
     378:	880b      	ldrh	r3, [r1, #0]
     37a:	18d3      	adds	r3, r2, r3
     37c:	b29a      	uxth	r2, r3
     37e:	2316      	movs	r3, #22
     380:	18fb      	adds	r3, r7, r3
     382:	881c      	ldrh	r4, [r3, #0]
     384:	231e      	movs	r3, #30
     386:	18fb      	adds	r3, r7, r3
     388:	8819      	ldrh	r1, [r3, #0]
     38a:	68f8      	ldr	r0, [r7, #12]
     38c:	0023      	movs	r3, r4
     38e:	f001 fbe5 	bl	1b5c <u8g2_DrawHLine>
    }
    
    if ( hh >= 3 )
     392:	2314      	movs	r3, #20
     394:	18fb      	adds	r3, r7, r3
     396:	881b      	ldrh	r3, [r3, #0]
     398:	2b02      	cmp	r3, #2
     39a:	d92b      	bls.n	3f4 <u8g2_DrawRFrame+0x2e2>
    {
      hh -= 2;
     39c:	2314      	movs	r3, #20
     39e:	18fb      	adds	r3, r7, r3
     3a0:	2214      	movs	r2, #20
     3a2:	18ba      	adds	r2, r7, r2
     3a4:	8812      	ldrh	r2, [r2, #0]
     3a6:	3a02      	subs	r2, #2
     3a8:	801a      	strh	r2, [r3, #0]
      w--;
     3aa:	1dbb      	adds	r3, r7, #6
     3ac:	881a      	ldrh	r2, [r3, #0]
     3ae:	1dbb      	adds	r3, r7, #6
     3b0:	3a01      	subs	r2, #1
     3b2:	801a      	strh	r2, [r3, #0]
      u8g2_DrawVLine(u8g2, x, yu, hh);
     3b4:	2314      	movs	r3, #20
     3b6:	18fb      	adds	r3, r7, r3
     3b8:	881c      	ldrh	r4, [r3, #0]
     3ba:	231c      	movs	r3, #28
     3bc:	18fb      	adds	r3, r7, r3
     3be:	881a      	ldrh	r2, [r3, #0]
     3c0:	230a      	movs	r3, #10
     3c2:	18fb      	adds	r3, r7, r3
     3c4:	8819      	ldrh	r1, [r3, #0]
     3c6:	68f8      	ldr	r0, [r7, #12]
     3c8:	0023      	movs	r3, r4
     3ca:	f001 fbeb 	bl	1ba4 <u8g2_DrawVLine>
      u8g2_DrawVLine(u8g2, x+w, yu, hh);
     3ce:	230a      	movs	r3, #10
     3d0:	18fa      	adds	r2, r7, r3
     3d2:	1dbb      	adds	r3, r7, #6
     3d4:	8812      	ldrh	r2, [r2, #0]
     3d6:	881b      	ldrh	r3, [r3, #0]
     3d8:	18d3      	adds	r3, r2, r3
     3da:	b299      	uxth	r1, r3
     3dc:	2314      	movs	r3, #20
     3de:	18fb      	adds	r3, r7, r3
     3e0:	881c      	ldrh	r4, [r3, #0]
     3e2:	231c      	movs	r3, #28
     3e4:	18fb      	adds	r3, r7, r3
     3e6:	881a      	ldrh	r2, [r3, #0]
     3e8:	68f8      	ldr	r0, [r7, #12]
     3ea:	0023      	movs	r3, r4
     3ec:	f001 fbda 	bl	1ba4 <u8g2_DrawVLine>
     3f0:	e000      	b.n	3f4 <u8g2_DrawRFrame+0x2e2>
    return;
     3f2:	46c0      	nop			; (mov r8, r8)
    }
  }
}
     3f4:	46bd      	mov	sp, r7
     3f6:	b008      	add	sp, #32
     3f8:	bdb0      	pop	{r4, r5, r7, pc}

000003fa <u8g2_ClearBuffer>:
#include "u8g2.h"
#include <string.h>

/*============================================*/
void u8g2_ClearBuffer(u8g2_t *u8g2)
{
     3fa:	b580      	push	{r7, lr}
     3fc:	b084      	sub	sp, #16
     3fe:	af00      	add	r7, sp, #0
     400:	6078      	str	r0, [r7, #4]
  size_t cnt;
  cnt = u8g2_GetU8x8(u8g2)->display_info->tile_width;
     402:	687b      	ldr	r3, [r7, #4]
     404:	681b      	ldr	r3, [r3, #0]
     406:	7c1b      	ldrb	r3, [r3, #16]
     408:	60fb      	str	r3, [r7, #12]
  cnt *= u8g2->tile_buf_height;
     40a:	687b      	ldr	r3, [r7, #4]
     40c:	2238      	movs	r2, #56	; 0x38
     40e:	5c9b      	ldrb	r3, [r3, r2]
     410:	001a      	movs	r2, r3
     412:	68fb      	ldr	r3, [r7, #12]
     414:	4353      	muls	r3, r2
     416:	60fb      	str	r3, [r7, #12]
  cnt *= 8;
     418:	68fb      	ldr	r3, [r7, #12]
     41a:	00db      	lsls	r3, r3, #3
     41c:	60fb      	str	r3, [r7, #12]
  memset(u8g2->tile_buf_ptr, 0, cnt);
     41e:	687b      	ldr	r3, [r7, #4]
     420:	6b5b      	ldr	r3, [r3, #52]	; 0x34
     422:	68fa      	ldr	r2, [r7, #12]
     424:	2100      	movs	r1, #0
     426:	0018      	movs	r0, r3
     428:	f006 fdd6 	bl	6fd8 <memset>
}
     42c:	46c0      	nop			; (mov r8, r8)
     42e:	46bd      	mov	sp, r7
     430:	b004      	add	sp, #16
     432:	bd80      	pop	{r7, pc}

00000434 <u8g2_send_tile_row>:

/*============================================*/

static void u8g2_send_tile_row(u8g2_t *u8g2, uint8_t src_tile_row, uint8_t dest_tile_row)
{
     434:	b580      	push	{r7, lr}
     436:	b086      	sub	sp, #24
     438:	af02      	add	r7, sp, #8
     43a:	6078      	str	r0, [r7, #4]
     43c:	0008      	movs	r0, r1
     43e:	0011      	movs	r1, r2
     440:	1cfb      	adds	r3, r7, #3
     442:	1c02      	adds	r2, r0, #0
     444:	701a      	strb	r2, [r3, #0]
     446:	1cbb      	adds	r3, r7, #2
     448:	1c0a      	adds	r2, r1, #0
     44a:	701a      	strb	r2, [r3, #0]
  uint8_t *ptr;
  uint16_t offset;
  uint8_t w;
  
  w = u8g2_GetU8x8(u8g2)->display_info->tile_width;
     44c:	687b      	ldr	r3, [r7, #4]
     44e:	681a      	ldr	r2, [r3, #0]
     450:	230f      	movs	r3, #15
     452:	18fb      	adds	r3, r7, r3
     454:	7c12      	ldrb	r2, [r2, #16]
     456:	701a      	strb	r2, [r3, #0]
  offset = src_tile_row;
     458:	230c      	movs	r3, #12
     45a:	18fb      	adds	r3, r7, r3
     45c:	1cfa      	adds	r2, r7, #3
     45e:	7812      	ldrb	r2, [r2, #0]
     460:	801a      	strh	r2, [r3, #0]
  ptr = u8g2->tile_buf_ptr;
     462:	687b      	ldr	r3, [r7, #4]
     464:	6b5b      	ldr	r3, [r3, #52]	; 0x34
     466:	60bb      	str	r3, [r7, #8]
  offset *= w;
     468:	230f      	movs	r3, #15
     46a:	18fb      	adds	r3, r7, r3
     46c:	781b      	ldrb	r3, [r3, #0]
     46e:	b29a      	uxth	r2, r3
     470:	230c      	movs	r3, #12
     472:	18fb      	adds	r3, r7, r3
     474:	210c      	movs	r1, #12
     476:	1879      	adds	r1, r7, r1
     478:	8809      	ldrh	r1, [r1, #0]
     47a:	434a      	muls	r2, r1
     47c:	801a      	strh	r2, [r3, #0]
  offset *= 8;
     47e:	230c      	movs	r3, #12
     480:	18fb      	adds	r3, r7, r3
     482:	220c      	movs	r2, #12
     484:	18ba      	adds	r2, r7, r2
     486:	8812      	ldrh	r2, [r2, #0]
     488:	00d2      	lsls	r2, r2, #3
     48a:	801a      	strh	r2, [r3, #0]
  ptr += offset;
     48c:	230c      	movs	r3, #12
     48e:	18fb      	adds	r3, r7, r3
     490:	881b      	ldrh	r3, [r3, #0]
     492:	68ba      	ldr	r2, [r7, #8]
     494:	18d3      	adds	r3, r2, r3
     496:	60bb      	str	r3, [r7, #8]
  u8x8_DrawTile(u8g2_GetU8x8(u8g2), 0, dest_tile_row, w, ptr);
     498:	230f      	movs	r3, #15
     49a:	18fb      	adds	r3, r7, r3
     49c:	7819      	ldrb	r1, [r3, #0]
     49e:	1cbb      	adds	r3, r7, #2
     4a0:	781a      	ldrb	r2, [r3, #0]
     4a2:	6878      	ldr	r0, [r7, #4]
     4a4:	68bb      	ldr	r3, [r7, #8]
     4a6:	9300      	str	r3, [sp, #0]
     4a8:	000b      	movs	r3, r1
     4aa:	2100      	movs	r1, #0
     4ac:	f002 f9c4 	bl	2838 <u8x8_DrawTile>
}
     4b0:	46c0      	nop			; (mov r8, r8)
     4b2:	46bd      	mov	sp, r7
     4b4:	b004      	add	sp, #16
     4b6:	bd80      	pop	{r7, pc}

000004b8 <u8g2_send_buffer>:
  For most displays, this will make the content visible to the user.
  Some displays (like the SSD1606) require a u8x8_RefreshDisplay()
*/
static void u8g2_send_buffer(u8g2_t *u8g2) U8X8_NOINLINE;
static void u8g2_send_buffer(u8g2_t *u8g2)
{
     4b8:	b580      	push	{r7, lr}
     4ba:	b084      	sub	sp, #16
     4bc:	af00      	add	r7, sp, #0
     4be:	6078      	str	r0, [r7, #4]
  uint8_t src_row;
  uint8_t src_max;
  uint8_t dest_row;
  uint8_t dest_max;

  src_row = 0;
     4c0:	230f      	movs	r3, #15
     4c2:	18fb      	adds	r3, r7, r3
     4c4:	2200      	movs	r2, #0
     4c6:	701a      	strb	r2, [r3, #0]
  src_max = u8g2->tile_buf_height;
     4c8:	230d      	movs	r3, #13
     4ca:	18fb      	adds	r3, r7, r3
     4cc:	687a      	ldr	r2, [r7, #4]
     4ce:	2138      	movs	r1, #56	; 0x38
     4d0:	5c52      	ldrb	r2, [r2, r1]
     4d2:	701a      	strb	r2, [r3, #0]
  dest_row = u8g2->tile_curr_row;
     4d4:	230e      	movs	r3, #14
     4d6:	18fb      	adds	r3, r7, r3
     4d8:	687a      	ldr	r2, [r7, #4]
     4da:	2139      	movs	r1, #57	; 0x39
     4dc:	5c52      	ldrb	r2, [r2, r1]
     4de:	701a      	strb	r2, [r3, #0]
  dest_max = u8g2_GetU8x8(u8g2)->display_info->tile_height;
     4e0:	687b      	ldr	r3, [r7, #4]
     4e2:	681a      	ldr	r2, [r3, #0]
     4e4:	230c      	movs	r3, #12
     4e6:	18fb      	adds	r3, r7, r3
     4e8:	7c52      	ldrb	r2, [r2, #17]
     4ea:	701a      	strb	r2, [r3, #0]
  
  do
  {
    u8g2_send_tile_row(u8g2, src_row, dest_row);
     4ec:	230e      	movs	r3, #14
     4ee:	18fb      	adds	r3, r7, r3
     4f0:	781a      	ldrb	r2, [r3, #0]
     4f2:	230f      	movs	r3, #15
     4f4:	18fb      	adds	r3, r7, r3
     4f6:	7819      	ldrb	r1, [r3, #0]
     4f8:	687b      	ldr	r3, [r7, #4]
     4fa:	0018      	movs	r0, r3
     4fc:	f7ff ff9a 	bl	434 <u8g2_send_tile_row>
    src_row++;
     500:	230f      	movs	r3, #15
     502:	18fb      	adds	r3, r7, r3
     504:	781a      	ldrb	r2, [r3, #0]
     506:	230f      	movs	r3, #15
     508:	18fb      	adds	r3, r7, r3
     50a:	3201      	adds	r2, #1
     50c:	701a      	strb	r2, [r3, #0]
    dest_row++;
     50e:	230e      	movs	r3, #14
     510:	18fb      	adds	r3, r7, r3
     512:	781a      	ldrb	r2, [r3, #0]
     514:	230e      	movs	r3, #14
     516:	18fb      	adds	r3, r7, r3
     518:	3201      	adds	r2, #1
     51a:	701a      	strb	r2, [r3, #0]
  } while( src_row < src_max && dest_row < dest_max );
     51c:	230f      	movs	r3, #15
     51e:	18fa      	adds	r2, r7, r3
     520:	230d      	movs	r3, #13
     522:	18fb      	adds	r3, r7, r3
     524:	7812      	ldrb	r2, [r2, #0]
     526:	781b      	ldrb	r3, [r3, #0]
     528:	429a      	cmp	r2, r3
     52a:	d207      	bcs.n	53c <u8g2_send_buffer+0x84>
     52c:	230e      	movs	r3, #14
     52e:	18fa      	adds	r2, r7, r3
     530:	230c      	movs	r3, #12
     532:	18fb      	adds	r3, r7, r3
     534:	7812      	ldrb	r2, [r2, #0]
     536:	781b      	ldrb	r3, [r3, #0]
     538:	429a      	cmp	r2, r3
     53a:	d3d7      	bcc.n	4ec <u8g2_send_buffer+0x34>
}
     53c:	46c0      	nop			; (mov r8, r8)
     53e:	46bd      	mov	sp, r7
     540:	b004      	add	sp, #16
     542:	bd80      	pop	{r7, pc}

00000544 <u8g2_SendBuffer>:

/* same as u8g2_send_buffer but also send the DISPLAY_REFRESH message (used by SSD1606) */
void u8g2_SendBuffer(u8g2_t *u8g2)
{
     544:	b580      	push	{r7, lr}
     546:	b082      	sub	sp, #8
     548:	af00      	add	r7, sp, #0
     54a:	6078      	str	r0, [r7, #4]
  u8g2_send_buffer(u8g2);
     54c:	687b      	ldr	r3, [r7, #4]
     54e:	0018      	movs	r0, r3
     550:	f7ff ffb2 	bl	4b8 <u8g2_send_buffer>
  u8x8_RefreshDisplay( u8g2_GetU8x8(u8g2) );  
     554:	687b      	ldr	r3, [r7, #4]
     556:	0018      	movs	r0, r3
     558:	f002 f9e2 	bl	2920 <u8x8_RefreshDisplay>
}
     55c:	46c0      	nop			; (mov r8, r8)
     55e:	46bd      	mov	sp, r7
     560:	b002      	add	sp, #8
     562:	bd80      	pop	{r7, pc}

00000564 <u8g2_draw_circle_section>:
/* Circle */

static void u8g2_draw_circle_section(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t x0, u8g2_uint_t y0, uint8_t option) U8G2_NOINLINE;

static void u8g2_draw_circle_section(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t x0, u8g2_uint_t y0, uint8_t option)
{
     564:	b590      	push	{r4, r7, lr}
     566:	b085      	sub	sp, #20
     568:	af00      	add	r7, sp, #0
     56a:	60f8      	str	r0, [r7, #12]
     56c:	000c      	movs	r4, r1
     56e:	0010      	movs	r0, r2
     570:	0019      	movs	r1, r3
     572:	230a      	movs	r3, #10
     574:	18fb      	adds	r3, r7, r3
     576:	1c22      	adds	r2, r4, #0
     578:	801a      	strh	r2, [r3, #0]
     57a:	2308      	movs	r3, #8
     57c:	18fb      	adds	r3, r7, r3
     57e:	1c02      	adds	r2, r0, #0
     580:	801a      	strh	r2, [r3, #0]
     582:	1dbb      	adds	r3, r7, #6
     584:	1c0a      	adds	r2, r1, #0
     586:	801a      	strh	r2, [r3, #0]
    /* upper right */
    if ( option & U8G2_DRAW_UPPER_RIGHT )
     588:	2324      	movs	r3, #36	; 0x24
     58a:	18fb      	adds	r3, r7, r3
     58c:	781b      	ldrb	r3, [r3, #0]
     58e:	2201      	movs	r2, #1
     590:	4013      	ands	r3, r2
     592:	d025      	beq.n	5e0 <u8g2_draw_circle_section+0x7c>
    {
      u8g2_DrawPixel(u8g2, x0 + x, y0 - y);
     594:	1dba      	adds	r2, r7, #6
     596:	230a      	movs	r3, #10
     598:	18fb      	adds	r3, r7, r3
     59a:	8812      	ldrh	r2, [r2, #0]
     59c:	881b      	ldrh	r3, [r3, #0]
     59e:	18d3      	adds	r3, r2, r3
     5a0:	b299      	uxth	r1, r3
     5a2:	2320      	movs	r3, #32
     5a4:	18fa      	adds	r2, r7, r3
     5a6:	2308      	movs	r3, #8
     5a8:	18fb      	adds	r3, r7, r3
     5aa:	8812      	ldrh	r2, [r2, #0]
     5ac:	881b      	ldrh	r3, [r3, #0]
     5ae:	1ad3      	subs	r3, r2, r3
     5b0:	b29a      	uxth	r2, r3
     5b2:	68fb      	ldr	r3, [r7, #12]
     5b4:	0018      	movs	r0, r3
     5b6:	f001 fb19 	bl	1bec <u8g2_DrawPixel>
      u8g2_DrawPixel(u8g2, x0 + y, y0 - x);
     5ba:	1dba      	adds	r2, r7, #6
     5bc:	2308      	movs	r3, #8
     5be:	18fb      	adds	r3, r7, r3
     5c0:	8812      	ldrh	r2, [r2, #0]
     5c2:	881b      	ldrh	r3, [r3, #0]
     5c4:	18d3      	adds	r3, r2, r3
     5c6:	b299      	uxth	r1, r3
     5c8:	2320      	movs	r3, #32
     5ca:	18fa      	adds	r2, r7, r3
     5cc:	230a      	movs	r3, #10
     5ce:	18fb      	adds	r3, r7, r3
     5d0:	8812      	ldrh	r2, [r2, #0]
     5d2:	881b      	ldrh	r3, [r3, #0]
     5d4:	1ad3      	subs	r3, r2, r3
     5d6:	b29a      	uxth	r2, r3
     5d8:	68fb      	ldr	r3, [r7, #12]
     5da:	0018      	movs	r0, r3
     5dc:	f001 fb06 	bl	1bec <u8g2_DrawPixel>
    }
    
    /* upper left */
    if ( option & U8G2_DRAW_UPPER_LEFT )
     5e0:	2324      	movs	r3, #36	; 0x24
     5e2:	18fb      	adds	r3, r7, r3
     5e4:	781b      	ldrb	r3, [r3, #0]
     5e6:	2202      	movs	r2, #2
     5e8:	4013      	ands	r3, r2
     5ea:	d025      	beq.n	638 <u8g2_draw_circle_section+0xd4>
    {
      u8g2_DrawPixel(u8g2, x0 - x, y0 - y);
     5ec:	1dba      	adds	r2, r7, #6
     5ee:	230a      	movs	r3, #10
     5f0:	18fb      	adds	r3, r7, r3
     5f2:	8812      	ldrh	r2, [r2, #0]
     5f4:	881b      	ldrh	r3, [r3, #0]
     5f6:	1ad3      	subs	r3, r2, r3
     5f8:	b299      	uxth	r1, r3
     5fa:	2320      	movs	r3, #32
     5fc:	18fa      	adds	r2, r7, r3
     5fe:	2308      	movs	r3, #8
     600:	18fb      	adds	r3, r7, r3
     602:	8812      	ldrh	r2, [r2, #0]
     604:	881b      	ldrh	r3, [r3, #0]
     606:	1ad3      	subs	r3, r2, r3
     608:	b29a      	uxth	r2, r3
     60a:	68fb      	ldr	r3, [r7, #12]
     60c:	0018      	movs	r0, r3
     60e:	f001 faed 	bl	1bec <u8g2_DrawPixel>
      u8g2_DrawPixel(u8g2, x0 - y, y0 - x);
     612:	1dba      	adds	r2, r7, #6
     614:	2308      	movs	r3, #8
     616:	18fb      	adds	r3, r7, r3
     618:	8812      	ldrh	r2, [r2, #0]
     61a:	881b      	ldrh	r3, [r3, #0]
     61c:	1ad3      	subs	r3, r2, r3
     61e:	b299      	uxth	r1, r3
     620:	2320      	movs	r3, #32
     622:	18fa      	adds	r2, r7, r3
     624:	230a      	movs	r3, #10
     626:	18fb      	adds	r3, r7, r3
     628:	8812      	ldrh	r2, [r2, #0]
     62a:	881b      	ldrh	r3, [r3, #0]
     62c:	1ad3      	subs	r3, r2, r3
     62e:	b29a      	uxth	r2, r3
     630:	68fb      	ldr	r3, [r7, #12]
     632:	0018      	movs	r0, r3
     634:	f001 fada 	bl	1bec <u8g2_DrawPixel>
    }
    
    /* lower right */
    if ( option & U8G2_DRAW_LOWER_RIGHT )
     638:	2324      	movs	r3, #36	; 0x24
     63a:	18fb      	adds	r3, r7, r3
     63c:	781b      	ldrb	r3, [r3, #0]
     63e:	2208      	movs	r2, #8
     640:	4013      	ands	r3, r2
     642:	d025      	beq.n	690 <u8g2_draw_circle_section+0x12c>
    {
      u8g2_DrawPixel(u8g2, x0 + x, y0 + y);
     644:	1dba      	adds	r2, r7, #6
     646:	230a      	movs	r3, #10
     648:	18fb      	adds	r3, r7, r3
     64a:	8812      	ldrh	r2, [r2, #0]
     64c:	881b      	ldrh	r3, [r3, #0]
     64e:	18d3      	adds	r3, r2, r3
     650:	b299      	uxth	r1, r3
     652:	2320      	movs	r3, #32
     654:	18fa      	adds	r2, r7, r3
     656:	2308      	movs	r3, #8
     658:	18fb      	adds	r3, r7, r3
     65a:	8812      	ldrh	r2, [r2, #0]
     65c:	881b      	ldrh	r3, [r3, #0]
     65e:	18d3      	adds	r3, r2, r3
     660:	b29a      	uxth	r2, r3
     662:	68fb      	ldr	r3, [r7, #12]
     664:	0018      	movs	r0, r3
     666:	f001 fac1 	bl	1bec <u8g2_DrawPixel>
      u8g2_DrawPixel(u8g2, x0 + y, y0 + x);
     66a:	1dba      	adds	r2, r7, #6
     66c:	2308      	movs	r3, #8
     66e:	18fb      	adds	r3, r7, r3
     670:	8812      	ldrh	r2, [r2, #0]
     672:	881b      	ldrh	r3, [r3, #0]
     674:	18d3      	adds	r3, r2, r3
     676:	b299      	uxth	r1, r3
     678:	2320      	movs	r3, #32
     67a:	18fa      	adds	r2, r7, r3
     67c:	230a      	movs	r3, #10
     67e:	18fb      	adds	r3, r7, r3
     680:	8812      	ldrh	r2, [r2, #0]
     682:	881b      	ldrh	r3, [r3, #0]
     684:	18d3      	adds	r3, r2, r3
     686:	b29a      	uxth	r2, r3
     688:	68fb      	ldr	r3, [r7, #12]
     68a:	0018      	movs	r0, r3
     68c:	f001 faae 	bl	1bec <u8g2_DrawPixel>
    }
    
    /* lower left */
    if ( option & U8G2_DRAW_LOWER_LEFT )
     690:	2324      	movs	r3, #36	; 0x24
     692:	18fb      	adds	r3, r7, r3
     694:	781b      	ldrb	r3, [r3, #0]
     696:	2204      	movs	r2, #4
     698:	4013      	ands	r3, r2
     69a:	d025      	beq.n	6e8 <u8g2_draw_circle_section+0x184>
    {
      u8g2_DrawPixel(u8g2, x0 - x, y0 + y);
     69c:	1dba      	adds	r2, r7, #6
     69e:	230a      	movs	r3, #10
     6a0:	18fb      	adds	r3, r7, r3
     6a2:	8812      	ldrh	r2, [r2, #0]
     6a4:	881b      	ldrh	r3, [r3, #0]
     6a6:	1ad3      	subs	r3, r2, r3
     6a8:	b299      	uxth	r1, r3
     6aa:	2320      	movs	r3, #32
     6ac:	18fa      	adds	r2, r7, r3
     6ae:	2308      	movs	r3, #8
     6b0:	18fb      	adds	r3, r7, r3
     6b2:	8812      	ldrh	r2, [r2, #0]
     6b4:	881b      	ldrh	r3, [r3, #0]
     6b6:	18d3      	adds	r3, r2, r3
     6b8:	b29a      	uxth	r2, r3
     6ba:	68fb      	ldr	r3, [r7, #12]
     6bc:	0018      	movs	r0, r3
     6be:	f001 fa95 	bl	1bec <u8g2_DrawPixel>
      u8g2_DrawPixel(u8g2, x0 - y, y0 + x);
     6c2:	1dba      	adds	r2, r7, #6
     6c4:	2308      	movs	r3, #8
     6c6:	18fb      	adds	r3, r7, r3
     6c8:	8812      	ldrh	r2, [r2, #0]
     6ca:	881b      	ldrh	r3, [r3, #0]
     6cc:	1ad3      	subs	r3, r2, r3
     6ce:	b299      	uxth	r1, r3
     6d0:	2320      	movs	r3, #32
     6d2:	18fa      	adds	r2, r7, r3
     6d4:	230a      	movs	r3, #10
     6d6:	18fb      	adds	r3, r7, r3
     6d8:	8812      	ldrh	r2, [r2, #0]
     6da:	881b      	ldrh	r3, [r3, #0]
     6dc:	18d3      	adds	r3, r2, r3
     6de:	b29a      	uxth	r2, r3
     6e0:	68fb      	ldr	r3, [r7, #12]
     6e2:	0018      	movs	r0, r3
     6e4:	f001 fa82 	bl	1bec <u8g2_DrawPixel>
    }
}
     6e8:	46c0      	nop			; (mov r8, r8)
     6ea:	46bd      	mov	sp, r7
     6ec:	b005      	add	sp, #20
     6ee:	bd90      	pop	{r4, r7, pc}

000006f0 <u8g2_draw_circle>:

static void u8g2_draw_circle(u8g2_t *u8g2, u8g2_uint_t x0, u8g2_uint_t y0, u8g2_uint_t rad, uint8_t option)
{
     6f0:	b590      	push	{r4, r7, lr}
     6f2:	b08b      	sub	sp, #44	; 0x2c
     6f4:	af02      	add	r7, sp, #8
     6f6:	60f8      	str	r0, [r7, #12]
     6f8:	000c      	movs	r4, r1
     6fa:	0010      	movs	r0, r2
     6fc:	0019      	movs	r1, r3
     6fe:	230a      	movs	r3, #10
     700:	18fb      	adds	r3, r7, r3
     702:	1c22      	adds	r2, r4, #0
     704:	801a      	strh	r2, [r3, #0]
     706:	2308      	movs	r3, #8
     708:	18fb      	adds	r3, r7, r3
     70a:	1c02      	adds	r2, r0, #0
     70c:	801a      	strh	r2, [r3, #0]
     70e:	1dbb      	adds	r3, r7, #6
     710:	1c0a      	adds	r2, r1, #0
     712:	801a      	strh	r2, [r3, #0]
    u8g2_int_t ddF_x;
    u8g2_int_t ddF_y;
    u8g2_uint_t x;
    u8g2_uint_t y;

    f = 1;
     714:	231e      	movs	r3, #30
     716:	18fb      	adds	r3, r7, r3
     718:	2201      	movs	r2, #1
     71a:	801a      	strh	r2, [r3, #0]
    f -= rad;
     71c:	231e      	movs	r3, #30
     71e:	18fb      	adds	r3, r7, r3
     720:	881a      	ldrh	r2, [r3, #0]
     722:	1dbb      	adds	r3, r7, #6
     724:	881b      	ldrh	r3, [r3, #0]
     726:	1ad3      	subs	r3, r2, r3
     728:	b29a      	uxth	r2, r3
     72a:	231e      	movs	r3, #30
     72c:	18fb      	adds	r3, r7, r3
     72e:	801a      	strh	r2, [r3, #0]
    ddF_x = 1;
     730:	231c      	movs	r3, #28
     732:	18fb      	adds	r3, r7, r3
     734:	2201      	movs	r2, #1
     736:	801a      	strh	r2, [r3, #0]
    ddF_y = 0;
     738:	231a      	movs	r3, #26
     73a:	18fb      	adds	r3, r7, r3
     73c:	2200      	movs	r2, #0
     73e:	801a      	strh	r2, [r3, #0]
    ddF_y -= rad;
     740:	231a      	movs	r3, #26
     742:	18fb      	adds	r3, r7, r3
     744:	881a      	ldrh	r2, [r3, #0]
     746:	1dbb      	adds	r3, r7, #6
     748:	881b      	ldrh	r3, [r3, #0]
     74a:	1ad3      	subs	r3, r2, r3
     74c:	b29a      	uxth	r2, r3
     74e:	231a      	movs	r3, #26
     750:	18fb      	adds	r3, r7, r3
     752:	801a      	strh	r2, [r3, #0]
    ddF_y *= 2;
     754:	231a      	movs	r3, #26
     756:	18fb      	adds	r3, r7, r3
     758:	881b      	ldrh	r3, [r3, #0]
     75a:	18db      	adds	r3, r3, r3
     75c:	b29a      	uxth	r2, r3
     75e:	231a      	movs	r3, #26
     760:	18fb      	adds	r3, r7, r3
     762:	801a      	strh	r2, [r3, #0]
    x = 0;
     764:	2318      	movs	r3, #24
     766:	18fb      	adds	r3, r7, r3
     768:	2200      	movs	r2, #0
     76a:	801a      	strh	r2, [r3, #0]
    y = rad;
     76c:	2316      	movs	r3, #22
     76e:	18fb      	adds	r3, r7, r3
     770:	1dba      	adds	r2, r7, #6
     772:	8812      	ldrh	r2, [r2, #0]
     774:	801a      	strh	r2, [r3, #0]

    u8g2_draw_circle_section(u8g2, x, y, x0, y0, option);
     776:	230a      	movs	r3, #10
     778:	18fb      	adds	r3, r7, r3
     77a:	881c      	ldrh	r4, [r3, #0]
     77c:	2316      	movs	r3, #22
     77e:	18fb      	adds	r3, r7, r3
     780:	881a      	ldrh	r2, [r3, #0]
     782:	2318      	movs	r3, #24
     784:	18fb      	adds	r3, r7, r3
     786:	8819      	ldrh	r1, [r3, #0]
     788:	68f8      	ldr	r0, [r7, #12]
     78a:	2330      	movs	r3, #48	; 0x30
     78c:	18fb      	adds	r3, r7, r3
     78e:	781b      	ldrb	r3, [r3, #0]
     790:	9301      	str	r3, [sp, #4]
     792:	2308      	movs	r3, #8
     794:	18fb      	adds	r3, r7, r3
     796:	881b      	ldrh	r3, [r3, #0]
     798:	9300      	str	r3, [sp, #0]
     79a:	0023      	movs	r3, r4
     79c:	f7ff fee2 	bl	564 <u8g2_draw_circle_section>
    
    while ( x < y )
     7a0:	e04e      	b.n	840 <u8g2_draw_circle+0x150>
    {
      if (f >= 0) 
     7a2:	231e      	movs	r3, #30
     7a4:	18fb      	adds	r3, r7, r3
     7a6:	2200      	movs	r2, #0
     7a8:	5e9b      	ldrsh	r3, [r3, r2]
     7aa:	2b00      	cmp	r3, #0
     7ac:	db19      	blt.n	7e2 <u8g2_draw_circle+0xf2>
      {
        y--;
     7ae:	2316      	movs	r3, #22
     7b0:	18fb      	adds	r3, r7, r3
     7b2:	881a      	ldrh	r2, [r3, #0]
     7b4:	2316      	movs	r3, #22
     7b6:	18fb      	adds	r3, r7, r3
     7b8:	3a01      	subs	r2, #1
     7ba:	801a      	strh	r2, [r3, #0]
        ddF_y += 2;
     7bc:	231a      	movs	r3, #26
     7be:	18fb      	adds	r3, r7, r3
     7c0:	881b      	ldrh	r3, [r3, #0]
     7c2:	3302      	adds	r3, #2
     7c4:	b29a      	uxth	r2, r3
     7c6:	231a      	movs	r3, #26
     7c8:	18fb      	adds	r3, r7, r3
     7ca:	801a      	strh	r2, [r3, #0]
        f += ddF_y;
     7cc:	231e      	movs	r3, #30
     7ce:	18fb      	adds	r3, r7, r3
     7d0:	881a      	ldrh	r2, [r3, #0]
     7d2:	231a      	movs	r3, #26
     7d4:	18fb      	adds	r3, r7, r3
     7d6:	881b      	ldrh	r3, [r3, #0]
     7d8:	18d3      	adds	r3, r2, r3
     7da:	b29a      	uxth	r2, r3
     7dc:	231e      	movs	r3, #30
     7de:	18fb      	adds	r3, r7, r3
     7e0:	801a      	strh	r2, [r3, #0]
      }
      x++;
     7e2:	2318      	movs	r3, #24
     7e4:	18fb      	adds	r3, r7, r3
     7e6:	881a      	ldrh	r2, [r3, #0]
     7e8:	2318      	movs	r3, #24
     7ea:	18fb      	adds	r3, r7, r3
     7ec:	3201      	adds	r2, #1
     7ee:	801a      	strh	r2, [r3, #0]
      ddF_x += 2;
     7f0:	231c      	movs	r3, #28
     7f2:	18fb      	adds	r3, r7, r3
     7f4:	881b      	ldrh	r3, [r3, #0]
     7f6:	3302      	adds	r3, #2
     7f8:	b29a      	uxth	r2, r3
     7fa:	231c      	movs	r3, #28
     7fc:	18fb      	adds	r3, r7, r3
     7fe:	801a      	strh	r2, [r3, #0]
      f += ddF_x;
     800:	231e      	movs	r3, #30
     802:	18fb      	adds	r3, r7, r3
     804:	881a      	ldrh	r2, [r3, #0]
     806:	231c      	movs	r3, #28
     808:	18fb      	adds	r3, r7, r3
     80a:	881b      	ldrh	r3, [r3, #0]
     80c:	18d3      	adds	r3, r2, r3
     80e:	b29a      	uxth	r2, r3
     810:	231e      	movs	r3, #30
     812:	18fb      	adds	r3, r7, r3
     814:	801a      	strh	r2, [r3, #0]

      u8g2_draw_circle_section(u8g2, x, y, x0, y0, option);    
     816:	230a      	movs	r3, #10
     818:	18fb      	adds	r3, r7, r3
     81a:	881c      	ldrh	r4, [r3, #0]
     81c:	2316      	movs	r3, #22
     81e:	18fb      	adds	r3, r7, r3
     820:	881a      	ldrh	r2, [r3, #0]
     822:	2318      	movs	r3, #24
     824:	18fb      	adds	r3, r7, r3
     826:	8819      	ldrh	r1, [r3, #0]
     828:	68f8      	ldr	r0, [r7, #12]
     82a:	2330      	movs	r3, #48	; 0x30
     82c:	18fb      	adds	r3, r7, r3
     82e:	781b      	ldrb	r3, [r3, #0]
     830:	9301      	str	r3, [sp, #4]
     832:	2308      	movs	r3, #8
     834:	18fb      	adds	r3, r7, r3
     836:	881b      	ldrh	r3, [r3, #0]
     838:	9300      	str	r3, [sp, #0]
     83a:	0023      	movs	r3, r4
     83c:	f7ff fe92 	bl	564 <u8g2_draw_circle_section>
    while ( x < y )
     840:	2318      	movs	r3, #24
     842:	18fa      	adds	r2, r7, r3
     844:	2316      	movs	r3, #22
     846:	18fb      	adds	r3, r7, r3
     848:	8812      	ldrh	r2, [r2, #0]
     84a:	881b      	ldrh	r3, [r3, #0]
     84c:	429a      	cmp	r2, r3
     84e:	d3a8      	bcc.n	7a2 <u8g2_draw_circle+0xb2>
    }
}
     850:	46c0      	nop			; (mov r8, r8)
     852:	46bd      	mov	sp, r7
     854:	b009      	add	sp, #36	; 0x24
     856:	bd90      	pop	{r4, r7, pc}

00000858 <u8g2_DrawCircle>:

void u8g2_DrawCircle(u8g2_t *u8g2, u8g2_uint_t x0, u8g2_uint_t y0, u8g2_uint_t rad, uint8_t option)
{
     858:	b5b0      	push	{r4, r5, r7, lr}
     85a:	b086      	sub	sp, #24
     85c:	af02      	add	r7, sp, #8
     85e:	60f8      	str	r0, [r7, #12]
     860:	000c      	movs	r4, r1
     862:	0010      	movs	r0, r2
     864:	0019      	movs	r1, r3
     866:	230a      	movs	r3, #10
     868:	18fb      	adds	r3, r7, r3
     86a:	1c22      	adds	r2, r4, #0
     86c:	801a      	strh	r2, [r3, #0]
     86e:	2308      	movs	r3, #8
     870:	18fb      	adds	r3, r7, r3
     872:	1c02      	adds	r2, r0, #0
     874:	801a      	strh	r2, [r3, #0]
     876:	1dbb      	adds	r3, r7, #6
     878:	1c0a      	adds	r2, r1, #0
     87a:	801a      	strh	r2, [r3, #0]
  /* check for bounding box */
#ifdef U8G2_WITH_INTERSECTION
  {
    if ( u8g2_IsIntersection(u8g2, x0-rad, y0-rad, x0+rad+1, y0+rad+1) == 0 ) 
     87c:	230a      	movs	r3, #10
     87e:	18fa      	adds	r2, r7, r3
     880:	1dbb      	adds	r3, r7, #6
     882:	8812      	ldrh	r2, [r2, #0]
     884:	881b      	ldrh	r3, [r3, #0]
     886:	1ad3      	subs	r3, r2, r3
     888:	b299      	uxth	r1, r3
     88a:	2308      	movs	r3, #8
     88c:	18fa      	adds	r2, r7, r3
     88e:	1dbb      	adds	r3, r7, #6
     890:	8812      	ldrh	r2, [r2, #0]
     892:	881b      	ldrh	r3, [r3, #0]
     894:	1ad3      	subs	r3, r2, r3
     896:	b29c      	uxth	r4, r3
     898:	230a      	movs	r3, #10
     89a:	18fa      	adds	r2, r7, r3
     89c:	1dbb      	adds	r3, r7, #6
     89e:	8812      	ldrh	r2, [r2, #0]
     8a0:	881b      	ldrh	r3, [r3, #0]
     8a2:	18d3      	adds	r3, r2, r3
     8a4:	b29b      	uxth	r3, r3
     8a6:	3301      	adds	r3, #1
     8a8:	b29d      	uxth	r5, r3
     8aa:	2308      	movs	r3, #8
     8ac:	18fa      	adds	r2, r7, r3
     8ae:	1dbb      	adds	r3, r7, #6
     8b0:	8812      	ldrh	r2, [r2, #0]
     8b2:	881b      	ldrh	r3, [r3, #0]
     8b4:	18d3      	adds	r3, r2, r3
     8b6:	b29b      	uxth	r3, r3
     8b8:	3301      	adds	r3, #1
     8ba:	b29b      	uxth	r3, r3
     8bc:	68f8      	ldr	r0, [r7, #12]
     8be:	9300      	str	r3, [sp, #0]
     8c0:	002b      	movs	r3, r5
     8c2:	0022      	movs	r2, r4
     8c4:	f001 fa0f 	bl	1ce6 <u8g2_IsIntersection>
     8c8:	1e03      	subs	r3, r0, #0
     8ca:	d010      	beq.n	8ee <u8g2_DrawCircle+0x96>
  }
#endif /* U8G2_WITH_INTERSECTION */
  
  
  /* draw circle */
  u8g2_draw_circle(u8g2, x0, y0, rad, option);
     8cc:	1dbb      	adds	r3, r7, #6
     8ce:	881c      	ldrh	r4, [r3, #0]
     8d0:	2308      	movs	r3, #8
     8d2:	18fb      	adds	r3, r7, r3
     8d4:	881a      	ldrh	r2, [r3, #0]
     8d6:	230a      	movs	r3, #10
     8d8:	18fb      	adds	r3, r7, r3
     8da:	8819      	ldrh	r1, [r3, #0]
     8dc:	68f8      	ldr	r0, [r7, #12]
     8de:	2320      	movs	r3, #32
     8e0:	18fb      	adds	r3, r7, r3
     8e2:	781b      	ldrb	r3, [r3, #0]
     8e4:	9300      	str	r3, [sp, #0]
     8e6:	0023      	movs	r3, r4
     8e8:	f7ff ff02 	bl	6f0 <u8g2_draw_circle>
     8ec:	e000      	b.n	8f0 <u8g2_DrawCircle+0x98>
      return;
     8ee:	46c0      	nop			; (mov r8, r8)
}
     8f0:	46bd      	mov	sp, r7
     8f2:	b004      	add	sp, #16
     8f4:	bdb0      	pop	{r4, r5, r7, pc}
	...

000008f8 <u8g2_m_32_7_f>:
  *page_cnt = 2;
  return buf;
  #endif
}
uint8_t *u8g2_m_32_7_f(uint8_t *page_cnt)
{
     8f8:	b580      	push	{r7, lr}
     8fa:	b082      	sub	sp, #8
     8fc:	af00      	add	r7, sp, #0
     8fe:	6078      	str	r0, [r7, #4]
  #ifdef U8G2_USE_DYNAMIC_ALLOC
  *page_cnt = 7;
  return 0;
  #else
  static uint8_t buf[1792];
  *page_cnt = 7;
     900:	687b      	ldr	r3, [r7, #4]
     902:	2207      	movs	r2, #7
     904:	701a      	strb	r2, [r3, #0]
  return buf;
     906:	4b02      	ldr	r3, [pc, #8]	; (910 <u8g2_m_32_7_f+0x18>)
  #endif
}
     908:	0018      	movs	r0, r3
     90a:	46bd      	mov	sp, r7
     90c:	b002      	add	sp, #8
     90e:	bd80      	pop	{r7, pc}
     910:	20000094 	.word	0x20000094

00000914 <u8g2_Setup_gp1287ai_256x50_f>:
  buf = u8g2_m_32_7_2(&tile_buf_height);
  u8g2_SetupBuffer(u8g2, buf, tile_buf_height, u8g2_ll_hvline_vertical_top_lsb, rotation);
}
/* gp1287ai f */
void u8g2_Setup_gp1287ai_256x50_f(u8g2_t *u8g2, const u8g2_cb_t *rotation, u8x8_msg_cb byte_cb, u8x8_msg_cb gpio_and_delay_cb)
{
     914:	b590      	push	{r4, r7, lr}
     916:	b089      	sub	sp, #36	; 0x24
     918:	af02      	add	r7, sp, #8
     91a:	60f8      	str	r0, [r7, #12]
     91c:	60b9      	str	r1, [r7, #8]
     91e:	607a      	str	r2, [r7, #4]
     920:	603b      	str	r3, [r7, #0]
  uint8_t tile_buf_height;
  uint8_t *buf;
  u8g2_SetupDisplay(u8g2, u8x8_d_gp1287ai_256x50, u8x8_cad_empty, byte_cb, gpio_and_delay_cb);
     922:	687c      	ldr	r4, [r7, #4]
     924:	4a0e      	ldr	r2, [pc, #56]	; (960 <u8g2_Setup_gp1287ai_256x50_f+0x4c>)
     926:	490f      	ldr	r1, [pc, #60]	; (964 <u8g2_Setup_gp1287ai_256x50_f+0x50>)
     928:	68f8      	ldr	r0, [r7, #12]
     92a:	683b      	ldr	r3, [r7, #0]
     92c:	9300      	str	r3, [sp, #0]
     92e:	0023      	movs	r3, r4
     930:	f002 fac4 	bl	2ebc <u8x8_Setup>
  buf = u8g2_m_32_7_f(&tile_buf_height);
     934:	2313      	movs	r3, #19
     936:	18fb      	adds	r3, r7, r3
     938:	0018      	movs	r0, r3
     93a:	f7ff ffdd 	bl	8f8 <u8g2_m_32_7_f>
     93e:	0003      	movs	r3, r0
     940:	617b      	str	r3, [r7, #20]
  u8g2_SetupBuffer(u8g2, buf, tile_buf_height, u8g2_ll_hvline_vertical_top_lsb, rotation);
     942:	2313      	movs	r3, #19
     944:	18fb      	adds	r3, r7, r3
     946:	781a      	ldrb	r2, [r3, #0]
     948:	4c07      	ldr	r4, [pc, #28]	; (968 <u8g2_Setup_gp1287ai_256x50_f+0x54>)
     94a:	6979      	ldr	r1, [r7, #20]
     94c:	68f8      	ldr	r0, [r7, #12]
     94e:	68bb      	ldr	r3, [r7, #8]
     950:	9300      	str	r3, [sp, #0]
     952:	0023      	movs	r3, r4
     954:	f001 fc4e 	bl	21f4 <u8g2_SetupBuffer>
}
     958:	46c0      	nop			; (mov r8, r8)
     95a:	46bd      	mov	sp, r7
     95c:	b007      	add	sp, #28
     95e:	bd90      	pop	{r4, r7, pc}
     960:	0000270d 	.word	0x0000270d
     964:	00002d89 	.word	0x00002d89
     968:	00001fd1 	.word	0x00001fd1

0000096c <u8g2_font_get_byte>:
/* low level byte and word access */

/* removed NOINLINE, because it leads to smaller code, might also be faster */
//static uint8_t u8g2_font_get_byte(const uint8_t *font, uint8_t offset) U8G2_NOINLINE;
static uint8_t u8g2_font_get_byte(const uint8_t *font, uint8_t offset)
{
     96c:	b580      	push	{r7, lr}
     96e:	b082      	sub	sp, #8
     970:	af00      	add	r7, sp, #0
     972:	6078      	str	r0, [r7, #4]
     974:	000a      	movs	r2, r1
     976:	1cfb      	adds	r3, r7, #3
     978:	701a      	strb	r2, [r3, #0]
  font += offset;
     97a:	1cfb      	adds	r3, r7, #3
     97c:	781b      	ldrb	r3, [r3, #0]
     97e:	687a      	ldr	r2, [r7, #4]
     980:	18d3      	adds	r3, r2, r3
     982:	607b      	str	r3, [r7, #4]
  return u8x8_pgm_read( font );  
     984:	687b      	ldr	r3, [r7, #4]
     986:	781b      	ldrb	r3, [r3, #0]
}
     988:	0018      	movs	r0, r3
     98a:	46bd      	mov	sp, r7
     98c:	b002      	add	sp, #8
     98e:	bd80      	pop	{r7, pc}

00000990 <u8g2_font_get_word>:

static uint16_t u8g2_font_get_word(const uint8_t *font, uint8_t offset) U8G2_NOINLINE; 
static uint16_t u8g2_font_get_word(const uint8_t *font, uint8_t offset)
{
     990:	b580      	push	{r7, lr}
     992:	b084      	sub	sp, #16
     994:	af00      	add	r7, sp, #0
     996:	6078      	str	r0, [r7, #4]
     998:	000a      	movs	r2, r1
     99a:	1cfb      	adds	r3, r7, #3
     99c:	701a      	strb	r2, [r3, #0]
    uint16_t pos;
    font += offset;
     99e:	1cfb      	adds	r3, r7, #3
     9a0:	781b      	ldrb	r3, [r3, #0]
     9a2:	687a      	ldr	r2, [r7, #4]
     9a4:	18d3      	adds	r3, r2, r3
     9a6:	607b      	str	r3, [r7, #4]
    pos = u8x8_pgm_read( font );
     9a8:	687b      	ldr	r3, [r7, #4]
     9aa:	781a      	ldrb	r2, [r3, #0]
     9ac:	230e      	movs	r3, #14
     9ae:	18fb      	adds	r3, r7, r3
     9b0:	801a      	strh	r2, [r3, #0]
    font++;
     9b2:	687b      	ldr	r3, [r7, #4]
     9b4:	3301      	adds	r3, #1
     9b6:	607b      	str	r3, [r7, #4]
    pos <<= 8;
     9b8:	230e      	movs	r3, #14
     9ba:	18fb      	adds	r3, r7, r3
     9bc:	220e      	movs	r2, #14
     9be:	18ba      	adds	r2, r7, r2
     9c0:	8812      	ldrh	r2, [r2, #0]
     9c2:	0212      	lsls	r2, r2, #8
     9c4:	801a      	strh	r2, [r3, #0]
    pos += u8x8_pgm_read( font);
     9c6:	687b      	ldr	r3, [r7, #4]
     9c8:	781b      	ldrb	r3, [r3, #0]
     9ca:	b299      	uxth	r1, r3
     9cc:	230e      	movs	r3, #14
     9ce:	18fb      	adds	r3, r7, r3
     9d0:	220e      	movs	r2, #14
     9d2:	18ba      	adds	r2, r7, r2
     9d4:	8812      	ldrh	r2, [r2, #0]
     9d6:	188a      	adds	r2, r1, r2
     9d8:	801a      	strh	r2, [r3, #0]
    return pos;
     9da:	230e      	movs	r3, #14
     9dc:	18fb      	adds	r3, r7, r3
     9de:	881b      	ldrh	r3, [r3, #0]
}
     9e0:	0018      	movs	r0, r3
     9e2:	46bd      	mov	sp, r7
     9e4:	b004      	add	sp, #16
     9e6:	bd80      	pop	{r7, pc}

000009e8 <u8g2_read_font_info>:

/*========================================================================*/
/* new font format */
void u8g2_read_font_info(u8g2_font_info_t *font_info, const uint8_t *font)
{
     9e8:	b580      	push	{r7, lr}
     9ea:	b082      	sub	sp, #8
     9ec:	af00      	add	r7, sp, #0
     9ee:	6078      	str	r0, [r7, #4]
     9f0:	6039      	str	r1, [r7, #0]
  /* offset 0 */
  font_info->glyph_cnt = u8g2_font_get_byte(font, 0);
     9f2:	683b      	ldr	r3, [r7, #0]
     9f4:	2100      	movs	r1, #0
     9f6:	0018      	movs	r0, r3
     9f8:	f7ff ffb8 	bl	96c <u8g2_font_get_byte>
     9fc:	0003      	movs	r3, r0
     9fe:	001a      	movs	r2, r3
     a00:	687b      	ldr	r3, [r7, #4]
     a02:	701a      	strb	r2, [r3, #0]
  font_info->bbx_mode = u8g2_font_get_byte(font, 1);
     a04:	683b      	ldr	r3, [r7, #0]
     a06:	2101      	movs	r1, #1
     a08:	0018      	movs	r0, r3
     a0a:	f7ff ffaf 	bl	96c <u8g2_font_get_byte>
     a0e:	0003      	movs	r3, r0
     a10:	001a      	movs	r2, r3
     a12:	687b      	ldr	r3, [r7, #4]
     a14:	705a      	strb	r2, [r3, #1]
  font_info->bits_per_0 = u8g2_font_get_byte(font, 2);
     a16:	683b      	ldr	r3, [r7, #0]
     a18:	2102      	movs	r1, #2
     a1a:	0018      	movs	r0, r3
     a1c:	f7ff ffa6 	bl	96c <u8g2_font_get_byte>
     a20:	0003      	movs	r3, r0
     a22:	001a      	movs	r2, r3
     a24:	687b      	ldr	r3, [r7, #4]
     a26:	709a      	strb	r2, [r3, #2]
  font_info->bits_per_1 = u8g2_font_get_byte(font, 3);
     a28:	683b      	ldr	r3, [r7, #0]
     a2a:	2103      	movs	r1, #3
     a2c:	0018      	movs	r0, r3
     a2e:	f7ff ff9d 	bl	96c <u8g2_font_get_byte>
     a32:	0003      	movs	r3, r0
     a34:	001a      	movs	r2, r3
     a36:	687b      	ldr	r3, [r7, #4]
     a38:	70da      	strb	r2, [r3, #3]
  
  /* offset 4 */
  font_info->bits_per_char_width = u8g2_font_get_byte(font, 4);
     a3a:	683b      	ldr	r3, [r7, #0]
     a3c:	2104      	movs	r1, #4
     a3e:	0018      	movs	r0, r3
     a40:	f7ff ff94 	bl	96c <u8g2_font_get_byte>
     a44:	0003      	movs	r3, r0
     a46:	001a      	movs	r2, r3
     a48:	687b      	ldr	r3, [r7, #4]
     a4a:	711a      	strb	r2, [r3, #4]
  font_info->bits_per_char_height = u8g2_font_get_byte(font, 5);
     a4c:	683b      	ldr	r3, [r7, #0]
     a4e:	2105      	movs	r1, #5
     a50:	0018      	movs	r0, r3
     a52:	f7ff ff8b 	bl	96c <u8g2_font_get_byte>
     a56:	0003      	movs	r3, r0
     a58:	001a      	movs	r2, r3
     a5a:	687b      	ldr	r3, [r7, #4]
     a5c:	715a      	strb	r2, [r3, #5]
  font_info->bits_per_char_x = u8g2_font_get_byte(font, 6);
     a5e:	683b      	ldr	r3, [r7, #0]
     a60:	2106      	movs	r1, #6
     a62:	0018      	movs	r0, r3
     a64:	f7ff ff82 	bl	96c <u8g2_font_get_byte>
     a68:	0003      	movs	r3, r0
     a6a:	001a      	movs	r2, r3
     a6c:	687b      	ldr	r3, [r7, #4]
     a6e:	719a      	strb	r2, [r3, #6]
  font_info->bits_per_char_y = u8g2_font_get_byte(font, 7);
     a70:	683b      	ldr	r3, [r7, #0]
     a72:	2107      	movs	r1, #7
     a74:	0018      	movs	r0, r3
     a76:	f7ff ff79 	bl	96c <u8g2_font_get_byte>
     a7a:	0003      	movs	r3, r0
     a7c:	001a      	movs	r2, r3
     a7e:	687b      	ldr	r3, [r7, #4]
     a80:	71da      	strb	r2, [r3, #7]
  font_info->bits_per_delta_x = u8g2_font_get_byte(font, 8);
     a82:	683b      	ldr	r3, [r7, #0]
     a84:	2108      	movs	r1, #8
     a86:	0018      	movs	r0, r3
     a88:	f7ff ff70 	bl	96c <u8g2_font_get_byte>
     a8c:	0003      	movs	r3, r0
     a8e:	001a      	movs	r2, r3
     a90:	687b      	ldr	r3, [r7, #4]
     a92:	721a      	strb	r2, [r3, #8]
  
  /* offset 9 */
  font_info->max_char_width = u8g2_font_get_byte(font, 9);
     a94:	683b      	ldr	r3, [r7, #0]
     a96:	2109      	movs	r1, #9
     a98:	0018      	movs	r0, r3
     a9a:	f7ff ff67 	bl	96c <u8g2_font_get_byte>
     a9e:	0003      	movs	r3, r0
     aa0:	b25a      	sxtb	r2, r3
     aa2:	687b      	ldr	r3, [r7, #4]
     aa4:	725a      	strb	r2, [r3, #9]
  font_info->max_char_height = u8g2_font_get_byte(font, 10);
     aa6:	683b      	ldr	r3, [r7, #0]
     aa8:	210a      	movs	r1, #10
     aaa:	0018      	movs	r0, r3
     aac:	f7ff ff5e 	bl	96c <u8g2_font_get_byte>
     ab0:	0003      	movs	r3, r0
     ab2:	b25a      	sxtb	r2, r3
     ab4:	687b      	ldr	r3, [r7, #4]
     ab6:	729a      	strb	r2, [r3, #10]
  font_info->x_offset = u8g2_font_get_byte(font, 11);
     ab8:	683b      	ldr	r3, [r7, #0]
     aba:	210b      	movs	r1, #11
     abc:	0018      	movs	r0, r3
     abe:	f7ff ff55 	bl	96c <u8g2_font_get_byte>
     ac2:	0003      	movs	r3, r0
     ac4:	b25a      	sxtb	r2, r3
     ac6:	687b      	ldr	r3, [r7, #4]
     ac8:	72da      	strb	r2, [r3, #11]
  font_info->y_offset = u8g2_font_get_byte(font, 12);
     aca:	683b      	ldr	r3, [r7, #0]
     acc:	210c      	movs	r1, #12
     ace:	0018      	movs	r0, r3
     ad0:	f7ff ff4c 	bl	96c <u8g2_font_get_byte>
     ad4:	0003      	movs	r3, r0
     ad6:	b25a      	sxtb	r2, r3
     ad8:	687b      	ldr	r3, [r7, #4]
     ada:	731a      	strb	r2, [r3, #12]
  
  /* offset 13 */
  font_info->ascent_A = u8g2_font_get_byte(font, 13);
     adc:	683b      	ldr	r3, [r7, #0]
     ade:	210d      	movs	r1, #13
     ae0:	0018      	movs	r0, r3
     ae2:	f7ff ff43 	bl	96c <u8g2_font_get_byte>
     ae6:	0003      	movs	r3, r0
     ae8:	b25a      	sxtb	r2, r3
     aea:	687b      	ldr	r3, [r7, #4]
     aec:	735a      	strb	r2, [r3, #13]
  font_info->descent_g = u8g2_font_get_byte(font, 14);
     aee:	683b      	ldr	r3, [r7, #0]
     af0:	210e      	movs	r1, #14
     af2:	0018      	movs	r0, r3
     af4:	f7ff ff3a 	bl	96c <u8g2_font_get_byte>
     af8:	0003      	movs	r3, r0
     afa:	b25a      	sxtb	r2, r3
     afc:	687b      	ldr	r3, [r7, #4]
     afe:	739a      	strb	r2, [r3, #14]
  font_info->ascent_para = u8g2_font_get_byte(font, 15);
     b00:	683b      	ldr	r3, [r7, #0]
     b02:	210f      	movs	r1, #15
     b04:	0018      	movs	r0, r3
     b06:	f7ff ff31 	bl	96c <u8g2_font_get_byte>
     b0a:	0003      	movs	r3, r0
     b0c:	b25a      	sxtb	r2, r3
     b0e:	687b      	ldr	r3, [r7, #4]
     b10:	73da      	strb	r2, [r3, #15]
  font_info->descent_para = u8g2_font_get_byte(font, 16);
     b12:	683b      	ldr	r3, [r7, #0]
     b14:	2110      	movs	r1, #16
     b16:	0018      	movs	r0, r3
     b18:	f7ff ff28 	bl	96c <u8g2_font_get_byte>
     b1c:	0003      	movs	r3, r0
     b1e:	b25a      	sxtb	r2, r3
     b20:	687b      	ldr	r3, [r7, #4]
     b22:	741a      	strb	r2, [r3, #16]
  
  /* offset 17 */
  font_info->start_pos_upper_A = u8g2_font_get_word(font, 17);
     b24:	683b      	ldr	r3, [r7, #0]
     b26:	2111      	movs	r1, #17
     b28:	0018      	movs	r0, r3
     b2a:	f7ff ff31 	bl	990 <u8g2_font_get_word>
     b2e:	0003      	movs	r3, r0
     b30:	001a      	movs	r2, r3
     b32:	687b      	ldr	r3, [r7, #4]
     b34:	825a      	strh	r2, [r3, #18]
  font_info->start_pos_lower_a = u8g2_font_get_word(font, 19); 
     b36:	683b      	ldr	r3, [r7, #0]
     b38:	2113      	movs	r1, #19
     b3a:	0018      	movs	r0, r3
     b3c:	f7ff ff28 	bl	990 <u8g2_font_get_word>
     b40:	0003      	movs	r3, r0
     b42:	001a      	movs	r2, r3
     b44:	687b      	ldr	r3, [r7, #4]
     b46:	829a      	strh	r2, [r3, #20]
  
  /* offset 21 */
#ifdef U8G2_WITH_UNICODE
  font_info->start_pos_unicode = u8g2_font_get_word(font, 21); 
     b48:	683b      	ldr	r3, [r7, #0]
     b4a:	2115      	movs	r1, #21
     b4c:	0018      	movs	r0, r3
     b4e:	f7ff ff1f 	bl	990 <u8g2_font_get_word>
     b52:	0003      	movs	r3, r0
     b54:	001a      	movs	r2, r3
     b56:	687b      	ldr	r3, [r7, #4]
     b58:	82da      	strh	r2, [r3, #22]
#endif
}
     b5a:	46c0      	nop			; (mov r8, r8)
     b5c:	46bd      	mov	sp, r7
     b5e:	b002      	add	sp, #8
     b60:	bd80      	pop	{r7, pc}

00000b62 <u8g2_font_decode_get_unsigned_bits>:
/*========================================================================*/
/* glyph handling */

/* optimized */
uint8_t u8g2_font_decode_get_unsigned_bits(u8g2_font_decode_t *f, uint8_t cnt) 
{
     b62:	b580      	push	{r7, lr}
     b64:	b084      	sub	sp, #16
     b66:	af00      	add	r7, sp, #0
     b68:	6078      	str	r0, [r7, #4]
     b6a:	000a      	movs	r2, r1
     b6c:	1cfb      	adds	r3, r7, #3
     b6e:	701a      	strb	r2, [r3, #0]
  uint8_t val;
  uint8_t bit_pos = f->decode_bit_pos;
     b70:	230d      	movs	r3, #13
     b72:	18fb      	adds	r3, r7, r3
     b74:	687a      	ldr	r2, [r7, #4]
     b76:	7b12      	ldrb	r2, [r2, #12]
     b78:	701a      	strb	r2, [r3, #0]
  uint8_t bit_pos_plus_cnt;
  
  //val = *(f->decode_ptr);
  val = u8x8_pgm_read( f->decode_ptr );  
     b7a:	687b      	ldr	r3, [r7, #4]
     b7c:	681a      	ldr	r2, [r3, #0]
     b7e:	230f      	movs	r3, #15
     b80:	18fb      	adds	r3, r7, r3
     b82:	7812      	ldrb	r2, [r2, #0]
     b84:	701a      	strb	r2, [r3, #0]
  
  val >>= bit_pos;
     b86:	230f      	movs	r3, #15
     b88:	18fb      	adds	r3, r7, r3
     b8a:	781a      	ldrb	r2, [r3, #0]
     b8c:	230d      	movs	r3, #13
     b8e:	18fb      	adds	r3, r7, r3
     b90:	781b      	ldrb	r3, [r3, #0]
     b92:	411a      	asrs	r2, r3
     b94:	230f      	movs	r3, #15
     b96:	18fb      	adds	r3, r7, r3
     b98:	701a      	strb	r2, [r3, #0]
  bit_pos_plus_cnt = bit_pos;
     b9a:	230e      	movs	r3, #14
     b9c:	18fb      	adds	r3, r7, r3
     b9e:	220d      	movs	r2, #13
     ba0:	18ba      	adds	r2, r7, r2
     ba2:	7812      	ldrb	r2, [r2, #0]
     ba4:	701a      	strb	r2, [r3, #0]
  bit_pos_plus_cnt += cnt;
     ba6:	230e      	movs	r3, #14
     ba8:	18fb      	adds	r3, r7, r3
     baa:	220e      	movs	r2, #14
     bac:	18b9      	adds	r1, r7, r2
     bae:	1cfa      	adds	r2, r7, #3
     bb0:	7809      	ldrb	r1, [r1, #0]
     bb2:	7812      	ldrb	r2, [r2, #0]
     bb4:	188a      	adds	r2, r1, r2
     bb6:	701a      	strb	r2, [r3, #0]
  if ( bit_pos_plus_cnt >= 8 )
     bb8:	230e      	movs	r3, #14
     bba:	18fb      	adds	r3, r7, r3
     bbc:	781b      	ldrb	r3, [r3, #0]
     bbe:	2b07      	cmp	r3, #7
     bc0:	d92c      	bls.n	c1c <u8g2_font_decode_get_unsigned_bits+0xba>
  {
    uint8_t s = 8;
     bc2:	230c      	movs	r3, #12
     bc4:	18fb      	adds	r3, r7, r3
     bc6:	2208      	movs	r2, #8
     bc8:	701a      	strb	r2, [r3, #0]
    s -= bit_pos;
     bca:	230c      	movs	r3, #12
     bcc:	18fb      	adds	r3, r7, r3
     bce:	220c      	movs	r2, #12
     bd0:	18b9      	adds	r1, r7, r2
     bd2:	220d      	movs	r2, #13
     bd4:	18ba      	adds	r2, r7, r2
     bd6:	7809      	ldrb	r1, [r1, #0]
     bd8:	7812      	ldrb	r2, [r2, #0]
     bda:	1a8a      	subs	r2, r1, r2
     bdc:	701a      	strb	r2, [r3, #0]
    f->decode_ptr++;
     bde:	687b      	ldr	r3, [r7, #4]
     be0:	681b      	ldr	r3, [r3, #0]
     be2:	1c5a      	adds	r2, r3, #1
     be4:	687b      	ldr	r3, [r7, #4]
     be6:	601a      	str	r2, [r3, #0]
    //val |= *(f->decode_ptr) << (8-bit_pos);
    val |= u8x8_pgm_read( f->decode_ptr ) << (s);
     be8:	687b      	ldr	r3, [r7, #4]
     bea:	681b      	ldr	r3, [r3, #0]
     bec:	781b      	ldrb	r3, [r3, #0]
     bee:	001a      	movs	r2, r3
     bf0:	230c      	movs	r3, #12
     bf2:	18fb      	adds	r3, r7, r3
     bf4:	781b      	ldrb	r3, [r3, #0]
     bf6:	409a      	lsls	r2, r3
     bf8:	0013      	movs	r3, r2
     bfa:	b25a      	sxtb	r2, r3
     bfc:	230f      	movs	r3, #15
     bfe:	18fb      	adds	r3, r7, r3
     c00:	781b      	ldrb	r3, [r3, #0]
     c02:	b25b      	sxtb	r3, r3
     c04:	4313      	orrs	r3, r2
     c06:	b25a      	sxtb	r2, r3
     c08:	230f      	movs	r3, #15
     c0a:	18fb      	adds	r3, r7, r3
     c0c:	701a      	strb	r2, [r3, #0]
    //bit_pos -= 8;
    bit_pos_plus_cnt -= 8;
     c0e:	230e      	movs	r3, #14
     c10:	18fb      	adds	r3, r7, r3
     c12:	220e      	movs	r2, #14
     c14:	18ba      	adds	r2, r7, r2
     c16:	7812      	ldrb	r2, [r2, #0]
     c18:	3a08      	subs	r2, #8
     c1a:	701a      	strb	r2, [r3, #0]
  }
  val &= (1U<<cnt)-1;
     c1c:	1cfb      	adds	r3, r7, #3
     c1e:	781b      	ldrb	r3, [r3, #0]
     c20:	2201      	movs	r2, #1
     c22:	409a      	lsls	r2, r3
     c24:	0013      	movs	r3, r2
     c26:	b2db      	uxtb	r3, r3
     c28:	3b01      	subs	r3, #1
     c2a:	b2da      	uxtb	r2, r3
     c2c:	230f      	movs	r3, #15
     c2e:	18fb      	adds	r3, r7, r3
     c30:	210f      	movs	r1, #15
     c32:	1879      	adds	r1, r7, r1
     c34:	7809      	ldrb	r1, [r1, #0]
     c36:	400a      	ands	r2, r1
     c38:	701a      	strb	r2, [r3, #0]
  //bit_pos += cnt;
  
  f->decode_bit_pos = bit_pos_plus_cnt;
     c3a:	687b      	ldr	r3, [r7, #4]
     c3c:	220e      	movs	r2, #14
     c3e:	18ba      	adds	r2, r7, r2
     c40:	7812      	ldrb	r2, [r2, #0]
     c42:	731a      	strb	r2, [r3, #12]
  return val;
     c44:	230f      	movs	r3, #15
     c46:	18fb      	adds	r3, r7, r3
     c48:	781b      	ldrb	r3, [r3, #0]
}
     c4a:	0018      	movs	r0, r3
     c4c:	46bd      	mov	sp, r7
     c4e:	b004      	add	sp, #16
     c50:	bd80      	pop	{r7, pc}

00000c52 <u8g2_font_decode_get_signed_bits>:
	r = bits(x)+1;

*/
/* optimized */
int8_t u8g2_font_decode_get_signed_bits(u8g2_font_decode_t *f, uint8_t cnt)
{
     c52:	b580      	push	{r7, lr}
     c54:	b084      	sub	sp, #16
     c56:	af00      	add	r7, sp, #0
     c58:	6078      	str	r0, [r7, #4]
     c5a:	000a      	movs	r2, r1
     c5c:	1cfb      	adds	r3, r7, #3
     c5e:	701a      	strb	r2, [r3, #0]
  int8_t v, d;
  v = (int8_t)u8g2_font_decode_get_unsigned_bits(f, cnt);
     c60:	1cfb      	adds	r3, r7, #3
     c62:	781a      	ldrb	r2, [r3, #0]
     c64:	687b      	ldr	r3, [r7, #4]
     c66:	0011      	movs	r1, r2
     c68:	0018      	movs	r0, r3
     c6a:	f7ff ff7a 	bl	b62 <u8g2_font_decode_get_unsigned_bits>
     c6e:	0003      	movs	r3, r0
     c70:	001a      	movs	r2, r3
     c72:	230f      	movs	r3, #15
     c74:	18fb      	adds	r3, r7, r3
     c76:	701a      	strb	r2, [r3, #0]
  d = 1;
     c78:	230e      	movs	r3, #14
     c7a:	18fb      	adds	r3, r7, r3
     c7c:	2201      	movs	r2, #1
     c7e:	701a      	strb	r2, [r3, #0]
  cnt--;
     c80:	1cfb      	adds	r3, r7, #3
     c82:	781a      	ldrb	r2, [r3, #0]
     c84:	1cfb      	adds	r3, r7, #3
     c86:	3a01      	subs	r2, #1
     c88:	701a      	strb	r2, [r3, #0]
  d <<= cnt;
     c8a:	230e      	movs	r3, #14
     c8c:	18fb      	adds	r3, r7, r3
     c8e:	2200      	movs	r2, #0
     c90:	569a      	ldrsb	r2, [r3, r2]
     c92:	1cfb      	adds	r3, r7, #3
     c94:	781b      	ldrb	r3, [r3, #0]
     c96:	409a      	lsls	r2, r3
     c98:	230e      	movs	r3, #14
     c9a:	18fb      	adds	r3, r7, r3
     c9c:	701a      	strb	r2, [r3, #0]
  v -= d;
     c9e:	230f      	movs	r3, #15
     ca0:	18fb      	adds	r3, r7, r3
     ca2:	781a      	ldrb	r2, [r3, #0]
     ca4:	230e      	movs	r3, #14
     ca6:	18fb      	adds	r3, r7, r3
     ca8:	781b      	ldrb	r3, [r3, #0]
     caa:	1ad3      	subs	r3, r2, r3
     cac:	b2da      	uxtb	r2, r3
     cae:	230f      	movs	r3, #15
     cb0:	18fb      	adds	r3, r7, r3
     cb2:	701a      	strb	r2, [r3, #0]
  return v;
     cb4:	230f      	movs	r3, #15
     cb6:	18fb      	adds	r3, r7, r3
     cb8:	781b      	ldrb	r3, [r3, #0]
     cba:	b25b      	sxtb	r3, r3
  //return (int8_t)u8g2_font_decode_get_unsigned_bits(f, cnt) - ((1<<cnt)>>1);
}
     cbc:	0018      	movs	r0, r3
     cbe:	46bd      	mov	sp, r7
     cc0:	b004      	add	sp, #16
     cc2:	bd80      	pop	{r7, pc}

00000cc4 <u8g2_add_vector_y>:


#ifdef U8G2_WITH_FONT_ROTATION
u8g2_uint_t u8g2_add_vector_y(u8g2_uint_t dy, int8_t x, int8_t y, uint8_t dir)
{
     cc4:	b5b0      	push	{r4, r5, r7, lr}
     cc6:	b082      	sub	sp, #8
     cc8:	af00      	add	r7, sp, #0
     cca:	0005      	movs	r5, r0
     ccc:	000c      	movs	r4, r1
     cce:	0010      	movs	r0, r2
     cd0:	0019      	movs	r1, r3
     cd2:	1dbb      	adds	r3, r7, #6
     cd4:	1c2a      	adds	r2, r5, #0
     cd6:	801a      	strh	r2, [r3, #0]
     cd8:	1d7b      	adds	r3, r7, #5
     cda:	1c22      	adds	r2, r4, #0
     cdc:	701a      	strb	r2, [r3, #0]
     cde:	1d3b      	adds	r3, r7, #4
     ce0:	1c02      	adds	r2, r0, #0
     ce2:	701a      	strb	r2, [r3, #0]
     ce4:	1cfb      	adds	r3, r7, #3
     ce6:	1c0a      	adds	r2, r1, #0
     ce8:	701a      	strb	r2, [r3, #0]
  switch(dir)
     cea:	1cfb      	adds	r3, r7, #3
     cec:	781b      	ldrb	r3, [r3, #0]
     cee:	2b01      	cmp	r3, #1
     cf0:	d00d      	beq.n	d0e <u8g2_add_vector_y+0x4a>
     cf2:	2b02      	cmp	r3, #2
     cf4:	d015      	beq.n	d22 <u8g2_add_vector_y+0x5e>
     cf6:	2b00      	cmp	r3, #0
     cf8:	d11d      	bne.n	d36 <u8g2_add_vector_y+0x72>
  {
    case 0:
      dy += y;
     cfa:	1d3b      	adds	r3, r7, #4
     cfc:	781b      	ldrb	r3, [r3, #0]
     cfe:	b25b      	sxtb	r3, r3
     d00:	b299      	uxth	r1, r3
     d02:	1dbb      	adds	r3, r7, #6
     d04:	1dba      	adds	r2, r7, #6
     d06:	8812      	ldrh	r2, [r2, #0]
     d08:	188a      	adds	r2, r1, r2
     d0a:	801a      	strh	r2, [r3, #0]
      break;
     d0c:	e01d      	b.n	d4a <u8g2_add_vector_y+0x86>
    case 1:
      dy += x;
     d0e:	1d7b      	adds	r3, r7, #5
     d10:	781b      	ldrb	r3, [r3, #0]
     d12:	b25b      	sxtb	r3, r3
     d14:	b299      	uxth	r1, r3
     d16:	1dbb      	adds	r3, r7, #6
     d18:	1dba      	adds	r2, r7, #6
     d1a:	8812      	ldrh	r2, [r2, #0]
     d1c:	188a      	adds	r2, r1, r2
     d1e:	801a      	strh	r2, [r3, #0]
      break;
     d20:	e013      	b.n	d4a <u8g2_add_vector_y+0x86>
    case 2:
      dy -= y;
     d22:	1d3b      	adds	r3, r7, #4
     d24:	781b      	ldrb	r3, [r3, #0]
     d26:	b25b      	sxtb	r3, r3
     d28:	b29a      	uxth	r2, r3
     d2a:	1dbb      	adds	r3, r7, #6
     d2c:	1db9      	adds	r1, r7, #6
     d2e:	8809      	ldrh	r1, [r1, #0]
     d30:	1a8a      	subs	r2, r1, r2
     d32:	801a      	strh	r2, [r3, #0]
      break;
     d34:	e009      	b.n	d4a <u8g2_add_vector_y+0x86>
    default:
      dy -= x;
     d36:	1d7b      	adds	r3, r7, #5
     d38:	781b      	ldrb	r3, [r3, #0]
     d3a:	b25b      	sxtb	r3, r3
     d3c:	b29a      	uxth	r2, r3
     d3e:	1dbb      	adds	r3, r7, #6
     d40:	1db9      	adds	r1, r7, #6
     d42:	8809      	ldrh	r1, [r1, #0]
     d44:	1a8a      	subs	r2, r1, r2
     d46:	801a      	strh	r2, [r3, #0]
      break;      
     d48:	46c0      	nop			; (mov r8, r8)
  }
  return dy;
     d4a:	1dbb      	adds	r3, r7, #6
     d4c:	881b      	ldrh	r3, [r3, #0]
}
     d4e:	0018      	movs	r0, r3
     d50:	46bd      	mov	sp, r7
     d52:	b002      	add	sp, #8
     d54:	bdb0      	pop	{r4, r5, r7, pc}

00000d56 <u8g2_add_vector_x>:

u8g2_uint_t u8g2_add_vector_x(u8g2_uint_t dx, int8_t x, int8_t y, uint8_t dir)
{
     d56:	b5b0      	push	{r4, r5, r7, lr}
     d58:	b082      	sub	sp, #8
     d5a:	af00      	add	r7, sp, #0
     d5c:	0005      	movs	r5, r0
     d5e:	000c      	movs	r4, r1
     d60:	0010      	movs	r0, r2
     d62:	0019      	movs	r1, r3
     d64:	1dbb      	adds	r3, r7, #6
     d66:	1c2a      	adds	r2, r5, #0
     d68:	801a      	strh	r2, [r3, #0]
     d6a:	1d7b      	adds	r3, r7, #5
     d6c:	1c22      	adds	r2, r4, #0
     d6e:	701a      	strb	r2, [r3, #0]
     d70:	1d3b      	adds	r3, r7, #4
     d72:	1c02      	adds	r2, r0, #0
     d74:	701a      	strb	r2, [r3, #0]
     d76:	1cfb      	adds	r3, r7, #3
     d78:	1c0a      	adds	r2, r1, #0
     d7a:	701a      	strb	r2, [r3, #0]
  switch(dir)
     d7c:	1cfb      	adds	r3, r7, #3
     d7e:	781b      	ldrb	r3, [r3, #0]
     d80:	2b01      	cmp	r3, #1
     d82:	d00d      	beq.n	da0 <u8g2_add_vector_x+0x4a>
     d84:	2b02      	cmp	r3, #2
     d86:	d015      	beq.n	db4 <u8g2_add_vector_x+0x5e>
     d88:	2b00      	cmp	r3, #0
     d8a:	d11d      	bne.n	dc8 <u8g2_add_vector_x+0x72>
  {
    case 0:
      dx += x;
     d8c:	1d7b      	adds	r3, r7, #5
     d8e:	781b      	ldrb	r3, [r3, #0]
     d90:	b25b      	sxtb	r3, r3
     d92:	b299      	uxth	r1, r3
     d94:	1dbb      	adds	r3, r7, #6
     d96:	1dba      	adds	r2, r7, #6
     d98:	8812      	ldrh	r2, [r2, #0]
     d9a:	188a      	adds	r2, r1, r2
     d9c:	801a      	strh	r2, [r3, #0]
      break;
     d9e:	e01d      	b.n	ddc <u8g2_add_vector_x+0x86>
    case 1:
      dx -= y;
     da0:	1d3b      	adds	r3, r7, #4
     da2:	781b      	ldrb	r3, [r3, #0]
     da4:	b25b      	sxtb	r3, r3
     da6:	b29a      	uxth	r2, r3
     da8:	1dbb      	adds	r3, r7, #6
     daa:	1db9      	adds	r1, r7, #6
     dac:	8809      	ldrh	r1, [r1, #0]
     dae:	1a8a      	subs	r2, r1, r2
     db0:	801a      	strh	r2, [r3, #0]
      break;
     db2:	e013      	b.n	ddc <u8g2_add_vector_x+0x86>
    case 2:
      dx -= x;
     db4:	1d7b      	adds	r3, r7, #5
     db6:	781b      	ldrb	r3, [r3, #0]
     db8:	b25b      	sxtb	r3, r3
     dba:	b29a      	uxth	r2, r3
     dbc:	1dbb      	adds	r3, r7, #6
     dbe:	1db9      	adds	r1, r7, #6
     dc0:	8809      	ldrh	r1, [r1, #0]
     dc2:	1a8a      	subs	r2, r1, r2
     dc4:	801a      	strh	r2, [r3, #0]
      break;
     dc6:	e009      	b.n	ddc <u8g2_add_vector_x+0x86>
    default:
      dx += y;
     dc8:	1d3b      	adds	r3, r7, #4
     dca:	781b      	ldrb	r3, [r3, #0]
     dcc:	b25b      	sxtb	r3, r3
     dce:	b299      	uxth	r1, r3
     dd0:	1dbb      	adds	r3, r7, #6
     dd2:	1dba      	adds	r2, r7, #6
     dd4:	8812      	ldrh	r2, [r2, #0]
     dd6:	188a      	adds	r2, r1, r2
     dd8:	801a      	strh	r2, [r3, #0]
      break;      
     dda:	46c0      	nop			; (mov r8, r8)
  }
  return dx;
     ddc:	1dbb      	adds	r3, r7, #6
     dde:	881b      	ldrh	r3, [r3, #0]
}
     de0:	0018      	movs	r0, r3
     de2:	46bd      	mov	sp, r7
     de4:	b002      	add	sp, #8
     de6:	bdb0      	pop	{r4, r5, r7, pc}

00000de8 <u8g2_font_decode_len>:
  Called by:
    u8g2_font_decode_glyph()
*/
/* optimized */
void u8g2_font_decode_len(u8g2_t *u8g2, uint8_t len, uint8_t is_foreground)
{
     de8:	b5b0      	push	{r4, r5, r7, lr}
     dea:	b088      	sub	sp, #32
     dec:	af02      	add	r7, sp, #8
     dee:	6078      	str	r0, [r7, #4]
     df0:	0008      	movs	r0, r1
     df2:	0011      	movs	r1, r2
     df4:	1cfb      	adds	r3, r7, #3
     df6:	1c02      	adds	r2, r0, #0
     df8:	701a      	strb	r2, [r3, #0]
     dfa:	1cbb      	adds	r3, r7, #2
     dfc:	1c0a      	adds	r2, r1, #0
     dfe:	701a      	strb	r2, [r3, #0]
  uint8_t lx,ly;
  
  /* target position on the screen */
  u8g2_uint_t x, y;
  
  u8g2_font_decode_t *decode = &(u8g2->font_decode);
     e00:	687b      	ldr	r3, [r7, #4]
     e02:	3360      	adds	r3, #96	; 0x60
     e04:	613b      	str	r3, [r7, #16]
  
  cnt = len;
     e06:	2317      	movs	r3, #23
     e08:	18fb      	adds	r3, r7, r3
     e0a:	1cfa      	adds	r2, r7, #3
     e0c:	7812      	ldrb	r2, [r2, #0]
     e0e:	701a      	strb	r2, [r3, #0]
  
  /* get the local position */
  lx = decode->x;
     e10:	693b      	ldr	r3, [r7, #16]
     e12:	2208      	movs	r2, #8
     e14:	569a      	ldrsb	r2, [r3, r2]
     e16:	2315      	movs	r3, #21
     e18:	18fb      	adds	r3, r7, r3
     e1a:	701a      	strb	r2, [r3, #0]
  ly = decode->y;
     e1c:	693b      	ldr	r3, [r7, #16]
     e1e:	2209      	movs	r2, #9
     e20:	569a      	ldrsb	r2, [r3, r2]
     e22:	2314      	movs	r3, #20
     e24:	18fb      	adds	r3, r7, r3
     e26:	701a      	strb	r2, [r3, #0]
  
  for(;;)
  {
    /* calculate the number of pixel to the right edge of the glyph */
    rem = decode->glyph_width;
     e28:	693b      	ldr	r3, [r7, #16]
     e2a:	220a      	movs	r2, #10
     e2c:	569a      	ldrsb	r2, [r3, r2]
     e2e:	230f      	movs	r3, #15
     e30:	18fb      	adds	r3, r7, r3
     e32:	701a      	strb	r2, [r3, #0]
    rem -= lx;
     e34:	230f      	movs	r3, #15
     e36:	18fb      	adds	r3, r7, r3
     e38:	220f      	movs	r2, #15
     e3a:	18b9      	adds	r1, r7, r2
     e3c:	2215      	movs	r2, #21
     e3e:	18ba      	adds	r2, r7, r2
     e40:	7809      	ldrb	r1, [r1, #0]
     e42:	7812      	ldrb	r2, [r2, #0]
     e44:	1a8a      	subs	r2, r1, r2
     e46:	701a      	strb	r2, [r3, #0]
    
    /* calculate how many pixel to draw. This is either to the right edge */
    /* or lesser, if not enough pixel are left */
    current = rem;
     e48:	2316      	movs	r3, #22
     e4a:	18fb      	adds	r3, r7, r3
     e4c:	220f      	movs	r2, #15
     e4e:	18ba      	adds	r2, r7, r2
     e50:	7812      	ldrb	r2, [r2, #0]
     e52:	701a      	strb	r2, [r3, #0]
    if ( cnt < rem )
     e54:	2317      	movs	r3, #23
     e56:	18fa      	adds	r2, r7, r3
     e58:	230f      	movs	r3, #15
     e5a:	18fb      	adds	r3, r7, r3
     e5c:	7812      	ldrb	r2, [r2, #0]
     e5e:	781b      	ldrb	r3, [r3, #0]
     e60:	429a      	cmp	r2, r3
     e62:	d205      	bcs.n	e70 <u8g2_font_decode_len+0x88>
      current = cnt;
     e64:	2316      	movs	r3, #22
     e66:	18fb      	adds	r3, r7, r3
     e68:	2217      	movs	r2, #23
     e6a:	18ba      	adds	r2, r7, r2
     e6c:	7812      	ldrb	r2, [r2, #0]
     e6e:	701a      	strb	r2, [r3, #0]
    
    /* now draw the line, but apply the rotation around the glyph target position */
    //u8g2_font_decode_draw_pixel(u8g2, lx,ly,current, is_foreground);

    /* get target position */
    x = decode->target_x;
     e70:	230c      	movs	r3, #12
     e72:	18fb      	adds	r3, r7, r3
     e74:	693a      	ldr	r2, [r7, #16]
     e76:	8892      	ldrh	r2, [r2, #4]
     e78:	801a      	strh	r2, [r3, #0]
    y = decode->target_y;
     e7a:	230a      	movs	r3, #10
     e7c:	18fb      	adds	r3, r7, r3
     e7e:	693a      	ldr	r2, [r7, #16]
     e80:	88d2      	ldrh	r2, [r2, #6]
     e82:	801a      	strh	r2, [r3, #0]

    /* apply rotation */
#ifdef U8G2_WITH_FONT_ROTATION
    
    x = u8g2_add_vector_x(x, lx, ly, decode->dir);
     e84:	2315      	movs	r3, #21
     e86:	18fb      	adds	r3, r7, r3
     e88:	2100      	movs	r1, #0
     e8a:	5659      	ldrsb	r1, [r3, r1]
     e8c:	2314      	movs	r3, #20
     e8e:	18fb      	adds	r3, r7, r3
     e90:	2200      	movs	r2, #0
     e92:	569a      	ldrsb	r2, [r3, r2]
     e94:	693b      	ldr	r3, [r7, #16]
     e96:	7c1d      	ldrb	r5, [r3, #16]
     e98:	230c      	movs	r3, #12
     e9a:	18fc      	adds	r4, r7, r3
     e9c:	230c      	movs	r3, #12
     e9e:	18fb      	adds	r3, r7, r3
     ea0:	8818      	ldrh	r0, [r3, #0]
     ea2:	002b      	movs	r3, r5
     ea4:	f7ff ff57 	bl	d56 <u8g2_add_vector_x>
     ea8:	0003      	movs	r3, r0
     eaa:	8023      	strh	r3, [r4, #0]
    y = u8g2_add_vector_y(y, lx, ly, decode->dir);
     eac:	2315      	movs	r3, #21
     eae:	18fb      	adds	r3, r7, r3
     eb0:	2100      	movs	r1, #0
     eb2:	5659      	ldrsb	r1, [r3, r1]
     eb4:	2314      	movs	r3, #20
     eb6:	18fb      	adds	r3, r7, r3
     eb8:	2200      	movs	r2, #0
     eba:	569a      	ldrsb	r2, [r3, r2]
     ebc:	693b      	ldr	r3, [r7, #16]
     ebe:	7c1d      	ldrb	r5, [r3, #16]
     ec0:	230a      	movs	r3, #10
     ec2:	18fc      	adds	r4, r7, r3
     ec4:	230a      	movs	r3, #10
     ec6:	18fb      	adds	r3, r7, r3
     ec8:	8818      	ldrh	r0, [r3, #0]
     eca:	002b      	movs	r3, r5
     ecc:	f7ff fefa 	bl	cc4 <u8g2_add_vector_y>
     ed0:	0003      	movs	r3, r0
     ed2:	8023      	strh	r3, [r4, #0]
    x += lx;
    y += ly;
#endif
    
    /* draw foreground and background (if required) */
    if ( is_foreground )
     ed4:	1cbb      	adds	r3, r7, #2
     ed6:	781b      	ldrb	r3, [r3, #0]
     ed8:	2b00      	cmp	r3, #0
     eda:	d017      	beq.n	f0c <u8g2_font_decode_len+0x124>
    {
      u8g2->draw_color = decode->fg_color;			/* draw_color will be restored later */
     edc:	693b      	ldr	r3, [r7, #16]
     ede:	7b99      	ldrb	r1, [r3, #14]
     ee0:	687b      	ldr	r3, [r7, #4]
     ee2:	2292      	movs	r2, #146	; 0x92
     ee4:	5499      	strb	r1, [r3, r2]
      u8g2_DrawHVLine(u8g2, 
     ee6:	2316      	movs	r3, #22
     ee8:	18fb      	adds	r3, r7, r3
     eea:	781b      	ldrb	r3, [r3, #0]
     eec:	b29d      	uxth	r5, r3
     eee:	693b      	ldr	r3, [r7, #16]
     ef0:	7c1b      	ldrb	r3, [r3, #16]
     ef2:	220a      	movs	r2, #10
     ef4:	18ba      	adds	r2, r7, r2
     ef6:	8814      	ldrh	r4, [r2, #0]
     ef8:	220c      	movs	r2, #12
     efa:	18ba      	adds	r2, r7, r2
     efc:	8811      	ldrh	r1, [r2, #0]
     efe:	6878      	ldr	r0, [r7, #4]
     f00:	9300      	str	r3, [sp, #0]
     f02:	002b      	movs	r3, r5
     f04:	0022      	movs	r2, r4
     f06:	f000 fd70 	bl	19ea <u8g2_DrawHVLine>
     f0a:	e01a      	b.n	f42 <u8g2_font_decode_len+0x15a>
#else
	0
#endif
      );
    }
    else if ( decode->is_transparent == 0 )    
     f0c:	693b      	ldr	r3, [r7, #16]
     f0e:	7b5b      	ldrb	r3, [r3, #13]
     f10:	2b00      	cmp	r3, #0
     f12:	d116      	bne.n	f42 <u8g2_font_decode_len+0x15a>
    {
      u8g2->draw_color = decode->bg_color;			/* draw_color will be restored later */
     f14:	693b      	ldr	r3, [r7, #16]
     f16:	7bd9      	ldrb	r1, [r3, #15]
     f18:	687b      	ldr	r3, [r7, #4]
     f1a:	2292      	movs	r2, #146	; 0x92
     f1c:	5499      	strb	r1, [r3, r2]
      u8g2_DrawHVLine(u8g2, 
     f1e:	2316      	movs	r3, #22
     f20:	18fb      	adds	r3, r7, r3
     f22:	781b      	ldrb	r3, [r3, #0]
     f24:	b29d      	uxth	r5, r3
     f26:	693b      	ldr	r3, [r7, #16]
     f28:	7c1b      	ldrb	r3, [r3, #16]
     f2a:	220a      	movs	r2, #10
     f2c:	18ba      	adds	r2, r7, r2
     f2e:	8814      	ldrh	r4, [r2, #0]
     f30:	220c      	movs	r2, #12
     f32:	18ba      	adds	r2, r7, r2
     f34:	8811      	ldrh	r1, [r2, #0]
     f36:	6878      	ldr	r0, [r7, #4]
     f38:	9300      	str	r3, [sp, #0]
     f3a:	002b      	movs	r3, r5
     f3c:	0022      	movs	r2, r4
     f3e:	f000 fd54 	bl	19ea <u8g2_DrawHVLine>
#endif
      );   
    }
    
    /* check, whether the end of the run length code has been reached */
    if ( cnt < rem )
     f42:	2317      	movs	r3, #23
     f44:	18fa      	adds	r2, r7, r3
     f46:	230f      	movs	r3, #15
     f48:	18fb      	adds	r3, r7, r3
     f4a:	7812      	ldrb	r2, [r2, #0]
     f4c:	781b      	ldrb	r3, [r3, #0]
     f4e:	429a      	cmp	r2, r3
     f50:	d315      	bcc.n	f7e <u8g2_font_decode_len+0x196>
      break;
    cnt -= rem;
     f52:	2317      	movs	r3, #23
     f54:	18fb      	adds	r3, r7, r3
     f56:	2217      	movs	r2, #23
     f58:	18b9      	adds	r1, r7, r2
     f5a:	220f      	movs	r2, #15
     f5c:	18ba      	adds	r2, r7, r2
     f5e:	7809      	ldrb	r1, [r1, #0]
     f60:	7812      	ldrb	r2, [r2, #0]
     f62:	1a8a      	subs	r2, r1, r2
     f64:	701a      	strb	r2, [r3, #0]
    lx = 0;
     f66:	2315      	movs	r3, #21
     f68:	18fb      	adds	r3, r7, r3
     f6a:	2200      	movs	r2, #0
     f6c:	701a      	strb	r2, [r3, #0]
    ly++;
     f6e:	2314      	movs	r3, #20
     f70:	18fb      	adds	r3, r7, r3
     f72:	781a      	ldrb	r2, [r3, #0]
     f74:	2314      	movs	r3, #20
     f76:	18fb      	adds	r3, r7, r3
     f78:	3201      	adds	r2, #1
     f7a:	701a      	strb	r2, [r3, #0]
    rem = decode->glyph_width;
     f7c:	e754      	b.n	e28 <u8g2_font_decode_len+0x40>
      break;
     f7e:	46c0      	nop			; (mov r8, r8)
  }
  lx += cnt;
     f80:	2315      	movs	r3, #21
     f82:	18fb      	adds	r3, r7, r3
     f84:	2215      	movs	r2, #21
     f86:	18b9      	adds	r1, r7, r2
     f88:	2217      	movs	r2, #23
     f8a:	18ba      	adds	r2, r7, r2
     f8c:	7809      	ldrb	r1, [r1, #0]
     f8e:	7812      	ldrb	r2, [r2, #0]
     f90:	188a      	adds	r2, r1, r2
     f92:	701a      	strb	r2, [r3, #0]
  
  decode->x = lx;
     f94:	2315      	movs	r3, #21
     f96:	18fb      	adds	r3, r7, r3
     f98:	2200      	movs	r2, #0
     f9a:	569a      	ldrsb	r2, [r3, r2]
     f9c:	693b      	ldr	r3, [r7, #16]
     f9e:	721a      	strb	r2, [r3, #8]
  decode->y = ly;  
     fa0:	2314      	movs	r3, #20
     fa2:	18fb      	adds	r3, r7, r3
     fa4:	2200      	movs	r2, #0
     fa6:	569a      	ldrsb	r2, [r3, r2]
     fa8:	693b      	ldr	r3, [r7, #16]
     faa:	725a      	strb	r2, [r3, #9]
}
     fac:	46c0      	nop			; (mov r8, r8)
     fae:	46bd      	mov	sp, r7
     fb0:	b006      	add	sp, #24
     fb2:	bdb0      	pop	{r4, r5, r7, pc}

00000fb4 <u8g2_font_setup_decode>:
  
}


static void u8g2_font_setup_decode(u8g2_t *u8g2, const uint8_t *glyph_data)
{
     fb4:	b580      	push	{r7, lr}
     fb6:	b084      	sub	sp, #16
     fb8:	af00      	add	r7, sp, #0
     fba:	6078      	str	r0, [r7, #4]
     fbc:	6039      	str	r1, [r7, #0]
  u8g2_font_decode_t *decode = &(u8g2->font_decode);
     fbe:	687b      	ldr	r3, [r7, #4]
     fc0:	3360      	adds	r3, #96	; 0x60
     fc2:	60fb      	str	r3, [r7, #12]
  decode->decode_ptr = glyph_data;
     fc4:	68fb      	ldr	r3, [r7, #12]
     fc6:	683a      	ldr	r2, [r7, #0]
     fc8:	601a      	str	r2, [r3, #0]
  decode->decode_bit_pos = 0;
     fca:	68fb      	ldr	r3, [r7, #12]
     fcc:	2200      	movs	r2, #0
     fce:	731a      	strb	r2, [r3, #12]
  /*
  decode->decode_ptr += 1;
  decode->decode_ptr += 1;
  */
  
  decode->glyph_width = u8g2_font_decode_get_unsigned_bits(decode, u8g2->font_info.bits_per_char_width);
     fd0:	687b      	ldr	r3, [r7, #4]
     fd2:	2278      	movs	r2, #120	; 0x78
     fd4:	5c9a      	ldrb	r2, [r3, r2]
     fd6:	68fb      	ldr	r3, [r7, #12]
     fd8:	0011      	movs	r1, r2
     fda:	0018      	movs	r0, r3
     fdc:	f7ff fdc1 	bl	b62 <u8g2_font_decode_get_unsigned_bits>
     fe0:	0003      	movs	r3, r0
     fe2:	b25a      	sxtb	r2, r3
     fe4:	68fb      	ldr	r3, [r7, #12]
     fe6:	729a      	strb	r2, [r3, #10]
  decode->glyph_height = u8g2_font_decode_get_unsigned_bits(decode,u8g2->font_info.bits_per_char_height);
     fe8:	687b      	ldr	r3, [r7, #4]
     fea:	2279      	movs	r2, #121	; 0x79
     fec:	5c9a      	ldrb	r2, [r3, r2]
     fee:	68fb      	ldr	r3, [r7, #12]
     ff0:	0011      	movs	r1, r2
     ff2:	0018      	movs	r0, r3
     ff4:	f7ff fdb5 	bl	b62 <u8g2_font_decode_get_unsigned_bits>
     ff8:	0003      	movs	r3, r0
     ffa:	b25a      	sxtb	r2, r3
     ffc:	68fb      	ldr	r3, [r7, #12]
     ffe:	72da      	strb	r2, [r3, #11]
  
  decode->fg_color = u8g2->draw_color;
    1000:	687b      	ldr	r3, [r7, #4]
    1002:	2292      	movs	r2, #146	; 0x92
    1004:	5c9a      	ldrb	r2, [r3, r2]
    1006:	68fb      	ldr	r3, [r7, #12]
    1008:	739a      	strb	r2, [r3, #14]
  decode->bg_color = (decode->fg_color == 0 ? 1 : 0);
    100a:	68fb      	ldr	r3, [r7, #12]
    100c:	7b9b      	ldrb	r3, [r3, #14]
    100e:	425a      	negs	r2, r3
    1010:	4153      	adcs	r3, r2
    1012:	b2db      	uxtb	r3, r3
    1014:	001a      	movs	r2, r3
    1016:	68fb      	ldr	r3, [r7, #12]
    1018:	73da      	strb	r2, [r3, #15]
}
    101a:	46c0      	nop			; (mov r8, r8)
    101c:	46bd      	mov	sp, r7
    101e:	b004      	add	sp, #16
    1020:	bd80      	pop	{r7, pc}

00001022 <u8g2_font_decode_glyph>:
  Calls:
    u8g2_font_decode_len()
*/
/* optimized */
int8_t u8g2_font_decode_glyph(u8g2_t *u8g2, const uint8_t *glyph_data)
{
    1022:	b590      	push	{r4, r7, lr}
    1024:	b08b      	sub	sp, #44	; 0x2c
    1026:	af02      	add	r7, sp, #8
    1028:	6078      	str	r0, [r7, #4]
    102a:	6039      	str	r1, [r7, #0]
  uint8_t a, b;
  int8_t x, y;
  int8_t d;
  int8_t h;
  u8g2_font_decode_t *decode = &(u8g2->font_decode);
    102c:	687b      	ldr	r3, [r7, #4]
    102e:	3360      	adds	r3, #96	; 0x60
    1030:	617b      	str	r3, [r7, #20]
    
  u8g2_font_setup_decode(u8g2, glyph_data);     /* set values in u8g2->font_decode data structure */
    1032:	683a      	ldr	r2, [r7, #0]
    1034:	687b      	ldr	r3, [r7, #4]
    1036:	0011      	movs	r1, r2
    1038:	0018      	movs	r0, r3
    103a:	f7ff ffbb 	bl	fb4 <u8g2_font_setup_decode>
  h = u8g2->font_decode.glyph_height;
    103e:	2313      	movs	r3, #19
    1040:	18fb      	adds	r3, r7, r3
    1042:	687a      	ldr	r2, [r7, #4]
    1044:	216b      	movs	r1, #107	; 0x6b
    1046:	5c52      	ldrb	r2, [r2, r1]
    1048:	701a      	strb	r2, [r3, #0]
  
  x = u8g2_font_decode_get_signed_bits(decode, u8g2->font_info.bits_per_char_x);
    104a:	687b      	ldr	r3, [r7, #4]
    104c:	227a      	movs	r2, #122	; 0x7a
    104e:	5c9a      	ldrb	r2, [r3, r2]
    1050:	2312      	movs	r3, #18
    1052:	18fc      	adds	r4, r7, r3
    1054:	697b      	ldr	r3, [r7, #20]
    1056:	0011      	movs	r1, r2
    1058:	0018      	movs	r0, r3
    105a:	f7ff fdfa 	bl	c52 <u8g2_font_decode_get_signed_bits>
    105e:	0003      	movs	r3, r0
    1060:	7023      	strb	r3, [r4, #0]
  y = u8g2_font_decode_get_signed_bits(decode, u8g2->font_info.bits_per_char_y);
    1062:	687b      	ldr	r3, [r7, #4]
    1064:	227b      	movs	r2, #123	; 0x7b
    1066:	5c9a      	ldrb	r2, [r3, r2]
    1068:	2311      	movs	r3, #17
    106a:	18fc      	adds	r4, r7, r3
    106c:	697b      	ldr	r3, [r7, #20]
    106e:	0011      	movs	r1, r2
    1070:	0018      	movs	r0, r3
    1072:	f7ff fdee 	bl	c52 <u8g2_font_decode_get_signed_bits>
    1076:	0003      	movs	r3, r0
    1078:	7023      	strb	r3, [r4, #0]
  d = u8g2_font_decode_get_signed_bits(decode, u8g2->font_info.bits_per_delta_x);
    107a:	687b      	ldr	r3, [r7, #4]
    107c:	227c      	movs	r2, #124	; 0x7c
    107e:	5c9a      	ldrb	r2, [r3, r2]
    1080:	2310      	movs	r3, #16
    1082:	18fc      	adds	r4, r7, r3
    1084:	697b      	ldr	r3, [r7, #20]
    1086:	0011      	movs	r1, r2
    1088:	0018      	movs	r0, r3
    108a:	f7ff fde2 	bl	c52 <u8g2_font_decode_get_signed_bits>
    108e:	0003      	movs	r3, r0
    1090:	7023      	strb	r3, [r4, #0]
  
  if ( decode->glyph_width > 0 )
    1092:	697b      	ldr	r3, [r7, #20]
    1094:	7a9b      	ldrb	r3, [r3, #10]
    1096:	b25b      	sxtb	r3, r3
    1098:	2b00      	cmp	r3, #0
    109a:	dc00      	bgt.n	109e <u8g2_font_decode_glyph+0x7c>
    109c:	e14c      	b.n	1338 <u8g2_font_decode_glyph+0x316>
  {
#ifdef U8G2_WITH_FONT_ROTATION
    decode->target_x = u8g2_add_vector_x(decode->target_x, x, -(h+y), decode->dir);
    109e:	697b      	ldr	r3, [r7, #20]
    10a0:	8898      	ldrh	r0, [r3, #4]
    10a2:	2313      	movs	r3, #19
    10a4:	18fb      	adds	r3, r7, r3
    10a6:	781a      	ldrb	r2, [r3, #0]
    10a8:	2311      	movs	r3, #17
    10aa:	18fb      	adds	r3, r7, r3
    10ac:	781b      	ldrb	r3, [r3, #0]
    10ae:	18d3      	adds	r3, r2, r3
    10b0:	b2db      	uxtb	r3, r3
    10b2:	425b      	negs	r3, r3
    10b4:	b2db      	uxtb	r3, r3
    10b6:	b25a      	sxtb	r2, r3
    10b8:	697b      	ldr	r3, [r7, #20]
    10ba:	7c1c      	ldrb	r4, [r3, #16]
    10bc:	2312      	movs	r3, #18
    10be:	18fb      	adds	r3, r7, r3
    10c0:	2100      	movs	r1, #0
    10c2:	5659      	ldrsb	r1, [r3, r1]
    10c4:	0023      	movs	r3, r4
    10c6:	f7ff fe46 	bl	d56 <u8g2_add_vector_x>
    10ca:	0003      	movs	r3, r0
    10cc:	001a      	movs	r2, r3
    10ce:	697b      	ldr	r3, [r7, #20]
    10d0:	809a      	strh	r2, [r3, #4]
    decode->target_y = u8g2_add_vector_y(decode->target_y, x, -(h+y), decode->dir);
    10d2:	697b      	ldr	r3, [r7, #20]
    10d4:	88d8      	ldrh	r0, [r3, #6]
    10d6:	2313      	movs	r3, #19
    10d8:	18fb      	adds	r3, r7, r3
    10da:	781a      	ldrb	r2, [r3, #0]
    10dc:	2311      	movs	r3, #17
    10de:	18fb      	adds	r3, r7, r3
    10e0:	781b      	ldrb	r3, [r3, #0]
    10e2:	18d3      	adds	r3, r2, r3
    10e4:	b2db      	uxtb	r3, r3
    10e6:	425b      	negs	r3, r3
    10e8:	b2db      	uxtb	r3, r3
    10ea:	b25a      	sxtb	r2, r3
    10ec:	697b      	ldr	r3, [r7, #20]
    10ee:	7c1c      	ldrb	r4, [r3, #16]
    10f0:	2312      	movs	r3, #18
    10f2:	18fb      	adds	r3, r7, r3
    10f4:	2100      	movs	r1, #0
    10f6:	5659      	ldrsb	r1, [r3, r1]
    10f8:	0023      	movs	r3, r4
    10fa:	f7ff fde3 	bl	cc4 <u8g2_add_vector_y>
    10fe:	0003      	movs	r3, r0
    1100:	001a      	movs	r2, r3
    1102:	697b      	ldr	r3, [r7, #20]
    1104:	80da      	strh	r2, [r3, #6]
    //u8g2_add_vector(&(decode->target_x), &(decode->target_y), x, -(h+y), decode->dir);

#ifdef U8G2_WITH_INTERSECTION
    {
      u8g2_uint_t x0, x1, y0, y1;
      x0 = decode->target_x;
    1106:	231e      	movs	r3, #30
    1108:	18fb      	adds	r3, r7, r3
    110a:	697a      	ldr	r2, [r7, #20]
    110c:	8892      	ldrh	r2, [r2, #4]
    110e:	801a      	strh	r2, [r3, #0]
      y0 = decode->target_y;
    1110:	231a      	movs	r3, #26
    1112:	18fb      	adds	r3, r7, r3
    1114:	697a      	ldr	r2, [r7, #20]
    1116:	88d2      	ldrh	r2, [r2, #6]
    1118:	801a      	strh	r2, [r3, #0]
      x1 = x0;
    111a:	231c      	movs	r3, #28
    111c:	18fb      	adds	r3, r7, r3
    111e:	221e      	movs	r2, #30
    1120:	18ba      	adds	r2, r7, r2
    1122:	8812      	ldrh	r2, [r2, #0]
    1124:	801a      	strh	r2, [r3, #0]
      y1 = y0;
    1126:	2318      	movs	r3, #24
    1128:	18fb      	adds	r3, r7, r3
    112a:	221a      	movs	r2, #26
    112c:	18ba      	adds	r2, r7, r2
    112e:	8812      	ldrh	r2, [r2, #0]
    1130:	801a      	strh	r2, [r3, #0]
      
#ifdef U8G2_WITH_FONT_ROTATION
      switch(decode->dir)
    1132:	697b      	ldr	r3, [r7, #20]
    1134:	7c1b      	ldrb	r3, [r3, #16]
    1136:	2b01      	cmp	r3, #1
    1138:	d021      	beq.n	117e <u8g2_font_decode_glyph+0x15c>
    113a:	dc02      	bgt.n	1142 <u8g2_font_decode_glyph+0x120>
    113c:	2b00      	cmp	r3, #0
    113e:	d006      	beq.n	114e <u8g2_font_decode_glyph+0x12c>
    1140:	e09d      	b.n	127e <u8g2_font_decode_glyph+0x25c>
    1142:	2b02      	cmp	r3, #2
    1144:	d041      	beq.n	11ca <u8g2_font_decode_glyph+0x1a8>
    1146:	2b03      	cmp	r3, #3
    1148:	d100      	bne.n	114c <u8g2_font_decode_glyph+0x12a>
    114a:	e072      	b.n	1232 <u8g2_font_decode_glyph+0x210>
    114c:	e097      	b.n	127e <u8g2_font_decode_glyph+0x25c>
      {
	case 0:
	    x1 += decode->glyph_width;
    114e:	697b      	ldr	r3, [r7, #20]
    1150:	7a9b      	ldrb	r3, [r3, #10]
    1152:	b25b      	sxtb	r3, r3
    1154:	b299      	uxth	r1, r3
    1156:	231c      	movs	r3, #28
    1158:	18fb      	adds	r3, r7, r3
    115a:	221c      	movs	r2, #28
    115c:	18ba      	adds	r2, r7, r2
    115e:	8812      	ldrh	r2, [r2, #0]
    1160:	188a      	adds	r2, r1, r2
    1162:	801a      	strh	r2, [r3, #0]
	    y1 += h;
    1164:	2313      	movs	r3, #19
    1166:	18fb      	adds	r3, r7, r3
    1168:	781b      	ldrb	r3, [r3, #0]
    116a:	b25b      	sxtb	r3, r3
    116c:	b299      	uxth	r1, r3
    116e:	2318      	movs	r3, #24
    1170:	18fb      	adds	r3, r7, r3
    1172:	2218      	movs	r2, #24
    1174:	18ba      	adds	r2, r7, r2
    1176:	8812      	ldrh	r2, [r2, #0]
    1178:	188a      	adds	r2, r1, r2
    117a:	801a      	strh	r2, [r3, #0]
	    break;
    117c:	e07f      	b.n	127e <u8g2_font_decode_glyph+0x25c>
	case 1:
	    x0 -= h;
    117e:	2313      	movs	r3, #19
    1180:	18fb      	adds	r3, r7, r3
    1182:	781b      	ldrb	r3, [r3, #0]
    1184:	b25b      	sxtb	r3, r3
    1186:	b29a      	uxth	r2, r3
    1188:	231e      	movs	r3, #30
    118a:	18fb      	adds	r3, r7, r3
    118c:	211e      	movs	r1, #30
    118e:	1879      	adds	r1, r7, r1
    1190:	8809      	ldrh	r1, [r1, #0]
    1192:	1a8a      	subs	r2, r1, r2
    1194:	801a      	strh	r2, [r3, #0]
	    x0++;	/* shift down, because of assymetric boundaries for the interseciton test */
    1196:	231e      	movs	r3, #30
    1198:	18fb      	adds	r3, r7, r3
    119a:	881a      	ldrh	r2, [r3, #0]
    119c:	231e      	movs	r3, #30
    119e:	18fb      	adds	r3, r7, r3
    11a0:	3201      	adds	r2, #1
    11a2:	801a      	strh	r2, [r3, #0]
	    x1++;
    11a4:	231c      	movs	r3, #28
    11a6:	18fb      	adds	r3, r7, r3
    11a8:	881a      	ldrh	r2, [r3, #0]
    11aa:	231c      	movs	r3, #28
    11ac:	18fb      	adds	r3, r7, r3
    11ae:	3201      	adds	r2, #1
    11b0:	801a      	strh	r2, [r3, #0]
	    y1 += decode->glyph_width;
    11b2:	697b      	ldr	r3, [r7, #20]
    11b4:	7a9b      	ldrb	r3, [r3, #10]
    11b6:	b25b      	sxtb	r3, r3
    11b8:	b299      	uxth	r1, r3
    11ba:	2318      	movs	r3, #24
    11bc:	18fb      	adds	r3, r7, r3
    11be:	2218      	movs	r2, #24
    11c0:	18ba      	adds	r2, r7, r2
    11c2:	8812      	ldrh	r2, [r2, #0]
    11c4:	188a      	adds	r2, r1, r2
    11c6:	801a      	strh	r2, [r3, #0]
	    break;
    11c8:	e059      	b.n	127e <u8g2_font_decode_glyph+0x25c>
	case 2:
	    x0 -= decode->glyph_width;
    11ca:	697b      	ldr	r3, [r7, #20]
    11cc:	7a9b      	ldrb	r3, [r3, #10]
    11ce:	b25b      	sxtb	r3, r3
    11d0:	b29a      	uxth	r2, r3
    11d2:	231e      	movs	r3, #30
    11d4:	18fb      	adds	r3, r7, r3
    11d6:	211e      	movs	r1, #30
    11d8:	1879      	adds	r1, r7, r1
    11da:	8809      	ldrh	r1, [r1, #0]
    11dc:	1a8a      	subs	r2, r1, r2
    11de:	801a      	strh	r2, [r3, #0]
	    x0++;	/* shift down, because of assymetric boundaries for the interseciton test */
    11e0:	231e      	movs	r3, #30
    11e2:	18fb      	adds	r3, r7, r3
    11e4:	881a      	ldrh	r2, [r3, #0]
    11e6:	231e      	movs	r3, #30
    11e8:	18fb      	adds	r3, r7, r3
    11ea:	3201      	adds	r2, #1
    11ec:	801a      	strh	r2, [r3, #0]
	    x1++;
    11ee:	231c      	movs	r3, #28
    11f0:	18fb      	adds	r3, r7, r3
    11f2:	881a      	ldrh	r2, [r3, #0]
    11f4:	231c      	movs	r3, #28
    11f6:	18fb      	adds	r3, r7, r3
    11f8:	3201      	adds	r2, #1
    11fa:	801a      	strh	r2, [r3, #0]
	    y0 -= h;
    11fc:	2313      	movs	r3, #19
    11fe:	18fb      	adds	r3, r7, r3
    1200:	781b      	ldrb	r3, [r3, #0]
    1202:	b25b      	sxtb	r3, r3
    1204:	b29a      	uxth	r2, r3
    1206:	231a      	movs	r3, #26
    1208:	18fb      	adds	r3, r7, r3
    120a:	211a      	movs	r1, #26
    120c:	1879      	adds	r1, r7, r1
    120e:	8809      	ldrh	r1, [r1, #0]
    1210:	1a8a      	subs	r2, r1, r2
    1212:	801a      	strh	r2, [r3, #0]
	    y0++;	/* shift down, because of assymetric boundaries for the interseciton test */
    1214:	231a      	movs	r3, #26
    1216:	18fb      	adds	r3, r7, r3
    1218:	881a      	ldrh	r2, [r3, #0]
    121a:	231a      	movs	r3, #26
    121c:	18fb      	adds	r3, r7, r3
    121e:	3201      	adds	r2, #1
    1220:	801a      	strh	r2, [r3, #0]
	    y1++;
    1222:	2318      	movs	r3, #24
    1224:	18fb      	adds	r3, r7, r3
    1226:	881a      	ldrh	r2, [r3, #0]
    1228:	2318      	movs	r3, #24
    122a:	18fb      	adds	r3, r7, r3
    122c:	3201      	adds	r2, #1
    122e:	801a      	strh	r2, [r3, #0]
	    break;	  
    1230:	e025      	b.n	127e <u8g2_font_decode_glyph+0x25c>
	case 3:
	    x1 += h;
    1232:	2313      	movs	r3, #19
    1234:	18fb      	adds	r3, r7, r3
    1236:	781b      	ldrb	r3, [r3, #0]
    1238:	b25b      	sxtb	r3, r3
    123a:	b299      	uxth	r1, r3
    123c:	231c      	movs	r3, #28
    123e:	18fb      	adds	r3, r7, r3
    1240:	221c      	movs	r2, #28
    1242:	18ba      	adds	r2, r7, r2
    1244:	8812      	ldrh	r2, [r2, #0]
    1246:	188a      	adds	r2, r1, r2
    1248:	801a      	strh	r2, [r3, #0]
	    y0 -= decode->glyph_width;
    124a:	697b      	ldr	r3, [r7, #20]
    124c:	7a9b      	ldrb	r3, [r3, #10]
    124e:	b25b      	sxtb	r3, r3
    1250:	b29a      	uxth	r2, r3
    1252:	231a      	movs	r3, #26
    1254:	18fb      	adds	r3, r7, r3
    1256:	211a      	movs	r1, #26
    1258:	1879      	adds	r1, r7, r1
    125a:	8809      	ldrh	r1, [r1, #0]
    125c:	1a8a      	subs	r2, r1, r2
    125e:	801a      	strh	r2, [r3, #0]
	    y0++;	/* shift down, because of assymetric boundaries for the interseciton test */
    1260:	231a      	movs	r3, #26
    1262:	18fb      	adds	r3, r7, r3
    1264:	881a      	ldrh	r2, [r3, #0]
    1266:	231a      	movs	r3, #26
    1268:	18fb      	adds	r3, r7, r3
    126a:	3201      	adds	r2, #1
    126c:	801a      	strh	r2, [r3, #0]
	    y1++;
    126e:	2318      	movs	r3, #24
    1270:	18fb      	adds	r3, r7, r3
    1272:	881a      	ldrh	r2, [r3, #0]
    1274:	2318      	movs	r3, #24
    1276:	18fb      	adds	r3, r7, r3
    1278:	3201      	adds	r2, #1
    127a:	801a      	strh	r2, [r3, #0]
	    break;	  
    127c:	46c0      	nop			; (mov r8, r8)
#else /* U8G2_WITH_FONT_ROTATION */
      x1 += decode->glyph_width;
      y1 += h;      
#endif
      
      if ( u8g2_IsIntersection(u8g2, x0, y0, x1, y1) == 0 ) 
    127e:	231c      	movs	r3, #28
    1280:	18fb      	adds	r3, r7, r3
    1282:	881c      	ldrh	r4, [r3, #0]
    1284:	231a      	movs	r3, #26
    1286:	18fb      	adds	r3, r7, r3
    1288:	881a      	ldrh	r2, [r3, #0]
    128a:	231e      	movs	r3, #30
    128c:	18fb      	adds	r3, r7, r3
    128e:	8819      	ldrh	r1, [r3, #0]
    1290:	6878      	ldr	r0, [r7, #4]
    1292:	2318      	movs	r3, #24
    1294:	18fb      	adds	r3, r7, r3
    1296:	881b      	ldrh	r3, [r3, #0]
    1298:	9300      	str	r3, [sp, #0]
    129a:	0023      	movs	r3, r4
    129c:	f000 fd23 	bl	1ce6 <u8g2_IsIntersection>
    12a0:	1e03      	subs	r3, r0, #0
    12a2:	d104      	bne.n	12ae <u8g2_font_decode_glyph+0x28c>
	return d;
    12a4:	2310      	movs	r3, #16
    12a6:	18fb      	adds	r3, r7, r3
    12a8:	781b      	ldrb	r3, [r3, #0]
    12aa:	b25b      	sxtb	r3, r3
    12ac:	e048      	b.n	1340 <u8g2_font_decode_glyph+0x31e>
    }
#endif /* U8G2_WITH_INTERSECTION */
   
    /* reset local x/y position */
    decode->x = 0;
    12ae:	697b      	ldr	r3, [r7, #20]
    12b0:	2200      	movs	r2, #0
    12b2:	721a      	strb	r2, [r3, #8]
    decode->y = 0;
    12b4:	697b      	ldr	r3, [r7, #20]
    12b6:	2200      	movs	r2, #0
    12b8:	725a      	strb	r2, [r3, #9]
    
    /* decode glyph */
    for(;;)
    {
      a = u8g2_font_decode_get_unsigned_bits(decode, u8g2->font_info.bits_per_0);
    12ba:	687b      	ldr	r3, [r7, #4]
    12bc:	2276      	movs	r2, #118	; 0x76
    12be:	5c9a      	ldrb	r2, [r3, r2]
    12c0:	230f      	movs	r3, #15
    12c2:	18fc      	adds	r4, r7, r3
    12c4:	697b      	ldr	r3, [r7, #20]
    12c6:	0011      	movs	r1, r2
    12c8:	0018      	movs	r0, r3
    12ca:	f7ff fc4a 	bl	b62 <u8g2_font_decode_get_unsigned_bits>
    12ce:	0003      	movs	r3, r0
    12d0:	7023      	strb	r3, [r4, #0]
      b = u8g2_font_decode_get_unsigned_bits(decode, u8g2->font_info.bits_per_1);
    12d2:	687b      	ldr	r3, [r7, #4]
    12d4:	2277      	movs	r2, #119	; 0x77
    12d6:	5c9a      	ldrb	r2, [r3, r2]
    12d8:	230e      	movs	r3, #14
    12da:	18fc      	adds	r4, r7, r3
    12dc:	697b      	ldr	r3, [r7, #20]
    12de:	0011      	movs	r1, r2
    12e0:	0018      	movs	r0, r3
    12e2:	f7ff fc3e 	bl	b62 <u8g2_font_decode_get_unsigned_bits>
    12e6:	0003      	movs	r3, r0
    12e8:	7023      	strb	r3, [r4, #0]
      do
      {
	u8g2_font_decode_len(u8g2, a, 0);
    12ea:	230f      	movs	r3, #15
    12ec:	18fb      	adds	r3, r7, r3
    12ee:	7819      	ldrb	r1, [r3, #0]
    12f0:	687b      	ldr	r3, [r7, #4]
    12f2:	2200      	movs	r2, #0
    12f4:	0018      	movs	r0, r3
    12f6:	f7ff fd77 	bl	de8 <u8g2_font_decode_len>
	u8g2_font_decode_len(u8g2, b, 1);
    12fa:	230e      	movs	r3, #14
    12fc:	18fb      	adds	r3, r7, r3
    12fe:	7819      	ldrb	r1, [r3, #0]
    1300:	687b      	ldr	r3, [r7, #4]
    1302:	2201      	movs	r2, #1
    1304:	0018      	movs	r0, r3
    1306:	f7ff fd6f 	bl	de8 <u8g2_font_decode_len>
      } while( u8g2_font_decode_get_unsigned_bits(decode, 1) != 0 );
    130a:	697b      	ldr	r3, [r7, #20]
    130c:	2101      	movs	r1, #1
    130e:	0018      	movs	r0, r3
    1310:	f7ff fc27 	bl	b62 <u8g2_font_decode_get_unsigned_bits>
    1314:	1e03      	subs	r3, r0, #0
    1316:	d1e8      	bne.n	12ea <u8g2_font_decode_glyph+0x2c8>

      if ( decode->y >= h )
    1318:	697b      	ldr	r3, [r7, #20]
    131a:	7a5b      	ldrb	r3, [r3, #9]
    131c:	b25b      	sxtb	r3, r3
    131e:	2213      	movs	r2, #19
    1320:	18ba      	adds	r2, r7, r2
    1322:	7812      	ldrb	r2, [r2, #0]
    1324:	b252      	sxtb	r2, r2
    1326:	429a      	cmp	r2, r3
    1328:	dd00      	ble.n	132c <u8g2_font_decode_glyph+0x30a>
      a = u8g2_font_decode_get_unsigned_bits(decode, u8g2->font_info.bits_per_0);
    132a:	e7c6      	b.n	12ba <u8g2_font_decode_glyph+0x298>
	break;
    132c:	46c0      	nop			; (mov r8, r8)
    }
    
    /* restore the u8g2 draw color, because this is modified by the decode algo */
    u8g2->draw_color = decode->fg_color;
    132e:	697b      	ldr	r3, [r7, #20]
    1330:	7b99      	ldrb	r1, [r3, #14]
    1332:	687b      	ldr	r3, [r7, #4]
    1334:	2292      	movs	r2, #146	; 0x92
    1336:	5499      	strb	r1, [r3, r2]
  }
  return d;
    1338:	2310      	movs	r3, #16
    133a:	18fb      	adds	r3, r7, r3
    133c:	781b      	ldrb	r3, [r3, #0]
    133e:	b25b      	sxtb	r3, r3
}
    1340:	0018      	movs	r0, r3
    1342:	46bd      	mov	sp, r7
    1344:	b009      	add	sp, #36	; 0x24
    1346:	bd90      	pop	{r4, r7, pc}

00001348 <u8g2_font_get_glyph_data>:
    encoding: Encoding (ASCII or Unicode) of the glyph
  Return:
    Address of the glyph data or NULL, if the encoding is not avialable in the font.
*/
const uint8_t *u8g2_font_get_glyph_data(u8g2_t *u8g2, uint16_t encoding)
{
    1348:	b590      	push	{r4, r7, lr}
    134a:	b087      	sub	sp, #28
    134c:	af00      	add	r7, sp, #0
    134e:	6078      	str	r0, [r7, #4]
    1350:	000a      	movs	r2, r1
    1352:	1cbb      	adds	r3, r7, #2
    1354:	801a      	strh	r2, [r3, #0]
  const uint8_t *font = u8g2->font;
    1356:	687b      	ldr	r3, [r7, #4]
    1358:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    135a:	617b      	str	r3, [r7, #20]
  font += U8G2_FONT_DATA_STRUCT_SIZE;
    135c:	697b      	ldr	r3, [r7, #20]
    135e:	3317      	adds	r3, #23
    1360:	617b      	str	r3, [r7, #20]

  
  if ( encoding <= 255 )
    1362:	1cbb      	adds	r3, r7, #2
    1364:	881b      	ldrh	r3, [r3, #0]
    1366:	2bff      	cmp	r3, #255	; 0xff
    1368:	d82d      	bhi.n	13c6 <u8g2_font_get_glyph_data+0x7e>
  {
    if ( encoding >= 'a' )
    136a:	1cbb      	adds	r3, r7, #2
    136c:	881b      	ldrh	r3, [r3, #0]
    136e:	2b60      	cmp	r3, #96	; 0x60
    1370:	d907      	bls.n	1382 <u8g2_font_get_glyph_data+0x3a>
    {
      font += u8g2->font_info.start_pos_lower_a;
    1372:	687b      	ldr	r3, [r7, #4]
    1374:	2288      	movs	r2, #136	; 0x88
    1376:	5a9b      	ldrh	r3, [r3, r2]
    1378:	001a      	movs	r2, r3
    137a:	697b      	ldr	r3, [r7, #20]
    137c:	189b      	adds	r3, r3, r2
    137e:	617b      	str	r3, [r7, #20]
    1380:	e00a      	b.n	1398 <u8g2_font_get_glyph_data+0x50>
    }
    else if ( encoding >= 'A' )
    1382:	1cbb      	adds	r3, r7, #2
    1384:	881b      	ldrh	r3, [r3, #0]
    1386:	2b40      	cmp	r3, #64	; 0x40
    1388:	d906      	bls.n	1398 <u8g2_font_get_glyph_data+0x50>
    {
      font += u8g2->font_info.start_pos_upper_A;
    138a:	687b      	ldr	r3, [r7, #4]
    138c:	2286      	movs	r2, #134	; 0x86
    138e:	5a9b      	ldrh	r3, [r3, r2]
    1390:	001a      	movs	r2, r3
    1392:	697b      	ldr	r3, [r7, #20]
    1394:	189b      	adds	r3, r3, r2
    1396:	617b      	str	r3, [r7, #20]
    }
    
    for(;;)
    {
      if ( u8x8_pgm_read( font + 1 ) == 0 )
    1398:	697b      	ldr	r3, [r7, #20]
    139a:	3301      	adds	r3, #1
    139c:	781b      	ldrb	r3, [r3, #0]
    139e:	2b00      	cmp	r3, #0
    13a0:	d065      	beq.n	146e <u8g2_font_get_glyph_data+0x126>
	break;
      if ( u8x8_pgm_read( font ) == encoding )
    13a2:	697b      	ldr	r3, [r7, #20]
    13a4:	781b      	ldrb	r3, [r3, #0]
    13a6:	b29b      	uxth	r3, r3
    13a8:	1cba      	adds	r2, r7, #2
    13aa:	8812      	ldrh	r2, [r2, #0]
    13ac:	429a      	cmp	r2, r3
    13ae:	d102      	bne.n	13b6 <u8g2_font_get_glyph_data+0x6e>
      {
	return font+2;	/* skip encoding and glyph size */
    13b0:	697b      	ldr	r3, [r7, #20]
    13b2:	3302      	adds	r3, #2
    13b4:	e05f      	b.n	1476 <u8g2_font_get_glyph_data+0x12e>
      }
      font += u8x8_pgm_read( font + 1 );
    13b6:	697b      	ldr	r3, [r7, #20]
    13b8:	3301      	adds	r3, #1
    13ba:	781b      	ldrb	r3, [r3, #0]
    13bc:	001a      	movs	r2, r3
    13be:	697b      	ldr	r3, [r7, #20]
    13c0:	189b      	adds	r3, r3, r2
    13c2:	617b      	str	r3, [r7, #20]
      if ( u8x8_pgm_read( font + 1 ) == 0 )
    13c4:	e7e8      	b.n	1398 <u8g2_font_get_glyph_data+0x50>
//	font = u8g2->last_font_data;
//    }
//    else
//#endif 

    font += u8g2->font_info.start_pos_unicode;
    13c6:	687b      	ldr	r3, [r7, #4]
    13c8:	228a      	movs	r2, #138	; 0x8a
    13ca:	5a9b      	ldrh	r3, [r3, r2]
    13cc:	001a      	movs	r2, r3
    13ce:	697b      	ldr	r3, [r7, #20]
    13d0:	189b      	adds	r3, r3, r2
    13d2:	617b      	str	r3, [r7, #20]
    unicode_lookup_table = font; 
    13d4:	697b      	ldr	r3, [r7, #20]
    13d6:	613b      	str	r3, [r7, #16]
  
    /* issue 596: search for the glyph start in the unicode lookup table */
    do
    {
      font += u8g2_font_get_word(unicode_lookup_table, 0);
    13d8:	693b      	ldr	r3, [r7, #16]
    13da:	2100      	movs	r1, #0
    13dc:	0018      	movs	r0, r3
    13de:	f7ff fad7 	bl	990 <u8g2_font_get_word>
    13e2:	0003      	movs	r3, r0
    13e4:	001a      	movs	r2, r3
    13e6:	697b      	ldr	r3, [r7, #20]
    13e8:	189b      	adds	r3, r3, r2
    13ea:	617b      	str	r3, [r7, #20]
      e = u8g2_font_get_word(unicode_lookup_table, 2);
    13ec:	230e      	movs	r3, #14
    13ee:	18fc      	adds	r4, r7, r3
    13f0:	693b      	ldr	r3, [r7, #16]
    13f2:	2102      	movs	r1, #2
    13f4:	0018      	movs	r0, r3
    13f6:	f7ff facb 	bl	990 <u8g2_font_get_word>
    13fa:	0003      	movs	r3, r0
    13fc:	8023      	strh	r3, [r4, #0]
      unicode_lookup_table+=4;
    13fe:	693b      	ldr	r3, [r7, #16]
    1400:	3304      	adds	r3, #4
    1402:	613b      	str	r3, [r7, #16]
    } while( e < encoding );
    1404:	230e      	movs	r3, #14
    1406:	18fa      	adds	r2, r7, r3
    1408:	1cbb      	adds	r3, r7, #2
    140a:	8812      	ldrh	r2, [r2, #0]
    140c:	881b      	ldrh	r3, [r3, #0]
    140e:	429a      	cmp	r2, r3
    1410:	d3e2      	bcc.n	13d8 <u8g2_font_get_glyph_data+0x90>
    
  
    for(;;)
    {
      e = u8x8_pgm_read( font );
    1412:	697b      	ldr	r3, [r7, #20]
    1414:	781a      	ldrb	r2, [r3, #0]
    1416:	230e      	movs	r3, #14
    1418:	18fb      	adds	r3, r7, r3
    141a:	801a      	strh	r2, [r3, #0]
      e <<= 8;
    141c:	230e      	movs	r3, #14
    141e:	18fb      	adds	r3, r7, r3
    1420:	220e      	movs	r2, #14
    1422:	18ba      	adds	r2, r7, r2
    1424:	8812      	ldrh	r2, [r2, #0]
    1426:	0212      	lsls	r2, r2, #8
    1428:	801a      	strh	r2, [r3, #0]
      e |= u8x8_pgm_read( font + 1 );
    142a:	697b      	ldr	r3, [r7, #20]
    142c:	3301      	adds	r3, #1
    142e:	781b      	ldrb	r3, [r3, #0]
    1430:	b299      	uxth	r1, r3
    1432:	230e      	movs	r3, #14
    1434:	18fb      	adds	r3, r7, r3
    1436:	220e      	movs	r2, #14
    1438:	18ba      	adds	r2, r7, r2
    143a:	8812      	ldrh	r2, [r2, #0]
    143c:	430a      	orrs	r2, r1
    143e:	801a      	strh	r2, [r3, #0]
//#ifdef  __unix__
//      if ( encoding < e )
//        break;
//#endif 

      if ( e == 0 )
    1440:	230e      	movs	r3, #14
    1442:	18fb      	adds	r3, r7, r3
    1444:	881b      	ldrh	r3, [r3, #0]
    1446:	2b00      	cmp	r3, #0
    1448:	d013      	beq.n	1472 <u8g2_font_get_glyph_data+0x12a>
	break;
  
      if ( e == encoding )
    144a:	230e      	movs	r3, #14
    144c:	18fa      	adds	r2, r7, r3
    144e:	1cbb      	adds	r3, r7, #2
    1450:	8812      	ldrh	r2, [r2, #0]
    1452:	881b      	ldrh	r3, [r3, #0]
    1454:	429a      	cmp	r2, r3
    1456:	d102      	bne.n	145e <u8g2_font_get_glyph_data+0x116>
// removed, there is now the new index table
//#ifdef  __unix__
//	u8g2->last_font_data = font;
//	u8g2->last_unicode = encoding;
//#endif 
	return font+3;	/* skip encoding and glyph size */
    1458:	697b      	ldr	r3, [r7, #20]
    145a:	3303      	adds	r3, #3
    145c:	e00b      	b.n	1476 <u8g2_font_get_glyph_data+0x12e>
      }
      font += u8x8_pgm_read( font + 2 );
    145e:	697b      	ldr	r3, [r7, #20]
    1460:	3302      	adds	r3, #2
    1462:	781b      	ldrb	r3, [r3, #0]
    1464:	001a      	movs	r2, r3
    1466:	697b      	ldr	r3, [r7, #20]
    1468:	189b      	adds	r3, r3, r2
    146a:	617b      	str	r3, [r7, #20]
      e = u8x8_pgm_read( font );
    146c:	e7d1      	b.n	1412 <u8g2_font_get_glyph_data+0xca>
	break;
    146e:	46c0      	nop			; (mov r8, r8)
    1470:	e000      	b.n	1474 <u8g2_font_get_glyph_data+0x12c>
	break;
    1472:	46c0      	nop			; (mov r8, r8)
    }  
  }
#endif
  
  return NULL;
    1474:	2300      	movs	r3, #0
}
    1476:	0018      	movs	r0, r3
    1478:	46bd      	mov	sp, r7
    147a:	b007      	add	sp, #28
    147c:	bd90      	pop	{r4, r7, pc}

0000147e <u8g2_font_draw_glyph>:

static u8g2_uint_t u8g2_font_draw_glyph(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, uint16_t encoding)
{
    147e:	b590      	push	{r4, r7, lr}
    1480:	b087      	sub	sp, #28
    1482:	af00      	add	r7, sp, #0
    1484:	60f8      	str	r0, [r7, #12]
    1486:	000c      	movs	r4, r1
    1488:	0010      	movs	r0, r2
    148a:	0019      	movs	r1, r3
    148c:	230a      	movs	r3, #10
    148e:	18fb      	adds	r3, r7, r3
    1490:	1c22      	adds	r2, r4, #0
    1492:	801a      	strh	r2, [r3, #0]
    1494:	2308      	movs	r3, #8
    1496:	18fb      	adds	r3, r7, r3
    1498:	1c02      	adds	r2, r0, #0
    149a:	801a      	strh	r2, [r3, #0]
    149c:	1dbb      	adds	r3, r7, #6
    149e:	1c0a      	adds	r2, r1, #0
    14a0:	801a      	strh	r2, [r3, #0]
  u8g2_uint_t dx = 0;
    14a2:	2316      	movs	r3, #22
    14a4:	18fb      	adds	r3, r7, r3
    14a6:	2200      	movs	r2, #0
    14a8:	801a      	strh	r2, [r3, #0]
  u8g2->font_decode.target_x = x;
    14aa:	68fb      	ldr	r3, [r7, #12]
    14ac:	220a      	movs	r2, #10
    14ae:	18ba      	adds	r2, r7, r2
    14b0:	2164      	movs	r1, #100	; 0x64
    14b2:	8812      	ldrh	r2, [r2, #0]
    14b4:	525a      	strh	r2, [r3, r1]
  u8g2->font_decode.target_y = y;
    14b6:	68fb      	ldr	r3, [r7, #12]
    14b8:	2208      	movs	r2, #8
    14ba:	18ba      	adds	r2, r7, r2
    14bc:	2166      	movs	r1, #102	; 0x66
    14be:	8812      	ldrh	r2, [r2, #0]
    14c0:	525a      	strh	r2, [r3, r1]
  //u8g2->font_decode.is_transparent = is_transparent; this is already set
  //u8g2->font_decode.dir = dir;
  const uint8_t *glyph_data = u8g2_font_get_glyph_data(u8g2, encoding);
    14c2:	1dbb      	adds	r3, r7, #6
    14c4:	881a      	ldrh	r2, [r3, #0]
    14c6:	68fb      	ldr	r3, [r7, #12]
    14c8:	0011      	movs	r1, r2
    14ca:	0018      	movs	r0, r3
    14cc:	f7ff ff3c 	bl	1348 <u8g2_font_get_glyph_data>
    14d0:	0003      	movs	r3, r0
    14d2:	613b      	str	r3, [r7, #16]
  if ( glyph_data != NULL )
    14d4:	693b      	ldr	r3, [r7, #16]
    14d6:	2b00      	cmp	r3, #0
    14d8:	d00a      	beq.n	14f0 <u8g2_font_draw_glyph+0x72>
  {
    dx = u8g2_font_decode_glyph(u8g2, glyph_data);
    14da:	693a      	ldr	r2, [r7, #16]
    14dc:	68fb      	ldr	r3, [r7, #12]
    14de:	0011      	movs	r1, r2
    14e0:	0018      	movs	r0, r3
    14e2:	f7ff fd9e 	bl	1022 <u8g2_font_decode_glyph>
    14e6:	0003      	movs	r3, r0
    14e8:	001a      	movs	r2, r3
    14ea:	2316      	movs	r3, #22
    14ec:	18fb      	adds	r3, r7, r3
    14ee:	801a      	strh	r2, [r3, #0]
  }
  return dx;
    14f0:	2316      	movs	r3, #22
    14f2:	18fb      	adds	r3, r7, r3
    14f4:	881b      	ldrh	r3, [r3, #0]
}
    14f6:	0018      	movs	r0, r3
    14f8:	46bd      	mov	sp, r7
    14fa:	b007      	add	sp, #28
    14fc:	bd90      	pop	{r4, r7, pc}

000014fe <u8g2_DrawGlyph>:
{
  u8g2->font_decode.is_transparent = is_transparent;		// new font procedures
}

u8g2_uint_t u8g2_DrawGlyph(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, uint16_t encoding)
{
    14fe:	b590      	push	{r4, r7, lr}
    1500:	b085      	sub	sp, #20
    1502:	af00      	add	r7, sp, #0
    1504:	60f8      	str	r0, [r7, #12]
    1506:	000c      	movs	r4, r1
    1508:	0010      	movs	r0, r2
    150a:	0019      	movs	r1, r3
    150c:	230a      	movs	r3, #10
    150e:	18fb      	adds	r3, r7, r3
    1510:	1c22      	adds	r2, r4, #0
    1512:	801a      	strh	r2, [r3, #0]
    1514:	2308      	movs	r3, #8
    1516:	18fb      	adds	r3, r7, r3
    1518:	1c02      	adds	r2, r0, #0
    151a:	801a      	strh	r2, [r3, #0]
    151c:	1dbb      	adds	r3, r7, #6
    151e:	1c0a      	adds	r2, r1, #0
    1520:	801a      	strh	r2, [r3, #0]
#ifdef U8G2_WITH_FONT_ROTATION
  switch(u8g2->font_decode.dir)
    1522:	68fb      	ldr	r3, [r7, #12]
    1524:	2270      	movs	r2, #112	; 0x70
    1526:	5c9b      	ldrb	r3, [r3, r2]
    1528:	2b01      	cmp	r3, #1
    152a:	d017      	beq.n	155c <u8g2_DrawGlyph+0x5e>
    152c:	dc02      	bgt.n	1534 <u8g2_DrawGlyph+0x36>
    152e:	2b00      	cmp	r3, #0
    1530:	d005      	beq.n	153e <u8g2_DrawGlyph+0x40>
    1532:	e040      	b.n	15b6 <u8g2_DrawGlyph+0xb8>
    1534:	2b02      	cmp	r3, #2
    1536:	d020      	beq.n	157a <u8g2_DrawGlyph+0x7c>
    1538:	2b03      	cmp	r3, #3
    153a:	d02d      	beq.n	1598 <u8g2_DrawGlyph+0x9a>
    153c:	e03b      	b.n	15b6 <u8g2_DrawGlyph+0xb8>
  {
    case 0:
      y += u8g2->font_calc_vref(u8g2);
    153e:	68fb      	ldr	r3, [r7, #12]
    1540:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
    1542:	68fa      	ldr	r2, [r7, #12]
    1544:	0010      	movs	r0, r2
    1546:	4798      	blx	r3
    1548:	0003      	movs	r3, r0
    154a:	0019      	movs	r1, r3
    154c:	2308      	movs	r3, #8
    154e:	18fb      	adds	r3, r7, r3
    1550:	2208      	movs	r2, #8
    1552:	18ba      	adds	r2, r7, r2
    1554:	8812      	ldrh	r2, [r2, #0]
    1556:	188a      	adds	r2, r1, r2
    1558:	801a      	strh	r2, [r3, #0]
      break;
    155a:	e02c      	b.n	15b6 <u8g2_DrawGlyph+0xb8>
    case 1:
      x -= u8g2->font_calc_vref(u8g2);
    155c:	68fb      	ldr	r3, [r7, #12]
    155e:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
    1560:	68fa      	ldr	r2, [r7, #12]
    1562:	0010      	movs	r0, r2
    1564:	4798      	blx	r3
    1566:	0003      	movs	r3, r0
    1568:	0019      	movs	r1, r3
    156a:	230a      	movs	r3, #10
    156c:	18fb      	adds	r3, r7, r3
    156e:	220a      	movs	r2, #10
    1570:	18ba      	adds	r2, r7, r2
    1572:	8812      	ldrh	r2, [r2, #0]
    1574:	1a52      	subs	r2, r2, r1
    1576:	801a      	strh	r2, [r3, #0]
      break;
    1578:	e01d      	b.n	15b6 <u8g2_DrawGlyph+0xb8>
    case 2:
      y -= u8g2->font_calc_vref(u8g2);
    157a:	68fb      	ldr	r3, [r7, #12]
    157c:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
    157e:	68fa      	ldr	r2, [r7, #12]
    1580:	0010      	movs	r0, r2
    1582:	4798      	blx	r3
    1584:	0003      	movs	r3, r0
    1586:	0019      	movs	r1, r3
    1588:	2308      	movs	r3, #8
    158a:	18fb      	adds	r3, r7, r3
    158c:	2208      	movs	r2, #8
    158e:	18ba      	adds	r2, r7, r2
    1590:	8812      	ldrh	r2, [r2, #0]
    1592:	1a52      	subs	r2, r2, r1
    1594:	801a      	strh	r2, [r3, #0]
      break;
    1596:	e00e      	b.n	15b6 <u8g2_DrawGlyph+0xb8>
    case 3:
      x += u8g2->font_calc_vref(u8g2);
    1598:	68fb      	ldr	r3, [r7, #12]
    159a:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
    159c:	68fa      	ldr	r2, [r7, #12]
    159e:	0010      	movs	r0, r2
    15a0:	4798      	blx	r3
    15a2:	0003      	movs	r3, r0
    15a4:	0019      	movs	r1, r3
    15a6:	230a      	movs	r3, #10
    15a8:	18fb      	adds	r3, r7, r3
    15aa:	220a      	movs	r2, #10
    15ac:	18ba      	adds	r2, r7, r2
    15ae:	8812      	ldrh	r2, [r2, #0]
    15b0:	188a      	adds	r2, r1, r2
    15b2:	801a      	strh	r2, [r3, #0]
      break;
    15b4:	46c0      	nop			; (mov r8, r8)
  }
#else
  y += u8g2->font_calc_vref(u8g2);
#endif
  return u8g2_font_draw_glyph(u8g2, x, y, encoding);
    15b6:	1dbb      	adds	r3, r7, #6
    15b8:	881c      	ldrh	r4, [r3, #0]
    15ba:	2308      	movs	r3, #8
    15bc:	18fb      	adds	r3, r7, r3
    15be:	881a      	ldrh	r2, [r3, #0]
    15c0:	230a      	movs	r3, #10
    15c2:	18fb      	adds	r3, r7, r3
    15c4:	8819      	ldrh	r1, [r3, #0]
    15c6:	68f8      	ldr	r0, [r7, #12]
    15c8:	0023      	movs	r3, r4
    15ca:	f7ff ff58 	bl	147e <u8g2_font_draw_glyph>
    15ce:	0003      	movs	r3, r0
}
    15d0:	0018      	movs	r0, r3
    15d2:	46bd      	mov	sp, r7
    15d4:	b005      	add	sp, #20
    15d6:	bd90      	pop	{r4, r7, pc}

000015d8 <u8g2_draw_string>:
  return u8g2_font_2x_draw_glyph(u8g2, x, y, encoding);
}

static u8g2_uint_t u8g2_draw_string(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, const char *str) U8G2_NOINLINE;
static u8g2_uint_t u8g2_draw_string(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, const char *str)
{
    15d8:	b5b0      	push	{r4, r5, r7, lr}
    15da:	b086      	sub	sp, #24
    15dc:	af00      	add	r7, sp, #0
    15de:	60f8      	str	r0, [r7, #12]
    15e0:	0008      	movs	r0, r1
    15e2:	0011      	movs	r1, r2
    15e4:	607b      	str	r3, [r7, #4]
    15e6:	230a      	movs	r3, #10
    15e8:	18fb      	adds	r3, r7, r3
    15ea:	1c02      	adds	r2, r0, #0
    15ec:	801a      	strh	r2, [r3, #0]
    15ee:	2308      	movs	r3, #8
    15f0:	18fb      	adds	r3, r7, r3
    15f2:	1c0a      	adds	r2, r1, #0
    15f4:	801a      	strh	r2, [r3, #0]
  uint16_t e;
  u8g2_uint_t delta, sum;
  u8x8_utf8_init(u8g2_GetU8x8(u8g2));
    15f6:	68fb      	ldr	r3, [r7, #12]
    15f8:	0018      	movs	r0, r3
    15fa:	f000 ff76 	bl	24ea <u8x8_utf8_init>
  sum = 0;
    15fe:	2316      	movs	r3, #22
    1600:	18fb      	adds	r3, r7, r3
    1602:	2200      	movs	r2, #0
    1604:	801a      	strh	r2, [r3, #0]
  for(;;)
  {
    e = u8g2->u8x8.next_cb(u8g2_GetU8x8(u8g2), (uint8_t)*str);
    1606:	68fb      	ldr	r3, [r7, #12]
    1608:	685b      	ldr	r3, [r3, #4]
    160a:	687a      	ldr	r2, [r7, #4]
    160c:	7811      	ldrb	r1, [r2, #0]
    160e:	2214      	movs	r2, #20
    1610:	18bc      	adds	r4, r7, r2
    1612:	68fa      	ldr	r2, [r7, #12]
    1614:	0010      	movs	r0, r2
    1616:	4798      	blx	r3
    1618:	0003      	movs	r3, r0
    161a:	8023      	strh	r3, [r4, #0]
    if ( e == 0x0ffff )
    161c:	2314      	movs	r3, #20
    161e:	18fb      	adds	r3, r7, r3
    1620:	881b      	ldrh	r3, [r3, #0]
    1622:	4a35      	ldr	r2, [pc, #212]	; (16f8 <u8g2_draw_string+0x120>)
    1624:	4293      	cmp	r3, r2
    1626:	d05e      	beq.n	16e6 <u8g2_draw_string+0x10e>
      break;
    str++;
    1628:	687b      	ldr	r3, [r7, #4]
    162a:	3301      	adds	r3, #1
    162c:	607b      	str	r3, [r7, #4]
    if ( e != 0x0fffe )
    162e:	2314      	movs	r3, #20
    1630:	18fb      	adds	r3, r7, r3
    1632:	881b      	ldrh	r3, [r3, #0]
    1634:	4a31      	ldr	r2, [pc, #196]	; (16fc <u8g2_draw_string+0x124>)
    1636:	4293      	cmp	r3, r2
    1638:	d0e5      	beq.n	1606 <u8g2_draw_string+0x2e>
    {
      delta = u8g2_DrawGlyph(u8g2, x, y, e);
    163a:	2312      	movs	r3, #18
    163c:	18fc      	adds	r4, r7, r3
    163e:	2314      	movs	r3, #20
    1640:	18fb      	adds	r3, r7, r3
    1642:	881d      	ldrh	r5, [r3, #0]
    1644:	2308      	movs	r3, #8
    1646:	18fb      	adds	r3, r7, r3
    1648:	881a      	ldrh	r2, [r3, #0]
    164a:	230a      	movs	r3, #10
    164c:	18fb      	adds	r3, r7, r3
    164e:	8819      	ldrh	r1, [r3, #0]
    1650:	68f8      	ldr	r0, [r7, #12]
    1652:	002b      	movs	r3, r5
    1654:	f7ff ff53 	bl	14fe <u8g2_DrawGlyph>
    1658:	0003      	movs	r3, r0
    165a:	8023      	strh	r3, [r4, #0]
    
#ifdef U8G2_WITH_FONT_ROTATION
      switch(u8g2->font_decode.dir)
    165c:	68fb      	ldr	r3, [r7, #12]
    165e:	2270      	movs	r2, #112	; 0x70
    1660:	5c9b      	ldrb	r3, [r3, r2]
    1662:	2b01      	cmp	r3, #1
    1664:	d013      	beq.n	168e <u8g2_draw_string+0xb6>
    1666:	dc02      	bgt.n	166e <u8g2_draw_string+0x96>
    1668:	2b00      	cmp	r3, #0
    166a:	d005      	beq.n	1678 <u8g2_draw_string+0xa0>
    166c:	e030      	b.n	16d0 <u8g2_draw_string+0xf8>
    166e:	2b02      	cmp	r3, #2
    1670:	d018      	beq.n	16a4 <u8g2_draw_string+0xcc>
    1672:	2b03      	cmp	r3, #3
    1674:	d021      	beq.n	16ba <u8g2_draw_string+0xe2>
    1676:	e02b      	b.n	16d0 <u8g2_draw_string+0xf8>
      {
	case 0:
	  x += delta;
    1678:	230a      	movs	r3, #10
    167a:	18fb      	adds	r3, r7, r3
    167c:	220a      	movs	r2, #10
    167e:	18b9      	adds	r1, r7, r2
    1680:	2212      	movs	r2, #18
    1682:	18ba      	adds	r2, r7, r2
    1684:	8809      	ldrh	r1, [r1, #0]
    1686:	8812      	ldrh	r2, [r2, #0]
    1688:	188a      	adds	r2, r1, r2
    168a:	801a      	strh	r2, [r3, #0]
	  break;
    168c:	e020      	b.n	16d0 <u8g2_draw_string+0xf8>
	case 1:
	  y += delta;
    168e:	2308      	movs	r3, #8
    1690:	18fb      	adds	r3, r7, r3
    1692:	2208      	movs	r2, #8
    1694:	18b9      	adds	r1, r7, r2
    1696:	2212      	movs	r2, #18
    1698:	18ba      	adds	r2, r7, r2
    169a:	8809      	ldrh	r1, [r1, #0]
    169c:	8812      	ldrh	r2, [r2, #0]
    169e:	188a      	adds	r2, r1, r2
    16a0:	801a      	strh	r2, [r3, #0]
	  break;
    16a2:	e015      	b.n	16d0 <u8g2_draw_string+0xf8>
	case 2:
	  x -= delta;
    16a4:	230a      	movs	r3, #10
    16a6:	18fb      	adds	r3, r7, r3
    16a8:	220a      	movs	r2, #10
    16aa:	18b9      	adds	r1, r7, r2
    16ac:	2212      	movs	r2, #18
    16ae:	18ba      	adds	r2, r7, r2
    16b0:	8809      	ldrh	r1, [r1, #0]
    16b2:	8812      	ldrh	r2, [r2, #0]
    16b4:	1a8a      	subs	r2, r1, r2
    16b6:	801a      	strh	r2, [r3, #0]
	  break;
    16b8:	e00a      	b.n	16d0 <u8g2_draw_string+0xf8>
	case 3:
	  y -= delta;
    16ba:	2308      	movs	r3, #8
    16bc:	18fb      	adds	r3, r7, r3
    16be:	2208      	movs	r2, #8
    16c0:	18b9      	adds	r1, r7, r2
    16c2:	2212      	movs	r2, #18
    16c4:	18ba      	adds	r2, r7, r2
    16c6:	8809      	ldrh	r1, [r1, #0]
    16c8:	8812      	ldrh	r2, [r2, #0]
    16ca:	1a8a      	subs	r2, r1, r2
    16cc:	801a      	strh	r2, [r3, #0]
	  break;
    16ce:	46c0      	nop			; (mov r8, r8)

#else
      x += delta;
#endif

      sum += delta;    
    16d0:	2316      	movs	r3, #22
    16d2:	18fb      	adds	r3, r7, r3
    16d4:	2216      	movs	r2, #22
    16d6:	18b9      	adds	r1, r7, r2
    16d8:	2212      	movs	r2, #18
    16da:	18ba      	adds	r2, r7, r2
    16dc:	8809      	ldrh	r1, [r1, #0]
    16de:	8812      	ldrh	r2, [r2, #0]
    16e0:	188a      	adds	r2, r1, r2
    16e2:	801a      	strh	r2, [r3, #0]
    e = u8g2->u8x8.next_cb(u8g2_GetU8x8(u8g2), (uint8_t)*str);
    16e4:	e78f      	b.n	1606 <u8g2_draw_string+0x2e>
      break;
    16e6:	46c0      	nop			; (mov r8, r8)
    }
  }
  return sum;
    16e8:	2316      	movs	r3, #22
    16ea:	18fb      	adds	r3, r7, r3
    16ec:	881b      	ldrh	r3, [r3, #0]
}
    16ee:	0018      	movs	r0, r3
    16f0:	46bd      	mov	sp, r7
    16f2:	b006      	add	sp, #24
    16f4:	bdb0      	pop	{r4, r5, r7, pc}
    16f6:	46c0      	nop			; (mov r8, r8)
    16f8:	0000ffff 	.word	0x0000ffff
    16fc:	0000fffe 	.word	0x0000fffe

00001700 <u8g2_DrawStr>:
  }
  return sum;
}

u8g2_uint_t u8g2_DrawStr(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, const char *str)
{
    1700:	b590      	push	{r4, r7, lr}
    1702:	b085      	sub	sp, #20
    1704:	af00      	add	r7, sp, #0
    1706:	60f8      	str	r0, [r7, #12]
    1708:	0008      	movs	r0, r1
    170a:	0011      	movs	r1, r2
    170c:	607b      	str	r3, [r7, #4]
    170e:	230a      	movs	r3, #10
    1710:	18fb      	adds	r3, r7, r3
    1712:	1c02      	adds	r2, r0, #0
    1714:	801a      	strh	r2, [r3, #0]
    1716:	2308      	movs	r3, #8
    1718:	18fb      	adds	r3, r7, r3
    171a:	1c0a      	adds	r2, r1, #0
    171c:	801a      	strh	r2, [r3, #0]
  u8g2->u8x8.next_cb = u8x8_ascii_next;
    171e:	68fb      	ldr	r3, [r7, #12]
    1720:	4a08      	ldr	r2, [pc, #32]	; (1744 <u8g2_DrawStr+0x44>)
    1722:	605a      	str	r2, [r3, #4]
  return u8g2_draw_string(u8g2, x, y, str);
    1724:	687c      	ldr	r4, [r7, #4]
    1726:	2308      	movs	r3, #8
    1728:	18fb      	adds	r3, r7, r3
    172a:	881a      	ldrh	r2, [r3, #0]
    172c:	230a      	movs	r3, #10
    172e:	18fb      	adds	r3, r7, r3
    1730:	8819      	ldrh	r1, [r3, #0]
    1732:	68f8      	ldr	r0, [r7, #12]
    1734:	0023      	movs	r3, r4
    1736:	f7ff ff4f 	bl	15d8 <u8g2_draw_string>
    173a:	0003      	movs	r3, r0
}
    173c:	0018      	movs	r0, r3
    173e:	46bd      	mov	sp, r7
    1740:	b005      	add	sp, #20
    1742:	bd90      	pop	{r4, r7, pc}
    1744:	00002505 	.word	0x00002505

00001748 <u8g2_UpdateRefHeight>:
/*===============================================*/

/* set ascent/descent for reference point calculation */

void u8g2_UpdateRefHeight(u8g2_t *u8g2)
{
    1748:	b580      	push	{r7, lr}
    174a:	b082      	sub	sp, #8
    174c:	af00      	add	r7, sp, #0
    174e:	6078      	str	r0, [r7, #4]
  if ( u8g2->font == NULL )
    1750:	687b      	ldr	r3, [r7, #4]
    1752:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    1754:	2b00      	cmp	r3, #0
    1756:	d05d      	beq.n	1814 <u8g2_UpdateRefHeight+0xcc>
    return;
  u8g2->font_ref_ascent = u8g2->font_info.ascent_A;
    1758:	687b      	ldr	r3, [r7, #4]
    175a:	2281      	movs	r2, #129	; 0x81
    175c:	5699      	ldrsb	r1, [r3, r2]
    175e:	687b      	ldr	r3, [r7, #4]
    1760:	228e      	movs	r2, #142	; 0x8e
    1762:	5499      	strb	r1, [r3, r2]
  u8g2->font_ref_descent = u8g2->font_info.descent_g;
    1764:	687b      	ldr	r3, [r7, #4]
    1766:	2282      	movs	r2, #130	; 0x82
    1768:	5699      	ldrsb	r1, [r3, r2]
    176a:	687b      	ldr	r3, [r7, #4]
    176c:	228f      	movs	r2, #143	; 0x8f
    176e:	5499      	strb	r1, [r3, r2]
  if ( u8g2->font_height_mode == U8G2_FONT_HEIGHT_MODE_TEXT )
    1770:	687b      	ldr	r3, [r7, #4]
    1772:	228d      	movs	r2, #141	; 0x8d
    1774:	5c9b      	ldrb	r3, [r3, r2]
    1776:	2b00      	cmp	r3, #0
    1778:	d04d      	beq.n	1816 <u8g2_UpdateRefHeight+0xce>
  {
  }
  else if ( u8g2->font_height_mode == U8G2_FONT_HEIGHT_MODE_XTEXT )
    177a:	687b      	ldr	r3, [r7, #4]
    177c:	228d      	movs	r2, #141	; 0x8d
    177e:	5c9b      	ldrb	r3, [r3, r2]
    1780:	2b01      	cmp	r3, #1
    1782:	d11c      	bne.n	17be <u8g2_UpdateRefHeight+0x76>
  {
    if ( u8g2->font_ref_ascent < u8g2->font_info.ascent_para )
    1784:	687b      	ldr	r3, [r7, #4]
    1786:	228e      	movs	r2, #142	; 0x8e
    1788:	569a      	ldrsb	r2, [r3, r2]
    178a:	687b      	ldr	r3, [r7, #4]
    178c:	2183      	movs	r1, #131	; 0x83
    178e:	565b      	ldrsb	r3, [r3, r1]
    1790:	429a      	cmp	r2, r3
    1792:	da05      	bge.n	17a0 <u8g2_UpdateRefHeight+0x58>
      u8g2->font_ref_ascent = u8g2->font_info.ascent_para;
    1794:	687b      	ldr	r3, [r7, #4]
    1796:	2283      	movs	r2, #131	; 0x83
    1798:	5699      	ldrsb	r1, [r3, r2]
    179a:	687b      	ldr	r3, [r7, #4]
    179c:	228e      	movs	r2, #142	; 0x8e
    179e:	5499      	strb	r1, [r3, r2]
    if ( u8g2->font_ref_descent > u8g2->font_info.descent_para )
    17a0:	687b      	ldr	r3, [r7, #4]
    17a2:	228f      	movs	r2, #143	; 0x8f
    17a4:	569a      	ldrsb	r2, [r3, r2]
    17a6:	687b      	ldr	r3, [r7, #4]
    17a8:	2184      	movs	r1, #132	; 0x84
    17aa:	565b      	ldrsb	r3, [r3, r1]
    17ac:	429a      	cmp	r2, r3
    17ae:	dd32      	ble.n	1816 <u8g2_UpdateRefHeight+0xce>
      u8g2->font_ref_descent = u8g2->font_info.descent_para;
    17b0:	687b      	ldr	r3, [r7, #4]
    17b2:	2284      	movs	r2, #132	; 0x84
    17b4:	5699      	ldrsb	r1, [r3, r2]
    17b6:	687b      	ldr	r3, [r7, #4]
    17b8:	228f      	movs	r2, #143	; 0x8f
    17ba:	5499      	strb	r1, [r3, r2]
    17bc:	e02b      	b.n	1816 <u8g2_UpdateRefHeight+0xce>
  }
  else
  {
    if ( u8g2->font_ref_ascent < u8g2->font_info.max_char_height+u8g2->font_info.y_offset )
    17be:	687b      	ldr	r3, [r7, #4]
    17c0:	228e      	movs	r2, #142	; 0x8e
    17c2:	569b      	ldrsb	r3, [r3, r2]
    17c4:	0019      	movs	r1, r3
    17c6:	687b      	ldr	r3, [r7, #4]
    17c8:	227e      	movs	r2, #126	; 0x7e
    17ca:	569b      	ldrsb	r3, [r3, r2]
    17cc:	0018      	movs	r0, r3
    17ce:	687b      	ldr	r3, [r7, #4]
    17d0:	2280      	movs	r2, #128	; 0x80
    17d2:	569b      	ldrsb	r3, [r3, r2]
    17d4:	18c3      	adds	r3, r0, r3
    17d6:	4299      	cmp	r1, r3
    17d8:	da0d      	bge.n	17f6 <u8g2_UpdateRefHeight+0xae>
      u8g2->font_ref_ascent = u8g2->font_info.max_char_height+u8g2->font_info.y_offset;
    17da:	687b      	ldr	r3, [r7, #4]
    17dc:	227e      	movs	r2, #126	; 0x7e
    17de:	569b      	ldrsb	r3, [r3, r2]
    17e0:	b2da      	uxtb	r2, r3
    17e2:	687b      	ldr	r3, [r7, #4]
    17e4:	2180      	movs	r1, #128	; 0x80
    17e6:	565b      	ldrsb	r3, [r3, r1]
    17e8:	b2db      	uxtb	r3, r3
    17ea:	18d3      	adds	r3, r2, r3
    17ec:	b2db      	uxtb	r3, r3
    17ee:	b259      	sxtb	r1, r3
    17f0:	687b      	ldr	r3, [r7, #4]
    17f2:	228e      	movs	r2, #142	; 0x8e
    17f4:	5499      	strb	r1, [r3, r2]
    if ( u8g2->font_ref_descent > u8g2->font_info.y_offset )
    17f6:	687b      	ldr	r3, [r7, #4]
    17f8:	228f      	movs	r2, #143	; 0x8f
    17fa:	569a      	ldrsb	r2, [r3, r2]
    17fc:	687b      	ldr	r3, [r7, #4]
    17fe:	2180      	movs	r1, #128	; 0x80
    1800:	565b      	ldrsb	r3, [r3, r1]
    1802:	429a      	cmp	r2, r3
    1804:	dd07      	ble.n	1816 <u8g2_UpdateRefHeight+0xce>
      u8g2->font_ref_descent = u8g2->font_info.y_offset;
    1806:	687b      	ldr	r3, [r7, #4]
    1808:	2280      	movs	r2, #128	; 0x80
    180a:	5699      	ldrsb	r1, [r3, r2]
    180c:	687b      	ldr	r3, [r7, #4]
    180e:	228f      	movs	r2, #143	; 0x8f
    1810:	5499      	strb	r1, [r3, r2]
    1812:	e000      	b.n	1816 <u8g2_UpdateRefHeight+0xce>
    return;
    1814:	46c0      	nop			; (mov r8, r8)
  }  
}
    1816:	46bd      	mov	sp, r7
    1818:	b002      	add	sp, #8
    181a:	bd80      	pop	{r7, pc}

0000181c <u8g2_font_calc_vref_font>:

/*===============================================*/
/* callback procedures to correct the y position */

u8g2_uint_t u8g2_font_calc_vref_font(U8X8_UNUSED u8g2_t *u8g2)
{
    181c:	b580      	push	{r7, lr}
    181e:	b082      	sub	sp, #8
    1820:	af00      	add	r7, sp, #0
    1822:	6078      	str	r0, [r7, #4]
  return 0;
    1824:	2300      	movs	r3, #0
}
    1826:	0018      	movs	r0, r3
    1828:	46bd      	mov	sp, r7
    182a:	b002      	add	sp, #8
    182c:	bd80      	pop	{r7, pc}
	...

00001830 <u8g2_SetFontPosBaseline>:

void u8g2_SetFontPosBaseline(u8g2_t *u8g2)
{
    1830:	b580      	push	{r7, lr}
    1832:	b082      	sub	sp, #8
    1834:	af00      	add	r7, sp, #0
    1836:	6078      	str	r0, [r7, #4]
  u8g2->font_calc_vref = u8g2_font_calc_vref_font;
    1838:	687b      	ldr	r3, [r7, #4]
    183a:	4a03      	ldr	r2, [pc, #12]	; (1848 <u8g2_SetFontPosBaseline+0x18>)
    183c:	65da      	str	r2, [r3, #92]	; 0x5c
}
    183e:	46c0      	nop			; (mov r8, r8)
    1840:	46bd      	mov	sp, r7
    1842:	b002      	add	sp, #8
    1844:	bd80      	pop	{r7, pc}
    1846:	46c0      	nop			; (mov r8, r8)
    1848:	0000181d 	.word	0x0000181d

0000184c <u8g2_SetFont>:
}

/*===============================================*/

void u8g2_SetFont(u8g2_t *u8g2, const uint8_t  *font)
{
    184c:	b580      	push	{r7, lr}
    184e:	b082      	sub	sp, #8
    1850:	af00      	add	r7, sp, #0
    1852:	6078      	str	r0, [r7, #4]
    1854:	6039      	str	r1, [r7, #0]
  if ( u8g2->font != font )
    1856:	687b      	ldr	r3, [r7, #4]
    1858:	6d9a      	ldr	r2, [r3, #88]	; 0x58
    185a:	683b      	ldr	r3, [r7, #0]
    185c:	429a      	cmp	r2, r3
    185e:	d00d      	beq.n	187c <u8g2_SetFont+0x30>
  {
//#ifdef  __unix__
//	u8g2->last_font_data = NULL;
//	u8g2->last_unicode = 0x0ffff;
//#endif 
    u8g2->font = font;
    1860:	687b      	ldr	r3, [r7, #4]
    1862:	683a      	ldr	r2, [r7, #0]
    1864:	659a      	str	r2, [r3, #88]	; 0x58
    u8g2_read_font_info(&(u8g2->font_info), font);
    1866:	687b      	ldr	r3, [r7, #4]
    1868:	3374      	adds	r3, #116	; 0x74
    186a:	683a      	ldr	r2, [r7, #0]
    186c:	0011      	movs	r1, r2
    186e:	0018      	movs	r0, r3
    1870:	f7ff f8ba 	bl	9e8 <u8g2_read_font_info>
    u8g2_UpdateRefHeight(u8g2);
    1874:	687b      	ldr	r3, [r7, #4]
    1876:	0018      	movs	r0, r3
    1878:	f7ff ff66 	bl	1748 <u8g2_UpdateRefHeight>
    /* u8g2_SetFontPosBaseline(u8g2); */ /* removed with issue 195 */
  }
}
    187c:	46c0      	nop			; (mov r8, r8)
    187e:	46bd      	mov	sp, r7
    1880:	b002      	add	sp, #8
    1882:	bd80      	pop	{r7, pc}

00001884 <u8g2_clip_intersection2>:
  will return 0 if there is no intersection and if a > b

*/

static uint8_t u8g2_clip_intersection2(u8g2_uint_t *ap, u8g2_uint_t *len, u8g2_uint_t c, u8g2_uint_t d)
{
    1884:	b580      	push	{r7, lr}
    1886:	b086      	sub	sp, #24
    1888:	af00      	add	r7, sp, #0
    188a:	60f8      	str	r0, [r7, #12]
    188c:	60b9      	str	r1, [r7, #8]
    188e:	0019      	movs	r1, r3
    1890:	1dbb      	adds	r3, r7, #6
    1892:	801a      	strh	r2, [r3, #0]
    1894:	1d3b      	adds	r3, r7, #4
    1896:	1c0a      	adds	r2, r1, #0
    1898:	801a      	strh	r2, [r3, #0]
  u8g2_uint_t a = *ap;
    189a:	2316      	movs	r3, #22
    189c:	18fb      	adds	r3, r7, r3
    189e:	68fa      	ldr	r2, [r7, #12]
    18a0:	8812      	ldrh	r2, [r2, #0]
    18a2:	801a      	strh	r2, [r3, #0]
  u8g2_uint_t b;
  b  = a;
    18a4:	2314      	movs	r3, #20
    18a6:	18fb      	adds	r3, r7, r3
    18a8:	2216      	movs	r2, #22
    18aa:	18ba      	adds	r2, r7, r2
    18ac:	8812      	ldrh	r2, [r2, #0]
    18ae:	801a      	strh	r2, [r3, #0]
  b += *len;
    18b0:	68bb      	ldr	r3, [r7, #8]
    18b2:	8819      	ldrh	r1, [r3, #0]
    18b4:	2314      	movs	r3, #20
    18b6:	18fb      	adds	r3, r7, r3
    18b8:	2214      	movs	r2, #20
    18ba:	18ba      	adds	r2, r7, r2
    18bc:	8812      	ldrh	r2, [r2, #0]
    18be:	188a      	adds	r2, r1, r2
    18c0:	801a      	strh	r2, [r3, #0]
  /* be removed completly (be aware about memory curruption for wrong */
  /* arguments) or return 0 for a>b (will lead to skipped lines for wrong */
  /* arguments) */  
  
  /* removing the following if clause completly may lead to memory corruption of a>b */
  if ( a > b )
    18c2:	2316      	movs	r3, #22
    18c4:	18fa      	adds	r2, r7, r3
    18c6:	2314      	movs	r3, #20
    18c8:	18fb      	adds	r3, r7, r3
    18ca:	8812      	ldrh	r2, [r2, #0]
    18cc:	881b      	ldrh	r3, [r3, #0]
    18ce:	429a      	cmp	r2, r3
    18d0:	d918      	bls.n	1904 <u8g2_clip_intersection2+0x80>
  {    
    /* replacing this if with a simple "return 0;" will not handle the case with negative a */    
    if ( a < d )
    18d2:	2316      	movs	r3, #22
    18d4:	18fa      	adds	r2, r7, r3
    18d6:	1d3b      	adds	r3, r7, #4
    18d8:	8812      	ldrh	r2, [r2, #0]
    18da:	881b      	ldrh	r3, [r3, #0]
    18dc:	429a      	cmp	r2, r3
    18de:	d20c      	bcs.n	18fa <u8g2_clip_intersection2+0x76>
    {
      b = d;
    18e0:	2314      	movs	r3, #20
    18e2:	18fb      	adds	r3, r7, r3
    18e4:	1d3a      	adds	r2, r7, #4
    18e6:	8812      	ldrh	r2, [r2, #0]
    18e8:	801a      	strh	r2, [r3, #0]
      b--;
    18ea:	2314      	movs	r3, #20
    18ec:	18fb      	adds	r3, r7, r3
    18ee:	881a      	ldrh	r2, [r3, #0]
    18f0:	2314      	movs	r3, #20
    18f2:	18fb      	adds	r3, r7, r3
    18f4:	3a01      	subs	r2, #1
    18f6:	801a      	strh	r2, [r3, #0]
    18f8:	e004      	b.n	1904 <u8g2_clip_intersection2+0x80>
    }
    else
    {
      a = c;
    18fa:	2316      	movs	r3, #22
    18fc:	18fb      	adds	r3, r7, r3
    18fe:	1dba      	adds	r2, r7, #6
    1900:	8812      	ldrh	r2, [r2, #0]
    1902:	801a      	strh	r2, [r3, #0]
    }
  }
  
  /* from now on, the asumption a <= b is ok */
  
  if ( a >= d )
    1904:	2316      	movs	r3, #22
    1906:	18fa      	adds	r2, r7, r3
    1908:	1d3b      	adds	r3, r7, #4
    190a:	8812      	ldrh	r2, [r2, #0]
    190c:	881b      	ldrh	r3, [r3, #0]
    190e:	429a      	cmp	r2, r3
    1910:	d301      	bcc.n	1916 <u8g2_clip_intersection2+0x92>
    return 0;
    1912:	2300      	movs	r3, #0
    1914:	e035      	b.n	1982 <u8g2_clip_intersection2+0xfe>
  if ( b <= c )
    1916:	2314      	movs	r3, #20
    1918:	18fa      	adds	r2, r7, r3
    191a:	1dbb      	adds	r3, r7, #6
    191c:	8812      	ldrh	r2, [r2, #0]
    191e:	881b      	ldrh	r3, [r3, #0]
    1920:	429a      	cmp	r2, r3
    1922:	d801      	bhi.n	1928 <u8g2_clip_intersection2+0xa4>
    return 0;
    1924:	2300      	movs	r3, #0
    1926:	e02c      	b.n	1982 <u8g2_clip_intersection2+0xfe>
  if ( a < c )		
    1928:	2316      	movs	r3, #22
    192a:	18fa      	adds	r2, r7, r3
    192c:	1dbb      	adds	r3, r7, #6
    192e:	8812      	ldrh	r2, [r2, #0]
    1930:	881b      	ldrh	r3, [r3, #0]
    1932:	429a      	cmp	r2, r3
    1934:	d204      	bcs.n	1940 <u8g2_clip_intersection2+0xbc>
    a = c;
    1936:	2316      	movs	r3, #22
    1938:	18fb      	adds	r3, r7, r3
    193a:	1dba      	adds	r2, r7, #6
    193c:	8812      	ldrh	r2, [r2, #0]
    193e:	801a      	strh	r2, [r3, #0]
  if ( b > d )
    1940:	2314      	movs	r3, #20
    1942:	18fa      	adds	r2, r7, r3
    1944:	1d3b      	adds	r3, r7, #4
    1946:	8812      	ldrh	r2, [r2, #0]
    1948:	881b      	ldrh	r3, [r3, #0]
    194a:	429a      	cmp	r2, r3
    194c:	d904      	bls.n	1958 <u8g2_clip_intersection2+0xd4>
    b = d;
    194e:	2314      	movs	r3, #20
    1950:	18fb      	adds	r3, r7, r3
    1952:	1d3a      	adds	r2, r7, #4
    1954:	8812      	ldrh	r2, [r2, #0]
    1956:	801a      	strh	r2, [r3, #0]
  
  *ap = a;
    1958:	68fb      	ldr	r3, [r7, #12]
    195a:	2216      	movs	r2, #22
    195c:	18ba      	adds	r2, r7, r2
    195e:	8812      	ldrh	r2, [r2, #0]
    1960:	801a      	strh	r2, [r3, #0]
  b -= a;
    1962:	2314      	movs	r3, #20
    1964:	18fb      	adds	r3, r7, r3
    1966:	2214      	movs	r2, #20
    1968:	18b9      	adds	r1, r7, r2
    196a:	2216      	movs	r2, #22
    196c:	18ba      	adds	r2, r7, r2
    196e:	8809      	ldrh	r1, [r1, #0]
    1970:	8812      	ldrh	r2, [r2, #0]
    1972:	1a8a      	subs	r2, r1, r2
    1974:	801a      	strh	r2, [r3, #0]
  *len = b;
    1976:	68bb      	ldr	r3, [r7, #8]
    1978:	2214      	movs	r2, #20
    197a:	18ba      	adds	r2, r7, r2
    197c:	8812      	ldrh	r2, [r2, #0]
    197e:	801a      	strh	r2, [r3, #0]
  return 1;
    1980:	2301      	movs	r3, #1
}
    1982:	0018      	movs	r0, r3
    1984:	46bd      	mov	sp, r7
    1986:	b006      	add	sp, #24
    1988:	bd80      	pop	{r7, pc}

0000198a <u8g2_draw_hv_line_2dir>:
  This function first adjusts the y position to the local buffer. Then it
  will clip the line and call u8g2_draw_low_level_hv_line()

*/
void u8g2_draw_hv_line_2dir(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t len, uint8_t dir)
{
    198a:	b5b0      	push	{r4, r5, r7, lr}
    198c:	b086      	sub	sp, #24
    198e:	af02      	add	r7, sp, #8
    1990:	60f8      	str	r0, [r7, #12]
    1992:	000c      	movs	r4, r1
    1994:	0010      	movs	r0, r2
    1996:	0019      	movs	r1, r3
    1998:	230a      	movs	r3, #10
    199a:	18fb      	adds	r3, r7, r3
    199c:	1c22      	adds	r2, r4, #0
    199e:	801a      	strh	r2, [r3, #0]
    19a0:	2308      	movs	r3, #8
    19a2:	18fb      	adds	r3, r7, r3
    19a4:	1c02      	adds	r2, r0, #0
    19a6:	801a      	strh	r2, [r3, #0]
    19a8:	1dbb      	adds	r3, r7, #6
    19aa:	1c0a      	adds	r2, r1, #0
    19ac:	801a      	strh	r2, [r3, #0]

  /* clipping happens before the display rotation */

  /* transform to pixel buffer coordinates */
  y -= u8g2->pixel_curr_row;
    19ae:	68fb      	ldr	r3, [r7, #12]
    19b0:	8fda      	ldrh	r2, [r3, #62]	; 0x3e
    19b2:	2308      	movs	r3, #8
    19b4:	18fb      	adds	r3, r7, r3
    19b6:	2108      	movs	r1, #8
    19b8:	1879      	adds	r1, r7, r1
    19ba:	8809      	ldrh	r1, [r1, #0]
    19bc:	1a8a      	subs	r2, r1, r2
    19be:	801a      	strh	r2, [r3, #0]
  
  u8g2->ll_hvline(u8g2, x, y, len, dir);
    19c0:	68fb      	ldr	r3, [r7, #12]
    19c2:	6adc      	ldr	r4, [r3, #44]	; 0x2c
    19c4:	1dbb      	adds	r3, r7, #6
    19c6:	881d      	ldrh	r5, [r3, #0]
    19c8:	2308      	movs	r3, #8
    19ca:	18fb      	adds	r3, r7, r3
    19cc:	881a      	ldrh	r2, [r3, #0]
    19ce:	230a      	movs	r3, #10
    19d0:	18fb      	adds	r3, r7, r3
    19d2:	8819      	ldrh	r1, [r3, #0]
    19d4:	68f8      	ldr	r0, [r7, #12]
    19d6:	2320      	movs	r3, #32
    19d8:	18fb      	adds	r3, r7, r3
    19da:	781b      	ldrb	r3, [r3, #0]
    19dc:	9300      	str	r3, [sp, #0]
    19de:	002b      	movs	r3, r5
    19e0:	47a0      	blx	r4
}
    19e2:	46c0      	nop			; (mov r8, r8)
    19e4:	46bd      	mov	sp, r7
    19e6:	b004      	add	sp, #16
    19e8:	bdb0      	pop	{r4, r5, r7, pc}

000019ea <u8g2_DrawHVLine>:
  This function should be called by the user.
  
  "dir" may have 4 directions: 0 (left to right), 1, 2, 3 (down up)
*/
void u8g2_DrawHVLine(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t len, uint8_t dir)
{
    19ea:	b5b0      	push	{r4, r5, r7, lr}
    19ec:	b086      	sub	sp, #24
    19ee:	af02      	add	r7, sp, #8
    19f0:	60f8      	str	r0, [r7, #12]
    19f2:	000c      	movs	r4, r1
    19f4:	0010      	movs	r0, r2
    19f6:	0019      	movs	r1, r3
    19f8:	230a      	movs	r3, #10
    19fa:	18fb      	adds	r3, r7, r3
    19fc:	1c22      	adds	r2, r4, #0
    19fe:	801a      	strh	r2, [r3, #0]
    1a00:	2308      	movs	r3, #8
    1a02:	18fb      	adds	r3, r7, r3
    1a04:	1c02      	adds	r2, r0, #0
    1a06:	801a      	strh	r2, [r3, #0]
    1a08:	1dbb      	adds	r3, r7, #6
    1a0a:	1c0a      	adds	r2, r1, #0
    1a0c:	801a      	strh	r2, [r3, #0]
  /* Make a call to the callback function (e.g. u8g2_draw_l90_r0). */
  /* The callback may rotate the hv line */
  /* after rotation this will call u8g2_draw_hv_line_4dir() */
  
#ifdef U8G2_WITH_CLIP_WINDOW_SUPPORT
  if ( u8g2->is_page_clip_window_intersection != 0 )
    1a0e:	68fb      	ldr	r3, [r7, #12]
    1a10:	228c      	movs	r2, #140	; 0x8c
    1a12:	5c9b      	ldrb	r3, [r3, r2]
    1a14:	2b00      	cmp	r3, #0
    1a16:	d100      	bne.n	1a1a <u8g2_DrawHVLine+0x30>
    1a18:	e09d      	b.n	1b56 <u8g2_DrawHVLine+0x16c>
#endif /* U8G2_WITH_CLIP_WINDOW_SUPPORT */
    if ( len != 0 )
    1a1a:	1dbb      	adds	r3, r7, #6
    1a1c:	881b      	ldrh	r3, [r3, #0]
    1a1e:	2b00      	cmp	r3, #0
    1a20:	d100      	bne.n	1a24 <u8g2_DrawHVLine+0x3a>
    1a22:	e098      	b.n	1b56 <u8g2_DrawHVLine+0x16c>
    {
    
      /* convert to two directions */    
      if ( len > 1 )
    1a24:	1dbb      	adds	r3, r7, #6
    1a26:	881b      	ldrh	r3, [r3, #0]
    1a28:	2b01      	cmp	r3, #1
    1a2a:	d92e      	bls.n	1a8a <u8g2_DrawHVLine+0xa0>
      {
	if ( dir == 2 )
    1a2c:	2320      	movs	r3, #32
    1a2e:	18fb      	adds	r3, r7, r3
    1a30:	781b      	ldrb	r3, [r3, #0]
    1a32:	2b02      	cmp	r3, #2
    1a34:	d112      	bne.n	1a5c <u8g2_DrawHVLine+0x72>
	{
	  x -= len;
    1a36:	230a      	movs	r3, #10
    1a38:	18fb      	adds	r3, r7, r3
    1a3a:	881a      	ldrh	r2, [r3, #0]
    1a3c:	1dbb      	adds	r3, r7, #6
    1a3e:	881b      	ldrh	r3, [r3, #0]
    1a40:	1ad3      	subs	r3, r2, r3
    1a42:	b29a      	uxth	r2, r3
    1a44:	230a      	movs	r3, #10
    1a46:	18fb      	adds	r3, r7, r3
    1a48:	801a      	strh	r2, [r3, #0]
	  x++;
    1a4a:	230a      	movs	r3, #10
    1a4c:	18fb      	adds	r3, r7, r3
    1a4e:	881b      	ldrh	r3, [r3, #0]
    1a50:	3301      	adds	r3, #1
    1a52:	b29a      	uxth	r2, r3
    1a54:	230a      	movs	r3, #10
    1a56:	18fb      	adds	r3, r7, r3
    1a58:	801a      	strh	r2, [r3, #0]
    1a5a:	e016      	b.n	1a8a <u8g2_DrawHVLine+0xa0>
	}
	else if ( dir == 3 )
    1a5c:	2320      	movs	r3, #32
    1a5e:	18fb      	adds	r3, r7, r3
    1a60:	781b      	ldrb	r3, [r3, #0]
    1a62:	2b03      	cmp	r3, #3
    1a64:	d111      	bne.n	1a8a <u8g2_DrawHVLine+0xa0>
	{
	  y -= len;
    1a66:	2308      	movs	r3, #8
    1a68:	18fb      	adds	r3, r7, r3
    1a6a:	881a      	ldrh	r2, [r3, #0]
    1a6c:	1dbb      	adds	r3, r7, #6
    1a6e:	881b      	ldrh	r3, [r3, #0]
    1a70:	1ad3      	subs	r3, r2, r3
    1a72:	b29a      	uxth	r2, r3
    1a74:	2308      	movs	r3, #8
    1a76:	18fb      	adds	r3, r7, r3
    1a78:	801a      	strh	r2, [r3, #0]
	  y++;
    1a7a:	2308      	movs	r3, #8
    1a7c:	18fb      	adds	r3, r7, r3
    1a7e:	881b      	ldrh	r3, [r3, #0]
    1a80:	3301      	adds	r3, #1
    1a82:	b29a      	uxth	r2, r3
    1a84:	2308      	movs	r3, #8
    1a86:	18fb      	adds	r3, r7, r3
    1a88:	801a      	strh	r2, [r3, #0]
	}
      }
      dir &= 1;  
    1a8a:	2320      	movs	r3, #32
    1a8c:	18f9      	adds	r1, r7, r3
    1a8e:	2320      	movs	r3, #32
    1a90:	18fb      	adds	r3, r7, r3
    1a92:	781b      	ldrb	r3, [r3, #0]
    1a94:	2201      	movs	r2, #1
    1a96:	4013      	ands	r3, r2
    1a98:	700b      	strb	r3, [r1, #0]
      
      /* clip against the user window */
      if ( dir == 0 )
    1a9a:	2320      	movs	r3, #32
    1a9c:	18fb      	adds	r3, r7, r3
    1a9e:	781b      	ldrb	r3, [r3, #0]
    1aa0:	2b00      	cmp	r3, #0
    1aa2:	d11e      	bne.n	1ae2 <u8g2_DrawHVLine+0xf8>
      {
	if ( y < u8g2->user_y0 )
    1aa4:	68fb      	ldr	r3, [r7, #12]
    1aa6:	224c      	movs	r2, #76	; 0x4c
    1aa8:	5a9a      	ldrh	r2, [r3, r2]
    1aaa:	2308      	movs	r3, #8
    1aac:	18fb      	adds	r3, r7, r3
    1aae:	881b      	ldrh	r3, [r3, #0]
    1ab0:	429a      	cmp	r2, r3
    1ab2:	d847      	bhi.n	1b44 <u8g2_DrawHVLine+0x15a>
	  return;
	if ( y >= u8g2->user_y1 )
    1ab4:	68fb      	ldr	r3, [r7, #12]
    1ab6:	224e      	movs	r2, #78	; 0x4e
    1ab8:	5a9a      	ldrh	r2, [r3, r2]
    1aba:	2308      	movs	r3, #8
    1abc:	18fb      	adds	r3, r7, r3
    1abe:	881b      	ldrh	r3, [r3, #0]
    1ac0:	429a      	cmp	r2, r3
    1ac2:	d941      	bls.n	1b48 <u8g2_DrawHVLine+0x15e>
	  return;
	if ( u8g2_clip_intersection2(&x, &len, u8g2->user_x0, u8g2->user_x1) == 0 )
    1ac4:	68fb      	ldr	r3, [r7, #12]
    1ac6:	2248      	movs	r2, #72	; 0x48
    1ac8:	5a9c      	ldrh	r4, [r3, r2]
    1aca:	68fb      	ldr	r3, [r7, #12]
    1acc:	224a      	movs	r2, #74	; 0x4a
    1ace:	5a9b      	ldrh	r3, [r3, r2]
    1ad0:	1db9      	adds	r1, r7, #6
    1ad2:	220a      	movs	r2, #10
    1ad4:	18b8      	adds	r0, r7, r2
    1ad6:	0022      	movs	r2, r4
    1ad8:	f7ff fed4 	bl	1884 <u8g2_clip_intersection2>
    1adc:	1e03      	subs	r3, r0, #0
    1ade:	d11e      	bne.n	1b1e <u8g2_DrawHVLine+0x134>
	  return;
    1ae0:	e039      	b.n	1b56 <u8g2_DrawHVLine+0x16c>
      }
      else
      {
	if ( x < u8g2->user_x0 )
    1ae2:	68fb      	ldr	r3, [r7, #12]
    1ae4:	2248      	movs	r2, #72	; 0x48
    1ae6:	5a9a      	ldrh	r2, [r3, r2]
    1ae8:	230a      	movs	r3, #10
    1aea:	18fb      	adds	r3, r7, r3
    1aec:	881b      	ldrh	r3, [r3, #0]
    1aee:	429a      	cmp	r2, r3
    1af0:	d82c      	bhi.n	1b4c <u8g2_DrawHVLine+0x162>
	  return;
	if ( x >= u8g2->user_x1 )
    1af2:	68fb      	ldr	r3, [r7, #12]
    1af4:	224a      	movs	r2, #74	; 0x4a
    1af6:	5a9a      	ldrh	r2, [r3, r2]
    1af8:	230a      	movs	r3, #10
    1afa:	18fb      	adds	r3, r7, r3
    1afc:	881b      	ldrh	r3, [r3, #0]
    1afe:	429a      	cmp	r2, r3
    1b00:	d926      	bls.n	1b50 <u8g2_DrawHVLine+0x166>
	  return;
	if ( u8g2_clip_intersection2(&y, &len, u8g2->user_y0, u8g2->user_y1) == 0 )
    1b02:	68fb      	ldr	r3, [r7, #12]
    1b04:	224c      	movs	r2, #76	; 0x4c
    1b06:	5a9c      	ldrh	r4, [r3, r2]
    1b08:	68fb      	ldr	r3, [r7, #12]
    1b0a:	224e      	movs	r2, #78	; 0x4e
    1b0c:	5a9b      	ldrh	r3, [r3, r2]
    1b0e:	1db9      	adds	r1, r7, #6
    1b10:	2208      	movs	r2, #8
    1b12:	18b8      	adds	r0, r7, r2
    1b14:	0022      	movs	r2, r4
    1b16:	f7ff feb5 	bl	1884 <u8g2_clip_intersection2>
    1b1a:	1e03      	subs	r3, r0, #0
    1b1c:	d01a      	beq.n	1b54 <u8g2_DrawHVLine+0x16a>
	  return;
      }
      
      
      u8g2->cb->draw_l90(u8g2, x, y, len, dir);
    1b1e:	68fb      	ldr	r3, [r7, #12]
    1b20:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    1b22:	689c      	ldr	r4, [r3, #8]
    1b24:	230a      	movs	r3, #10
    1b26:	18fb      	adds	r3, r7, r3
    1b28:	8819      	ldrh	r1, [r3, #0]
    1b2a:	2308      	movs	r3, #8
    1b2c:	18fb      	adds	r3, r7, r3
    1b2e:	881a      	ldrh	r2, [r3, #0]
    1b30:	1dbb      	adds	r3, r7, #6
    1b32:	881d      	ldrh	r5, [r3, #0]
    1b34:	68f8      	ldr	r0, [r7, #12]
    1b36:	2320      	movs	r3, #32
    1b38:	18fb      	adds	r3, r7, r3
    1b3a:	781b      	ldrb	r3, [r3, #0]
    1b3c:	9300      	str	r3, [sp, #0]
    1b3e:	002b      	movs	r3, r5
    1b40:	47a0      	blx	r4
    1b42:	e008      	b.n	1b56 <u8g2_DrawHVLine+0x16c>
	  return;
    1b44:	46c0      	nop			; (mov r8, r8)
    1b46:	e006      	b.n	1b56 <u8g2_DrawHVLine+0x16c>
	  return;
    1b48:	46c0      	nop			; (mov r8, r8)
    1b4a:	e004      	b.n	1b56 <u8g2_DrawHVLine+0x16c>
	  return;
    1b4c:	46c0      	nop			; (mov r8, r8)
    1b4e:	e002      	b.n	1b56 <u8g2_DrawHVLine+0x16c>
	  return;
    1b50:	46c0      	nop			; (mov r8, r8)
    1b52:	e000      	b.n	1b56 <u8g2_DrawHVLine+0x16c>
	  return;
    1b54:	46c0      	nop			; (mov r8, r8)
    }
}
    1b56:	46bd      	mov	sp, r7
    1b58:	b004      	add	sp, #16
    1b5a:	bdb0      	pop	{r4, r5, r7, pc}

00001b5c <u8g2_DrawHLine>:

void u8g2_DrawHLine(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t len)
{
    1b5c:	b590      	push	{r4, r7, lr}
    1b5e:	b087      	sub	sp, #28
    1b60:	af02      	add	r7, sp, #8
    1b62:	60f8      	str	r0, [r7, #12]
    1b64:	000c      	movs	r4, r1
    1b66:	0010      	movs	r0, r2
    1b68:	0019      	movs	r1, r3
    1b6a:	230a      	movs	r3, #10
    1b6c:	18fb      	adds	r3, r7, r3
    1b6e:	1c22      	adds	r2, r4, #0
    1b70:	801a      	strh	r2, [r3, #0]
    1b72:	2308      	movs	r3, #8
    1b74:	18fb      	adds	r3, r7, r3
    1b76:	1c02      	adds	r2, r0, #0
    1b78:	801a      	strh	r2, [r3, #0]
    1b7a:	1dbb      	adds	r3, r7, #6
    1b7c:	1c0a      	adds	r2, r1, #0
    1b7e:	801a      	strh	r2, [r3, #0]
// #ifdef U8G2_WITH_INTERSECTION
//   if ( u8g2_IsIntersection(u8g2, x, y, x+len, y+1) == 0 ) 
//     return;
// #endif /* U8G2_WITH_INTERSECTION */
  u8g2_DrawHVLine(u8g2, x, y, len, 0);
    1b80:	1dbb      	adds	r3, r7, #6
    1b82:	881c      	ldrh	r4, [r3, #0]
    1b84:	2308      	movs	r3, #8
    1b86:	18fb      	adds	r3, r7, r3
    1b88:	881a      	ldrh	r2, [r3, #0]
    1b8a:	230a      	movs	r3, #10
    1b8c:	18fb      	adds	r3, r7, r3
    1b8e:	8819      	ldrh	r1, [r3, #0]
    1b90:	68f8      	ldr	r0, [r7, #12]
    1b92:	2300      	movs	r3, #0
    1b94:	9300      	str	r3, [sp, #0]
    1b96:	0023      	movs	r3, r4
    1b98:	f7ff ff27 	bl	19ea <u8g2_DrawHVLine>
}
    1b9c:	46c0      	nop			; (mov r8, r8)
    1b9e:	46bd      	mov	sp, r7
    1ba0:	b005      	add	sp, #20
    1ba2:	bd90      	pop	{r4, r7, pc}

00001ba4 <u8g2_DrawVLine>:

void u8g2_DrawVLine(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t len)
{
    1ba4:	b590      	push	{r4, r7, lr}
    1ba6:	b087      	sub	sp, #28
    1ba8:	af02      	add	r7, sp, #8
    1baa:	60f8      	str	r0, [r7, #12]
    1bac:	000c      	movs	r4, r1
    1bae:	0010      	movs	r0, r2
    1bb0:	0019      	movs	r1, r3
    1bb2:	230a      	movs	r3, #10
    1bb4:	18fb      	adds	r3, r7, r3
    1bb6:	1c22      	adds	r2, r4, #0
    1bb8:	801a      	strh	r2, [r3, #0]
    1bba:	2308      	movs	r3, #8
    1bbc:	18fb      	adds	r3, r7, r3
    1bbe:	1c02      	adds	r2, r0, #0
    1bc0:	801a      	strh	r2, [r3, #0]
    1bc2:	1dbb      	adds	r3, r7, #6
    1bc4:	1c0a      	adds	r2, r1, #0
    1bc6:	801a      	strh	r2, [r3, #0]
// #ifdef U8G2_WITH_INTERSECTION
//   if ( u8g2_IsIntersection(u8g2, x, y, x+1, y+len) == 0 ) 
//     return;
// #endif /* U8G2_WITH_INTERSECTION */
  u8g2_DrawHVLine(u8g2, x, y, len, 1);
    1bc8:	1dbb      	adds	r3, r7, #6
    1bca:	881c      	ldrh	r4, [r3, #0]
    1bcc:	2308      	movs	r3, #8
    1bce:	18fb      	adds	r3, r7, r3
    1bd0:	881a      	ldrh	r2, [r3, #0]
    1bd2:	230a      	movs	r3, #10
    1bd4:	18fb      	adds	r3, r7, r3
    1bd6:	8819      	ldrh	r1, [r3, #0]
    1bd8:	68f8      	ldr	r0, [r7, #12]
    1bda:	2301      	movs	r3, #1
    1bdc:	9300      	str	r3, [sp, #0]
    1bde:	0023      	movs	r3, r4
    1be0:	f7ff ff03 	bl	19ea <u8g2_DrawHVLine>
}
    1be4:	46c0      	nop			; (mov r8, r8)
    1be6:	46bd      	mov	sp, r7
    1be8:	b005      	add	sp, #20
    1bea:	bd90      	pop	{r4, r7, pc}

00001bec <u8g2_DrawPixel>:

void u8g2_DrawPixel(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y)
{
    1bec:	b580      	push	{r7, lr}
    1bee:	b084      	sub	sp, #16
    1bf0:	af02      	add	r7, sp, #8
    1bf2:	6078      	str	r0, [r7, #4]
    1bf4:	0008      	movs	r0, r1
    1bf6:	0011      	movs	r1, r2
    1bf8:	1cbb      	adds	r3, r7, #2
    1bfa:	1c02      	adds	r2, r0, #0
    1bfc:	801a      	strh	r2, [r3, #0]
    1bfe:	003b      	movs	r3, r7
    1c00:	1c0a      	adds	r2, r1, #0
    1c02:	801a      	strh	r2, [r3, #0]
#ifdef U8G2_WITH_INTERSECTION
  if ( y < u8g2->user_y0 )
    1c04:	687b      	ldr	r3, [r7, #4]
    1c06:	224c      	movs	r2, #76	; 0x4c
    1c08:	5a9b      	ldrh	r3, [r3, r2]
    1c0a:	003a      	movs	r2, r7
    1c0c:	8812      	ldrh	r2, [r2, #0]
    1c0e:	429a      	cmp	r2, r3
    1c10:	d31f      	bcc.n	1c52 <u8g2_DrawPixel+0x66>
    return;
  if ( y >= u8g2->user_y1 )
    1c12:	687b      	ldr	r3, [r7, #4]
    1c14:	224e      	movs	r2, #78	; 0x4e
    1c16:	5a9b      	ldrh	r3, [r3, r2]
    1c18:	003a      	movs	r2, r7
    1c1a:	8812      	ldrh	r2, [r2, #0]
    1c1c:	429a      	cmp	r2, r3
    1c1e:	d21a      	bcs.n	1c56 <u8g2_DrawPixel+0x6a>
    return;
  if ( x < u8g2->user_x0 )
    1c20:	687b      	ldr	r3, [r7, #4]
    1c22:	2248      	movs	r2, #72	; 0x48
    1c24:	5a9b      	ldrh	r3, [r3, r2]
    1c26:	1cba      	adds	r2, r7, #2
    1c28:	8812      	ldrh	r2, [r2, #0]
    1c2a:	429a      	cmp	r2, r3
    1c2c:	d315      	bcc.n	1c5a <u8g2_DrawPixel+0x6e>
    return;
  if ( x >= u8g2->user_x1 )
    1c2e:	687b      	ldr	r3, [r7, #4]
    1c30:	224a      	movs	r2, #74	; 0x4a
    1c32:	5a9b      	ldrh	r3, [r3, r2]
    1c34:	1cba      	adds	r2, r7, #2
    1c36:	8812      	ldrh	r2, [r2, #0]
    1c38:	429a      	cmp	r2, r3
    1c3a:	d210      	bcs.n	1c5e <u8g2_DrawPixel+0x72>
    return;
#endif /* U8G2_WITH_INTERSECTION */
  u8g2_DrawHVLine(u8g2, x, y, 1, 0);
    1c3c:	003b      	movs	r3, r7
    1c3e:	881a      	ldrh	r2, [r3, #0]
    1c40:	1cbb      	adds	r3, r7, #2
    1c42:	8819      	ldrh	r1, [r3, #0]
    1c44:	6878      	ldr	r0, [r7, #4]
    1c46:	2300      	movs	r3, #0
    1c48:	9300      	str	r3, [sp, #0]
    1c4a:	2301      	movs	r3, #1
    1c4c:	f7ff fecd 	bl	19ea <u8g2_DrawHVLine>
    1c50:	e006      	b.n	1c60 <u8g2_DrawPixel+0x74>
    return;
    1c52:	46c0      	nop			; (mov r8, r8)
    1c54:	e004      	b.n	1c60 <u8g2_DrawPixel+0x74>
    return;
    1c56:	46c0      	nop			; (mov r8, r8)
    1c58:	e002      	b.n	1c60 <u8g2_DrawPixel+0x74>
    return;
    1c5a:	46c0      	nop			; (mov r8, r8)
    1c5c:	e000      	b.n	1c60 <u8g2_DrawPixel+0x74>
    return;
    1c5e:	46c0      	nop			; (mov r8, r8)
}
    1c60:	46bd      	mov	sp, r7
    1c62:	b002      	add	sp, #8
    1c64:	bd80      	pop	{r7, pc}

00001c66 <u8g2_is_intersection_decision_tree>:
  version with asymetric boundaries.
  a1 and v1 are excluded
  v0 == v1 is not support end return 1
*/
uint8_t u8g2_is_intersection_decision_tree(u8g2_uint_t a0, u8g2_uint_t a1, u8g2_uint_t v0, u8g2_uint_t v1)
{
    1c66:	b5b0      	push	{r4, r5, r7, lr}
    1c68:	b082      	sub	sp, #8
    1c6a:	af00      	add	r7, sp, #0
    1c6c:	0005      	movs	r5, r0
    1c6e:	000c      	movs	r4, r1
    1c70:	0010      	movs	r0, r2
    1c72:	0019      	movs	r1, r3
    1c74:	1dbb      	adds	r3, r7, #6
    1c76:	1c2a      	adds	r2, r5, #0
    1c78:	801a      	strh	r2, [r3, #0]
    1c7a:	1d3b      	adds	r3, r7, #4
    1c7c:	1c22      	adds	r2, r4, #0
    1c7e:	801a      	strh	r2, [r3, #0]
    1c80:	1cbb      	adds	r3, r7, #2
    1c82:	1c02      	adds	r2, r0, #0
    1c84:	801a      	strh	r2, [r3, #0]
    1c86:	003b      	movs	r3, r7
    1c88:	1c0a      	adds	r2, r1, #0
    1c8a:	801a      	strh	r2, [r3, #0]
  if ( v0 < a1 )		// v0 <= a1
    1c8c:	1cba      	adds	r2, r7, #2
    1c8e:	1d3b      	adds	r3, r7, #4
    1c90:	8812      	ldrh	r2, [r2, #0]
    1c92:	881b      	ldrh	r3, [r3, #0]
    1c94:	429a      	cmp	r2, r3
    1c96:	d211      	bcs.n	1cbc <u8g2_is_intersection_decision_tree+0x56>
  {
    if ( v1 > a0 )	// v1 >= a0
    1c98:	003a      	movs	r2, r7
    1c9a:	1dbb      	adds	r3, r7, #6
    1c9c:	8812      	ldrh	r2, [r2, #0]
    1c9e:	881b      	ldrh	r3, [r3, #0]
    1ca0:	429a      	cmp	r2, r3
    1ca2:	d901      	bls.n	1ca8 <u8g2_is_intersection_decision_tree+0x42>
    {
      return 1;
    1ca4:	2301      	movs	r3, #1
    1ca6:	e01a      	b.n	1cde <u8g2_is_intersection_decision_tree+0x78>
    }
    else
    {
      if ( v0 > v1 )	// v0 > v1
    1ca8:	1cba      	adds	r2, r7, #2
    1caa:	003b      	movs	r3, r7
    1cac:	8812      	ldrh	r2, [r2, #0]
    1cae:	881b      	ldrh	r3, [r3, #0]
    1cb0:	429a      	cmp	r2, r3
    1cb2:	d901      	bls.n	1cb8 <u8g2_is_intersection_decision_tree+0x52>
      {
	return 1;
    1cb4:	2301      	movs	r3, #1
    1cb6:	e012      	b.n	1cde <u8g2_is_intersection_decision_tree+0x78>
      }
      else
      {
	return 0;
    1cb8:	2300      	movs	r3, #0
    1cba:	e010      	b.n	1cde <u8g2_is_intersection_decision_tree+0x78>
      }
    }
  }
  else
  {
    if ( v1 > a0 )	// v1 >= a0
    1cbc:	003a      	movs	r2, r7
    1cbe:	1dbb      	adds	r3, r7, #6
    1cc0:	8812      	ldrh	r2, [r2, #0]
    1cc2:	881b      	ldrh	r3, [r3, #0]
    1cc4:	429a      	cmp	r2, r3
    1cc6:	d909      	bls.n	1cdc <u8g2_is_intersection_decision_tree+0x76>
    {
      if ( v0 > v1 )	// v0 > v1
    1cc8:	1cba      	adds	r2, r7, #2
    1cca:	003b      	movs	r3, r7
    1ccc:	8812      	ldrh	r2, [r2, #0]
    1cce:	881b      	ldrh	r3, [r3, #0]
    1cd0:	429a      	cmp	r2, r3
    1cd2:	d901      	bls.n	1cd8 <u8g2_is_intersection_decision_tree+0x72>
      {
	return 1;
    1cd4:	2301      	movs	r3, #1
    1cd6:	e002      	b.n	1cde <u8g2_is_intersection_decision_tree+0x78>
      }
      else
      {
	return 0;
    1cd8:	2300      	movs	r3, #0
    1cda:	e000      	b.n	1cde <u8g2_is_intersection_decision_tree+0x78>
      }
    }
    else
    {
      return 0;
    1cdc:	2300      	movs	r3, #0
    }
  }
}
    1cde:	0018      	movs	r0, r3
    1ce0:	46bd      	mov	sp, r7
    1ce2:	b002      	add	sp, #8
    1ce4:	bdb0      	pop	{r4, r5, r7, pc}

00001ce6 <u8g2_IsIntersection>:



/* upper limits are not included (asymetric boundaries) */
uint8_t u8g2_IsIntersection(u8g2_t *u8g2, u8g2_uint_t x0, u8g2_uint_t y0, u8g2_uint_t x1, u8g2_uint_t y1)
{
    1ce6:	b590      	push	{r4, r7, lr}
    1ce8:	b085      	sub	sp, #20
    1cea:	af00      	add	r7, sp, #0
    1cec:	60f8      	str	r0, [r7, #12]
    1cee:	000c      	movs	r4, r1
    1cf0:	0010      	movs	r0, r2
    1cf2:	0019      	movs	r1, r3
    1cf4:	230a      	movs	r3, #10
    1cf6:	18fb      	adds	r3, r7, r3
    1cf8:	1c22      	adds	r2, r4, #0
    1cfa:	801a      	strh	r2, [r3, #0]
    1cfc:	2308      	movs	r3, #8
    1cfe:	18fb      	adds	r3, r7, r3
    1d00:	1c02      	adds	r2, r0, #0
    1d02:	801a      	strh	r2, [r3, #0]
    1d04:	1dbb      	adds	r3, r7, #6
    1d06:	1c0a      	adds	r2, r1, #0
    1d08:	801a      	strh	r2, [r3, #0]
  if ( u8g2_is_intersection_decision_tree(u8g2->user_y0, u8g2->user_y1, y0, y1) == 0 )
    1d0a:	68fb      	ldr	r3, [r7, #12]
    1d0c:	224c      	movs	r2, #76	; 0x4c
    1d0e:	5a98      	ldrh	r0, [r3, r2]
    1d10:	68fb      	ldr	r3, [r7, #12]
    1d12:	224e      	movs	r2, #78	; 0x4e
    1d14:	5a99      	ldrh	r1, [r3, r2]
    1d16:	2320      	movs	r3, #32
    1d18:	18fb      	adds	r3, r7, r3
    1d1a:	881c      	ldrh	r4, [r3, #0]
    1d1c:	2308      	movs	r3, #8
    1d1e:	18fb      	adds	r3, r7, r3
    1d20:	881a      	ldrh	r2, [r3, #0]
    1d22:	0023      	movs	r3, r4
    1d24:	f7ff ff9f 	bl	1c66 <u8g2_is_intersection_decision_tree>
    1d28:	1e03      	subs	r3, r0, #0
    1d2a:	d101      	bne.n	1d30 <u8g2_IsIntersection+0x4a>
    return 0; 
    1d2c:	2300      	movs	r3, #0
    1d2e:	e00e      	b.n	1d4e <u8g2_IsIntersection+0x68>
  
  return u8g2_is_intersection_decision_tree(u8g2->user_x0, u8g2->user_x1, x0, x1);
    1d30:	68fb      	ldr	r3, [r7, #12]
    1d32:	2248      	movs	r2, #72	; 0x48
    1d34:	5a98      	ldrh	r0, [r3, r2]
    1d36:	68fb      	ldr	r3, [r7, #12]
    1d38:	224a      	movs	r2, #74	; 0x4a
    1d3a:	5a99      	ldrh	r1, [r3, r2]
    1d3c:	1dbb      	adds	r3, r7, #6
    1d3e:	881c      	ldrh	r4, [r3, #0]
    1d40:	230a      	movs	r3, #10
    1d42:	18fb      	adds	r3, r7, r3
    1d44:	881a      	ldrh	r2, [r3, #0]
    1d46:	0023      	movs	r3, r4
    1d48:	f7ff ff8d 	bl	1c66 <u8g2_is_intersection_decision_tree>
    1d4c:	0003      	movs	r3, r0
}
    1d4e:	0018      	movs	r0, r3
    1d50:	46bd      	mov	sp, r7
    1d52:	b005      	add	sp, #20
    1d54:	bd90      	pop	{r4, r7, pc}
	...

00001d58 <u8g2_DrawLine>:

#include "u8g2.h"


void u8g2_DrawLine(u8g2_t *u8g2, u8g2_uint_t x1, u8g2_uint_t y1, u8g2_uint_t x2, u8g2_uint_t y2)
{
    1d58:	b590      	push	{r4, r7, lr}
    1d5a:	b089      	sub	sp, #36	; 0x24
    1d5c:	af00      	add	r7, sp, #0
    1d5e:	60f8      	str	r0, [r7, #12]
    1d60:	000c      	movs	r4, r1
    1d62:	0010      	movs	r0, r2
    1d64:	0019      	movs	r1, r3
    1d66:	230a      	movs	r3, #10
    1d68:	18fb      	adds	r3, r7, r3
    1d6a:	1c22      	adds	r2, r4, #0
    1d6c:	801a      	strh	r2, [r3, #0]
    1d6e:	2308      	movs	r3, #8
    1d70:	18fb      	adds	r3, r7, r3
    1d72:	1c02      	adds	r2, r0, #0
    1d74:	801a      	strh	r2, [r3, #0]
    1d76:	1dbb      	adds	r3, r7, #6
    1d78:	1c0a      	adds	r2, r1, #0
    1d7a:	801a      	strh	r2, [r3, #0]
  u8g2_uint_t x,y;
  u8g2_uint_t dx, dy;
  u8g2_int_t err;
  u8g2_int_t ystep;

  uint8_t swapxy = 0;
    1d7c:	2313      	movs	r3, #19
    1d7e:	18fb      	adds	r3, r7, r3
    1d80:	2200      	movs	r2, #0
    1d82:	701a      	strb	r2, [r3, #0]
  
  /* no intersection check at the moment, should be added... */

  if ( x1 > x2 ) dx = x1-x2; else dx = x2-x1;
    1d84:	230a      	movs	r3, #10
    1d86:	18fa      	adds	r2, r7, r3
    1d88:	1dbb      	adds	r3, r7, #6
    1d8a:	8812      	ldrh	r2, [r2, #0]
    1d8c:	881b      	ldrh	r3, [r3, #0]
    1d8e:	429a      	cmp	r2, r3
    1d90:	d909      	bls.n	1da6 <u8g2_DrawLine+0x4e>
    1d92:	231a      	movs	r3, #26
    1d94:	18fb      	adds	r3, r7, r3
    1d96:	220a      	movs	r2, #10
    1d98:	18b9      	adds	r1, r7, r2
    1d9a:	1dba      	adds	r2, r7, #6
    1d9c:	8809      	ldrh	r1, [r1, #0]
    1d9e:	8812      	ldrh	r2, [r2, #0]
    1da0:	1a8a      	subs	r2, r1, r2
    1da2:	801a      	strh	r2, [r3, #0]
    1da4:	e008      	b.n	1db8 <u8g2_DrawLine+0x60>
    1da6:	231a      	movs	r3, #26
    1da8:	18fb      	adds	r3, r7, r3
    1daa:	1db9      	adds	r1, r7, #6
    1dac:	220a      	movs	r2, #10
    1dae:	18ba      	adds	r2, r7, r2
    1db0:	8809      	ldrh	r1, [r1, #0]
    1db2:	8812      	ldrh	r2, [r2, #0]
    1db4:	1a8a      	subs	r2, r1, r2
    1db6:	801a      	strh	r2, [r3, #0]
  if ( y1 > y2 ) dy = y1-y2; else dy = y2-y1;
    1db8:	2308      	movs	r3, #8
    1dba:	18fb      	adds	r3, r7, r3
    1dbc:	2230      	movs	r2, #48	; 0x30
    1dbe:	18b9      	adds	r1, r7, r2
    1dc0:	881a      	ldrh	r2, [r3, #0]
    1dc2:	880b      	ldrh	r3, [r1, #0]
    1dc4:	429a      	cmp	r2, r3
    1dc6:	d90a      	bls.n	1dde <u8g2_DrawLine+0x86>
    1dc8:	2318      	movs	r3, #24
    1dca:	18fb      	adds	r3, r7, r3
    1dcc:	2208      	movs	r2, #8
    1dce:	18ba      	adds	r2, r7, r2
    1dd0:	2130      	movs	r1, #48	; 0x30
    1dd2:	1878      	adds	r0, r7, r1
    1dd4:	8811      	ldrh	r1, [r2, #0]
    1dd6:	8802      	ldrh	r2, [r0, #0]
    1dd8:	1a8a      	subs	r2, r1, r2
    1dda:	801a      	strh	r2, [r3, #0]
    1ddc:	e009      	b.n	1df2 <u8g2_DrawLine+0x9a>
    1dde:	2318      	movs	r3, #24
    1de0:	18fb      	adds	r3, r7, r3
    1de2:	2230      	movs	r2, #48	; 0x30
    1de4:	18b9      	adds	r1, r7, r2
    1de6:	2208      	movs	r2, #8
    1de8:	18ba      	adds	r2, r7, r2
    1dea:	8809      	ldrh	r1, [r1, #0]
    1dec:	8812      	ldrh	r2, [r2, #0]
    1dee:	1a8a      	subs	r2, r1, r2
    1df0:	801a      	strh	r2, [r3, #0]

  if ( dy > dx ) 
    1df2:	2318      	movs	r3, #24
    1df4:	18fa      	adds	r2, r7, r3
    1df6:	231a      	movs	r3, #26
    1df8:	18fb      	adds	r3, r7, r3
    1dfa:	8812      	ldrh	r2, [r2, #0]
    1dfc:	881b      	ldrh	r3, [r3, #0]
    1dfe:	429a      	cmp	r2, r3
    1e00:	d937      	bls.n	1e72 <u8g2_DrawLine+0x11a>
  {
    swapxy = 1;
    1e02:	2313      	movs	r3, #19
    1e04:	18fb      	adds	r3, r7, r3
    1e06:	2201      	movs	r2, #1
    1e08:	701a      	strb	r2, [r3, #0]
    tmp = dx; dx =dy; dy = tmp;
    1e0a:	2310      	movs	r3, #16
    1e0c:	18fb      	adds	r3, r7, r3
    1e0e:	221a      	movs	r2, #26
    1e10:	18ba      	adds	r2, r7, r2
    1e12:	8812      	ldrh	r2, [r2, #0]
    1e14:	801a      	strh	r2, [r3, #0]
    1e16:	231a      	movs	r3, #26
    1e18:	18fb      	adds	r3, r7, r3
    1e1a:	2218      	movs	r2, #24
    1e1c:	18ba      	adds	r2, r7, r2
    1e1e:	8812      	ldrh	r2, [r2, #0]
    1e20:	801a      	strh	r2, [r3, #0]
    1e22:	2318      	movs	r3, #24
    1e24:	18fb      	adds	r3, r7, r3
    1e26:	2210      	movs	r2, #16
    1e28:	18ba      	adds	r2, r7, r2
    1e2a:	8812      	ldrh	r2, [r2, #0]
    1e2c:	801a      	strh	r2, [r3, #0]
    tmp = x1; x1 =y1; y1 = tmp;
    1e2e:	2310      	movs	r3, #16
    1e30:	18fb      	adds	r3, r7, r3
    1e32:	220a      	movs	r2, #10
    1e34:	18ba      	adds	r2, r7, r2
    1e36:	8812      	ldrh	r2, [r2, #0]
    1e38:	801a      	strh	r2, [r3, #0]
    1e3a:	230a      	movs	r3, #10
    1e3c:	18fb      	adds	r3, r7, r3
    1e3e:	2208      	movs	r2, #8
    1e40:	18ba      	adds	r2, r7, r2
    1e42:	8812      	ldrh	r2, [r2, #0]
    1e44:	801a      	strh	r2, [r3, #0]
    1e46:	2308      	movs	r3, #8
    1e48:	18fb      	adds	r3, r7, r3
    1e4a:	2210      	movs	r2, #16
    1e4c:	18ba      	adds	r2, r7, r2
    1e4e:	8812      	ldrh	r2, [r2, #0]
    1e50:	801a      	strh	r2, [r3, #0]
    tmp = x2; x2 =y2; y2 = tmp;
    1e52:	2310      	movs	r3, #16
    1e54:	18fb      	adds	r3, r7, r3
    1e56:	1dba      	adds	r2, r7, #6
    1e58:	8812      	ldrh	r2, [r2, #0]
    1e5a:	801a      	strh	r2, [r3, #0]
    1e5c:	1dbb      	adds	r3, r7, #6
    1e5e:	2230      	movs	r2, #48	; 0x30
    1e60:	18ba      	adds	r2, r7, r2
    1e62:	8812      	ldrh	r2, [r2, #0]
    1e64:	801a      	strh	r2, [r3, #0]
    1e66:	2330      	movs	r3, #48	; 0x30
    1e68:	18fa      	adds	r2, r7, r3
    1e6a:	2310      	movs	r3, #16
    1e6c:	18fb      	adds	r3, r7, r3
    1e6e:	881b      	ldrh	r3, [r3, #0]
    1e70:	8013      	strh	r3, [r2, #0]
  }
  if ( x1 > x2 ) 
    1e72:	230a      	movs	r3, #10
    1e74:	18fa      	adds	r2, r7, r3
    1e76:	1dbb      	adds	r3, r7, #6
    1e78:	8812      	ldrh	r2, [r2, #0]
    1e7a:	881b      	ldrh	r3, [r3, #0]
    1e7c:	429a      	cmp	r2, r3
    1e7e:	d921      	bls.n	1ec4 <u8g2_DrawLine+0x16c>
  {
    tmp = x1; x1 =x2; x2 = tmp;
    1e80:	2310      	movs	r3, #16
    1e82:	18fb      	adds	r3, r7, r3
    1e84:	220a      	movs	r2, #10
    1e86:	18ba      	adds	r2, r7, r2
    1e88:	8812      	ldrh	r2, [r2, #0]
    1e8a:	801a      	strh	r2, [r3, #0]
    1e8c:	230a      	movs	r3, #10
    1e8e:	18fb      	adds	r3, r7, r3
    1e90:	1dba      	adds	r2, r7, #6
    1e92:	8812      	ldrh	r2, [r2, #0]
    1e94:	801a      	strh	r2, [r3, #0]
    1e96:	1dbb      	adds	r3, r7, #6
    1e98:	2210      	movs	r2, #16
    1e9a:	18ba      	adds	r2, r7, r2
    1e9c:	8812      	ldrh	r2, [r2, #0]
    1e9e:	801a      	strh	r2, [r3, #0]
    tmp = y1; y1 =y2; y2 = tmp;
    1ea0:	2310      	movs	r3, #16
    1ea2:	18fb      	adds	r3, r7, r3
    1ea4:	2208      	movs	r2, #8
    1ea6:	18ba      	adds	r2, r7, r2
    1ea8:	8812      	ldrh	r2, [r2, #0]
    1eaa:	801a      	strh	r2, [r3, #0]
    1eac:	2308      	movs	r3, #8
    1eae:	18fb      	adds	r3, r7, r3
    1eb0:	2230      	movs	r2, #48	; 0x30
    1eb2:	18ba      	adds	r2, r7, r2
    1eb4:	8812      	ldrh	r2, [r2, #0]
    1eb6:	801a      	strh	r2, [r3, #0]
    1eb8:	2330      	movs	r3, #48	; 0x30
    1eba:	18fa      	adds	r2, r7, r3
    1ebc:	2310      	movs	r3, #16
    1ebe:	18fb      	adds	r3, r7, r3
    1ec0:	881b      	ldrh	r3, [r3, #0]
    1ec2:	8013      	strh	r3, [r2, #0]
  }
  err = dx >> 1;
    1ec4:	231a      	movs	r3, #26
    1ec6:	18fb      	adds	r3, r7, r3
    1ec8:	881b      	ldrh	r3, [r3, #0]
    1eca:	085b      	lsrs	r3, r3, #1
    1ecc:	b29a      	uxth	r2, r3
    1ece:	2316      	movs	r3, #22
    1ed0:	18fb      	adds	r3, r7, r3
    1ed2:	801a      	strh	r2, [r3, #0]
  if ( y2 > y1 ) ystep = 1; else ystep = -1;
    1ed4:	2330      	movs	r3, #48	; 0x30
    1ed6:	18fa      	adds	r2, r7, r3
    1ed8:	2308      	movs	r3, #8
    1eda:	18fb      	adds	r3, r7, r3
    1edc:	8812      	ldrh	r2, [r2, #0]
    1ede:	881b      	ldrh	r3, [r3, #0]
    1ee0:	429a      	cmp	r2, r3
    1ee2:	d904      	bls.n	1eee <u8g2_DrawLine+0x196>
    1ee4:	2314      	movs	r3, #20
    1ee6:	18fb      	adds	r3, r7, r3
    1ee8:	2201      	movs	r2, #1
    1eea:	801a      	strh	r2, [r3, #0]
    1eec:	e004      	b.n	1ef8 <u8g2_DrawLine+0x1a0>
    1eee:	2314      	movs	r3, #20
    1ef0:	18fb      	adds	r3, r7, r3
    1ef2:	2201      	movs	r2, #1
    1ef4:	4252      	negs	r2, r2
    1ef6:	801a      	strh	r2, [r3, #0]
  y = y1;
    1ef8:	231c      	movs	r3, #28
    1efa:	18fb      	adds	r3, r7, r3
    1efc:	2208      	movs	r2, #8
    1efe:	18ba      	adds	r2, r7, r2
    1f00:	8812      	ldrh	r2, [r2, #0]
    1f02:	801a      	strh	r2, [r3, #0]

#ifndef  U8G2_16BIT
  if ( x2 == 255 )
    x2--;
#else
  if ( x2 == 0xffff )
    1f04:	1dbb      	adds	r3, r7, #6
    1f06:	881b      	ldrh	r3, [r3, #0]
    1f08:	4a30      	ldr	r2, [pc, #192]	; (1fcc <u8g2_DrawLine+0x274>)
    1f0a:	4293      	cmp	r3, r2
    1f0c:	d104      	bne.n	1f18 <u8g2_DrawLine+0x1c0>
    x2--;
    1f0e:	1dbb      	adds	r3, r7, #6
    1f10:	881a      	ldrh	r2, [r3, #0]
    1f12:	1dbb      	adds	r3, r7, #6
    1f14:	3a01      	subs	r2, #1
    1f16:	801a      	strh	r2, [r3, #0]
#endif

  for( x = x1; x <= x2; x++ )
    1f18:	231e      	movs	r3, #30
    1f1a:	18fb      	adds	r3, r7, r3
    1f1c:	220a      	movs	r2, #10
    1f1e:	18ba      	adds	r2, r7, r2
    1f20:	8812      	ldrh	r2, [r2, #0]
    1f22:	801a      	strh	r2, [r3, #0]
    1f24:	e046      	b.n	1fb4 <u8g2_DrawLine+0x25c>
  {
    if ( swapxy == 0 ) 
    1f26:	2313      	movs	r3, #19
    1f28:	18fb      	adds	r3, r7, r3
    1f2a:	781b      	ldrb	r3, [r3, #0]
    1f2c:	2b00      	cmp	r3, #0
    1f2e:	d10a      	bne.n	1f46 <u8g2_DrawLine+0x1ee>
      u8g2_DrawPixel(u8g2, x, y); 
    1f30:	231c      	movs	r3, #28
    1f32:	18fb      	adds	r3, r7, r3
    1f34:	881a      	ldrh	r2, [r3, #0]
    1f36:	231e      	movs	r3, #30
    1f38:	18fb      	adds	r3, r7, r3
    1f3a:	8819      	ldrh	r1, [r3, #0]
    1f3c:	68fb      	ldr	r3, [r7, #12]
    1f3e:	0018      	movs	r0, r3
    1f40:	f7ff fe54 	bl	1bec <u8g2_DrawPixel>
    1f44:	e009      	b.n	1f5a <u8g2_DrawLine+0x202>
    else 
      u8g2_DrawPixel(u8g2, y, x); 
    1f46:	231e      	movs	r3, #30
    1f48:	18fb      	adds	r3, r7, r3
    1f4a:	881a      	ldrh	r2, [r3, #0]
    1f4c:	231c      	movs	r3, #28
    1f4e:	18fb      	adds	r3, r7, r3
    1f50:	8819      	ldrh	r1, [r3, #0]
    1f52:	68fb      	ldr	r3, [r7, #12]
    1f54:	0018      	movs	r0, r3
    1f56:	f7ff fe49 	bl	1bec <u8g2_DrawPixel>
    err -= (u8g2_uint_t)dy;
    1f5a:	2316      	movs	r3, #22
    1f5c:	18fb      	adds	r3, r7, r3
    1f5e:	881a      	ldrh	r2, [r3, #0]
    1f60:	2318      	movs	r3, #24
    1f62:	18fb      	adds	r3, r7, r3
    1f64:	881b      	ldrh	r3, [r3, #0]
    1f66:	1ad3      	subs	r3, r2, r3
    1f68:	b29a      	uxth	r2, r3
    1f6a:	2316      	movs	r3, #22
    1f6c:	18fb      	adds	r3, r7, r3
    1f6e:	801a      	strh	r2, [r3, #0]
    if ( err < 0 ) 
    1f70:	2316      	movs	r3, #22
    1f72:	18fb      	adds	r3, r7, r3
    1f74:	2200      	movs	r2, #0
    1f76:	5e9b      	ldrsh	r3, [r3, r2]
    1f78:	2b00      	cmp	r3, #0
    1f7a:	da14      	bge.n	1fa6 <u8g2_DrawLine+0x24e>
    {
      y += (u8g2_uint_t)ystep;
    1f7c:	2314      	movs	r3, #20
    1f7e:	18fb      	adds	r3, r7, r3
    1f80:	8819      	ldrh	r1, [r3, #0]
    1f82:	231c      	movs	r3, #28
    1f84:	18fb      	adds	r3, r7, r3
    1f86:	221c      	movs	r2, #28
    1f88:	18ba      	adds	r2, r7, r2
    1f8a:	8812      	ldrh	r2, [r2, #0]
    1f8c:	188a      	adds	r2, r1, r2
    1f8e:	801a      	strh	r2, [r3, #0]
      err += (u8g2_uint_t)dx;
    1f90:	2316      	movs	r3, #22
    1f92:	18fb      	adds	r3, r7, r3
    1f94:	881a      	ldrh	r2, [r3, #0]
    1f96:	231a      	movs	r3, #26
    1f98:	18fb      	adds	r3, r7, r3
    1f9a:	881b      	ldrh	r3, [r3, #0]
    1f9c:	18d3      	adds	r3, r2, r3
    1f9e:	b29a      	uxth	r2, r3
    1fa0:	2316      	movs	r3, #22
    1fa2:	18fb      	adds	r3, r7, r3
    1fa4:	801a      	strh	r2, [r3, #0]
  for( x = x1; x <= x2; x++ )
    1fa6:	231e      	movs	r3, #30
    1fa8:	18fb      	adds	r3, r7, r3
    1faa:	881a      	ldrh	r2, [r3, #0]
    1fac:	231e      	movs	r3, #30
    1fae:	18fb      	adds	r3, r7, r3
    1fb0:	3201      	adds	r2, #1
    1fb2:	801a      	strh	r2, [r3, #0]
    1fb4:	231e      	movs	r3, #30
    1fb6:	18fa      	adds	r2, r7, r3
    1fb8:	1dbb      	adds	r3, r7, #6
    1fba:	8812      	ldrh	r2, [r2, #0]
    1fbc:	881b      	ldrh	r3, [r3, #0]
    1fbe:	429a      	cmp	r2, r3
    1fc0:	d9b1      	bls.n	1f26 <u8g2_DrawLine+0x1ce>
    }
  }
}
    1fc2:	46c0      	nop			; (mov r8, r8)
    1fc4:	46bd      	mov	sp, r7
    1fc6:	b009      	add	sp, #36	; 0x24
    1fc8:	bd90      	pop	{r4, r7, pc}
    1fca:	46c0      	nop			; (mov r8, r8)
    1fcc:	0000ffff 	.word	0x0000ffff

00001fd0 <u8g2_ll_hvline_vertical_top_lsb>:
		1: vertical line (top to bottom)
  asumption: 
    all clipping done
*/
void u8g2_ll_hvline_vertical_top_lsb(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t len, uint8_t dir)
{
    1fd0:	b590      	push	{r4, r7, lr}
    1fd2:	b089      	sub	sp, #36	; 0x24
    1fd4:	af00      	add	r7, sp, #0
    1fd6:	60f8      	str	r0, [r7, #12]
    1fd8:	000c      	movs	r4, r1
    1fda:	0010      	movs	r0, r2
    1fdc:	0019      	movs	r1, r3
    1fde:	230a      	movs	r3, #10
    1fe0:	18fb      	adds	r3, r7, r3
    1fe2:	1c22      	adds	r2, r4, #0
    1fe4:	801a      	strh	r2, [r3, #0]
    1fe6:	2308      	movs	r3, #8
    1fe8:	18fb      	adds	r3, r7, r3
    1fea:	1c02      	adds	r2, r0, #0
    1fec:	801a      	strh	r2, [r3, #0]
    1fee:	1dbb      	adds	r3, r7, #6
    1ff0:	1c0a      	adds	r2, r1, #0
    1ff2:	801a      	strh	r2, [r3, #0]
  //assert(x < u8g2_GetU8x8(u8g2)->display_info->tile_width*8);
  //assert(y >= u8g2->buf_y0);
  //assert(y < u8g2_GetU8x8(u8g2)->display_info->tile_height*8);
  
  /* bytes are vertical, lsb on top (y=0), msb at bottom (y=7) */
  bit_pos = y;		/* overflow truncate is ok here... */
    1ff4:	231b      	movs	r3, #27
    1ff6:	18fb      	adds	r3, r7, r3
    1ff8:	2208      	movs	r2, #8
    1ffa:	18ba      	adds	r2, r7, r2
    1ffc:	8812      	ldrh	r2, [r2, #0]
    1ffe:	701a      	strb	r2, [r3, #0]
  bit_pos &= 7; 	/* ... because only the lowest 3 bits are needed */
    2000:	231b      	movs	r3, #27
    2002:	18fb      	adds	r3, r7, r3
    2004:	221b      	movs	r2, #27
    2006:	18ba      	adds	r2, r7, r2
    2008:	7812      	ldrb	r2, [r2, #0]
    200a:	2107      	movs	r1, #7
    200c:	400a      	ands	r2, r1
    200e:	701a      	strb	r2, [r3, #0]
  mask = 1;
    2010:	2318      	movs	r3, #24
    2012:	18fb      	adds	r3, r7, r3
    2014:	2201      	movs	r2, #1
    2016:	701a      	strb	r2, [r3, #0]
  mask <<= bit_pos;
    2018:	2318      	movs	r3, #24
    201a:	18fb      	adds	r3, r7, r3
    201c:	781a      	ldrb	r2, [r3, #0]
    201e:	231b      	movs	r3, #27
    2020:	18fb      	adds	r3, r7, r3
    2022:	781b      	ldrb	r3, [r3, #0]
    2024:	409a      	lsls	r2, r3
    2026:	2318      	movs	r3, #24
    2028:	18fb      	adds	r3, r7, r3
    202a:	701a      	strb	r2, [r3, #0]

  or_mask = 0;
    202c:	231a      	movs	r3, #26
    202e:	18fb      	adds	r3, r7, r3
    2030:	2200      	movs	r2, #0
    2032:	701a      	strb	r2, [r3, #0]
  xor_mask = 0;
    2034:	2319      	movs	r3, #25
    2036:	18fb      	adds	r3, r7, r3
    2038:	2200      	movs	r2, #0
    203a:	701a      	strb	r2, [r3, #0]
  if ( u8g2->draw_color <= 1 )
    203c:	68fb      	ldr	r3, [r7, #12]
    203e:	2292      	movs	r2, #146	; 0x92
    2040:	5c9b      	ldrb	r3, [r3, r2]
    2042:	2b01      	cmp	r3, #1
    2044:	d805      	bhi.n	2052 <STACK_SIZE+0x52>
    or_mask  = mask;
    2046:	231a      	movs	r3, #26
    2048:	18fb      	adds	r3, r7, r3
    204a:	2218      	movs	r2, #24
    204c:	18ba      	adds	r2, r7, r2
    204e:	7812      	ldrb	r2, [r2, #0]
    2050:	701a      	strb	r2, [r3, #0]
  if ( u8g2->draw_color != 1 )
    2052:	68fb      	ldr	r3, [r7, #12]
    2054:	2292      	movs	r2, #146	; 0x92
    2056:	5c9b      	ldrb	r3, [r3, r2]
    2058:	2b01      	cmp	r3, #1
    205a:	d005      	beq.n	2068 <STACK_SIZE+0x68>
    xor_mask = mask;
    205c:	2319      	movs	r3, #25
    205e:	18fb      	adds	r3, r7, r3
    2060:	2218      	movs	r2, #24
    2062:	18ba      	adds	r2, r7, r2
    2064:	7812      	ldrb	r2, [r2, #0]
    2066:	701a      	strb	r2, [r3, #0]


  offset = y;		/* y might be 8 or 16 bit, but we need 16 bit, so use a 16 bit variable */
    2068:	2316      	movs	r3, #22
    206a:	18fb      	adds	r3, r7, r3
    206c:	2208      	movs	r2, #8
    206e:	18ba      	adds	r2, r7, r2
    2070:	8812      	ldrh	r2, [r2, #0]
    2072:	801a      	strh	r2, [r3, #0]
  offset &= ~7;
    2074:	2316      	movs	r3, #22
    2076:	18fb      	adds	r3, r7, r3
    2078:	2216      	movs	r2, #22
    207a:	18ba      	adds	r2, r7, r2
    207c:	8812      	ldrh	r2, [r2, #0]
    207e:	2107      	movs	r1, #7
    2080:	438a      	bics	r2, r1
    2082:	801a      	strh	r2, [r3, #0]
  offset *= u8g2_GetU8x8(u8g2)->display_info->tile_width;
    2084:	68fb      	ldr	r3, [r7, #12]
    2086:	681b      	ldr	r3, [r3, #0]
    2088:	7c1b      	ldrb	r3, [r3, #16]
    208a:	b29a      	uxth	r2, r3
    208c:	2316      	movs	r3, #22
    208e:	18fb      	adds	r3, r7, r3
    2090:	2116      	movs	r1, #22
    2092:	1879      	adds	r1, r7, r1
    2094:	8809      	ldrh	r1, [r1, #0]
    2096:	434a      	muls	r2, r1
    2098:	801a      	strh	r2, [r3, #0]
  ptr = u8g2->tile_buf_ptr;
    209a:	68fb      	ldr	r3, [r7, #12]
    209c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    209e:	61fb      	str	r3, [r7, #28]
  ptr += offset;
    20a0:	2316      	movs	r3, #22
    20a2:	18fb      	adds	r3, r7, r3
    20a4:	881b      	ldrh	r3, [r3, #0]
    20a6:	69fa      	ldr	r2, [r7, #28]
    20a8:	18d3      	adds	r3, r2, r3
    20aa:	61fb      	str	r3, [r7, #28]
  ptr += x;
    20ac:	230a      	movs	r3, #10
    20ae:	18fb      	adds	r3, r7, r3
    20b0:	881b      	ldrh	r3, [r3, #0]
    20b2:	69fa      	ldr	r2, [r7, #28]
    20b4:	18d3      	adds	r3, r2, r3
    20b6:	61fb      	str	r3, [r7, #28]
  
  if ( dir == 0 )
    20b8:	2330      	movs	r3, #48	; 0x30
    20ba:	18fb      	adds	r3, r7, r3
    20bc:	781b      	ldrb	r3, [r3, #0]
    20be:	2b00      	cmp	r3, #0
    20c0:	d11e      	bne.n	2100 <STACK_SIZE+0x100>
      do
      {
#ifdef __unix
	assert(ptr < max_ptr);
#endif
	*ptr |= or_mask;
    20c2:	69fb      	ldr	r3, [r7, #28]
    20c4:	781a      	ldrb	r2, [r3, #0]
    20c6:	231a      	movs	r3, #26
    20c8:	18fb      	adds	r3, r7, r3
    20ca:	781b      	ldrb	r3, [r3, #0]
    20cc:	4313      	orrs	r3, r2
    20ce:	b2da      	uxtb	r2, r3
    20d0:	69fb      	ldr	r3, [r7, #28]
    20d2:	701a      	strb	r2, [r3, #0]
	*ptr ^= xor_mask;
    20d4:	69fb      	ldr	r3, [r7, #28]
    20d6:	781a      	ldrb	r2, [r3, #0]
    20d8:	2319      	movs	r3, #25
    20da:	18fb      	adds	r3, r7, r3
    20dc:	781b      	ldrb	r3, [r3, #0]
    20de:	4053      	eors	r3, r2
    20e0:	b2da      	uxtb	r2, r3
    20e2:	69fb      	ldr	r3, [r7, #28]
    20e4:	701a      	strb	r2, [r3, #0]
	ptr++;
    20e6:	69fb      	ldr	r3, [r7, #28]
    20e8:	3301      	adds	r3, #1
    20ea:	61fb      	str	r3, [r7, #28]
	len--;
    20ec:	1dbb      	adds	r3, r7, #6
    20ee:	881a      	ldrh	r2, [r3, #0]
    20f0:	1dbb      	adds	r3, r7, #6
    20f2:	3a01      	subs	r2, #1
    20f4:	801a      	strh	r2, [r3, #0]
      } while( len != 0 );
    20f6:	1dbb      	adds	r3, r7, #6
    20f8:	881b      	ldrh	r3, [r3, #0]
    20fa:	2b00      	cmp	r3, #0
    20fc:	d1e1      	bne.n	20c2 <STACK_SIZE+0xc2>
	or_mask <<= 1;
	xor_mask <<= 1;
      }
    } while( len != 0 );
  }
}
    20fe:	e055      	b.n	21ac <STACK_SIZE+0x1ac>
      *ptr |= or_mask;
    2100:	69fb      	ldr	r3, [r7, #28]
    2102:	781a      	ldrb	r2, [r3, #0]
    2104:	231a      	movs	r3, #26
    2106:	18fb      	adds	r3, r7, r3
    2108:	781b      	ldrb	r3, [r3, #0]
    210a:	4313      	orrs	r3, r2
    210c:	b2da      	uxtb	r2, r3
    210e:	69fb      	ldr	r3, [r7, #28]
    2110:	701a      	strb	r2, [r3, #0]
      *ptr ^= xor_mask;
    2112:	69fb      	ldr	r3, [r7, #28]
    2114:	781a      	ldrb	r2, [r3, #0]
    2116:	2319      	movs	r3, #25
    2118:	18fb      	adds	r3, r7, r3
    211a:	781b      	ldrb	r3, [r3, #0]
    211c:	4053      	eors	r3, r2
    211e:	b2da      	uxtb	r2, r3
    2120:	69fb      	ldr	r3, [r7, #28]
    2122:	701a      	strb	r2, [r3, #0]
      bit_pos++;
    2124:	231b      	movs	r3, #27
    2126:	18fb      	adds	r3, r7, r3
    2128:	781a      	ldrb	r2, [r3, #0]
    212a:	231b      	movs	r3, #27
    212c:	18fb      	adds	r3, r7, r3
    212e:	3201      	adds	r2, #1
    2130:	701a      	strb	r2, [r3, #0]
      bit_pos &= 7;
    2132:	231b      	movs	r3, #27
    2134:	18fb      	adds	r3, r7, r3
    2136:	221b      	movs	r2, #27
    2138:	18ba      	adds	r2, r7, r2
    213a:	7812      	ldrb	r2, [r2, #0]
    213c:	2107      	movs	r1, #7
    213e:	400a      	ands	r2, r1
    2140:	701a      	strb	r2, [r3, #0]
      len--;
    2142:	1dbb      	adds	r3, r7, #6
    2144:	881a      	ldrh	r2, [r3, #0]
    2146:	1dbb      	adds	r3, r7, #6
    2148:	3a01      	subs	r2, #1
    214a:	801a      	strh	r2, [r3, #0]
      if ( bit_pos == 0 )
    214c:	231b      	movs	r3, #27
    214e:	18fb      	adds	r3, r7, r3
    2150:	781b      	ldrb	r3, [r3, #0]
    2152:	2b00      	cmp	r3, #0
    2154:	d118      	bne.n	2188 <STACK_SIZE+0x188>
	ptr+=u8g2->pixel_buf_width;	/* 6 Jan 17: Changed u8g2->width to u8g2->pixel_buf_width, issue #148 */
    2156:	68fb      	ldr	r3, [r7, #12]
    2158:	8f5b      	ldrh	r3, [r3, #58]	; 0x3a
    215a:	001a      	movs	r2, r3
    215c:	69fb      	ldr	r3, [r7, #28]
    215e:	189b      	adds	r3, r3, r2
    2160:	61fb      	str	r3, [r7, #28]
	if ( u8g2->draw_color <= 1 )
    2162:	68fb      	ldr	r3, [r7, #12]
    2164:	2292      	movs	r2, #146	; 0x92
    2166:	5c9b      	ldrb	r3, [r3, r2]
    2168:	2b01      	cmp	r3, #1
    216a:	d803      	bhi.n	2174 <STACK_SIZE+0x174>
	  or_mask  = 1;
    216c:	231a      	movs	r3, #26
    216e:	18fb      	adds	r3, r7, r3
    2170:	2201      	movs	r2, #1
    2172:	701a      	strb	r2, [r3, #0]
	if ( u8g2->draw_color != 1 )
    2174:	68fb      	ldr	r3, [r7, #12]
    2176:	2292      	movs	r2, #146	; 0x92
    2178:	5c9b      	ldrb	r3, [r3, r2]
    217a:	2b01      	cmp	r3, #1
    217c:	d012      	beq.n	21a4 <STACK_SIZE+0x1a4>
	  xor_mask = 1;
    217e:	2319      	movs	r3, #25
    2180:	18fb      	adds	r3, r7, r3
    2182:	2201      	movs	r2, #1
    2184:	701a      	strb	r2, [r3, #0]
    2186:	e00d      	b.n	21a4 <STACK_SIZE+0x1a4>
	or_mask <<= 1;
    2188:	231a      	movs	r3, #26
    218a:	18fa      	adds	r2, r7, r3
    218c:	231a      	movs	r3, #26
    218e:	18fb      	adds	r3, r7, r3
    2190:	781b      	ldrb	r3, [r3, #0]
    2192:	18db      	adds	r3, r3, r3
    2194:	7013      	strb	r3, [r2, #0]
	xor_mask <<= 1;
    2196:	2319      	movs	r3, #25
    2198:	18fa      	adds	r2, r7, r3
    219a:	2319      	movs	r3, #25
    219c:	18fb      	adds	r3, r7, r3
    219e:	781b      	ldrb	r3, [r3, #0]
    21a0:	18db      	adds	r3, r3, r3
    21a2:	7013      	strb	r3, [r2, #0]
    } while( len != 0 );
    21a4:	1dbb      	adds	r3, r7, #6
    21a6:	881b      	ldrh	r3, [r3, #0]
    21a8:	2b00      	cmp	r3, #0
    21aa:	d1a9      	bne.n	2100 <STACK_SIZE+0x100>
}
    21ac:	46c0      	nop			; (mov r8, r8)
    21ae:	46bd      	mov	sp, r7
    21b0:	b009      	add	sp, #36	; 0x24
    21b2:	bd90      	pop	{r4, r7, pc}

000021b4 <u8g2_SetMaxClipWindow>:


#ifdef U8G2_WITH_CLIP_WINDOW_SUPPORT

void u8g2_SetMaxClipWindow(u8g2_t *u8g2)
{
    21b4:	b580      	push	{r7, lr}
    21b6:	b082      	sub	sp, #8
    21b8:	af00      	add	r7, sp, #0
    21ba:	6078      	str	r0, [r7, #4]
  u8g2->clip_x0 = 0;
    21bc:	687b      	ldr	r3, [r7, #4]
    21be:	2250      	movs	r2, #80	; 0x50
    21c0:	2100      	movs	r1, #0
    21c2:	5299      	strh	r1, [r3, r2]
  u8g2->clip_y0 = 0;
    21c4:	687b      	ldr	r3, [r7, #4]
    21c6:	2254      	movs	r2, #84	; 0x54
    21c8:	2100      	movs	r1, #0
    21ca:	5299      	strh	r1, [r3, r2]
  u8g2->clip_x1 = (u8g2_uint_t)~(u8g2_uint_t)0;
    21cc:	687b      	ldr	r3, [r7, #4]
    21ce:	2252      	movs	r2, #82	; 0x52
    21d0:	2101      	movs	r1, #1
    21d2:	4249      	negs	r1, r1
    21d4:	5299      	strh	r1, [r3, r2]
  u8g2->clip_y1 = (u8g2_uint_t)~(u8g2_uint_t)0;
    21d6:	687b      	ldr	r3, [r7, #4]
    21d8:	2256      	movs	r2, #86	; 0x56
    21da:	2101      	movs	r1, #1
    21dc:	4249      	negs	r1, r1
    21de:	5299      	strh	r1, [r3, r2]
  
  u8g2->cb->update_page_win(u8g2);
    21e0:	687b      	ldr	r3, [r7, #4]
    21e2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    21e4:	685b      	ldr	r3, [r3, #4]
    21e6:	687a      	ldr	r2, [r7, #4]
    21e8:	0010      	movs	r0, r2
    21ea:	4798      	blx	r3
}
    21ec:	46c0      	nop			; (mov r8, r8)
    21ee:	46bd      	mov	sp, r7
    21f0:	b002      	add	sp, #8
    21f2:	bd80      	pop	{r7, pc}

000021f4 <u8g2_SetupBuffer>:
/*
  This procedure is called after setting up the display (u8x8 structure).
  --> This is the central init procedure for u8g2 object
*/
void u8g2_SetupBuffer(u8g2_t *u8g2, uint8_t *buf, uint8_t tile_buf_height, u8g2_draw_ll_hvline_cb ll_hvline_cb, const u8g2_cb_t *u8g2_cb)
{
    21f4:	b580      	push	{r7, lr}
    21f6:	b084      	sub	sp, #16
    21f8:	af00      	add	r7, sp, #0
    21fa:	60f8      	str	r0, [r7, #12]
    21fc:	60b9      	str	r1, [r7, #8]
    21fe:	603b      	str	r3, [r7, #0]
    2200:	1dfb      	adds	r3, r7, #7
    2202:	701a      	strb	r2, [r3, #0]
  u8g2->font = NULL;
    2204:	68fb      	ldr	r3, [r7, #12]
    2206:	2200      	movs	r2, #0
    2208:	659a      	str	r2, [r3, #88]	; 0x58
  //u8g2->kerning = NULL;
  //u8g2->get_kerning_cb = u8g2_GetNullKerning;
  
  //u8g2->ll_hvline = u8g2_ll_hvline_vertical_top_lsb;
  u8g2->ll_hvline = ll_hvline_cb;
    220a:	68fb      	ldr	r3, [r7, #12]
    220c:	683a      	ldr	r2, [r7, #0]
    220e:	62da      	str	r2, [r3, #44]	; 0x2c
  
  u8g2->tile_buf_ptr = buf;
    2210:	68fb      	ldr	r3, [r7, #12]
    2212:	68ba      	ldr	r2, [r7, #8]
    2214:	635a      	str	r2, [r3, #52]	; 0x34
  u8g2->tile_buf_height = tile_buf_height;
    2216:	68fb      	ldr	r3, [r7, #12]
    2218:	1dfa      	adds	r2, r7, #7
    221a:	2138      	movs	r1, #56	; 0x38
    221c:	7812      	ldrb	r2, [r2, #0]
    221e:	545a      	strb	r2, [r3, r1]
  
  u8g2->tile_curr_row = 0;
    2220:	68fb      	ldr	r3, [r7, #12]
    2222:	2239      	movs	r2, #57	; 0x39
    2224:	2100      	movs	r1, #0
    2226:	5499      	strb	r1, [r3, r2]
  
  u8g2->font_decode.is_transparent = 0; /* issue 443 */
    2228:	68fb      	ldr	r3, [r7, #12]
    222a:	226d      	movs	r2, #109	; 0x6d
    222c:	2100      	movs	r1, #0
    222e:	5499      	strb	r1, [r3, r2]
  u8g2->bitmap_transparency = 0;
    2230:	68fb      	ldr	r3, [r7, #12]
    2232:	2291      	movs	r2, #145	; 0x91
    2234:	2100      	movs	r1, #0
    2236:	5499      	strb	r1, [r3, r2]
  
  u8g2->font_height_mode = 0; /* issue 2046 */
    2238:	68fb      	ldr	r3, [r7, #12]
    223a:	228d      	movs	r2, #141	; 0x8d
    223c:	2100      	movs	r1, #0
    223e:	5499      	strb	r1, [r3, r2]
  u8g2->draw_color = 1;
    2240:	68fb      	ldr	r3, [r7, #12]
    2242:	2292      	movs	r2, #146	; 0x92
    2244:	2101      	movs	r1, #1
    2246:	5499      	strb	r1, [r3, r2]
  u8g2->is_auto_page_clear = 1;
    2248:	68fb      	ldr	r3, [r7, #12]
    224a:	2293      	movs	r2, #147	; 0x93
    224c:	2101      	movs	r1, #1
    224e:	5499      	strb	r1, [r3, r2]
  
  u8g2->cb = u8g2_cb;
    2250:	68fb      	ldr	r3, [r7, #12]
    2252:	69ba      	ldr	r2, [r7, #24]
    2254:	631a      	str	r2, [r3, #48]	; 0x30
  u8g2->cb->update_dimension(u8g2);
    2256:	68fb      	ldr	r3, [r7, #12]
    2258:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    225a:	681b      	ldr	r3, [r3, #0]
    225c:	68fa      	ldr	r2, [r7, #12]
    225e:	0010      	movs	r0, r2
    2260:	4798      	blx	r3
#ifdef U8G2_WITH_CLIP_WINDOW_SUPPORT
  u8g2_SetMaxClipWindow(u8g2);		/* assign a clip window and call the update() procedure */
    2262:	68fb      	ldr	r3, [r7, #12]
    2264:	0018      	movs	r0, r3
    2266:	f7ff ffa5 	bl	21b4 <u8g2_SetMaxClipWindow>
#else
  u8g2->cb->update_page_win(u8g2);
#endif

  u8g2_SetFontPosBaseline(u8g2);  /* issue 195 */
    226a:	68fb      	ldr	r3, [r7, #12]
    226c:	0018      	movs	r0, r3
    226e:	f7ff fadf 	bl	1830 <u8g2_SetFontPosBaseline>
  
#ifdef U8G2_WITH_FONT_ROTATION  
  u8g2->font_decode.dir = 0;
    2272:	68fb      	ldr	r3, [r7, #12]
    2274:	2270      	movs	r2, #112	; 0x70
    2276:	2100      	movs	r1, #0
    2278:	5499      	strb	r1, [r3, r2]
#endif
}
    227a:	46c0      	nop			; (mov r8, r8)
    227c:	46bd      	mov	sp, r7
    227e:	b004      	add	sp, #16
    2280:	bd80      	pop	{r7, pc}

00002282 <u8g2_update_dimension_common>:
    u8g2_uint_t buf_y0;
    u8g2_uint_t buf_y1; 	
*/

static void u8g2_update_dimension_common(u8g2_t *u8g2)
{
    2282:	b580      	push	{r7, lr}
    2284:	b084      	sub	sp, #16
    2286:	af00      	add	r7, sp, #0
    2288:	6078      	str	r0, [r7, #4]
  const u8x8_display_info_t *display_info = u8g2_GetU8x8(u8g2)->display_info;
    228a:	687b      	ldr	r3, [r7, #4]
    228c:	681b      	ldr	r3, [r3, #0]
    228e:	60bb      	str	r3, [r7, #8]
  u8g2_uint_t t;
  
  t = u8g2->tile_buf_height;
    2290:	687b      	ldr	r3, [r7, #4]
    2292:	2238      	movs	r2, #56	; 0x38
    2294:	5c9a      	ldrb	r2, [r3, r2]
    2296:	230e      	movs	r3, #14
    2298:	18fb      	adds	r3, r7, r3
    229a:	801a      	strh	r2, [r3, #0]
  t *= 8;
    229c:	230e      	movs	r3, #14
    229e:	18fb      	adds	r3, r7, r3
    22a0:	220e      	movs	r2, #14
    22a2:	18ba      	adds	r2, r7, r2
    22a4:	8812      	ldrh	r2, [r2, #0]
    22a6:	00d2      	lsls	r2, r2, #3
    22a8:	801a      	strh	r2, [r3, #0]
  u8g2->pixel_buf_height = t;
    22aa:	687b      	ldr	r3, [r7, #4]
    22ac:	220e      	movs	r2, #14
    22ae:	18ba      	adds	r2, r7, r2
    22b0:	8812      	ldrh	r2, [r2, #0]
    22b2:	879a      	strh	r2, [r3, #60]	; 0x3c
  
  t = display_info->tile_width;
    22b4:	68bb      	ldr	r3, [r7, #8]
    22b6:	7c1a      	ldrb	r2, [r3, #16]
    22b8:	230e      	movs	r3, #14
    22ba:	18fb      	adds	r3, r7, r3
    22bc:	801a      	strh	r2, [r3, #0]
#ifndef U8G2_16BIT
  if ( t >= 32 )
    t = 31;
#endif
  t *= 8;
    22be:	230e      	movs	r3, #14
    22c0:	18fb      	adds	r3, r7, r3
    22c2:	220e      	movs	r2, #14
    22c4:	18ba      	adds	r2, r7, r2
    22c6:	8812      	ldrh	r2, [r2, #0]
    22c8:	00d2      	lsls	r2, r2, #3
    22ca:	801a      	strh	r2, [r3, #0]
  u8g2->pixel_buf_width = t;
    22cc:	687b      	ldr	r3, [r7, #4]
    22ce:	220e      	movs	r2, #14
    22d0:	18ba      	adds	r2, r7, r2
    22d2:	8812      	ldrh	r2, [r2, #0]
    22d4:	875a      	strh	r2, [r3, #58]	; 0x3a
  
  t = u8g2->tile_curr_row;
    22d6:	687b      	ldr	r3, [r7, #4]
    22d8:	2239      	movs	r2, #57	; 0x39
    22da:	5c9a      	ldrb	r2, [r3, r2]
    22dc:	230e      	movs	r3, #14
    22de:	18fb      	adds	r3, r7, r3
    22e0:	801a      	strh	r2, [r3, #0]
  t *= 8;
    22e2:	230e      	movs	r3, #14
    22e4:	18fb      	adds	r3, r7, r3
    22e6:	220e      	movs	r2, #14
    22e8:	18ba      	adds	r2, r7, r2
    22ea:	8812      	ldrh	r2, [r2, #0]
    22ec:	00d2      	lsls	r2, r2, #3
    22ee:	801a      	strh	r2, [r3, #0]
  u8g2->pixel_curr_row = t;
    22f0:	687b      	ldr	r3, [r7, #4]
    22f2:	220e      	movs	r2, #14
    22f4:	18ba      	adds	r2, r7, r2
    22f6:	8812      	ldrh	r2, [r2, #0]
    22f8:	87da      	strh	r2, [r3, #62]	; 0x3e
  
  t = u8g2->tile_buf_height;
    22fa:	687b      	ldr	r3, [r7, #4]
    22fc:	2238      	movs	r2, #56	; 0x38
    22fe:	5c9a      	ldrb	r2, [r3, r2]
    2300:	230e      	movs	r3, #14
    2302:	18fb      	adds	r3, r7, r3
    2304:	801a      	strh	r2, [r3, #0]
  /* handle the case, where the buffer is larger than the (remaining) part of the display */
  if ( t + u8g2->tile_curr_row > display_info->tile_height )
    2306:	230e      	movs	r3, #14
    2308:	18fb      	adds	r3, r7, r3
    230a:	881b      	ldrh	r3, [r3, #0]
    230c:	687a      	ldr	r2, [r7, #4]
    230e:	2139      	movs	r1, #57	; 0x39
    2310:	5c52      	ldrb	r2, [r2, r1]
    2312:	189b      	adds	r3, r3, r2
    2314:	68ba      	ldr	r2, [r7, #8]
    2316:	7c52      	ldrb	r2, [r2, #17]
    2318:	4293      	cmp	r3, r2
    231a:	dd0a      	ble.n	2332 <u8g2_update_dimension_common+0xb0>
    t = display_info->tile_height - u8g2->tile_curr_row;
    231c:	68bb      	ldr	r3, [r7, #8]
    231e:	7c5b      	ldrb	r3, [r3, #17]
    2320:	b299      	uxth	r1, r3
    2322:	687b      	ldr	r3, [r7, #4]
    2324:	2239      	movs	r2, #57	; 0x39
    2326:	5c9b      	ldrb	r3, [r3, r2]
    2328:	b29a      	uxth	r2, r3
    232a:	230e      	movs	r3, #14
    232c:	18fb      	adds	r3, r7, r3
    232e:	1a8a      	subs	r2, r1, r2
    2330:	801a      	strh	r2, [r3, #0]
  t *= 8;
    2332:	230e      	movs	r3, #14
    2334:	18fb      	adds	r3, r7, r3
    2336:	220e      	movs	r2, #14
    2338:	18ba      	adds	r2, r7, r2
    233a:	8812      	ldrh	r2, [r2, #0]
    233c:	00d2      	lsls	r2, r2, #3
    233e:	801a      	strh	r2, [r3, #0]
  
  u8g2->buf_y0 = u8g2->pixel_curr_row;   
    2340:	687b      	ldr	r3, [r7, #4]
    2342:	8fd9      	ldrh	r1, [r3, #62]	; 0x3e
    2344:	687b      	ldr	r3, [r7, #4]
    2346:	2240      	movs	r2, #64	; 0x40
    2348:	5299      	strh	r1, [r3, r2]
  u8g2->buf_y1 = u8g2->buf_y0;
    234a:	687b      	ldr	r3, [r7, #4]
    234c:	2240      	movs	r2, #64	; 0x40
    234e:	5a99      	ldrh	r1, [r3, r2]
    2350:	687b      	ldr	r3, [r7, #4]
    2352:	2242      	movs	r2, #66	; 0x42
    2354:	5299      	strh	r1, [r3, r2]
  u8g2->buf_y1 += t;
    2356:	687b      	ldr	r3, [r7, #4]
    2358:	2242      	movs	r2, #66	; 0x42
    235a:	5a9a      	ldrh	r2, [r3, r2]
    235c:	230e      	movs	r3, #14
    235e:	18fb      	adds	r3, r7, r3
    2360:	881b      	ldrh	r3, [r3, #0]
    2362:	18d3      	adds	r3, r2, r3
    2364:	b299      	uxth	r1, r3
    2366:	687b      	ldr	r3, [r7, #4]
    2368:	2242      	movs	r2, #66	; 0x42
    236a:	5299      	strh	r1, [r3, r2]

  
#ifdef U8G2_16BIT
  u8g2->width = display_info->pixel_width;
    236c:	68bb      	ldr	r3, [r7, #8]
    236e:	8a99      	ldrh	r1, [r3, #20]
    2370:	687b      	ldr	r3, [r7, #4]
    2372:	2244      	movs	r2, #68	; 0x44
    2374:	5299      	strh	r1, [r3, r2]
  u8g2->height = display_info->pixel_height;
    2376:	68bb      	ldr	r3, [r7, #8]
    2378:	8ad9      	ldrh	r1, [r3, #22]
    237a:	687b      	ldr	r3, [r7, #4]
    237c:	2246      	movs	r2, #70	; 0x46
    237e:	5299      	strh	r1, [r3, r2]
  if ( display_info->pixel_width <= 240 )
    u8g2->width = display_info->pixel_width;
  u8g2->height = display_info->pixel_height;
#endif

}
    2380:	46c0      	nop			; (mov r8, r8)
    2382:	46bd      	mov	sp, r7
    2384:	b004      	add	sp, #16
    2386:	bd80      	pop	{r7, pc}

00002388 <u8g2_apply_clip_window>:
/*==========================================================*/
/* apply clip window */

#ifdef U8G2_WITH_CLIP_WINDOW_SUPPORT
static void u8g2_apply_clip_window(u8g2_t *u8g2)
{
    2388:	b5b0      	push	{r4, r5, r7, lr}
    238a:	b084      	sub	sp, #16
    238c:	af02      	add	r7, sp, #8
    238e:	6078      	str	r0, [r7, #4]
  /* check aganst the current user_??? window */
  if ( u8g2_IsIntersection(u8g2, u8g2->clip_x0, u8g2->clip_y0, u8g2->clip_x1, u8g2->clip_y1) == 0 ) 
    2390:	687b      	ldr	r3, [r7, #4]
    2392:	2250      	movs	r2, #80	; 0x50
    2394:	5a99      	ldrh	r1, [r3, r2]
    2396:	687b      	ldr	r3, [r7, #4]
    2398:	2254      	movs	r2, #84	; 0x54
    239a:	5a9c      	ldrh	r4, [r3, r2]
    239c:	687b      	ldr	r3, [r7, #4]
    239e:	2252      	movs	r2, #82	; 0x52
    23a0:	5a9d      	ldrh	r5, [r3, r2]
    23a2:	687b      	ldr	r3, [r7, #4]
    23a4:	2256      	movs	r2, #86	; 0x56
    23a6:	5a9b      	ldrh	r3, [r3, r2]
    23a8:	6878      	ldr	r0, [r7, #4]
    23aa:	9300      	str	r3, [sp, #0]
    23ac:	002b      	movs	r3, r5
    23ae:	0022      	movs	r2, r4
    23b0:	f7ff fc99 	bl	1ce6 <u8g2_IsIntersection>
    23b4:	1e03      	subs	r3, r0, #0
    23b6:	d104      	bne.n	23c2 <u8g2_apply_clip_window+0x3a>
  {
    u8g2->is_page_clip_window_intersection = 0;
    23b8:	687b      	ldr	r3, [r7, #4]
    23ba:	228c      	movs	r2, #140	; 0x8c
    23bc:	2100      	movs	r1, #0
    23be:	5499      	strb	r1, [r3, r2]
    if ( u8g2->user_y0 < u8g2->clip_y0 )
      u8g2->user_y0 = u8g2->clip_y0;
    if ( u8g2->user_y1 > u8g2->clip_y1 )
      u8g2->user_y1 = u8g2->clip_y1;
  }
}
    23c0:	e03b      	b.n	243a <u8g2_apply_clip_window+0xb2>
    u8g2->is_page_clip_window_intersection = 1;
    23c2:	687b      	ldr	r3, [r7, #4]
    23c4:	228c      	movs	r2, #140	; 0x8c
    23c6:	2101      	movs	r1, #1
    23c8:	5499      	strb	r1, [r3, r2]
    if ( u8g2->user_x0 < u8g2->clip_x0 )
    23ca:	687b      	ldr	r3, [r7, #4]
    23cc:	2248      	movs	r2, #72	; 0x48
    23ce:	5a9a      	ldrh	r2, [r3, r2]
    23d0:	687b      	ldr	r3, [r7, #4]
    23d2:	2150      	movs	r1, #80	; 0x50
    23d4:	5a5b      	ldrh	r3, [r3, r1]
    23d6:	429a      	cmp	r2, r3
    23d8:	d205      	bcs.n	23e6 <u8g2_apply_clip_window+0x5e>
      u8g2->user_x0 = u8g2->clip_x0;
    23da:	687b      	ldr	r3, [r7, #4]
    23dc:	2250      	movs	r2, #80	; 0x50
    23de:	5a99      	ldrh	r1, [r3, r2]
    23e0:	687b      	ldr	r3, [r7, #4]
    23e2:	2248      	movs	r2, #72	; 0x48
    23e4:	5299      	strh	r1, [r3, r2]
    if ( u8g2->user_x1 > u8g2->clip_x1 )
    23e6:	687b      	ldr	r3, [r7, #4]
    23e8:	224a      	movs	r2, #74	; 0x4a
    23ea:	5a9a      	ldrh	r2, [r3, r2]
    23ec:	687b      	ldr	r3, [r7, #4]
    23ee:	2152      	movs	r1, #82	; 0x52
    23f0:	5a5b      	ldrh	r3, [r3, r1]
    23f2:	429a      	cmp	r2, r3
    23f4:	d905      	bls.n	2402 <u8g2_apply_clip_window+0x7a>
      u8g2->user_x1 = u8g2->clip_x1;
    23f6:	687b      	ldr	r3, [r7, #4]
    23f8:	2252      	movs	r2, #82	; 0x52
    23fa:	5a99      	ldrh	r1, [r3, r2]
    23fc:	687b      	ldr	r3, [r7, #4]
    23fe:	224a      	movs	r2, #74	; 0x4a
    2400:	5299      	strh	r1, [r3, r2]
    if ( u8g2->user_y0 < u8g2->clip_y0 )
    2402:	687b      	ldr	r3, [r7, #4]
    2404:	224c      	movs	r2, #76	; 0x4c
    2406:	5a9a      	ldrh	r2, [r3, r2]
    2408:	687b      	ldr	r3, [r7, #4]
    240a:	2154      	movs	r1, #84	; 0x54
    240c:	5a5b      	ldrh	r3, [r3, r1]
    240e:	429a      	cmp	r2, r3
    2410:	d205      	bcs.n	241e <u8g2_apply_clip_window+0x96>
      u8g2->user_y0 = u8g2->clip_y0;
    2412:	687b      	ldr	r3, [r7, #4]
    2414:	2254      	movs	r2, #84	; 0x54
    2416:	5a99      	ldrh	r1, [r3, r2]
    2418:	687b      	ldr	r3, [r7, #4]
    241a:	224c      	movs	r2, #76	; 0x4c
    241c:	5299      	strh	r1, [r3, r2]
    if ( u8g2->user_y1 > u8g2->clip_y1 )
    241e:	687b      	ldr	r3, [r7, #4]
    2420:	224e      	movs	r2, #78	; 0x4e
    2422:	5a9a      	ldrh	r2, [r3, r2]
    2424:	687b      	ldr	r3, [r7, #4]
    2426:	2156      	movs	r1, #86	; 0x56
    2428:	5a5b      	ldrh	r3, [r3, r1]
    242a:	429a      	cmp	r2, r3
    242c:	d905      	bls.n	243a <u8g2_apply_clip_window+0xb2>
      u8g2->user_y1 = u8g2->clip_y1;
    242e:	687b      	ldr	r3, [r7, #4]
    2430:	2256      	movs	r2, #86	; 0x56
    2432:	5a99      	ldrh	r1, [r3, r2]
    2434:	687b      	ldr	r3, [r7, #4]
    2436:	224e      	movs	r2, #78	; 0x4e
    2438:	5299      	strh	r1, [r3, r2]
}
    243a:	46c0      	nop			; (mov r8, r8)
    243c:	46bd      	mov	sp, r7
    243e:	b002      	add	sp, #8
    2440:	bdb0      	pop	{r4, r5, r7, pc}

00002442 <u8g2_update_dimension_r0>:

/*==========================================================*/


void u8g2_update_dimension_r0(u8g2_t *u8g2)
{
    2442:	b580      	push	{r7, lr}
    2444:	b082      	sub	sp, #8
    2446:	af00      	add	r7, sp, #0
    2448:	6078      	str	r0, [r7, #4]
  u8g2_update_dimension_common(u8g2);  
    244a:	687b      	ldr	r3, [r7, #4]
    244c:	0018      	movs	r0, r3
    244e:	f7ff ff18 	bl	2282 <u8g2_update_dimension_common>
}
    2452:	46c0      	nop			; (mov r8, r8)
    2454:	46bd      	mov	sp, r7
    2456:	b002      	add	sp, #8
    2458:	bd80      	pop	{r7, pc}

0000245a <u8g2_update_page_win_r0>:

void u8g2_update_page_win_r0(u8g2_t *u8g2)
{
    245a:	b580      	push	{r7, lr}
    245c:	b082      	sub	sp, #8
    245e:	af00      	add	r7, sp, #0
    2460:	6078      	str	r0, [r7, #4]
  u8g2->user_x0 = 0;
    2462:	687b      	ldr	r3, [r7, #4]
    2464:	2248      	movs	r2, #72	; 0x48
    2466:	2100      	movs	r1, #0
    2468:	5299      	strh	r1, [r3, r2]
  u8g2->user_x1 = u8g2->width;			/* pixel_buf_width replaced with width */
    246a:	687b      	ldr	r3, [r7, #4]
    246c:	2244      	movs	r2, #68	; 0x44
    246e:	5a99      	ldrh	r1, [r3, r2]
    2470:	687b      	ldr	r3, [r7, #4]
    2472:	224a      	movs	r2, #74	; 0x4a
    2474:	5299      	strh	r1, [r3, r2]
  
  u8g2->user_y0 = u8g2->buf_y0;
    2476:	687b      	ldr	r3, [r7, #4]
    2478:	2240      	movs	r2, #64	; 0x40
    247a:	5a99      	ldrh	r1, [r3, r2]
    247c:	687b      	ldr	r3, [r7, #4]
    247e:	224c      	movs	r2, #76	; 0x4c
    2480:	5299      	strh	r1, [r3, r2]
  u8g2->user_y1 = u8g2->buf_y1;
    2482:	687b      	ldr	r3, [r7, #4]
    2484:	2242      	movs	r2, #66	; 0x42
    2486:	5a99      	ldrh	r1, [r3, r2]
    2488:	687b      	ldr	r3, [r7, #4]
    248a:	224e      	movs	r2, #78	; 0x4e
    248c:	5299      	strh	r1, [r3, r2]
  
#ifdef U8G2_WITH_CLIP_WINDOW_SUPPORT
  u8g2_apply_clip_window(u8g2);
    248e:	687b      	ldr	r3, [r7, #4]
    2490:	0018      	movs	r0, r3
    2492:	f7ff ff79 	bl	2388 <u8g2_apply_clip_window>
#endif /* U8G2_WITH_CLIP_WINDOW_SUPPORT */
}
    2496:	46c0      	nop			; (mov r8, r8)
    2498:	46bd      	mov	sp, r7
    249a:	b002      	add	sp, #8
    249c:	bd80      	pop	{r7, pc}

0000249e <u8g2_draw_l90_r0>:
/*============================================*/
extern void u8g2_draw_hv_line_2dir(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t len, uint8_t dir);


void u8g2_draw_l90_r0(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t len, uint8_t dir)
{
    249e:	b590      	push	{r4, r7, lr}
    24a0:	b087      	sub	sp, #28
    24a2:	af02      	add	r7, sp, #8
    24a4:	60f8      	str	r0, [r7, #12]
    24a6:	000c      	movs	r4, r1
    24a8:	0010      	movs	r0, r2
    24aa:	0019      	movs	r1, r3
    24ac:	230a      	movs	r3, #10
    24ae:	18fb      	adds	r3, r7, r3
    24b0:	1c22      	adds	r2, r4, #0
    24b2:	801a      	strh	r2, [r3, #0]
    24b4:	2308      	movs	r3, #8
    24b6:	18fb      	adds	r3, r7, r3
    24b8:	1c02      	adds	r2, r0, #0
    24ba:	801a      	strh	r2, [r3, #0]
    24bc:	1dbb      	adds	r3, r7, #6
    24be:	1c0a      	adds	r2, r1, #0
    24c0:	801a      	strh	r2, [r3, #0]
#ifdef __unix
  assert( dir <= 1 );
#endif
  u8g2_draw_hv_line_2dir(u8g2, x, y, len, dir);
    24c2:	1dbb      	adds	r3, r7, #6
    24c4:	881c      	ldrh	r4, [r3, #0]
    24c6:	2308      	movs	r3, #8
    24c8:	18fb      	adds	r3, r7, r3
    24ca:	881a      	ldrh	r2, [r3, #0]
    24cc:	230a      	movs	r3, #10
    24ce:	18fb      	adds	r3, r7, r3
    24d0:	8819      	ldrh	r1, [r3, #0]
    24d2:	68f8      	ldr	r0, [r7, #12]
    24d4:	2320      	movs	r3, #32
    24d6:	18fb      	adds	r3, r7, r3
    24d8:	781b      	ldrb	r3, [r3, #0]
    24da:	9300      	str	r3, [sp, #0]
    24dc:	0023      	movs	r3, r4
    24de:	f7ff fa54 	bl	198a <u8g2_draw_hv_line_2dir>
}
    24e2:	46c0      	nop			; (mov r8, r8)
    24e4:	46bd      	mov	sp, r7
    24e6:	b005      	add	sp, #20
    24e8:	bd90      	pop	{r4, r7, pc}

000024ea <u8x8_utf8_init>:

*/

/* reset the internal state machine */
void u8x8_utf8_init(u8x8_t *u8x8)
{
    24ea:	b580      	push	{r7, lr}
    24ec:	b082      	sub	sp, #8
    24ee:	af00      	add	r7, sp, #0
    24f0:	6078      	str	r0, [r7, #4]
  u8x8->utf8_state = 0;	/* also reset during u8x8_SetupDefaults() */
    24f2:	687b      	ldr	r3, [r7, #4]
    24f4:	2226      	movs	r2, #38	; 0x26
    24f6:	2100      	movs	r1, #0
    24f8:	5499      	strb	r1, [r3, r2]
}
    24fa:	46c0      	nop			; (mov r8, r8)
    24fc:	46bd      	mov	sp, r7
    24fe:	b002      	add	sp, #8
    2500:	bd80      	pop	{r7, pc}
	...

00002504 <u8x8_ascii_next>:

uint16_t u8x8_ascii_next(U8X8_UNUSED u8x8_t *u8x8, uint8_t b)
{
    2504:	b580      	push	{r7, lr}
    2506:	b082      	sub	sp, #8
    2508:	af00      	add	r7, sp, #0
    250a:	6078      	str	r0, [r7, #4]
    250c:	000a      	movs	r2, r1
    250e:	1cfb      	adds	r3, r7, #3
    2510:	701a      	strb	r2, [r3, #0]
  if ( b == 0 || b == '\n' ) /* '\n' terminates the string to support the string list procedures */
    2512:	1cfb      	adds	r3, r7, #3
    2514:	781b      	ldrb	r3, [r3, #0]
    2516:	2b00      	cmp	r3, #0
    2518:	d003      	beq.n	2522 <u8x8_ascii_next+0x1e>
    251a:	1cfb      	adds	r3, r7, #3
    251c:	781b      	ldrb	r3, [r3, #0]
    251e:	2b0a      	cmp	r3, #10
    2520:	d101      	bne.n	2526 <u8x8_ascii_next+0x22>
    return 0x0ffff;	/* end of string detected*/
    2522:	4b04      	ldr	r3, [pc, #16]	; (2534 <u8x8_ascii_next+0x30>)
    2524:	e002      	b.n	252c <u8x8_ascii_next+0x28>
  return b;
    2526:	1cfb      	adds	r3, r7, #3
    2528:	781b      	ldrb	r3, [r3, #0]
    252a:	b29b      	uxth	r3, r3
}
    252c:	0018      	movs	r0, r3
    252e:	46bd      	mov	sp, r7
    2530:	b002      	add	sp, #8
    2532:	bd80      	pop	{r7, pc}
    2534:	0000ffff 	.word	0x0000ffff

00002538 <u8x8_byte_SendBytes>:
{
  return u8x8->byte_cb(u8x8, U8X8_MSG_BYTE_SET_DC, dc, NULL);
}

uint8_t u8x8_byte_SendBytes(u8x8_t *u8x8, uint8_t cnt, uint8_t *data)
{
    2538:	b590      	push	{r4, r7, lr}
    253a:	b085      	sub	sp, #20
    253c:	af00      	add	r7, sp, #0
    253e:	60f8      	str	r0, [r7, #12]
    2540:	607a      	str	r2, [r7, #4]
    2542:	230b      	movs	r3, #11
    2544:	18fb      	adds	r3, r7, r3
    2546:	1c0a      	adds	r2, r1, #0
    2548:	701a      	strb	r2, [r3, #0]
  return u8x8->byte_cb(u8x8, U8X8_MSG_BYTE_SEND, cnt, (void *)data);
    254a:	68fb      	ldr	r3, [r7, #12]
    254c:	691c      	ldr	r4, [r3, #16]
    254e:	6879      	ldr	r1, [r7, #4]
    2550:	230b      	movs	r3, #11
    2552:	18fb      	adds	r3, r7, r3
    2554:	781a      	ldrb	r2, [r3, #0]
    2556:	68f8      	ldr	r0, [r7, #12]
    2558:	000b      	movs	r3, r1
    255a:	2117      	movs	r1, #23
    255c:	47a0      	blx	r4
    255e:	0003      	movs	r3, r0
}
    2560:	0018      	movs	r0, r3
    2562:	46bd      	mov	sp, r7
    2564:	b005      	add	sp, #20
    2566:	bd90      	pop	{r4, r7, pc}

00002568 <u8x8_byte_SendByte>:

uint8_t u8x8_byte_SendByte(u8x8_t *u8x8, uint8_t byte)
{
    2568:	b580      	push	{r7, lr}
    256a:	b082      	sub	sp, #8
    256c:	af00      	add	r7, sp, #0
    256e:	6078      	str	r0, [r7, #4]
    2570:	000a      	movs	r2, r1
    2572:	1cfb      	adds	r3, r7, #3
    2574:	701a      	strb	r2, [r3, #0]
  return u8x8_byte_SendBytes(u8x8, 1, &byte);
    2576:	1cfa      	adds	r2, r7, #3
    2578:	687b      	ldr	r3, [r7, #4]
    257a:	2101      	movs	r1, #1
    257c:	0018      	movs	r0, r3
    257e:	f7ff ffdb 	bl	2538 <u8x8_byte_SendBytes>
    2582:	0003      	movs	r3, r0
}
    2584:	0018      	movs	r0, r3
    2586:	46bd      	mov	sp, r7
    2588:	b002      	add	sp, #8
    258a:	bd80      	pop	{r7, pc}

0000258c <u8x8_cad_SendCmd>:
*/

#include "u8x8.h"

uint8_t u8x8_cad_SendCmd(u8x8_t *u8x8, uint8_t cmd)
{
    258c:	b590      	push	{r4, r7, lr}
    258e:	b083      	sub	sp, #12
    2590:	af00      	add	r7, sp, #0
    2592:	6078      	str	r0, [r7, #4]
    2594:	000a      	movs	r2, r1
    2596:	1cfb      	adds	r3, r7, #3
    2598:	701a      	strb	r2, [r3, #0]
  return u8x8->cad_cb(u8x8, U8X8_MSG_CAD_SEND_CMD, cmd, NULL);
    259a:	687b      	ldr	r3, [r7, #4]
    259c:	68dc      	ldr	r4, [r3, #12]
    259e:	1cfb      	adds	r3, r7, #3
    25a0:	781a      	ldrb	r2, [r3, #0]
    25a2:	6878      	ldr	r0, [r7, #4]
    25a4:	2300      	movs	r3, #0
    25a6:	2115      	movs	r1, #21
    25a8:	47a0      	blx	r4
    25aa:	0003      	movs	r3, r0
}
    25ac:	0018      	movs	r0, r3
    25ae:	46bd      	mov	sp, r7
    25b0:	b003      	add	sp, #12
    25b2:	bd90      	pop	{r4, r7, pc}

000025b4 <u8x8_cad_SendArg>:

uint8_t u8x8_cad_SendArg(u8x8_t *u8x8, uint8_t arg)
{
    25b4:	b590      	push	{r4, r7, lr}
    25b6:	b083      	sub	sp, #12
    25b8:	af00      	add	r7, sp, #0
    25ba:	6078      	str	r0, [r7, #4]
    25bc:	000a      	movs	r2, r1
    25be:	1cfb      	adds	r3, r7, #3
    25c0:	701a      	strb	r2, [r3, #0]
  return u8x8->cad_cb(u8x8, U8X8_MSG_CAD_SEND_ARG, arg, NULL);
    25c2:	687b      	ldr	r3, [r7, #4]
    25c4:	68dc      	ldr	r4, [r3, #12]
    25c6:	1cfb      	adds	r3, r7, #3
    25c8:	781a      	ldrb	r2, [r3, #0]
    25ca:	6878      	ldr	r0, [r7, #4]
    25cc:	2300      	movs	r3, #0
    25ce:	2116      	movs	r1, #22
    25d0:	47a0      	blx	r4
    25d2:	0003      	movs	r3, r0
}
    25d4:	0018      	movs	r0, r3
    25d6:	46bd      	mov	sp, r7
    25d8:	b003      	add	sp, #12
    25da:	bd90      	pop	{r4, r7, pc}

000025dc <u8x8_cad_SendData>:
  }
  return 1;
}

uint8_t u8x8_cad_SendData(u8x8_t *u8x8, uint8_t cnt, uint8_t *data)
{
    25dc:	b590      	push	{r4, r7, lr}
    25de:	b085      	sub	sp, #20
    25e0:	af00      	add	r7, sp, #0
    25e2:	60f8      	str	r0, [r7, #12]
    25e4:	607a      	str	r2, [r7, #4]
    25e6:	230b      	movs	r3, #11
    25e8:	18fb      	adds	r3, r7, r3
    25ea:	1c0a      	adds	r2, r1, #0
    25ec:	701a      	strb	r2, [r3, #0]
  return u8x8->cad_cb(u8x8, U8X8_MSG_CAD_SEND_DATA, cnt, data);
    25ee:	68fb      	ldr	r3, [r7, #12]
    25f0:	68dc      	ldr	r4, [r3, #12]
    25f2:	6879      	ldr	r1, [r7, #4]
    25f4:	230b      	movs	r3, #11
    25f6:	18fb      	adds	r3, r7, r3
    25f8:	781a      	ldrb	r2, [r3, #0]
    25fa:	68f8      	ldr	r0, [r7, #12]
    25fc:	000b      	movs	r3, r1
    25fe:	2117      	movs	r1, #23
    2600:	47a0      	blx	r4
    2602:	0003      	movs	r3, r0
}
    2604:	0018      	movs	r0, r3
    2606:	46bd      	mov	sp, r7
    2608:	b005      	add	sp, #20
    260a:	bd90      	pop	{r4, r7, pc}

0000260c <u8x8_cad_StartTransfer>:

uint8_t u8x8_cad_StartTransfer(u8x8_t *u8x8)
{
    260c:	b590      	push	{r4, r7, lr}
    260e:	b083      	sub	sp, #12
    2610:	af00      	add	r7, sp, #0
    2612:	6078      	str	r0, [r7, #4]
  return u8x8->cad_cb(u8x8, U8X8_MSG_CAD_START_TRANSFER, 0, NULL);
    2614:	687b      	ldr	r3, [r7, #4]
    2616:	68dc      	ldr	r4, [r3, #12]
    2618:	6878      	ldr	r0, [r7, #4]
    261a:	2300      	movs	r3, #0
    261c:	2200      	movs	r2, #0
    261e:	2118      	movs	r1, #24
    2620:	47a0      	blx	r4
    2622:	0003      	movs	r3, r0
}
    2624:	0018      	movs	r0, r3
    2626:	46bd      	mov	sp, r7
    2628:	b003      	add	sp, #12
    262a:	bd90      	pop	{r4, r7, pc}

0000262c <u8x8_cad_EndTransfer>:

uint8_t u8x8_cad_EndTransfer(u8x8_t *u8x8)
{
    262c:	b590      	push	{r4, r7, lr}
    262e:	b083      	sub	sp, #12
    2630:	af00      	add	r7, sp, #0
    2632:	6078      	str	r0, [r7, #4]
  return u8x8->cad_cb(u8x8, U8X8_MSG_CAD_END_TRANSFER, 0, NULL);
    2634:	687b      	ldr	r3, [r7, #4]
    2636:	68dc      	ldr	r4, [r3, #12]
    2638:	6878      	ldr	r0, [r7, #4]
    263a:	2300      	movs	r3, #0
    263c:	2200      	movs	r2, #0
    263e:	2119      	movs	r1, #25
    2640:	47a0      	blx	r4
    2642:	0003      	movs	r3, r0
}
    2644:	0018      	movs	r0, r3
    2646:	46bd      	mov	sp, r7
    2648:	b003      	add	sp, #12
    264a:	bd90      	pop	{r4, r7, pc}

0000264c <u8x8_cad_SendSequence>:
  254 milli	delay by milliseconds
  255		end of sequence
*/

void u8x8_cad_SendSequence(u8x8_t *u8x8, uint8_t const *data)
{
    264c:	b590      	push	{r4, r7, lr}
    264e:	b085      	sub	sp, #20
    2650:	af00      	add	r7, sp, #0
    2652:	6078      	str	r0, [r7, #4]
    2654:	6039      	str	r1, [r7, #0]
  uint8_t cmd;
  uint8_t v;

  for(;;)
  {
    cmd = *data;
    2656:	230f      	movs	r3, #15
    2658:	18fb      	adds	r3, r7, r3
    265a:	683a      	ldr	r2, [r7, #0]
    265c:	7812      	ldrb	r2, [r2, #0]
    265e:	701a      	strb	r2, [r3, #0]
    data++;
    2660:	683b      	ldr	r3, [r7, #0]
    2662:	3301      	adds	r3, #1
    2664:	603b      	str	r3, [r7, #0]
    switch( cmd )
    2666:	230f      	movs	r3, #15
    2668:	18fb      	adds	r3, r7, r3
    266a:	781b      	ldrb	r3, [r3, #0]
    266c:	2b17      	cmp	r3, #23
    266e:	d01c      	beq.n	26aa <u8x8_cad_SendSequence+0x5e>
    2670:	dc02      	bgt.n	2678 <u8x8_cad_SendSequence+0x2c>
    2672:	2b15      	cmp	r3, #21
    2674:	db45      	blt.n	2702 <u8x8_cad_SendSequence+0xb6>
    2676:	e004      	b.n	2682 <u8x8_cad_SendSequence+0x36>
    2678:	2b19      	cmp	r3, #25
    267a:	dd26      	ble.n	26ca <u8x8_cad_SendSequence+0x7e>
    267c:	2bfe      	cmp	r3, #254	; 0xfe
    267e:	d02e      	beq.n	26de <u8x8_cad_SendSequence+0x92>
	  v = *data;
	  u8x8_gpio_Delay(u8x8, U8X8_MSG_DELAY_MILLI, v);	    
	  data++;
	  break;
      default:
	return;
    2680:	e03f      	b.n	2702 <u8x8_cad_SendSequence+0xb6>
	  v = *data;
    2682:	683b      	ldr	r3, [r7, #0]
    2684:	781a      	ldrb	r2, [r3, #0]
    2686:	230e      	movs	r3, #14
    2688:	18fb      	adds	r3, r7, r3
    268a:	701a      	strb	r2, [r3, #0]
	  u8x8->cad_cb(u8x8, cmd, v, NULL);
    268c:	687b      	ldr	r3, [r7, #4]
    268e:	68dc      	ldr	r4, [r3, #12]
    2690:	230e      	movs	r3, #14
    2692:	18fb      	adds	r3, r7, r3
    2694:	781a      	ldrb	r2, [r3, #0]
    2696:	230f      	movs	r3, #15
    2698:	18fb      	adds	r3, r7, r3
    269a:	7819      	ldrb	r1, [r3, #0]
    269c:	6878      	ldr	r0, [r7, #4]
    269e:	2300      	movs	r3, #0
    26a0:	47a0      	blx	r4
	  data++;
    26a2:	683b      	ldr	r3, [r7, #0]
    26a4:	3301      	adds	r3, #1
    26a6:	603b      	str	r3, [r7, #0]
	  break;
    26a8:	e02a      	b.n	2700 <u8x8_cad_SendSequence+0xb4>
	  v = *data;
    26aa:	683b      	ldr	r3, [r7, #0]
    26ac:	781a      	ldrb	r2, [r3, #0]
    26ae:	230e      	movs	r3, #14
    26b0:	18fb      	adds	r3, r7, r3
    26b2:	701a      	strb	r2, [r3, #0]
	  u8x8_cad_SendData(u8x8, 1, &v);
    26b4:	230e      	movs	r3, #14
    26b6:	18fa      	adds	r2, r7, r3
    26b8:	687b      	ldr	r3, [r7, #4]
    26ba:	2101      	movs	r1, #1
    26bc:	0018      	movs	r0, r3
    26be:	f7ff ff8d 	bl	25dc <u8x8_cad_SendData>
	  data++;
    26c2:	683b      	ldr	r3, [r7, #0]
    26c4:	3301      	adds	r3, #1
    26c6:	603b      	str	r3, [r7, #0]
	  break;
    26c8:	e01a      	b.n	2700 <u8x8_cad_SendSequence+0xb4>
	  u8x8->cad_cb(u8x8, cmd, 0, NULL);
    26ca:	687b      	ldr	r3, [r7, #4]
    26cc:	68dc      	ldr	r4, [r3, #12]
    26ce:	230f      	movs	r3, #15
    26d0:	18fb      	adds	r3, r7, r3
    26d2:	7819      	ldrb	r1, [r3, #0]
    26d4:	6878      	ldr	r0, [r7, #4]
    26d6:	2300      	movs	r3, #0
    26d8:	2200      	movs	r2, #0
    26da:	47a0      	blx	r4
	  break;
    26dc:	e010      	b.n	2700 <u8x8_cad_SendSequence+0xb4>
	  v = *data;
    26de:	683b      	ldr	r3, [r7, #0]
    26e0:	781a      	ldrb	r2, [r3, #0]
    26e2:	230e      	movs	r3, #14
    26e4:	18fb      	adds	r3, r7, r3
    26e6:	701a      	strb	r2, [r3, #0]
	  u8x8_gpio_Delay(u8x8, U8X8_MSG_DELAY_MILLI, v);	    
    26e8:	230e      	movs	r3, #14
    26ea:	18fb      	adds	r3, r7, r3
    26ec:	781a      	ldrb	r2, [r3, #0]
    26ee:	687b      	ldr	r3, [r7, #4]
    26f0:	2129      	movs	r1, #41	; 0x29
    26f2:	0018      	movs	r0, r3
    26f4:	f000 fb88 	bl	2e08 <u8x8_gpio_call>
	  data++;
    26f8:	683b      	ldr	r3, [r7, #0]
    26fa:	3301      	adds	r3, #1
    26fc:	603b      	str	r3, [r7, #0]
	  break;
    26fe:	46c0      	nop			; (mov r8, r8)
    cmd = *data;
    2700:	e7a9      	b.n	2656 <u8x8_cad_SendSequence+0xa>
	return;
    2702:	46c0      	nop			; (mov r8, r8)
    }
  }
}
    2704:	46bd      	mov	sp, r7
    2706:	b005      	add	sp, #20
    2708:	bd90      	pop	{r4, r7, pc}
	...

0000270c <u8x8_cad_empty>:


uint8_t u8x8_cad_empty(u8x8_t *u8x8, uint8_t msg, uint8_t arg_int, void *arg_ptr)
{
    270c:	b5b0      	push	{r4, r5, r7, lr}
    270e:	b084      	sub	sp, #16
    2710:	af00      	add	r7, sp, #0
    2712:	60f8      	str	r0, [r7, #12]
    2714:	0008      	movs	r0, r1
    2716:	0011      	movs	r1, r2
    2718:	607b      	str	r3, [r7, #4]
    271a:	230b      	movs	r3, #11
    271c:	18fb      	adds	r3, r7, r3
    271e:	1c02      	adds	r2, r0, #0
    2720:	701a      	strb	r2, [r3, #0]
    2722:	230a      	movs	r3, #10
    2724:	18fb      	adds	r3, r7, r3
    2726:	1c0a      	adds	r2, r1, #0
    2728:	701a      	strb	r2, [r3, #0]
  switch(msg)
    272a:	230b      	movs	r3, #11
    272c:	18fb      	adds	r3, r7, r3
    272e:	781b      	ldrb	r3, [r3, #0]
    2730:	3b14      	subs	r3, #20
    2732:	2b05      	cmp	r3, #5
    2734:	d824      	bhi.n	2780 <u8x8_cad_empty+0x74>
    2736:	009a      	lsls	r2, r3, #2
    2738:	4b15      	ldr	r3, [pc, #84]	; (2790 <u8x8_cad_empty+0x84>)
    273a:	18d3      	adds	r3, r2, r3
    273c:	681b      	ldr	r3, [r3, #0]
    273e:	469f      	mov	pc, r3
  {
    case U8X8_MSG_CAD_SEND_CMD:
      u8x8_byte_SendByte(u8x8, arg_int);
    2740:	230a      	movs	r3, #10
    2742:	18fb      	adds	r3, r7, r3
    2744:	781a      	ldrb	r2, [r3, #0]
    2746:	68fb      	ldr	r3, [r7, #12]
    2748:	0011      	movs	r1, r2
    274a:	0018      	movs	r0, r3
    274c:	f7ff ff0c 	bl	2568 <u8x8_byte_SendByte>
      break;
    2750:	e018      	b.n	2784 <u8x8_cad_empty+0x78>
    case U8X8_MSG_CAD_SEND_ARG:
      u8x8_byte_SendByte(u8x8, arg_int);
    2752:	230a      	movs	r3, #10
    2754:	18fb      	adds	r3, r7, r3
    2756:	781a      	ldrb	r2, [r3, #0]
    2758:	68fb      	ldr	r3, [r7, #12]
    275a:	0011      	movs	r1, r2
    275c:	0018      	movs	r0, r3
    275e:	f7ff ff03 	bl	2568 <u8x8_byte_SendByte>
      break;
    2762:	e00f      	b.n	2784 <u8x8_cad_empty+0x78>
    case U8X8_MSG_CAD_SEND_DATA:
    case U8X8_MSG_CAD_INIT:
    case U8X8_MSG_CAD_START_TRANSFER:
    case U8X8_MSG_CAD_END_TRANSFER:
      return u8x8->byte_cb(u8x8, msg, arg_int, arg_ptr);
    2764:	68fb      	ldr	r3, [r7, #12]
    2766:	691c      	ldr	r4, [r3, #16]
    2768:	687d      	ldr	r5, [r7, #4]
    276a:	230a      	movs	r3, #10
    276c:	18fb      	adds	r3, r7, r3
    276e:	781a      	ldrb	r2, [r3, #0]
    2770:	230b      	movs	r3, #11
    2772:	18fb      	adds	r3, r7, r3
    2774:	7819      	ldrb	r1, [r3, #0]
    2776:	68f8      	ldr	r0, [r7, #12]
    2778:	002b      	movs	r3, r5
    277a:	47a0      	blx	r4
    277c:	0003      	movs	r3, r0
    277e:	e002      	b.n	2786 <u8x8_cad_empty+0x7a>
    default:
      return 0;
    2780:	2300      	movs	r3, #0
    2782:	e000      	b.n	2786 <u8x8_cad_empty+0x7a>
  }
  return 1;
    2784:	2301      	movs	r3, #1
}
    2786:	0018      	movs	r0, r3
    2788:	46bd      	mov	sp, r7
    278a:	b004      	add	sp, #16
    278c:	bdb0      	pop	{r4, r5, r7, pc}
    278e:	46c0      	nop			; (mov r8, r8)
    2790:	00007cc8 	.word	0x00007cc8

00002794 <u8x8_d_helper_display_setup_memory>:
  this is a helper function for the U8X8_MSG_DISPLAY_SETUP_MEMORY function.
  It can be called within the display callback function to carry out the usual standard tasks.
  
*/
void u8x8_d_helper_display_setup_memory(u8x8_t *u8x8, const u8x8_display_info_t *display_info)
{
    2794:	b580      	push	{r7, lr}
    2796:	b082      	sub	sp, #8
    2798:	af00      	add	r7, sp, #0
    279a:	6078      	str	r0, [r7, #4]
    279c:	6039      	str	r1, [r7, #0]
      /* 1) set display info struct */
      u8x8->display_info = display_info;
    279e:	687b      	ldr	r3, [r7, #4]
    27a0:	683a      	ldr	r2, [r7, #0]
    27a2:	601a      	str	r2, [r3, #0]
      u8x8->x_offset = u8x8->display_info->default_x_offset;
    27a4:	687b      	ldr	r3, [r7, #4]
    27a6:	681b      	ldr	r3, [r3, #0]
    27a8:	7c99      	ldrb	r1, [r3, #18]
    27aa:	687b      	ldr	r3, [r7, #4]
    27ac:	2222      	movs	r2, #34	; 0x22
    27ae:	5499      	strb	r1, [r3, r2]
}
    27b0:	46c0      	nop			; (mov r8, r8)
    27b2:	46bd      	mov	sp, r7
    27b4:	b002      	add	sp, #8
    27b6:	bd80      	pop	{r7, pc}

000027b8 <u8x8_d_helper_display_init>:
  this is a helper function for the U8X8_MSG_DISPLAY_INIT function.
  It can be called within the display callback function to carry out the usual standard tasks.
  
*/
void u8x8_d_helper_display_init(u8x8_t *u8x8)
{
    27b8:	b590      	push	{r4, r7, lr}
    27ba:	b083      	sub	sp, #12
    27bc:	af00      	add	r7, sp, #0
    27be:	6078      	str	r0, [r7, #4]
      /* 2) apply port directions to the GPIO lines and apply default values for the IO lines*/
      u8x8_gpio_Init(u8x8);
    27c0:	687b      	ldr	r3, [r7, #4]
    27c2:	695c      	ldr	r4, [r3, #20]
    27c4:	6878      	ldr	r0, [r7, #4]
    27c6:	2300      	movs	r3, #0
    27c8:	2200      	movs	r2, #0
    27ca:	2128      	movs	r1, #40	; 0x28
    27cc:	47a0      	blx	r4
      u8x8_cad_Init(u8x8);              /* this will also call U8X8_MSG_BYTE_INIT, byte init will NOT call GPIO_INIT */
    27ce:	687b      	ldr	r3, [r7, #4]
    27d0:	68dc      	ldr	r4, [r3, #12]
    27d2:	6878      	ldr	r0, [r7, #4]
    27d4:	2300      	movs	r3, #0
    27d6:	2200      	movs	r2, #0
    27d8:	2114      	movs	r1, #20
    27da:	47a0      	blx	r4

      /* 3) do reset */
      u8x8_gpio_SetReset(u8x8, 1);
    27dc:	687b      	ldr	r3, [r7, #4]
    27de:	2201      	movs	r2, #1
    27e0:	214b      	movs	r1, #75	; 0x4b
    27e2:	0018      	movs	r0, r3
    27e4:	f000 fb10 	bl	2e08 <u8x8_gpio_call>
      u8x8_gpio_Delay(u8x8, U8X8_MSG_DELAY_MILLI, u8x8->display_info->reset_pulse_width_ms);
    27e8:	687b      	ldr	r3, [r7, #4]
    27ea:	681b      	ldr	r3, [r3, #0]
    27ec:	791a      	ldrb	r2, [r3, #4]
    27ee:	687b      	ldr	r3, [r7, #4]
    27f0:	2129      	movs	r1, #41	; 0x29
    27f2:	0018      	movs	r0, r3
    27f4:	f000 fb08 	bl	2e08 <u8x8_gpio_call>
      u8x8_gpio_SetReset(u8x8, 0);
    27f8:	687b      	ldr	r3, [r7, #4]
    27fa:	2200      	movs	r2, #0
    27fc:	214b      	movs	r1, #75	; 0x4b
    27fe:	0018      	movs	r0, r3
    2800:	f000 fb02 	bl	2e08 <u8x8_gpio_call>
      u8x8_gpio_Delay(u8x8, U8X8_MSG_DELAY_MILLI, u8x8->display_info->reset_pulse_width_ms);
    2804:	687b      	ldr	r3, [r7, #4]
    2806:	681b      	ldr	r3, [r3, #0]
    2808:	791a      	ldrb	r2, [r3, #4]
    280a:	687b      	ldr	r3, [r7, #4]
    280c:	2129      	movs	r1, #41	; 0x29
    280e:	0018      	movs	r0, r3
    2810:	f000 fafa 	bl	2e08 <u8x8_gpio_call>
      u8x8_gpio_SetReset(u8x8, 1);
    2814:	687b      	ldr	r3, [r7, #4]
    2816:	2201      	movs	r2, #1
    2818:	214b      	movs	r1, #75	; 0x4b
    281a:	0018      	movs	r0, r3
    281c:	f000 faf4 	bl	2e08 <u8x8_gpio_call>
      u8x8_gpio_Delay(u8x8, U8X8_MSG_DELAY_MILLI, u8x8->display_info->post_reset_wait_ms);
    2820:	687b      	ldr	r3, [r7, #4]
    2822:	681b      	ldr	r3, [r3, #0]
    2824:	795a      	ldrb	r2, [r3, #5]
    2826:	687b      	ldr	r3, [r7, #4]
    2828:	2129      	movs	r1, #41	; 0x29
    282a:	0018      	movs	r0, r3
    282c:	f000 faec 	bl	2e08 <u8x8_gpio_call>
}    
    2830:	46c0      	nop			; (mov r8, r8)
    2832:	46bd      	mov	sp, r7
    2834:	b003      	add	sp, #12
    2836:	bd90      	pop	{r4, r7, pc}

00002838 <u8x8_DrawTile>:

/*==========================================*/
/* official functions */

uint8_t u8x8_DrawTile(u8x8_t *u8x8, uint8_t x, uint8_t y, uint8_t cnt, uint8_t *tile_ptr)
{
    2838:	b590      	push	{r4, r7, lr}
    283a:	b085      	sub	sp, #20
    283c:	af00      	add	r7, sp, #0
    283e:	6078      	str	r0, [r7, #4]
    2840:	000c      	movs	r4, r1
    2842:	0010      	movs	r0, r2
    2844:	0019      	movs	r1, r3
    2846:	1cfb      	adds	r3, r7, #3
    2848:	1c22      	adds	r2, r4, #0
    284a:	701a      	strb	r2, [r3, #0]
    284c:	1cbb      	adds	r3, r7, #2
    284e:	1c02      	adds	r2, r0, #0
    2850:	701a      	strb	r2, [r3, #0]
    2852:	1c7b      	adds	r3, r7, #1
    2854:	1c0a      	adds	r2, r1, #0
    2856:	701a      	strb	r2, [r3, #0]
  u8x8_tile_t tile;
  tile.x_pos = x;
    2858:	2308      	movs	r3, #8
    285a:	18fb      	adds	r3, r7, r3
    285c:	1cfa      	adds	r2, r7, #3
    285e:	7812      	ldrb	r2, [r2, #0]
    2860:	715a      	strb	r2, [r3, #5]
  tile.y_pos = y;
    2862:	2308      	movs	r3, #8
    2864:	18fb      	adds	r3, r7, r3
    2866:	1cba      	adds	r2, r7, #2
    2868:	7812      	ldrb	r2, [r2, #0]
    286a:	719a      	strb	r2, [r3, #6]
  tile.cnt = cnt;
    286c:	2308      	movs	r3, #8
    286e:	18fb      	adds	r3, r7, r3
    2870:	1c7a      	adds	r2, r7, #1
    2872:	7812      	ldrb	r2, [r2, #0]
    2874:	711a      	strb	r2, [r3, #4]
  tile.tile_ptr = tile_ptr;
    2876:	2308      	movs	r3, #8
    2878:	18fb      	adds	r3, r7, r3
    287a:	6a3a      	ldr	r2, [r7, #32]
    287c:	601a      	str	r2, [r3, #0]
  return u8x8->display_cb(u8x8, U8X8_MSG_DISPLAY_DRAW_TILE, 1, (void *)&tile);
    287e:	687b      	ldr	r3, [r7, #4]
    2880:	689c      	ldr	r4, [r3, #8]
    2882:	2308      	movs	r3, #8
    2884:	18fb      	adds	r3, r7, r3
    2886:	6878      	ldr	r0, [r7, #4]
    2888:	2201      	movs	r2, #1
    288a:	210f      	movs	r1, #15
    288c:	47a0      	blx	r4
    288e:	0003      	movs	r3, r0
}
    2890:	0018      	movs	r0, r3
    2892:	46bd      	mov	sp, r7
    2894:	b005      	add	sp, #20
    2896:	bd90      	pop	{r4, r7, pc}

00002898 <u8x8_SetupMemory>:

/* should be implemented as macro */
void u8x8_SetupMemory(u8x8_t *u8x8)
{
    2898:	b590      	push	{r4, r7, lr}
    289a:	b083      	sub	sp, #12
    289c:	af00      	add	r7, sp, #0
    289e:	6078      	str	r0, [r7, #4]
  u8x8->display_cb(u8x8, U8X8_MSG_DISPLAY_SETUP_MEMORY, 0, NULL);  
    28a0:	687b      	ldr	r3, [r7, #4]
    28a2:	689c      	ldr	r4, [r3, #8]
    28a4:	6878      	ldr	r0, [r7, #4]
    28a6:	2300      	movs	r3, #0
    28a8:	2200      	movs	r2, #0
    28aa:	2109      	movs	r1, #9
    28ac:	47a0      	blx	r4
}
    28ae:	46c0      	nop			; (mov r8, r8)
    28b0:	46bd      	mov	sp, r7
    28b2:	b003      	add	sp, #12
    28b4:	bd90      	pop	{r4, r7, pc}

000028b6 <u8x8_InitDisplay>:
  In some cases it is not required to init the display (for example if the display is already running, but the controller comes out of deep sleep mode).
  Then InitDisplay can be skipped, but u8x8_InitInterface()  (== u8x8_gpio_Init() and u8x8_cad_Init()) need to be executed.

*/
void u8x8_InitDisplay(u8x8_t *u8x8)
{
    28b6:	b590      	push	{r4, r7, lr}
    28b8:	b083      	sub	sp, #12
    28ba:	af00      	add	r7, sp, #0
    28bc:	6078      	str	r0, [r7, #4]
  u8x8->display_cb(u8x8, U8X8_MSG_DISPLAY_INIT, 0, NULL);       /* this will call u8x8_d_helper_display_init() and send the init seqence to the display */
    28be:	687b      	ldr	r3, [r7, #4]
    28c0:	689c      	ldr	r4, [r3, #8]
    28c2:	6878      	ldr	r0, [r7, #4]
    28c4:	2300      	movs	r3, #0
    28c6:	2200      	movs	r2, #0
    28c8:	210a      	movs	r1, #10
    28ca:	47a0      	blx	r4
  /* u8x8->display_cb(u8x8, U8X8_MSG_DISPLAY_SET_FLIP_MODE, 0, NULL);  */ /* It would make sense to call flip mode 0 here after U8X8_MSG_DISPLAY_INIT */
}
    28cc:	46c0      	nop			; (mov r8, r8)
    28ce:	46bd      	mov	sp, r7
    28d0:	b003      	add	sp, #12
    28d2:	bd90      	pop	{r4, r7, pc}

000028d4 <u8x8_SetPowerSave>:

void u8x8_SetPowerSave(u8x8_t *u8x8, uint8_t is_enable)
{
    28d4:	b590      	push	{r4, r7, lr}
    28d6:	b083      	sub	sp, #12
    28d8:	af00      	add	r7, sp, #0
    28da:	6078      	str	r0, [r7, #4]
    28dc:	000a      	movs	r2, r1
    28de:	1cfb      	adds	r3, r7, #3
    28e0:	701a      	strb	r2, [r3, #0]
  u8x8->display_cb(u8x8, U8X8_MSG_DISPLAY_SET_POWER_SAVE, is_enable, NULL);  
    28e2:	687b      	ldr	r3, [r7, #4]
    28e4:	689c      	ldr	r4, [r3, #8]
    28e6:	1cfb      	adds	r3, r7, #3
    28e8:	781a      	ldrb	r2, [r3, #0]
    28ea:	6878      	ldr	r0, [r7, #4]
    28ec:	2300      	movs	r3, #0
    28ee:	210b      	movs	r1, #11
    28f0:	47a0      	blx	r4
}
    28f2:	46c0      	nop			; (mov r8, r8)
    28f4:	46bd      	mov	sp, r7
    28f6:	b003      	add	sp, #12
    28f8:	bd90      	pop	{r4, r7, pc}

000028fa <u8x8_SetContrast>:
{
  u8x8->display_cb(u8x8, U8X8_MSG_DISPLAY_SET_FLIP_MODE, mode, NULL);  
}

void u8x8_SetContrast(u8x8_t *u8x8, uint8_t value)
{
    28fa:	b590      	push	{r4, r7, lr}
    28fc:	b083      	sub	sp, #12
    28fe:	af00      	add	r7, sp, #0
    2900:	6078      	str	r0, [r7, #4]
    2902:	000a      	movs	r2, r1
    2904:	1cfb      	adds	r3, r7, #3
    2906:	701a      	strb	r2, [r3, #0]
  u8x8->display_cb(u8x8, U8X8_MSG_DISPLAY_SET_CONTRAST, value, NULL);  
    2908:	687b      	ldr	r3, [r7, #4]
    290a:	689c      	ldr	r4, [r3, #8]
    290c:	1cfb      	adds	r3, r7, #3
    290e:	781a      	ldrb	r2, [r3, #0]
    2910:	6878      	ldr	r0, [r7, #4]
    2912:	2300      	movs	r3, #0
    2914:	210e      	movs	r1, #14
    2916:	47a0      	blx	r4
}
    2918:	46c0      	nop			; (mov r8, r8)
    291a:	46bd      	mov	sp, r7
    291c:	b003      	add	sp, #12
    291e:	bd90      	pop	{r4, r7, pc}

00002920 <u8x8_RefreshDisplay>:

void u8x8_RefreshDisplay(u8x8_t *u8x8)
{
    2920:	b590      	push	{r4, r7, lr}
    2922:	b083      	sub	sp, #12
    2924:	af00      	add	r7, sp, #0
    2926:	6078      	str	r0, [r7, #4]
  u8x8->display_cb(u8x8, U8X8_MSG_DISPLAY_REFRESH, 0, NULL);  
    2928:	687b      	ldr	r3, [r7, #4]
    292a:	689c      	ldr	r4, [r3, #8]
    292c:	6878      	ldr	r0, [r7, #4]
    292e:	2300      	movs	r3, #0
    2930:	2200      	movs	r2, #0
    2932:	2110      	movs	r1, #16
    2934:	47a0      	blx	r4
}
    2936:	46c0      	nop			; (mov r8, r8)
    2938:	46bd      	mov	sp, r7
    293a:	b003      	add	sp, #12
    293c:	bd90      	pop	{r4, r7, pc}
	...

00002940 <u8x8_d_gp1287ai_common>:
    U8X8_END_TRANSFER(),

    U8X8_END() /* end of sequence */
};
uint8_t u8x8_d_gp1287ai_common(u8x8_t *u8x8, uint8_t msg, uint8_t arg_int, void *arg_ptr)
{
    2940:	b580      	push	{r7, lr}
    2942:	b088      	sub	sp, #32
    2944:	af00      	add	r7, sp, #0
    2946:	60f8      	str	r0, [r7, #12]
    2948:	0008      	movs	r0, r1
    294a:	0011      	movs	r1, r2
    294c:	607b      	str	r3, [r7, #4]
    294e:	230b      	movs	r3, #11
    2950:	18fb      	adds	r3, r7, r3
    2952:	1c02      	adds	r2, r0, #0
    2954:	701a      	strb	r2, [r3, #0]
    2956:	230a      	movs	r3, #10
    2958:	18fb      	adds	r3, r7, r3
    295a:	1c0a      	adds	r2, r1, #0
    295c:	701a      	strb	r2, [r3, #0]
    uint8_t *ptr;
    uint8_t x, y;
    uint16_t tx_cnt;
    uint8_t swapped_byte;
    switch (msg)
    295e:	230b      	movs	r3, #11
    2960:	18fb      	adds	r3, r7, r3
    2962:	781b      	ldrb	r3, [r3, #0]
    2964:	2b0e      	cmp	r3, #14
    2966:	d018      	beq.n	299a <u8x8_d_gp1287ai_common+0x5a>
    2968:	2b0f      	cmp	r3, #15
    296a:	d100      	bne.n	296e <u8x8_d_gp1287ai_common+0x2e>
    296c:	e0cf      	b.n	2b0e <u8x8_d_gp1287ai_common+0x1ce>
    296e:	2b0b      	cmp	r3, #11
    2970:	d000      	beq.n	2974 <u8x8_d_gp1287ai_common+0x34>
    2972:	e201      	b.n	2d78 <u8x8_d_gp1287ai_common+0x438>
    {
    case U8X8_MSG_DISPLAY_SET_POWER_SAVE:
        if (arg_int == 0)
    2974:	230a      	movs	r3, #10
    2976:	18fb      	adds	r3, r7, r3
    2978:	781b      	ldrb	r3, [r3, #0]
    297a:	2b00      	cmp	r3, #0
    297c:	d106      	bne.n	298c <u8x8_d_gp1287ai_common+0x4c>
            u8x8_cad_SendSequence(u8x8, u8x8_d_gp1287ai_wakeup_seq);
    297e:	4ac6      	ldr	r2, [pc, #792]	; (2c98 <u8x8_d_gp1287ai_common+0x358>)
    2980:	68fb      	ldr	r3, [r7, #12]
    2982:	0011      	movs	r1, r2
    2984:	0018      	movs	r0, r3
    2986:	f7ff fe61 	bl	264c <u8x8_cad_SendSequence>
        else
            u8x8_cad_SendSequence(u8x8, u8x8_d_gp1287ai_standby_seq);
        break;
    298a:	e1f7      	b.n	2d7c <u8x8_d_gp1287ai_common+0x43c>
            u8x8_cad_SendSequence(u8x8, u8x8_d_gp1287ai_standby_seq);
    298c:	4ac3      	ldr	r2, [pc, #780]	; (2c9c <u8x8_d_gp1287ai_common+0x35c>)
    298e:	68fb      	ldr	r3, [r7, #12]
    2990:	0011      	movs	r1, r2
    2992:	0018      	movs	r0, r3
    2994:	f7ff fe5a 	bl	264c <u8x8_cad_SendSequence>
        break;
    2998:	e1f0      	b.n	2d7c <u8x8_d_gp1287ai_common+0x43c>
#ifdef U8X8_WITH_SET_CONTRAST
    case U8X8_MSG_DISPLAY_SET_CONTRAST:
        u8x8_cad_StartTransfer(u8x8);
    299a:	68fb      	ldr	r3, [r7, #12]
    299c:	0018      	movs	r0, r3
    299e:	f7ff fe35 	bl	260c <u8x8_cad_StartTransfer>
        u8x8_cad_SendCmd(u8x8, SWAP8(0x0A0));
    29a2:	68fb      	ldr	r3, [r7, #12]
    29a4:	2105      	movs	r1, #5
    29a6:	0018      	movs	r0, r3
    29a8:	f7ff fdf0 	bl	258c <u8x8_cad_SendCmd>
        //u8x8_cad_SendArg(u8x8, SWAP8((arg_int * 4) >> 8));   /* Dimming level */
        //u8x8_cad_SendArg(u8x8, SWAP8((arg_int * 4) & 0xFF)); /* Dimming level */
		
		u8x8_cad_SendArg(u8x8, SWAP8((arg_int * 4) >> 8));   /* Dimming level */
    29ac:	230a      	movs	r3, #10
    29ae:	18fb      	adds	r3, r7, r3
    29b0:	781b      	ldrb	r3, [r3, #0]
    29b2:	009b      	lsls	r3, r3, #2
    29b4:	13db      	asrs	r3, r3, #15
    29b6:	b25b      	sxtb	r3, r3
    29b8:	2201      	movs	r2, #1
    29ba:	4013      	ands	r3, r2
    29bc:	b25a      	sxtb	r2, r3
    29be:	230a      	movs	r3, #10
    29c0:	18fb      	adds	r3, r7, r3
    29c2:	781b      	ldrb	r3, [r3, #0]
    29c4:	009b      	lsls	r3, r3, #2
    29c6:	135b      	asrs	r3, r3, #13
    29c8:	b25b      	sxtb	r3, r3
    29ca:	2102      	movs	r1, #2
    29cc:	400b      	ands	r3, r1
    29ce:	b25b      	sxtb	r3, r3
    29d0:	4313      	orrs	r3, r2
    29d2:	b25a      	sxtb	r2, r3
    29d4:	230a      	movs	r3, #10
    29d6:	18fb      	adds	r3, r7, r3
    29d8:	781b      	ldrb	r3, [r3, #0]
    29da:	009b      	lsls	r3, r3, #2
    29dc:	12db      	asrs	r3, r3, #11
    29de:	b25b      	sxtb	r3, r3
    29e0:	2104      	movs	r1, #4
    29e2:	400b      	ands	r3, r1
    29e4:	b25b      	sxtb	r3, r3
    29e6:	4313      	orrs	r3, r2
    29e8:	b25a      	sxtb	r2, r3
    29ea:	230a      	movs	r3, #10
    29ec:	18fb      	adds	r3, r7, r3
    29ee:	781b      	ldrb	r3, [r3, #0]
    29f0:	009b      	lsls	r3, r3, #2
    29f2:	125b      	asrs	r3, r3, #9
    29f4:	b25b      	sxtb	r3, r3
    29f6:	2108      	movs	r1, #8
    29f8:	400b      	ands	r3, r1
    29fa:	b25b      	sxtb	r3, r3
    29fc:	4313      	orrs	r3, r2
    29fe:	b25a      	sxtb	r2, r3
    2a00:	230a      	movs	r3, #10
    2a02:	18fb      	adds	r3, r7, r3
    2a04:	781b      	ldrb	r3, [r3, #0]
    2a06:	009b      	lsls	r3, r3, #2
    2a08:	121b      	asrs	r3, r3, #8
    2a0a:	005b      	lsls	r3, r3, #1
    2a0c:	b25b      	sxtb	r3, r3
    2a0e:	2110      	movs	r1, #16
    2a10:	400b      	ands	r3, r1
    2a12:	b25b      	sxtb	r3, r3
    2a14:	4313      	orrs	r3, r2
    2a16:	b25a      	sxtb	r2, r3
    2a18:	230a      	movs	r3, #10
    2a1a:	18fb      	adds	r3, r7, r3
    2a1c:	781b      	ldrb	r3, [r3, #0]
    2a1e:	009b      	lsls	r3, r3, #2
    2a20:	121b      	asrs	r3, r3, #8
    2a22:	00db      	lsls	r3, r3, #3
    2a24:	b25b      	sxtb	r3, r3
    2a26:	2120      	movs	r1, #32
    2a28:	400b      	ands	r3, r1
    2a2a:	b25b      	sxtb	r3, r3
    2a2c:	4313      	orrs	r3, r2
    2a2e:	b25a      	sxtb	r2, r3
    2a30:	230a      	movs	r3, #10
    2a32:	18fb      	adds	r3, r7, r3
    2a34:	781b      	ldrb	r3, [r3, #0]
    2a36:	009b      	lsls	r3, r3, #2
    2a38:	121b      	asrs	r3, r3, #8
    2a3a:	015b      	lsls	r3, r3, #5
    2a3c:	b25b      	sxtb	r3, r3
    2a3e:	2140      	movs	r1, #64	; 0x40
    2a40:	400b      	ands	r3, r1
    2a42:	b25b      	sxtb	r3, r3
    2a44:	4313      	orrs	r3, r2
    2a46:	b25a      	sxtb	r2, r3
    2a48:	230a      	movs	r3, #10
    2a4a:	18fb      	adds	r3, r7, r3
    2a4c:	781b      	ldrb	r3, [r3, #0]
    2a4e:	009b      	lsls	r3, r3, #2
    2a50:	121b      	asrs	r3, r3, #8
    2a52:	01db      	lsls	r3, r3, #7
    2a54:	b25b      	sxtb	r3, r3
    2a56:	4313      	orrs	r3, r2
    2a58:	b25b      	sxtb	r3, r3
    2a5a:	b2da      	uxtb	r2, r3
    2a5c:	68fb      	ldr	r3, [r7, #12]
    2a5e:	0011      	movs	r1, r2
    2a60:	0018      	movs	r0, r3
    2a62:	f7ff fda7 	bl	25b4 <u8x8_cad_SendArg>
		u8x8_cad_SendArg(u8x8, SWAP8(arg_int)); /* Dimming level */
    2a66:	230a      	movs	r3, #10
    2a68:	18fb      	adds	r3, r7, r3
    2a6a:	781b      	ldrb	r3, [r3, #0]
    2a6c:	09db      	lsrs	r3, r3, #7
    2a6e:	b2db      	uxtb	r3, r3
    2a70:	b25a      	sxtb	r2, r3
    2a72:	230a      	movs	r3, #10
    2a74:	18fb      	adds	r3, r7, r3
    2a76:	781b      	ldrb	r3, [r3, #0]
    2a78:	115b      	asrs	r3, r3, #5
    2a7a:	b25b      	sxtb	r3, r3
    2a7c:	2102      	movs	r1, #2
    2a7e:	400b      	ands	r3, r1
    2a80:	b25b      	sxtb	r3, r3
    2a82:	4313      	orrs	r3, r2
    2a84:	b25a      	sxtb	r2, r3
    2a86:	230a      	movs	r3, #10
    2a88:	18fb      	adds	r3, r7, r3
    2a8a:	781b      	ldrb	r3, [r3, #0]
    2a8c:	10db      	asrs	r3, r3, #3
    2a8e:	b25b      	sxtb	r3, r3
    2a90:	2104      	movs	r1, #4
    2a92:	400b      	ands	r3, r1
    2a94:	b25b      	sxtb	r3, r3
    2a96:	4313      	orrs	r3, r2
    2a98:	b25a      	sxtb	r2, r3
    2a9a:	230a      	movs	r3, #10
    2a9c:	18fb      	adds	r3, r7, r3
    2a9e:	781b      	ldrb	r3, [r3, #0]
    2aa0:	105b      	asrs	r3, r3, #1
    2aa2:	b25b      	sxtb	r3, r3
    2aa4:	2108      	movs	r1, #8
    2aa6:	400b      	ands	r3, r1
    2aa8:	b25b      	sxtb	r3, r3
    2aaa:	4313      	orrs	r3, r2
    2aac:	b25a      	sxtb	r2, r3
    2aae:	230a      	movs	r3, #10
    2ab0:	18fb      	adds	r3, r7, r3
    2ab2:	781b      	ldrb	r3, [r3, #0]
    2ab4:	005b      	lsls	r3, r3, #1
    2ab6:	b25b      	sxtb	r3, r3
    2ab8:	2110      	movs	r1, #16
    2aba:	400b      	ands	r3, r1
    2abc:	b25b      	sxtb	r3, r3
    2abe:	4313      	orrs	r3, r2
    2ac0:	b25a      	sxtb	r2, r3
    2ac2:	230a      	movs	r3, #10
    2ac4:	18fb      	adds	r3, r7, r3
    2ac6:	781b      	ldrb	r3, [r3, #0]
    2ac8:	00db      	lsls	r3, r3, #3
    2aca:	b25b      	sxtb	r3, r3
    2acc:	2120      	movs	r1, #32
    2ace:	400b      	ands	r3, r1
    2ad0:	b25b      	sxtb	r3, r3
    2ad2:	4313      	orrs	r3, r2
    2ad4:	b25a      	sxtb	r2, r3
    2ad6:	230a      	movs	r3, #10
    2ad8:	18fb      	adds	r3, r7, r3
    2ada:	781b      	ldrb	r3, [r3, #0]
    2adc:	015b      	lsls	r3, r3, #5
    2ade:	b25b      	sxtb	r3, r3
    2ae0:	2140      	movs	r1, #64	; 0x40
    2ae2:	400b      	ands	r3, r1
    2ae4:	b25b      	sxtb	r3, r3
    2ae6:	4313      	orrs	r3, r2
    2ae8:	b25a      	sxtb	r2, r3
    2aea:	230a      	movs	r3, #10
    2aec:	18fb      	adds	r3, r7, r3
    2aee:	781b      	ldrb	r3, [r3, #0]
    2af0:	01db      	lsls	r3, r3, #7
    2af2:	b25b      	sxtb	r3, r3
    2af4:	4313      	orrs	r3, r2
    2af6:	b25b      	sxtb	r3, r3
    2af8:	b2da      	uxtb	r2, r3
    2afa:	68fb      	ldr	r3, [r7, #12]
    2afc:	0011      	movs	r1, r2
    2afe:	0018      	movs	r0, r3
    2b00:	f7ff fd58 	bl	25b4 <u8x8_cad_SendArg>
		
        u8x8_cad_EndTransfer(u8x8);
    2b04:	68fb      	ldr	r3, [r7, #12]
    2b06:	0018      	movs	r0, r3
    2b08:	f7ff fd90 	bl	262c <u8x8_cad_EndTransfer>
        break;
    2b0c:	e136      	b.n	2d7c <u8x8_d_gp1287ai_common+0x43c>
#endif
    case U8X8_MSG_DISPLAY_DRAW_TILE:
        x = ((u8x8_tile_t *)arg_ptr)->x_pos * 8;
    2b0e:	687b      	ldr	r3, [r7, #4]
    2b10:	795a      	ldrb	r2, [r3, #5]
    2b12:	2319      	movs	r3, #25
    2b14:	18fb      	adds	r3, r7, r3
    2b16:	00d2      	lsls	r2, r2, #3
    2b18:	701a      	strb	r2, [r3, #0]
        y = ((u8x8_tile_t *)arg_ptr)->y_pos * 8 + 4;
    2b1a:	687b      	ldr	r3, [r7, #4]
    2b1c:	799b      	ldrb	r3, [r3, #6]
    2b1e:	00db      	lsls	r3, r3, #3
    2b20:	b2da      	uxtb	r2, r3
    2b22:	2318      	movs	r3, #24
    2b24:	18fb      	adds	r3, r7, r3
    2b26:	3204      	adds	r2, #4
    2b28:	701a      	strb	r2, [r3, #0]

        u8x8_cad_StartTransfer(u8x8);
    2b2a:	68fb      	ldr	r3, [r7, #12]
    2b2c:	0018      	movs	r0, r3
    2b2e:	f7ff fd6d 	bl	260c <u8x8_cad_StartTransfer>

        u8x8_cad_SendCmd(u8x8, SWAP8(0x0F0));
    2b32:	68fb      	ldr	r3, [r7, #12]
    2b34:	210f      	movs	r1, #15
    2b36:	0018      	movs	r0, r3
    2b38:	f7ff fd28 	bl	258c <u8x8_cad_SendCmd>
        u8x8_cad_SendArg(u8x8, SWAP8(x));
    2b3c:	2319      	movs	r3, #25
    2b3e:	18fb      	adds	r3, r7, r3
    2b40:	781b      	ldrb	r3, [r3, #0]
    2b42:	09db      	lsrs	r3, r3, #7
    2b44:	b2db      	uxtb	r3, r3
    2b46:	b25a      	sxtb	r2, r3
    2b48:	2319      	movs	r3, #25
    2b4a:	18fb      	adds	r3, r7, r3
    2b4c:	781b      	ldrb	r3, [r3, #0]
    2b4e:	115b      	asrs	r3, r3, #5
    2b50:	b25b      	sxtb	r3, r3
    2b52:	2102      	movs	r1, #2
    2b54:	400b      	ands	r3, r1
    2b56:	b25b      	sxtb	r3, r3
    2b58:	4313      	orrs	r3, r2
    2b5a:	b25a      	sxtb	r2, r3
    2b5c:	2319      	movs	r3, #25
    2b5e:	18fb      	adds	r3, r7, r3
    2b60:	781b      	ldrb	r3, [r3, #0]
    2b62:	10db      	asrs	r3, r3, #3
    2b64:	b25b      	sxtb	r3, r3
    2b66:	2104      	movs	r1, #4
    2b68:	400b      	ands	r3, r1
    2b6a:	b25b      	sxtb	r3, r3
    2b6c:	4313      	orrs	r3, r2
    2b6e:	b25a      	sxtb	r2, r3
    2b70:	2319      	movs	r3, #25
    2b72:	18fb      	adds	r3, r7, r3
    2b74:	781b      	ldrb	r3, [r3, #0]
    2b76:	105b      	asrs	r3, r3, #1
    2b78:	b25b      	sxtb	r3, r3
    2b7a:	2108      	movs	r1, #8
    2b7c:	400b      	ands	r3, r1
    2b7e:	b25b      	sxtb	r3, r3
    2b80:	4313      	orrs	r3, r2
    2b82:	b25a      	sxtb	r2, r3
    2b84:	2319      	movs	r3, #25
    2b86:	18fb      	adds	r3, r7, r3
    2b88:	781b      	ldrb	r3, [r3, #0]
    2b8a:	005b      	lsls	r3, r3, #1
    2b8c:	b25b      	sxtb	r3, r3
    2b8e:	2110      	movs	r1, #16
    2b90:	400b      	ands	r3, r1
    2b92:	b25b      	sxtb	r3, r3
    2b94:	4313      	orrs	r3, r2
    2b96:	b25a      	sxtb	r2, r3
    2b98:	2319      	movs	r3, #25
    2b9a:	18fb      	adds	r3, r7, r3
    2b9c:	781b      	ldrb	r3, [r3, #0]
    2b9e:	00db      	lsls	r3, r3, #3
    2ba0:	b25b      	sxtb	r3, r3
    2ba2:	2120      	movs	r1, #32
    2ba4:	400b      	ands	r3, r1
    2ba6:	b25b      	sxtb	r3, r3
    2ba8:	4313      	orrs	r3, r2
    2baa:	b25a      	sxtb	r2, r3
    2bac:	2319      	movs	r3, #25
    2bae:	18fb      	adds	r3, r7, r3
    2bb0:	781b      	ldrb	r3, [r3, #0]
    2bb2:	015b      	lsls	r3, r3, #5
    2bb4:	b25b      	sxtb	r3, r3
    2bb6:	2140      	movs	r1, #64	; 0x40
    2bb8:	400b      	ands	r3, r1
    2bba:	b25b      	sxtb	r3, r3
    2bbc:	4313      	orrs	r3, r2
    2bbe:	b25a      	sxtb	r2, r3
    2bc0:	2319      	movs	r3, #25
    2bc2:	18fb      	adds	r3, r7, r3
    2bc4:	781b      	ldrb	r3, [r3, #0]
    2bc6:	01db      	lsls	r3, r3, #7
    2bc8:	b25b      	sxtb	r3, r3
    2bca:	4313      	orrs	r3, r2
    2bcc:	b25b      	sxtb	r3, r3
    2bce:	b2da      	uxtb	r2, r3
    2bd0:	68fb      	ldr	r3, [r7, #12]
    2bd2:	0011      	movs	r1, r2
    2bd4:	0018      	movs	r0, r3
    2bd6:	f7ff fced 	bl	25b4 <u8x8_cad_SendArg>
        u8x8_cad_SendArg(u8x8, SWAP8(y));
    2bda:	2318      	movs	r3, #24
    2bdc:	18fb      	adds	r3, r7, r3
    2bde:	781b      	ldrb	r3, [r3, #0]
    2be0:	09db      	lsrs	r3, r3, #7
    2be2:	b2db      	uxtb	r3, r3
    2be4:	b25a      	sxtb	r2, r3
    2be6:	2318      	movs	r3, #24
    2be8:	18fb      	adds	r3, r7, r3
    2bea:	781b      	ldrb	r3, [r3, #0]
    2bec:	115b      	asrs	r3, r3, #5
    2bee:	b25b      	sxtb	r3, r3
    2bf0:	2102      	movs	r1, #2
    2bf2:	400b      	ands	r3, r1
    2bf4:	b25b      	sxtb	r3, r3
    2bf6:	4313      	orrs	r3, r2
    2bf8:	b25a      	sxtb	r2, r3
    2bfa:	2318      	movs	r3, #24
    2bfc:	18fb      	adds	r3, r7, r3
    2bfe:	781b      	ldrb	r3, [r3, #0]
    2c00:	10db      	asrs	r3, r3, #3
    2c02:	b25b      	sxtb	r3, r3
    2c04:	2104      	movs	r1, #4
    2c06:	400b      	ands	r3, r1
    2c08:	b25b      	sxtb	r3, r3
    2c0a:	4313      	orrs	r3, r2
    2c0c:	b25a      	sxtb	r2, r3
    2c0e:	2318      	movs	r3, #24
    2c10:	18fb      	adds	r3, r7, r3
    2c12:	781b      	ldrb	r3, [r3, #0]
    2c14:	105b      	asrs	r3, r3, #1
    2c16:	b25b      	sxtb	r3, r3
    2c18:	2108      	movs	r1, #8
    2c1a:	400b      	ands	r3, r1
    2c1c:	b25b      	sxtb	r3, r3
    2c1e:	4313      	orrs	r3, r2
    2c20:	b25a      	sxtb	r2, r3
    2c22:	2318      	movs	r3, #24
    2c24:	18fb      	adds	r3, r7, r3
    2c26:	781b      	ldrb	r3, [r3, #0]
    2c28:	005b      	lsls	r3, r3, #1
    2c2a:	b25b      	sxtb	r3, r3
    2c2c:	2110      	movs	r1, #16
    2c2e:	400b      	ands	r3, r1
    2c30:	b25b      	sxtb	r3, r3
    2c32:	4313      	orrs	r3, r2
    2c34:	b25a      	sxtb	r2, r3
    2c36:	2318      	movs	r3, #24
    2c38:	18fb      	adds	r3, r7, r3
    2c3a:	781b      	ldrb	r3, [r3, #0]
    2c3c:	00db      	lsls	r3, r3, #3
    2c3e:	b25b      	sxtb	r3, r3
    2c40:	2120      	movs	r1, #32
    2c42:	400b      	ands	r3, r1
    2c44:	b25b      	sxtb	r3, r3
    2c46:	4313      	orrs	r3, r2
    2c48:	b25a      	sxtb	r2, r3
    2c4a:	2318      	movs	r3, #24
    2c4c:	18fb      	adds	r3, r7, r3
    2c4e:	781b      	ldrb	r3, [r3, #0]
    2c50:	015b      	lsls	r3, r3, #5
    2c52:	b25b      	sxtb	r3, r3
    2c54:	2140      	movs	r1, #64	; 0x40
    2c56:	400b      	ands	r3, r1
    2c58:	b25b      	sxtb	r3, r3
    2c5a:	4313      	orrs	r3, r2
    2c5c:	b25a      	sxtb	r2, r3
    2c5e:	2318      	movs	r3, #24
    2c60:	18fb      	adds	r3, r7, r3
    2c62:	781b      	ldrb	r3, [r3, #0]
    2c64:	01db      	lsls	r3, r3, #7
    2c66:	b25b      	sxtb	r3, r3
    2c68:	4313      	orrs	r3, r2
    2c6a:	b25b      	sxtb	r3, r3
    2c6c:	b2da      	uxtb	r2, r3
    2c6e:	68fb      	ldr	r3, [r7, #12]
    2c70:	0011      	movs	r1, r2
    2c72:	0018      	movs	r0, r3
    2c74:	f7ff fc9e 	bl	25b4 <u8x8_cad_SendArg>
        u8x8_cad_SendArg(u8x8, SWAP8(0x007)); /* return every 8 pixels */
    2c78:	68fb      	ldr	r3, [r7, #12]
    2c7a:	21e0      	movs	r1, #224	; 0xe0
    2c7c:	0018      	movs	r0, r3
    2c7e:	f7ff fc99 	bl	25b4 <u8x8_cad_SendArg>
        do
        {
            ptr = ((u8x8_tile_t *)arg_ptr)->tile_ptr;
    2c82:	687b      	ldr	r3, [r7, #4]
    2c84:	681b      	ldr	r3, [r3, #0]
    2c86:	61fb      	str	r3, [r7, #28]
            tx_cnt = ((u8x8_tile_t *)arg_ptr)->cnt * 8;
    2c88:	687b      	ldr	r3, [r7, #4]
    2c8a:	791b      	ldrb	r3, [r3, #4]
    2c8c:	b29a      	uxth	r2, r3
    2c8e:	231a      	movs	r3, #26
    2c90:	18fb      	adds	r3, r7, r3
    2c92:	00d2      	lsls	r2, r2, #3
    2c94:	801a      	strh	r2, [r3, #0]
            while (tx_cnt > 0)
    2c96:	e059      	b.n	2d4c <u8x8_d_gp1287ai_common+0x40c>
    2c98:	00007d68 	.word	0x00007d68
    2c9c:	00007d60 	.word	0x00007d60
            {
                swapped_byte = SWAP8(*ptr);
    2ca0:	69fb      	ldr	r3, [r7, #28]
    2ca2:	781b      	ldrb	r3, [r3, #0]
    2ca4:	09db      	lsrs	r3, r3, #7
    2ca6:	b2db      	uxtb	r3, r3
    2ca8:	b25a      	sxtb	r2, r3
    2caa:	69fb      	ldr	r3, [r7, #28]
    2cac:	781b      	ldrb	r3, [r3, #0]
    2cae:	115b      	asrs	r3, r3, #5
    2cb0:	b25b      	sxtb	r3, r3
    2cb2:	2102      	movs	r1, #2
    2cb4:	400b      	ands	r3, r1
    2cb6:	b25b      	sxtb	r3, r3
    2cb8:	4313      	orrs	r3, r2
    2cba:	b25a      	sxtb	r2, r3
    2cbc:	69fb      	ldr	r3, [r7, #28]
    2cbe:	781b      	ldrb	r3, [r3, #0]
    2cc0:	10db      	asrs	r3, r3, #3
    2cc2:	b25b      	sxtb	r3, r3
    2cc4:	2104      	movs	r1, #4
    2cc6:	400b      	ands	r3, r1
    2cc8:	b25b      	sxtb	r3, r3
    2cca:	4313      	orrs	r3, r2
    2ccc:	b25a      	sxtb	r2, r3
    2cce:	69fb      	ldr	r3, [r7, #28]
    2cd0:	781b      	ldrb	r3, [r3, #0]
    2cd2:	105b      	asrs	r3, r3, #1
    2cd4:	b25b      	sxtb	r3, r3
    2cd6:	2108      	movs	r1, #8
    2cd8:	400b      	ands	r3, r1
    2cda:	b25b      	sxtb	r3, r3
    2cdc:	4313      	orrs	r3, r2
    2cde:	b25a      	sxtb	r2, r3
    2ce0:	69fb      	ldr	r3, [r7, #28]
    2ce2:	781b      	ldrb	r3, [r3, #0]
    2ce4:	005b      	lsls	r3, r3, #1
    2ce6:	b25b      	sxtb	r3, r3
    2ce8:	2110      	movs	r1, #16
    2cea:	400b      	ands	r3, r1
    2cec:	b25b      	sxtb	r3, r3
    2cee:	4313      	orrs	r3, r2
    2cf0:	b25a      	sxtb	r2, r3
    2cf2:	69fb      	ldr	r3, [r7, #28]
    2cf4:	781b      	ldrb	r3, [r3, #0]
    2cf6:	00db      	lsls	r3, r3, #3
    2cf8:	b25b      	sxtb	r3, r3
    2cfa:	2120      	movs	r1, #32
    2cfc:	400b      	ands	r3, r1
    2cfe:	b25b      	sxtb	r3, r3
    2d00:	4313      	orrs	r3, r2
    2d02:	b25a      	sxtb	r2, r3
    2d04:	69fb      	ldr	r3, [r7, #28]
    2d06:	781b      	ldrb	r3, [r3, #0]
    2d08:	015b      	lsls	r3, r3, #5
    2d0a:	b25b      	sxtb	r3, r3
    2d0c:	2140      	movs	r1, #64	; 0x40
    2d0e:	400b      	ands	r3, r1
    2d10:	b25b      	sxtb	r3, r3
    2d12:	4313      	orrs	r3, r2
    2d14:	b25a      	sxtb	r2, r3
    2d16:	69fb      	ldr	r3, [r7, #28]
    2d18:	781b      	ldrb	r3, [r3, #0]
    2d1a:	01db      	lsls	r3, r3, #7
    2d1c:	b25b      	sxtb	r3, r3
    2d1e:	4313      	orrs	r3, r2
    2d20:	b25b      	sxtb	r3, r3
    2d22:	b2da      	uxtb	r2, r3
    2d24:	2317      	movs	r3, #23
    2d26:	18fb      	adds	r3, r7, r3
    2d28:	701a      	strb	r2, [r3, #0]
                u8x8_cad_SendData(u8x8, 1, &swapped_byte);
    2d2a:	2317      	movs	r3, #23
    2d2c:	18fa      	adds	r2, r7, r3
    2d2e:	68fb      	ldr	r3, [r7, #12]
    2d30:	2101      	movs	r1, #1
    2d32:	0018      	movs	r0, r3
    2d34:	f7ff fc52 	bl	25dc <u8x8_cad_SendData>
                ptr += 1;
    2d38:	69fb      	ldr	r3, [r7, #28]
    2d3a:	3301      	adds	r3, #1
    2d3c:	61fb      	str	r3, [r7, #28]
                tx_cnt -= 1;
    2d3e:	231a      	movs	r3, #26
    2d40:	18fb      	adds	r3, r7, r3
    2d42:	221a      	movs	r2, #26
    2d44:	18ba      	adds	r2, r7, r2
    2d46:	8812      	ldrh	r2, [r2, #0]
    2d48:	3a01      	subs	r2, #1
    2d4a:	801a      	strh	r2, [r3, #0]
            while (tx_cnt > 0)
    2d4c:	231a      	movs	r3, #26
    2d4e:	18fb      	adds	r3, r7, r3
    2d50:	881b      	ldrh	r3, [r3, #0]
    2d52:	2b00      	cmp	r3, #0
    2d54:	d1a4      	bne.n	2ca0 <u8x8_d_gp1287ai_common+0x360>
            }
            arg_int--;
    2d56:	230a      	movs	r3, #10
    2d58:	18fb      	adds	r3, r7, r3
    2d5a:	781a      	ldrb	r2, [r3, #0]
    2d5c:	230a      	movs	r3, #10
    2d5e:	18fb      	adds	r3, r7, r3
    2d60:	3a01      	subs	r2, #1
    2d62:	701a      	strb	r2, [r3, #0]
        } while (arg_int > 0);
    2d64:	230a      	movs	r3, #10
    2d66:	18fb      	adds	r3, r7, r3
    2d68:	781b      	ldrb	r3, [r3, #0]
    2d6a:	2b00      	cmp	r3, #0
    2d6c:	d189      	bne.n	2c82 <u8x8_d_gp1287ai_common+0x342>

        u8x8_cad_EndTransfer(u8x8);
    2d6e:	68fb      	ldr	r3, [r7, #12]
    2d70:	0018      	movs	r0, r3
    2d72:	f7ff fc5b 	bl	262c <u8x8_cad_EndTransfer>
        break;
    2d76:	e001      	b.n	2d7c <u8x8_d_gp1287ai_common+0x43c>
    default:
        return 0;
    2d78:	2300      	movs	r3, #0
    2d7a:	e000      	b.n	2d7e <u8x8_d_gp1287ai_common+0x43e>
    }
    return 1;
    2d7c:	2301      	movs	r3, #1
}
    2d7e:	0018      	movs	r0, r3
    2d80:	46bd      	mov	sp, r7
    2d82:	b008      	add	sp, #32
    2d84:	bd80      	pop	{r7, pc}
    2d86:	46c0      	nop			; (mov r8, r8)

00002d88 <u8x8_d_gp1287ai_256x50>:
uint8_t u8x8_d_gp1287ai_256x50(u8x8_t *u8x8, uint8_t msg, uint8_t arg_int, void *arg_ptr)
{
    2d88:	b590      	push	{r4, r7, lr}
    2d8a:	b085      	sub	sp, #20
    2d8c:	af00      	add	r7, sp, #0
    2d8e:	60f8      	str	r0, [r7, #12]
    2d90:	0008      	movs	r0, r1
    2d92:	0011      	movs	r1, r2
    2d94:	607b      	str	r3, [r7, #4]
    2d96:	230b      	movs	r3, #11
    2d98:	18fb      	adds	r3, r7, r3
    2d9a:	1c02      	adds	r2, r0, #0
    2d9c:	701a      	strb	r2, [r3, #0]
    2d9e:	230a      	movs	r3, #10
    2da0:	18fb      	adds	r3, r7, r3
    2da2:	1c0a      	adds	r2, r1, #0
    2da4:	701a      	strb	r2, [r3, #0]
    switch (msg)
    2da6:	230b      	movs	r3, #11
    2da8:	18fb      	adds	r3, r7, r3
    2daa:	781b      	ldrb	r3, [r3, #0]
    2dac:	2b09      	cmp	r3, #9
    2dae:	d002      	beq.n	2db6 <u8x8_d_gp1287ai_256x50+0x2e>
    2db0:	2b0a      	cmp	r3, #10
    2db2:	d007      	beq.n	2dc4 <u8x8_d_gp1287ai_256x50+0x3c>
    2db4:	e011      	b.n	2dda <u8x8_d_gp1287ai_256x50+0x52>
    {
    case U8X8_MSG_DISPLAY_SETUP_MEMORY:
        u8x8_d_helper_display_setup_memory(u8x8, &u8x8_gp1287ai_display_info);
    2db6:	4a12      	ldr	r2, [pc, #72]	; (2e00 <u8x8_d_gp1287ai_256x50+0x78>)
    2db8:	68fb      	ldr	r3, [r7, #12]
    2dba:	0011      	movs	r1, r2
    2dbc:	0018      	movs	r0, r3
    2dbe:	f7ff fce9 	bl	2794 <u8x8_d_helper_display_setup_memory>
        break;
    2dc2:	e017      	b.n	2df4 <u8x8_d_gp1287ai_256x50+0x6c>
    case U8X8_MSG_DISPLAY_INIT:
        u8x8_d_helper_display_init(u8x8);
    2dc4:	68fb      	ldr	r3, [r7, #12]
    2dc6:	0018      	movs	r0, r3
    2dc8:	f7ff fcf6 	bl	27b8 <u8x8_d_helper_display_init>
        u8x8_cad_SendSequence(u8x8, u8x8_d_gp1287ai_init_seq);
    2dcc:	4a0d      	ldr	r2, [pc, #52]	; (2e04 <u8x8_d_gp1287ai_256x50+0x7c>)
    2dce:	68fb      	ldr	r3, [r7, #12]
    2dd0:	0011      	movs	r1, r2
    2dd2:	0018      	movs	r0, r3
    2dd4:	f7ff fc3a 	bl	264c <u8x8_cad_SendSequence>
        break;
    2dd8:	e00c      	b.n	2df4 <u8x8_d_gp1287ai_256x50+0x6c>
    default:
        return u8x8_d_gp1287ai_common(u8x8, msg, arg_int, arg_ptr);
    2dda:	687c      	ldr	r4, [r7, #4]
    2ddc:	230a      	movs	r3, #10
    2dde:	18fb      	adds	r3, r7, r3
    2de0:	781a      	ldrb	r2, [r3, #0]
    2de2:	230b      	movs	r3, #11
    2de4:	18fb      	adds	r3, r7, r3
    2de6:	7819      	ldrb	r1, [r3, #0]
    2de8:	68f8      	ldr	r0, [r7, #12]
    2dea:	0023      	movs	r3, r4
    2dec:	f7ff fda8 	bl	2940 <u8x8_d_gp1287ai_common>
    2df0:	0003      	movs	r3, r0
    2df2:	e000      	b.n	2df6 <u8x8_d_gp1287ai_256x50+0x6e>
    }
    return 1;
    2df4:	2301      	movs	r3, #1
}
    2df6:	0018      	movs	r0, r3
    2df8:	46bd      	mov	sp, r7
    2dfa:	b005      	add	sp, #20
    2dfc:	bd90      	pop	{r4, r7, pc}
    2dfe:	46c0      	nop			; (mov r8, r8)
    2e00:	00007ce0 	.word	0x00007ce0
    2e04:	00007cf8 	.word	0x00007cf8

00002e08 <u8x8_gpio_call>:

#include "u8x8.h"


void u8x8_gpio_call(u8x8_t *u8x8, uint8_t msg, uint8_t arg)
{
    2e08:	b590      	push	{r4, r7, lr}
    2e0a:	b083      	sub	sp, #12
    2e0c:	af00      	add	r7, sp, #0
    2e0e:	6078      	str	r0, [r7, #4]
    2e10:	0008      	movs	r0, r1
    2e12:	0011      	movs	r1, r2
    2e14:	1cfb      	adds	r3, r7, #3
    2e16:	1c02      	adds	r2, r0, #0
    2e18:	701a      	strb	r2, [r3, #0]
    2e1a:	1cbb      	adds	r3, r7, #2
    2e1c:	1c0a      	adds	r2, r1, #0
    2e1e:	701a      	strb	r2, [r3, #0]
  u8x8->gpio_and_delay_cb(u8x8, msg, arg, NULL);
    2e20:	687b      	ldr	r3, [r7, #4]
    2e22:	695c      	ldr	r4, [r3, #20]
    2e24:	1cbb      	adds	r3, r7, #2
    2e26:	781a      	ldrb	r2, [r3, #0]
    2e28:	1cfb      	adds	r3, r7, #3
    2e2a:	7819      	ldrb	r1, [r3, #0]
    2e2c:	6878      	ldr	r0, [r7, #4]
    2e2e:	2300      	movs	r3, #0
    2e30:	47a0      	blx	r4
}
    2e32:	46c0      	nop			; (mov r8, r8)
    2e34:	46bd      	mov	sp, r7
    2e36:	b003      	add	sp, #12
    2e38:	bd90      	pop	{r4, r7, pc}

00002e3a <u8x8_dummy_cb>:

#include "u8x8.h"

/* universal dummy callback, which will be default for all callbacks */
uint8_t u8x8_dummy_cb(U8X8_UNUSED u8x8_t *u8x8, U8X8_UNUSED uint8_t msg, U8X8_UNUSED uint8_t arg_int, U8X8_UNUSED void *arg_ptr)
{
    2e3a:	b580      	push	{r7, lr}
    2e3c:	b084      	sub	sp, #16
    2e3e:	af00      	add	r7, sp, #0
    2e40:	60f8      	str	r0, [r7, #12]
    2e42:	0008      	movs	r0, r1
    2e44:	0011      	movs	r1, r2
    2e46:	607b      	str	r3, [r7, #4]
    2e48:	230b      	movs	r3, #11
    2e4a:	18fb      	adds	r3, r7, r3
    2e4c:	1c02      	adds	r2, r0, #0
    2e4e:	701a      	strb	r2, [r3, #0]
    2e50:	230a      	movs	r3, #10
    2e52:	18fb      	adds	r3, r7, r3
    2e54:	1c0a      	adds	r2, r1, #0
    2e56:	701a      	strb	r2, [r3, #0]
  /* the dummy callback will not handle any message and will fail for all messages */
  return 0;
    2e58:	2300      	movs	r3, #0
}
    2e5a:	0018      	movs	r0, r3
    2e5c:	46bd      	mov	sp, r7
    2e5e:	b004      	add	sp, #16
    2e60:	bd80      	pop	{r7, pc}
	...

00002e64 <u8x8_SetupDefaults>:
    Setup u8x8
  Args:
    u8x8	An empty u8x8 structure
*/
void u8x8_SetupDefaults(u8x8_t *u8x8)
{
    2e64:	b580      	push	{r7, lr}
    2e66:	b082      	sub	sp, #8
    2e68:	af00      	add	r7, sp, #0
    2e6a:	6078      	str	r0, [r7, #4]
    u8x8->display_info = NULL;
    2e6c:	687b      	ldr	r3, [r7, #4]
    2e6e:	2200      	movs	r2, #0
    2e70:	601a      	str	r2, [r3, #0]
    u8x8->display_cb = u8x8_dummy_cb;
    2e72:	687b      	ldr	r3, [r7, #4]
    2e74:	4a10      	ldr	r2, [pc, #64]	; (2eb8 <u8x8_SetupDefaults+0x54>)
    2e76:	609a      	str	r2, [r3, #8]
    u8x8->cad_cb = u8x8_dummy_cb;
    2e78:	687b      	ldr	r3, [r7, #4]
    2e7a:	4a0f      	ldr	r2, [pc, #60]	; (2eb8 <u8x8_SetupDefaults+0x54>)
    2e7c:	60da      	str	r2, [r3, #12]
    u8x8->byte_cb = u8x8_dummy_cb;
    2e7e:	687b      	ldr	r3, [r7, #4]
    2e80:	4a0d      	ldr	r2, [pc, #52]	; (2eb8 <u8x8_SetupDefaults+0x54>)
    2e82:	611a      	str	r2, [r3, #16]
    u8x8->gpio_and_delay_cb = u8x8_dummy_cb;
    2e84:	687b      	ldr	r3, [r7, #4]
    2e86:	4a0c      	ldr	r2, [pc, #48]	; (2eb8 <u8x8_SetupDefaults+0x54>)
    2e88:	615a      	str	r2, [r3, #20]
    u8x8->is_font_inverse_mode = 0;
    2e8a:	687b      	ldr	r3, [r7, #4]
    2e8c:	2223      	movs	r2, #35	; 0x23
    2e8e:	2100      	movs	r1, #0
    2e90:	5499      	strb	r1, [r3, r2]
    //u8x8->device_address = 0;
    u8x8->utf8_state = 0;		/* also reset by u8x8_utf8_init */
    2e92:	687b      	ldr	r3, [r7, #4]
    2e94:	2226      	movs	r2, #38	; 0x26
    2e96:	2100      	movs	r1, #0
    2e98:	5499      	strb	r1, [r3, r2]
    u8x8->bus_clock = 0;		/* issue 769 */
    2e9a:	687b      	ldr	r3, [r7, #4]
    2e9c:	2200      	movs	r2, #0
    2e9e:	619a      	str	r2, [r3, #24]
    u8x8->i2c_address = 255;
    2ea0:	687b      	ldr	r3, [r7, #4]
    2ea2:	2224      	movs	r2, #36	; 0x24
    2ea4:	21ff      	movs	r1, #255	; 0xff
    2ea6:	5499      	strb	r1, [r3, r2]
    u8x8->debounce_default_pin_state = 255;	/* assume all low active buttons */
    2ea8:	687b      	ldr	r3, [r7, #4]
    2eaa:	2228      	movs	r2, #40	; 0x28
    2eac:	21ff      	movs	r1, #255	; 0xff
    2eae:	5499      	strb	r1, [r3, r2]
    uint8_t i;
    for( i = 0; i < U8X8_PIN_CNT; i++ )
      u8x8->pins[i] = U8X8_PIN_NONE;
  }
#endif
}
    2eb0:	46c0      	nop			; (mov r8, r8)
    2eb2:	46bd      	mov	sp, r7
    2eb4:	b002      	add	sp, #8
    2eb6:	bd80      	pop	{r7, pc}
    2eb8:	00002e3b 	.word	0x00002e3b

00002ebc <u8x8_Setup>:
    byte_cb			Display controller/communication specific callback funtion
    gpio_and_delay_cb	Environment specific callback function

*/
void u8x8_Setup(u8x8_t *u8x8, u8x8_msg_cb display_cb, u8x8_msg_cb cad_cb, u8x8_msg_cb byte_cb, u8x8_msg_cb gpio_and_delay_cb)
{
    2ebc:	b580      	push	{r7, lr}
    2ebe:	b084      	sub	sp, #16
    2ec0:	af00      	add	r7, sp, #0
    2ec2:	60f8      	str	r0, [r7, #12]
    2ec4:	60b9      	str	r1, [r7, #8]
    2ec6:	607a      	str	r2, [r7, #4]
    2ec8:	603b      	str	r3, [r7, #0]
  /* setup defaults and reset pins to U8X8_PIN_NONE */
  u8x8_SetupDefaults(u8x8);
    2eca:	68fb      	ldr	r3, [r7, #12]
    2ecc:	0018      	movs	r0, r3
    2ece:	f7ff ffc9 	bl	2e64 <u8x8_SetupDefaults>

  /* setup specific callbacks */
  u8x8->display_cb = display_cb;
    2ed2:	68fb      	ldr	r3, [r7, #12]
    2ed4:	68ba      	ldr	r2, [r7, #8]
    2ed6:	609a      	str	r2, [r3, #8]
  u8x8->cad_cb = cad_cb;
    2ed8:	68fb      	ldr	r3, [r7, #12]
    2eda:	687a      	ldr	r2, [r7, #4]
    2edc:	60da      	str	r2, [r3, #12]
  u8x8->byte_cb = byte_cb;
    2ede:	68fb      	ldr	r3, [r7, #12]
    2ee0:	683a      	ldr	r2, [r7, #0]
    2ee2:	611a      	str	r2, [r3, #16]
  u8x8->gpio_and_delay_cb = gpio_and_delay_cb;
    2ee4:	68fb      	ldr	r3, [r7, #12]
    2ee6:	69ba      	ldr	r2, [r7, #24]
    2ee8:	615a      	str	r2, [r3, #20]

  /* setup display info */
  u8x8_SetupMemory(u8x8);
    2eea:	68fb      	ldr	r3, [r7, #12]
    2eec:	0018      	movs	r0, r3
    2eee:	f7ff fcd3 	bl	2898 <u8x8_SetupMemory>
}
    2ef2:	46c0      	nop			; (mov r8, r8)
    2ef4:	46bd      	mov	sp, r7
    2ef6:	b004      	add	sp, #16
    2ef8:	bd80      	pop	{r7, pc}
	...

00002efc <Reset_Handler>:
/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
{
    2efc:	b580      	push	{r7, lr}
    2efe:	b082      	sub	sp, #8
    2f00:	af00      	add	r7, sp, #0
        uint32_t *pSrc, *pDest;

        /* Initialize the relocate segment */
        pSrc = &_etext;
    2f02:	4b19      	ldr	r3, [pc, #100]	; (2f68 <Reset_Handler+0x6c>)
    2f04:	607b      	str	r3, [r7, #4]
        pDest = &_srelocate;
    2f06:	4b19      	ldr	r3, [pc, #100]	; (2f6c <Reset_Handler+0x70>)
    2f08:	603b      	str	r3, [r7, #0]

        if (pSrc != pDest) {
    2f0a:	687a      	ldr	r2, [r7, #4]
    2f0c:	683b      	ldr	r3, [r7, #0]
    2f0e:	429a      	cmp	r2, r3
    2f10:	d00c      	beq.n	2f2c <Reset_Handler+0x30>
                for (; pDest < &_erelocate;) {
    2f12:	e007      	b.n	2f24 <Reset_Handler+0x28>
                        *pDest++ = *pSrc++;
    2f14:	683b      	ldr	r3, [r7, #0]
    2f16:	1d1a      	adds	r2, r3, #4
    2f18:	603a      	str	r2, [r7, #0]
    2f1a:	687a      	ldr	r2, [r7, #4]
    2f1c:	1d11      	adds	r1, r2, #4
    2f1e:	6079      	str	r1, [r7, #4]
    2f20:	6812      	ldr	r2, [r2, #0]
    2f22:	601a      	str	r2, [r3, #0]
                for (; pDest < &_erelocate;) {
    2f24:	683a      	ldr	r2, [r7, #0]
    2f26:	4b12      	ldr	r3, [pc, #72]	; (2f70 <Reset_Handler+0x74>)
    2f28:	429a      	cmp	r2, r3
    2f2a:	d3f3      	bcc.n	2f14 <Reset_Handler+0x18>
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
    2f2c:	4b11      	ldr	r3, [pc, #68]	; (2f74 <Reset_Handler+0x78>)
    2f2e:	603b      	str	r3, [r7, #0]
    2f30:	e004      	b.n	2f3c <Reset_Handler+0x40>
                *pDest++ = 0;
    2f32:	683b      	ldr	r3, [r7, #0]
    2f34:	1d1a      	adds	r2, r3, #4
    2f36:	603a      	str	r2, [r7, #0]
    2f38:	2200      	movs	r2, #0
    2f3a:	601a      	str	r2, [r3, #0]
        for (pDest = &_szero; pDest < &_ezero;) {
    2f3c:	683a      	ldr	r2, [r7, #0]
    2f3e:	4b0e      	ldr	r3, [pc, #56]	; (2f78 <Reset_Handler+0x7c>)
    2f40:	429a      	cmp	r2, r3
    2f42:	d3f6      	bcc.n	2f32 <Reset_Handler+0x36>
        }

        /* Set the vector table base address */
        pSrc = (uint32_t *) & _sfixed;
    2f44:	4b0d      	ldr	r3, [pc, #52]	; (2f7c <Reset_Handler+0x80>)
    2f46:	607b      	str	r3, [r7, #4]
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
    2f48:	4b0d      	ldr	r3, [pc, #52]	; (2f80 <Reset_Handler+0x84>)
    2f4a:	687a      	ldr	r2, [r7, #4]
    2f4c:	21ff      	movs	r1, #255	; 0xff
    2f4e:	438a      	bics	r2, r1
    2f50:	609a      	str	r2, [r3, #8]

        /* Overwriting the default value of the NVMCTRL.CTRLB.MANW bit (errata reference 13134) */
        NVMCTRL->CTRLB.bit.MANW = 1;
    2f52:	4a0c      	ldr	r2, [pc, #48]	; (2f84 <Reset_Handler+0x88>)
    2f54:	6853      	ldr	r3, [r2, #4]
    2f56:	2180      	movs	r1, #128	; 0x80
    2f58:	430b      	orrs	r3, r1
    2f5a:	6053      	str	r3, [r2, #4]

        /* Initialize the C library */
        __libc_init_array();
    2f5c:	f004 f818 	bl	6f90 <__libc_init_array>

        /* Branch to main function */
        main();
    2f60:	f003 fdf8 	bl	6b54 <main>

        /* Infinite loop */
        while (1);
    2f64:	e7fe      	b.n	2f64 <Reset_Handler+0x68>
    2f66:	46c0      	nop			; (mov r8, r8)
    2f68:	00008044 	.word	0x00008044
    2f6c:	20000000 	.word	0x20000000
    2f70:	20000078 	.word	0x20000078
    2f74:	20000078 	.word	0x20000078
    2f78:	200008fc 	.word	0x200008fc
    2f7c:	00000000 	.word	0x00000000
    2f80:	e000ed00 	.word	0xe000ed00
    2f84:	41004000 	.word	0x41004000

00002f88 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
    2f88:	b580      	push	{r7, lr}
    2f8a:	af00      	add	r7, sp, #0
        while (1) {
    2f8c:	e7fe      	b.n	2f8c <Dummy_Handler+0x4>

00002f8e <hri_gclk_write_CLKCTRL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_gclk_write_CLKCTRL_reg(const void *const hw, hri_gclk_clkctrl_reg_t data)
{
    2f8e:	b580      	push	{r7, lr}
    2f90:	b082      	sub	sp, #8
    2f92:	af00      	add	r7, sp, #0
    2f94:	6078      	str	r0, [r7, #4]
    2f96:	000a      	movs	r2, r1
    2f98:	1cbb      	adds	r3, r7, #2
    2f9a:	801a      	strh	r2, [r3, #0]
	GCLK_CRITICAL_SECTION_ENTER();
	((Gclk *)hw)->CLKCTRL.reg = data;
    2f9c:	687b      	ldr	r3, [r7, #4]
    2f9e:	1cba      	adds	r2, r7, #2
    2fa0:	8812      	ldrh	r2, [r2, #0]
    2fa2:	805a      	strh	r2, [r3, #2]
	GCLK_CRITICAL_SECTION_LEAVE();
}
    2fa4:	46c0      	nop			; (mov r8, r8)
    2fa6:	46bd      	mov	sp, r7
    2fa8:	b002      	add	sp, #8
    2faa:	bd80      	pop	{r7, pc}

00002fac <hri_port_set_DIR_reg>:
{
	((Port *)hw)->Group[submodule_index].DIRTGL.reg = PORT_DIR_DIR(mask);
}

static inline void hri_port_set_DIR_reg(const void *const hw, uint8_t submodule_index, hri_port_dir_reg_t mask)
{
    2fac:	b580      	push	{r7, lr}
    2fae:	b084      	sub	sp, #16
    2fb0:	af00      	add	r7, sp, #0
    2fb2:	60f8      	str	r0, [r7, #12]
    2fb4:	607a      	str	r2, [r7, #4]
    2fb6:	230b      	movs	r3, #11
    2fb8:	18fb      	adds	r3, r7, r3
    2fba:	1c0a      	adds	r2, r1, #0
    2fbc:	701a      	strb	r2, [r3, #0]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    2fbe:	230b      	movs	r3, #11
    2fc0:	18fb      	adds	r3, r7, r3
    2fc2:	781b      	ldrb	r3, [r3, #0]
    2fc4:	68fa      	ldr	r2, [r7, #12]
    2fc6:	01db      	lsls	r3, r3, #7
    2fc8:	18d3      	adds	r3, r2, r3
    2fca:	3308      	adds	r3, #8
    2fcc:	687a      	ldr	r2, [r7, #4]
    2fce:	601a      	str	r2, [r3, #0]
}
    2fd0:	46c0      	nop			; (mov r8, r8)
    2fd2:	46bd      	mov	sp, r7
    2fd4:	b004      	add	sp, #16
    2fd6:	bd80      	pop	{r7, pc}

00002fd8 <hri_port_clear_DIR_reg>:
	((Port *)hw)->Group[submodule_index].DIRSET.reg = data;
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = ~data;
}

static inline void hri_port_clear_DIR_reg(const void *const hw, uint8_t submodule_index, hri_port_dir_reg_t mask)
{
    2fd8:	b580      	push	{r7, lr}
    2fda:	b084      	sub	sp, #16
    2fdc:	af00      	add	r7, sp, #0
    2fde:	60f8      	str	r0, [r7, #12]
    2fe0:	607a      	str	r2, [r7, #4]
    2fe2:	230b      	movs	r3, #11
    2fe4:	18fb      	adds	r3, r7, r3
    2fe6:	1c0a      	adds	r2, r1, #0
    2fe8:	701a      	strb	r2, [r3, #0]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    2fea:	230b      	movs	r3, #11
    2fec:	18fb      	adds	r3, r7, r3
    2fee:	781b      	ldrb	r3, [r3, #0]
    2ff0:	68fa      	ldr	r2, [r7, #12]
    2ff2:	01db      	lsls	r3, r3, #7
    2ff4:	18d3      	adds	r3, r2, r3
    2ff6:	3304      	adds	r3, #4
    2ff8:	687a      	ldr	r2, [r7, #4]
    2ffa:	601a      	str	r2, [r3, #0]
}
    2ffc:	46c0      	nop			; (mov r8, r8)
    2ffe:	46bd      	mov	sp, r7
    3000:	b004      	add	sp, #16
    3002:	bd80      	pop	{r7, pc}

00003004 <hri_port_set_OUT_reg>:
{
	((Port *)hw)->Group[submodule_index].OUTTGL.reg = PORT_OUT_OUT(mask);
}

static inline void hri_port_set_OUT_reg(const void *const hw, uint8_t submodule_index, hri_port_out_reg_t mask)
{
    3004:	b580      	push	{r7, lr}
    3006:	b084      	sub	sp, #16
    3008:	af00      	add	r7, sp, #0
    300a:	60f8      	str	r0, [r7, #12]
    300c:	607a      	str	r2, [r7, #4]
    300e:	230b      	movs	r3, #11
    3010:	18fb      	adds	r3, r7, r3
    3012:	1c0a      	adds	r2, r1, #0
    3014:	701a      	strb	r2, [r3, #0]
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    3016:	230b      	movs	r3, #11
    3018:	18fb      	adds	r3, r7, r3
    301a:	781b      	ldrb	r3, [r3, #0]
    301c:	68fa      	ldr	r2, [r7, #12]
    301e:	01db      	lsls	r3, r3, #7
    3020:	18d3      	adds	r3, r2, r3
    3022:	3318      	adds	r3, #24
    3024:	687a      	ldr	r2, [r7, #4]
    3026:	601a      	str	r2, [r3, #0]
}
    3028:	46c0      	nop			; (mov r8, r8)
    302a:	46bd      	mov	sp, r7
    302c:	b004      	add	sp, #16
    302e:	bd80      	pop	{r7, pc}

00003030 <hri_port_clear_OUT_reg>:
	((Port *)hw)->Group[submodule_index].OUTSET.reg = data;
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = ~data;
}

static inline void hri_port_clear_OUT_reg(const void *const hw, uint8_t submodule_index, hri_port_out_reg_t mask)
{
    3030:	b580      	push	{r7, lr}
    3032:	b084      	sub	sp, #16
    3034:	af00      	add	r7, sp, #0
    3036:	60f8      	str	r0, [r7, #12]
    3038:	607a      	str	r2, [r7, #4]
    303a:	230b      	movs	r3, #11
    303c:	18fb      	adds	r3, r7, r3
    303e:	1c0a      	adds	r2, r1, #0
    3040:	701a      	strb	r2, [r3, #0]
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    3042:	230b      	movs	r3, #11
    3044:	18fb      	adds	r3, r7, r3
    3046:	781b      	ldrb	r3, [r3, #0]
    3048:	68fa      	ldr	r2, [r7, #12]
    304a:	01db      	lsls	r3, r3, #7
    304c:	18d3      	adds	r3, r2, r3
    304e:	3314      	adds	r3, #20
    3050:	687a      	ldr	r2, [r7, #4]
    3052:	601a      	str	r2, [r3, #0]
}
    3054:	46c0      	nop			; (mov r8, r8)
    3056:	46bd      	mov	sp, r7
    3058:	b004      	add	sp, #16
    305a:	bd80      	pop	{r7, pc}

0000305c <hri_port_write_PMUX_PMUXE_bf>:
	return tmp;
}

static inline void hri_port_write_PMUX_PMUXE_bf(const void *const hw, uint8_t submodule_index, uint8_t index,
                                                hri_port_pmux_reg_t data)
{
    305c:	b590      	push	{r4, r7, lr}
    305e:	b085      	sub	sp, #20
    3060:	af00      	add	r7, sp, #0
    3062:	6078      	str	r0, [r7, #4]
    3064:	000c      	movs	r4, r1
    3066:	0010      	movs	r0, r2
    3068:	0019      	movs	r1, r3
    306a:	1cfb      	adds	r3, r7, #3
    306c:	1c22      	adds	r2, r4, #0
    306e:	701a      	strb	r2, [r3, #0]
    3070:	1cbb      	adds	r3, r7, #2
    3072:	1c02      	adds	r2, r0, #0
    3074:	701a      	strb	r2, [r3, #0]
    3076:	1c7b      	adds	r3, r7, #1
    3078:	1c0a      	adds	r2, r1, #0
    307a:	701a      	strb	r2, [r3, #0]
	uint8_t tmp;
	PORT_CRITICAL_SECTION_ENTER();
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
    307c:	1cfb      	adds	r3, r7, #3
    307e:	7819      	ldrb	r1, [r3, #0]
    3080:	1cbb      	adds	r3, r7, #2
    3082:	781a      	ldrb	r2, [r3, #0]
    3084:	230f      	movs	r3, #15
    3086:	18fb      	adds	r3, r7, r3
    3088:	6878      	ldr	r0, [r7, #4]
    308a:	2430      	movs	r4, #48	; 0x30
    308c:	01c9      	lsls	r1, r1, #7
    308e:	1841      	adds	r1, r0, r1
    3090:	188a      	adds	r2, r1, r2
    3092:	1912      	adds	r2, r2, r4
    3094:	7812      	ldrb	r2, [r2, #0]
    3096:	701a      	strb	r2, [r3, #0]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
    3098:	230f      	movs	r3, #15
    309a:	18fb      	adds	r3, r7, r3
    309c:	220f      	movs	r2, #15
    309e:	18ba      	adds	r2, r7, r2
    30a0:	7812      	ldrb	r2, [r2, #0]
    30a2:	210f      	movs	r1, #15
    30a4:	438a      	bics	r2, r1
    30a6:	701a      	strb	r2, [r3, #0]
	tmp |= PORT_PMUX_PMUXE(data);
    30a8:	1c7b      	adds	r3, r7, #1
    30aa:	781b      	ldrb	r3, [r3, #0]
    30ac:	220f      	movs	r2, #15
    30ae:	4013      	ands	r3, r2
    30b0:	b2d9      	uxtb	r1, r3
    30b2:	230f      	movs	r3, #15
    30b4:	18fb      	adds	r3, r7, r3
    30b6:	220f      	movs	r2, #15
    30b8:	18ba      	adds	r2, r7, r2
    30ba:	7812      	ldrb	r2, [r2, #0]
    30bc:	430a      	orrs	r2, r1
    30be:	701a      	strb	r2, [r3, #0]
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
    30c0:	1cfb      	adds	r3, r7, #3
    30c2:	781a      	ldrb	r2, [r3, #0]
    30c4:	1cbb      	adds	r3, r7, #2
    30c6:	781b      	ldrb	r3, [r3, #0]
    30c8:	6879      	ldr	r1, [r7, #4]
    30ca:	2030      	movs	r0, #48	; 0x30
    30cc:	01d2      	lsls	r2, r2, #7
    30ce:	188a      	adds	r2, r1, r2
    30d0:	18d3      	adds	r3, r2, r3
    30d2:	181b      	adds	r3, r3, r0
    30d4:	220f      	movs	r2, #15
    30d6:	18ba      	adds	r2, r7, r2
    30d8:	7812      	ldrb	r2, [r2, #0]
    30da:	701a      	strb	r2, [r3, #0]
	PORT_CRITICAL_SECTION_LEAVE();
}
    30dc:	46c0      	nop			; (mov r8, r8)
    30de:	46bd      	mov	sp, r7
    30e0:	b005      	add	sp, #20
    30e2:	bd90      	pop	{r4, r7, pc}

000030e4 <hri_port_write_PMUX_PMUXO_bf>:
	return tmp;
}

static inline void hri_port_write_PMUX_PMUXO_bf(const void *const hw, uint8_t submodule_index, uint8_t index,
                                                hri_port_pmux_reg_t data)
{
    30e4:	b590      	push	{r4, r7, lr}
    30e6:	b085      	sub	sp, #20
    30e8:	af00      	add	r7, sp, #0
    30ea:	6078      	str	r0, [r7, #4]
    30ec:	000c      	movs	r4, r1
    30ee:	0010      	movs	r0, r2
    30f0:	0019      	movs	r1, r3
    30f2:	1cfb      	adds	r3, r7, #3
    30f4:	1c22      	adds	r2, r4, #0
    30f6:	701a      	strb	r2, [r3, #0]
    30f8:	1cbb      	adds	r3, r7, #2
    30fa:	1c02      	adds	r2, r0, #0
    30fc:	701a      	strb	r2, [r3, #0]
    30fe:	1c7b      	adds	r3, r7, #1
    3100:	1c0a      	adds	r2, r1, #0
    3102:	701a      	strb	r2, [r3, #0]
	uint8_t tmp;
	PORT_CRITICAL_SECTION_ENTER();
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
    3104:	1cfb      	adds	r3, r7, #3
    3106:	7819      	ldrb	r1, [r3, #0]
    3108:	1cbb      	adds	r3, r7, #2
    310a:	781a      	ldrb	r2, [r3, #0]
    310c:	230f      	movs	r3, #15
    310e:	18fb      	adds	r3, r7, r3
    3110:	6878      	ldr	r0, [r7, #4]
    3112:	2430      	movs	r4, #48	; 0x30
    3114:	01c9      	lsls	r1, r1, #7
    3116:	1841      	adds	r1, r0, r1
    3118:	188a      	adds	r2, r1, r2
    311a:	1912      	adds	r2, r2, r4
    311c:	7812      	ldrb	r2, [r2, #0]
    311e:	701a      	strb	r2, [r3, #0]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
    3120:	230f      	movs	r3, #15
    3122:	18fb      	adds	r3, r7, r3
    3124:	220f      	movs	r2, #15
    3126:	18ba      	adds	r2, r7, r2
    3128:	7812      	ldrb	r2, [r2, #0]
    312a:	210f      	movs	r1, #15
    312c:	400a      	ands	r2, r1
    312e:	701a      	strb	r2, [r3, #0]
	tmp |= PORT_PMUX_PMUXO(data);
    3130:	1c7b      	adds	r3, r7, #1
    3132:	781b      	ldrb	r3, [r3, #0]
    3134:	011b      	lsls	r3, r3, #4
    3136:	b2d9      	uxtb	r1, r3
    3138:	230f      	movs	r3, #15
    313a:	18fb      	adds	r3, r7, r3
    313c:	220f      	movs	r2, #15
    313e:	18ba      	adds	r2, r7, r2
    3140:	7812      	ldrb	r2, [r2, #0]
    3142:	430a      	orrs	r2, r1
    3144:	701a      	strb	r2, [r3, #0]
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
    3146:	1cfb      	adds	r3, r7, #3
    3148:	781a      	ldrb	r2, [r3, #0]
    314a:	1cbb      	adds	r3, r7, #2
    314c:	781b      	ldrb	r3, [r3, #0]
    314e:	6879      	ldr	r1, [r7, #4]
    3150:	2030      	movs	r0, #48	; 0x30
    3152:	01d2      	lsls	r2, r2, #7
    3154:	188a      	adds	r2, r1, r2
    3156:	18d3      	adds	r3, r2, r3
    3158:	181b      	adds	r3, r3, r0
    315a:	220f      	movs	r2, #15
    315c:	18ba      	adds	r2, r7, r2
    315e:	7812      	ldrb	r2, [r2, #0]
    3160:	701a      	strb	r2, [r3, #0]
	PORT_CRITICAL_SECTION_LEAVE();
}
    3162:	46c0      	nop			; (mov r8, r8)
    3164:	46bd      	mov	sp, r7
    3166:	b005      	add	sp, #20
    3168:	bd90      	pop	{r4, r7, pc}

0000316a <hri_port_write_PINCFG_PMUXEN_bit>:
	return (bool)tmp;
}

static inline void hri_port_write_PINCFG_PMUXEN_bit(const void *const hw, uint8_t submodule_index, uint8_t index,
                                                    bool value)
{
    316a:	b590      	push	{r4, r7, lr}
    316c:	b085      	sub	sp, #20
    316e:	af00      	add	r7, sp, #0
    3170:	6078      	str	r0, [r7, #4]
    3172:	000c      	movs	r4, r1
    3174:	0010      	movs	r0, r2
    3176:	0019      	movs	r1, r3
    3178:	1cfb      	adds	r3, r7, #3
    317a:	1c22      	adds	r2, r4, #0
    317c:	701a      	strb	r2, [r3, #0]
    317e:	1cbb      	adds	r3, r7, #2
    3180:	1c02      	adds	r2, r0, #0
    3182:	701a      	strb	r2, [r3, #0]
    3184:	1c7b      	adds	r3, r7, #1
    3186:	1c0a      	adds	r2, r1, #0
    3188:	701a      	strb	r2, [r3, #0]
	uint8_t tmp;
	PORT_CRITICAL_SECTION_ENTER();
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    318a:	1cfb      	adds	r3, r7, #3
    318c:	7819      	ldrb	r1, [r3, #0]
    318e:	1cbb      	adds	r3, r7, #2
    3190:	781a      	ldrb	r2, [r3, #0]
    3192:	230f      	movs	r3, #15
    3194:	18fb      	adds	r3, r7, r3
    3196:	6878      	ldr	r0, [r7, #4]
    3198:	2440      	movs	r4, #64	; 0x40
    319a:	01c9      	lsls	r1, r1, #7
    319c:	1841      	adds	r1, r0, r1
    319e:	188a      	adds	r2, r1, r2
    31a0:	1912      	adds	r2, r2, r4
    31a2:	7812      	ldrb	r2, [r2, #0]
    31a4:	701a      	strb	r2, [r3, #0]
	tmp &= ~PORT_PINCFG_PMUXEN;
    31a6:	230f      	movs	r3, #15
    31a8:	18fb      	adds	r3, r7, r3
    31aa:	220f      	movs	r2, #15
    31ac:	18ba      	adds	r2, r7, r2
    31ae:	7812      	ldrb	r2, [r2, #0]
    31b0:	2101      	movs	r1, #1
    31b2:	438a      	bics	r2, r1
    31b4:	701a      	strb	r2, [r3, #0]
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
    31b6:	1c7b      	adds	r3, r7, #1
    31b8:	7819      	ldrb	r1, [r3, #0]
    31ba:	230f      	movs	r3, #15
    31bc:	18fb      	adds	r3, r7, r3
    31be:	220f      	movs	r2, #15
    31c0:	18ba      	adds	r2, r7, r2
    31c2:	7812      	ldrb	r2, [r2, #0]
    31c4:	430a      	orrs	r2, r1
    31c6:	701a      	strb	r2, [r3, #0]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    31c8:	1cfb      	adds	r3, r7, #3
    31ca:	781a      	ldrb	r2, [r3, #0]
    31cc:	1cbb      	adds	r3, r7, #2
    31ce:	781b      	ldrb	r3, [r3, #0]
    31d0:	6879      	ldr	r1, [r7, #4]
    31d2:	2040      	movs	r0, #64	; 0x40
    31d4:	01d2      	lsls	r2, r2, #7
    31d6:	188a      	adds	r2, r1, r2
    31d8:	18d3      	adds	r3, r2, r3
    31da:	181b      	adds	r3, r3, r0
    31dc:	220f      	movs	r2, #15
    31de:	18ba      	adds	r2, r7, r2
    31e0:	7812      	ldrb	r2, [r2, #0]
    31e2:	701a      	strb	r2, [r3, #0]
	PORT_CRITICAL_SECTION_LEAVE();
}
    31e4:	46c0      	nop			; (mov r8, r8)
    31e6:	46bd      	mov	sp, r7
    31e8:	b005      	add	sp, #20
    31ea:	bd90      	pop	{r4, r7, pc}

000031ec <hri_port_set_PINCFG_PULLEN_bit>:
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg ^= PORT_PINCFG_INEN;
	PORT_CRITICAL_SECTION_LEAVE();
}

static inline void hri_port_set_PINCFG_PULLEN_bit(const void *const hw, uint8_t submodule_index, uint8_t index)
{
    31ec:	b5b0      	push	{r4, r5, r7, lr}
    31ee:	b082      	sub	sp, #8
    31f0:	af00      	add	r7, sp, #0
    31f2:	6078      	str	r0, [r7, #4]
    31f4:	0008      	movs	r0, r1
    31f6:	0011      	movs	r1, r2
    31f8:	1cfb      	adds	r3, r7, #3
    31fa:	1c02      	adds	r2, r0, #0
    31fc:	701a      	strb	r2, [r3, #0]
    31fe:	1cbb      	adds	r3, r7, #2
    3200:	1c0a      	adds	r2, r1, #0
    3202:	701a      	strb	r2, [r3, #0]
	PORT_CRITICAL_SECTION_ENTER();
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg |= PORT_PINCFG_PULLEN;
    3204:	1cfb      	adds	r3, r7, #3
    3206:	781a      	ldrb	r2, [r3, #0]
    3208:	1cbb      	adds	r3, r7, #2
    320a:	781b      	ldrb	r3, [r3, #0]
    320c:	1cf9      	adds	r1, r7, #3
    320e:	7808      	ldrb	r0, [r1, #0]
    3210:	1cb9      	adds	r1, r7, #2
    3212:	7809      	ldrb	r1, [r1, #0]
    3214:	687c      	ldr	r4, [r7, #4]
    3216:	2540      	movs	r5, #64	; 0x40
    3218:	01c0      	lsls	r0, r0, #7
    321a:	1820      	adds	r0, r4, r0
    321c:	1841      	adds	r1, r0, r1
    321e:	1949      	adds	r1, r1, r5
    3220:	7809      	ldrb	r1, [r1, #0]
    3222:	b2c9      	uxtb	r1, r1
    3224:	2004      	movs	r0, #4
    3226:	4301      	orrs	r1, r0
    3228:	b2cc      	uxtb	r4, r1
    322a:	6879      	ldr	r1, [r7, #4]
    322c:	2040      	movs	r0, #64	; 0x40
    322e:	01d2      	lsls	r2, r2, #7
    3230:	188a      	adds	r2, r1, r2
    3232:	18d3      	adds	r3, r2, r3
    3234:	181b      	adds	r3, r3, r0
    3236:	1c22      	adds	r2, r4, #0
    3238:	701a      	strb	r2, [r3, #0]
	PORT_CRITICAL_SECTION_LEAVE();
}
    323a:	46c0      	nop			; (mov r8, r8)
    323c:	46bd      	mov	sp, r7
    323e:	b002      	add	sp, #8
    3240:	bdb0      	pop	{r4, r5, r7, pc}

00003242 <hri_port_clear_PINCFG_PULLEN_bit>:
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
	PORT_CRITICAL_SECTION_LEAVE();
}

static inline void hri_port_clear_PINCFG_PULLEN_bit(const void *const hw, uint8_t submodule_index, uint8_t index)
{
    3242:	b5b0      	push	{r4, r5, r7, lr}
    3244:	b082      	sub	sp, #8
    3246:	af00      	add	r7, sp, #0
    3248:	6078      	str	r0, [r7, #4]
    324a:	0008      	movs	r0, r1
    324c:	0011      	movs	r1, r2
    324e:	1cfb      	adds	r3, r7, #3
    3250:	1c02      	adds	r2, r0, #0
    3252:	701a      	strb	r2, [r3, #0]
    3254:	1cbb      	adds	r3, r7, #2
    3256:	1c0a      	adds	r2, r1, #0
    3258:	701a      	strb	r2, [r3, #0]
	PORT_CRITICAL_SECTION_ENTER();
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
    325a:	1cfb      	adds	r3, r7, #3
    325c:	781a      	ldrb	r2, [r3, #0]
    325e:	1cbb      	adds	r3, r7, #2
    3260:	781b      	ldrb	r3, [r3, #0]
    3262:	1cf9      	adds	r1, r7, #3
    3264:	7808      	ldrb	r0, [r1, #0]
    3266:	1cb9      	adds	r1, r7, #2
    3268:	7809      	ldrb	r1, [r1, #0]
    326a:	687c      	ldr	r4, [r7, #4]
    326c:	2540      	movs	r5, #64	; 0x40
    326e:	01c0      	lsls	r0, r0, #7
    3270:	1820      	adds	r0, r4, r0
    3272:	1841      	adds	r1, r0, r1
    3274:	1949      	adds	r1, r1, r5
    3276:	7809      	ldrb	r1, [r1, #0]
    3278:	b2c9      	uxtb	r1, r1
    327a:	2004      	movs	r0, #4
    327c:	4381      	bics	r1, r0
    327e:	b2cc      	uxtb	r4, r1
    3280:	6879      	ldr	r1, [r7, #4]
    3282:	2040      	movs	r0, #64	; 0x40
    3284:	01d2      	lsls	r2, r2, #7
    3286:	188a      	adds	r2, r1, r2
    3288:	18d3      	adds	r3, r2, r3
    328a:	181b      	adds	r3, r3, r0
    328c:	1c22      	adds	r2, r4, #0
    328e:	701a      	strb	r2, [r3, #0]
	PORT_CRITICAL_SECTION_LEAVE();
}
    3290:	46c0      	nop			; (mov r8, r8)
    3292:	46bd      	mov	sp, r7
    3294:	b002      	add	sp, #8
    3296:	bdb0      	pop	{r4, r5, r7, pc}

00003298 <hri_port_write_WRCONFIG_reg>:
	return ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
}

static inline void hri_port_write_WRCONFIG_reg(const void *const hw, uint8_t submodule_index,
                                               hri_port_wrconfig_reg_t data)
{
    3298:	b580      	push	{r7, lr}
    329a:	b084      	sub	sp, #16
    329c:	af00      	add	r7, sp, #0
    329e:	60f8      	str	r0, [r7, #12]
    32a0:	607a      	str	r2, [r7, #4]
    32a2:	230b      	movs	r3, #11
    32a4:	18fb      	adds	r3, r7, r3
    32a6:	1c0a      	adds	r2, r1, #0
    32a8:	701a      	strb	r2, [r3, #0]
	PORT_CRITICAL_SECTION_ENTER();
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    32aa:	230b      	movs	r3, #11
    32ac:	18fb      	adds	r3, r7, r3
    32ae:	781b      	ldrb	r3, [r3, #0]
    32b0:	68fa      	ldr	r2, [r7, #12]
    32b2:	01db      	lsls	r3, r3, #7
    32b4:	18d3      	adds	r3, r2, r3
    32b6:	3328      	adds	r3, #40	; 0x28
    32b8:	687a      	ldr	r2, [r7, #4]
    32ba:	601a      	str	r2, [r3, #0]
	PORT_CRITICAL_SECTION_LEAVE();
}
    32bc:	46c0      	nop			; (mov r8, r8)
    32be:	46bd      	mov	sp, r7
    32c0:	b004      	add	sp, #16
    32c2:	bd80      	pop	{r7, pc}

000032c4 <_gpio_set_direction>:
/**
 * \brief Set direction on port with mask
 */
static inline void _gpio_set_direction(const enum gpio_port port, const uint32_t mask,
                                       const enum gpio_direction direction)
{
    32c4:	b580      	push	{r7, lr}
    32c6:	b082      	sub	sp, #8
    32c8:	af00      	add	r7, sp, #0
    32ca:	6039      	str	r1, [r7, #0]
    32cc:	0011      	movs	r1, r2
    32ce:	1dfb      	adds	r3, r7, #7
    32d0:	1c02      	adds	r2, r0, #0
    32d2:	701a      	strb	r2, [r3, #0]
    32d4:	1dbb      	adds	r3, r7, #6
    32d6:	1c0a      	adds	r2, r1, #0
    32d8:	701a      	strb	r2, [r3, #0]
	switch (direction) {
    32da:	1dbb      	adds	r3, r7, #6
    32dc:	781b      	ldrb	r3, [r3, #0]
    32de:	2b01      	cmp	r3, #1
    32e0:	d023      	beq.n	332a <_gpio_set_direction+0x66>
    32e2:	2b02      	cmp	r3, #2
    32e4:	d03f      	beq.n	3366 <_gpio_set_direction+0xa2>
    32e6:	2b00      	cmp	r3, #0
    32e8:	d15d      	bne.n	33a6 <_gpio_set_direction+0xe2>
	case GPIO_DIRECTION_OFF:
		hri_port_clear_DIR_reg(PORT_IOBUS, port, mask);
    32ea:	683a      	ldr	r2, [r7, #0]
    32ec:	1dfb      	adds	r3, r7, #7
    32ee:	7819      	ldrb	r1, [r3, #0]
    32f0:	23c0      	movs	r3, #192	; 0xc0
    32f2:	05db      	lsls	r3, r3, #23
    32f4:	0018      	movs	r0, r3
    32f6:	f7ff fe6f 	bl	2fd8 <hri_port_clear_DIR_reg>
		hri_port_write_WRCONFIG_reg(PORT, port, PORT_WRCONFIG_WRPINCFG | (mask & 0xffff));
    32fa:	683b      	ldr	r3, [r7, #0]
    32fc:	041b      	lsls	r3, r3, #16
    32fe:	0c1b      	lsrs	r3, r3, #16
    3300:	2280      	movs	r2, #128	; 0x80
    3302:	05d2      	lsls	r2, r2, #23
    3304:	431a      	orrs	r2, r3
    3306:	1dfb      	adds	r3, r7, #7
    3308:	781b      	ldrb	r3, [r3, #0]
    330a:	482c      	ldr	r0, [pc, #176]	; (33bc <_gpio_set_direction+0xf8>)
    330c:	0019      	movs	r1, r3
    330e:	f7ff ffc3 	bl	3298 <hri_port_write_WRCONFIG_reg>
		hri_port_write_WRCONFIG_reg(
		    PORT, port, PORT_WRCONFIG_HWSEL | PORT_WRCONFIG_WRPINCFG | ((mask & 0xffff0000) >> 16));
    3312:	683b      	ldr	r3, [r7, #0]
    3314:	0c1b      	lsrs	r3, r3, #16
		hri_port_write_WRCONFIG_reg(
    3316:	22c0      	movs	r2, #192	; 0xc0
    3318:	0612      	lsls	r2, r2, #24
    331a:	431a      	orrs	r2, r3
    331c:	1dfb      	adds	r3, r7, #7
    331e:	781b      	ldrb	r3, [r3, #0]
    3320:	4826      	ldr	r0, [pc, #152]	; (33bc <_gpio_set_direction+0xf8>)
    3322:	0019      	movs	r1, r3
    3324:	f7ff ffb8 	bl	3298 <hri_port_write_WRCONFIG_reg>
		break;
    3328:	e043      	b.n	33b2 <_gpio_set_direction+0xee>

	case GPIO_DIRECTION_IN:
		hri_port_clear_DIR_reg(PORT_IOBUS, port, mask);
    332a:	683a      	ldr	r2, [r7, #0]
    332c:	1dfb      	adds	r3, r7, #7
    332e:	7819      	ldrb	r1, [r3, #0]
    3330:	23c0      	movs	r3, #192	; 0xc0
    3332:	05db      	lsls	r3, r3, #23
    3334:	0018      	movs	r0, r3
    3336:	f7ff fe4f 	bl	2fd8 <hri_port_clear_DIR_reg>
		hri_port_write_WRCONFIG_reg(PORT, port, PORT_WRCONFIG_WRPINCFG | PORT_WRCONFIG_INEN | (mask & 0xffff));
    333a:	683b      	ldr	r3, [r7, #0]
    333c:	041b      	lsls	r3, r3, #16
    333e:	0c1b      	lsrs	r3, r3, #16
    3340:	4a1f      	ldr	r2, [pc, #124]	; (33c0 <_gpio_set_direction+0xfc>)
    3342:	431a      	orrs	r2, r3
    3344:	1dfb      	adds	r3, r7, #7
    3346:	781b      	ldrb	r3, [r3, #0]
    3348:	481c      	ldr	r0, [pc, #112]	; (33bc <_gpio_set_direction+0xf8>)
    334a:	0019      	movs	r1, r3
    334c:	f7ff ffa4 	bl	3298 <hri_port_write_WRCONFIG_reg>
		hri_port_write_WRCONFIG_reg(PORT,
		                            port,
		                            PORT_WRCONFIG_HWSEL | PORT_WRCONFIG_WRPINCFG | PORT_WRCONFIG_INEN
		                                | ((mask & 0xffff0000) >> 16));
    3350:	683b      	ldr	r3, [r7, #0]
    3352:	0c1b      	lsrs	r3, r3, #16
		hri_port_write_WRCONFIG_reg(PORT,
    3354:	4a1b      	ldr	r2, [pc, #108]	; (33c4 <_gpio_set_direction+0x100>)
    3356:	431a      	orrs	r2, r3
    3358:	1dfb      	adds	r3, r7, #7
    335a:	781b      	ldrb	r3, [r3, #0]
    335c:	4817      	ldr	r0, [pc, #92]	; (33bc <_gpio_set_direction+0xf8>)
    335e:	0019      	movs	r1, r3
    3360:	f7ff ff9a 	bl	3298 <hri_port_write_WRCONFIG_reg>
		break;
    3364:	e025      	b.n	33b2 <_gpio_set_direction+0xee>

	case GPIO_DIRECTION_OUT:
		hri_port_set_DIR_reg(PORT_IOBUS, port, mask);
    3366:	683a      	ldr	r2, [r7, #0]
    3368:	1dfb      	adds	r3, r7, #7
    336a:	7819      	ldrb	r1, [r3, #0]
    336c:	23c0      	movs	r3, #192	; 0xc0
    336e:	05db      	lsls	r3, r3, #23
    3370:	0018      	movs	r0, r3
    3372:	f7ff fe1b 	bl	2fac <hri_port_set_DIR_reg>
		hri_port_write_WRCONFIG_reg(PORT, port, PORT_WRCONFIG_WRPINCFG | (mask & 0xffff));
    3376:	683b      	ldr	r3, [r7, #0]
    3378:	041b      	lsls	r3, r3, #16
    337a:	0c1b      	lsrs	r3, r3, #16
    337c:	2280      	movs	r2, #128	; 0x80
    337e:	05d2      	lsls	r2, r2, #23
    3380:	431a      	orrs	r2, r3
    3382:	1dfb      	adds	r3, r7, #7
    3384:	781b      	ldrb	r3, [r3, #0]
    3386:	480d      	ldr	r0, [pc, #52]	; (33bc <_gpio_set_direction+0xf8>)
    3388:	0019      	movs	r1, r3
    338a:	f7ff ff85 	bl	3298 <hri_port_write_WRCONFIG_reg>
		hri_port_write_WRCONFIG_reg(
		    PORT, port, PORT_WRCONFIG_HWSEL | PORT_WRCONFIG_WRPINCFG | ((mask & 0xffff0000) >> 16));
    338e:	683b      	ldr	r3, [r7, #0]
    3390:	0c1b      	lsrs	r3, r3, #16
		hri_port_write_WRCONFIG_reg(
    3392:	22c0      	movs	r2, #192	; 0xc0
    3394:	0612      	lsls	r2, r2, #24
    3396:	431a      	orrs	r2, r3
    3398:	1dfb      	adds	r3, r7, #7
    339a:	781b      	ldrb	r3, [r3, #0]
    339c:	4807      	ldr	r0, [pc, #28]	; (33bc <_gpio_set_direction+0xf8>)
    339e:	0019      	movs	r1, r3
    33a0:	f7ff ff7a 	bl	3298 <hri_port_write_WRCONFIG_reg>
		break;
    33a4:	e005      	b.n	33b2 <_gpio_set_direction+0xee>

	default:
		ASSERT(false);
    33a6:	4b08      	ldr	r3, [pc, #32]	; (33c8 <_gpio_set_direction+0x104>)
    33a8:	2245      	movs	r2, #69	; 0x45
    33aa:	0019      	movs	r1, r3
    33ac:	2000      	movs	r0, #0
    33ae:	f000 feeb 	bl	4188 <assert>
	}
}
    33b2:	46c0      	nop			; (mov r8, r8)
    33b4:	46bd      	mov	sp, r7
    33b6:	b002      	add	sp, #8
    33b8:	bd80      	pop	{r7, pc}
    33ba:	46c0      	nop			; (mov r8, r8)
    33bc:	41004400 	.word	0x41004400
    33c0:	40020000 	.word	0x40020000
    33c4:	c0020000 	.word	0xc0020000
    33c8:	00007d78 	.word	0x00007d78

000033cc <_gpio_set_level>:

/**
 * \brief Set output level on port with mask
 */
static inline void _gpio_set_level(const enum gpio_port port, const uint32_t mask, const bool level)
{
    33cc:	b580      	push	{r7, lr}
    33ce:	b082      	sub	sp, #8
    33d0:	af00      	add	r7, sp, #0
    33d2:	6039      	str	r1, [r7, #0]
    33d4:	0011      	movs	r1, r2
    33d6:	1dfb      	adds	r3, r7, #7
    33d8:	1c02      	adds	r2, r0, #0
    33da:	701a      	strb	r2, [r3, #0]
    33dc:	1dbb      	adds	r3, r7, #6
    33de:	1c0a      	adds	r2, r1, #0
    33e0:	701a      	strb	r2, [r3, #0]
	if (level) {
    33e2:	1dbb      	adds	r3, r7, #6
    33e4:	781b      	ldrb	r3, [r3, #0]
    33e6:	2b00      	cmp	r3, #0
    33e8:	d008      	beq.n	33fc <_gpio_set_level+0x30>
		hri_port_set_OUT_reg(PORT_IOBUS, port, mask);
    33ea:	683a      	ldr	r2, [r7, #0]
    33ec:	1dfb      	adds	r3, r7, #7
    33ee:	7819      	ldrb	r1, [r3, #0]
    33f0:	23c0      	movs	r3, #192	; 0xc0
    33f2:	05db      	lsls	r3, r3, #23
    33f4:	0018      	movs	r0, r3
    33f6:	f7ff fe05 	bl	3004 <hri_port_set_OUT_reg>
	} else {
		hri_port_clear_OUT_reg(PORT_IOBUS, port, mask);
	}
}
    33fa:	e007      	b.n	340c <_gpio_set_level+0x40>
		hri_port_clear_OUT_reg(PORT_IOBUS, port, mask);
    33fc:	683a      	ldr	r2, [r7, #0]
    33fe:	1dfb      	adds	r3, r7, #7
    3400:	7819      	ldrb	r1, [r3, #0]
    3402:	23c0      	movs	r3, #192	; 0xc0
    3404:	05db      	lsls	r3, r3, #23
    3406:	0018      	movs	r0, r3
    3408:	f7ff fe12 	bl	3030 <hri_port_clear_OUT_reg>
}
    340c:	46c0      	nop			; (mov r8, r8)
    340e:	46bd      	mov	sp, r7
    3410:	b002      	add	sp, #8
    3412:	bd80      	pop	{r7, pc}

00003414 <_gpio_set_pin_pull_mode>:
/**
 * \brief Set pin pull mode
 */
static inline void _gpio_set_pin_pull_mode(const enum gpio_port port, const uint8_t pin,
                                           const enum gpio_pull_mode pull_mode)
{
    3414:	b590      	push	{r4, r7, lr}
    3416:	b083      	sub	sp, #12
    3418:	af00      	add	r7, sp, #0
    341a:	0004      	movs	r4, r0
    341c:	0008      	movs	r0, r1
    341e:	0011      	movs	r1, r2
    3420:	1dfb      	adds	r3, r7, #7
    3422:	1c22      	adds	r2, r4, #0
    3424:	701a      	strb	r2, [r3, #0]
    3426:	1dbb      	adds	r3, r7, #6
    3428:	1c02      	adds	r2, r0, #0
    342a:	701a      	strb	r2, [r3, #0]
    342c:	1d7b      	adds	r3, r7, #5
    342e:	1c0a      	adds	r2, r1, #0
    3430:	701a      	strb	r2, [r3, #0]
	switch (pull_mode) {
    3432:	1d7b      	adds	r3, r7, #5
    3434:	781b      	ldrb	r3, [r3, #0]
    3436:	2b01      	cmp	r3, #1
    3438:	d00c      	beq.n	3454 <_gpio_set_pin_pull_mode+0x40>
    343a:	2b02      	cmp	r3, #2
    343c:	d029      	beq.n	3492 <_gpio_set_pin_pull_mode+0x7e>
    343e:	2b00      	cmp	r3, #0
    3440:	d146      	bne.n	34d0 <_gpio_set_pin_pull_mode+0xbc>
	case GPIO_PULL_OFF:
		hri_port_clear_PINCFG_PULLEN_bit(PORT, port, pin);
    3442:	1dbb      	adds	r3, r7, #6
    3444:	781a      	ldrb	r2, [r3, #0]
    3446:	1dfb      	adds	r3, r7, #7
    3448:	781b      	ldrb	r3, [r3, #0]
    344a:	4827      	ldr	r0, [pc, #156]	; (34e8 <_gpio_set_pin_pull_mode+0xd4>)
    344c:	0019      	movs	r1, r3
    344e:	f7ff fef8 	bl	3242 <hri_port_clear_PINCFG_PULLEN_bit>
		break;
    3452:	e044      	b.n	34de <_gpio_set_pin_pull_mode+0xca>

	case GPIO_PULL_UP:
		hri_port_clear_DIR_reg(PORT_IOBUS, port, 1U << pin);
    3454:	1dbb      	adds	r3, r7, #6
    3456:	781b      	ldrb	r3, [r3, #0]
    3458:	2201      	movs	r2, #1
    345a:	409a      	lsls	r2, r3
    345c:	1dfb      	adds	r3, r7, #7
    345e:	7819      	ldrb	r1, [r3, #0]
    3460:	23c0      	movs	r3, #192	; 0xc0
    3462:	05db      	lsls	r3, r3, #23
    3464:	0018      	movs	r0, r3
    3466:	f7ff fdb7 	bl	2fd8 <hri_port_clear_DIR_reg>
		hri_port_set_PINCFG_PULLEN_bit(PORT, port, pin);
    346a:	1dbb      	adds	r3, r7, #6
    346c:	781a      	ldrb	r2, [r3, #0]
    346e:	1dfb      	adds	r3, r7, #7
    3470:	781b      	ldrb	r3, [r3, #0]
    3472:	481d      	ldr	r0, [pc, #116]	; (34e8 <_gpio_set_pin_pull_mode+0xd4>)
    3474:	0019      	movs	r1, r3
    3476:	f7ff feb9 	bl	31ec <hri_port_set_PINCFG_PULLEN_bit>
		hri_port_set_OUT_reg(PORT_IOBUS, port, 1U << pin);
    347a:	1dbb      	adds	r3, r7, #6
    347c:	781b      	ldrb	r3, [r3, #0]
    347e:	2201      	movs	r2, #1
    3480:	409a      	lsls	r2, r3
    3482:	1dfb      	adds	r3, r7, #7
    3484:	7819      	ldrb	r1, [r3, #0]
    3486:	23c0      	movs	r3, #192	; 0xc0
    3488:	05db      	lsls	r3, r3, #23
    348a:	0018      	movs	r0, r3
    348c:	f7ff fdba 	bl	3004 <hri_port_set_OUT_reg>
		break;
    3490:	e025      	b.n	34de <_gpio_set_pin_pull_mode+0xca>

	case GPIO_PULL_DOWN:
		hri_port_clear_DIR_reg(PORT_IOBUS, port, 1U << pin);
    3492:	1dbb      	adds	r3, r7, #6
    3494:	781b      	ldrb	r3, [r3, #0]
    3496:	2201      	movs	r2, #1
    3498:	409a      	lsls	r2, r3
    349a:	1dfb      	adds	r3, r7, #7
    349c:	7819      	ldrb	r1, [r3, #0]
    349e:	23c0      	movs	r3, #192	; 0xc0
    34a0:	05db      	lsls	r3, r3, #23
    34a2:	0018      	movs	r0, r3
    34a4:	f7ff fd98 	bl	2fd8 <hri_port_clear_DIR_reg>
		hri_port_set_PINCFG_PULLEN_bit(PORT, port, pin);
    34a8:	1dbb      	adds	r3, r7, #6
    34aa:	781a      	ldrb	r2, [r3, #0]
    34ac:	1dfb      	adds	r3, r7, #7
    34ae:	781b      	ldrb	r3, [r3, #0]
    34b0:	480d      	ldr	r0, [pc, #52]	; (34e8 <_gpio_set_pin_pull_mode+0xd4>)
    34b2:	0019      	movs	r1, r3
    34b4:	f7ff fe9a 	bl	31ec <hri_port_set_PINCFG_PULLEN_bit>
		hri_port_clear_OUT_reg(PORT_IOBUS, port, 1U << pin);
    34b8:	1dbb      	adds	r3, r7, #6
    34ba:	781b      	ldrb	r3, [r3, #0]
    34bc:	2201      	movs	r2, #1
    34be:	409a      	lsls	r2, r3
    34c0:	1dfb      	adds	r3, r7, #7
    34c2:	7819      	ldrb	r1, [r3, #0]
    34c4:	23c0      	movs	r3, #192	; 0xc0
    34c6:	05db      	lsls	r3, r3, #23
    34c8:	0018      	movs	r0, r3
    34ca:	f7ff fdb1 	bl	3030 <hri_port_clear_OUT_reg>
		break;
    34ce:	e006      	b.n	34de <_gpio_set_pin_pull_mode+0xca>

	default:
		ASSERT(false);
    34d0:	4b06      	ldr	r3, [pc, #24]	; (34ec <_gpio_set_pin_pull_mode+0xd8>)
    34d2:	2288      	movs	r2, #136	; 0x88
    34d4:	0019      	movs	r1, r3
    34d6:	2000      	movs	r0, #0
    34d8:	f000 fe56 	bl	4188 <assert>
		break;
    34dc:	46c0      	nop			; (mov r8, r8)
	}
}
    34de:	46c0      	nop			; (mov r8, r8)
    34e0:	46bd      	mov	sp, r7
    34e2:	b003      	add	sp, #12
    34e4:	bd90      	pop	{r4, r7, pc}
    34e6:	46c0      	nop			; (mov r8, r8)
    34e8:	41004400 	.word	0x41004400
    34ec:	00007d78 	.word	0x00007d78

000034f0 <_gpio_set_pin_function>:

/**
 * \brief Set gpio pin function
 */
static inline void _gpio_set_pin_function(const uint32_t gpio, const uint32_t function)
{
    34f0:	b590      	push	{r4, r7, lr}
    34f2:	b085      	sub	sp, #20
    34f4:	af00      	add	r7, sp, #0
    34f6:	6078      	str	r0, [r7, #4]
    34f8:	6039      	str	r1, [r7, #0]
	uint8_t port = GPIO_PORT(gpio);
    34fa:	687b      	ldr	r3, [r7, #4]
    34fc:	095a      	lsrs	r2, r3, #5
    34fe:	230f      	movs	r3, #15
    3500:	18fb      	adds	r3, r7, r3
    3502:	701a      	strb	r2, [r3, #0]
	uint8_t pin  = GPIO_PIN(gpio);
    3504:	687b      	ldr	r3, [r7, #4]
    3506:	b2da      	uxtb	r2, r3
    3508:	230e      	movs	r3, #14
    350a:	18fb      	adds	r3, r7, r3
    350c:	211f      	movs	r1, #31
    350e:	400a      	ands	r2, r1
    3510:	701a      	strb	r2, [r3, #0]

	if (function == GPIO_PIN_FUNCTION_OFF) {
    3512:	683b      	ldr	r3, [r7, #0]
    3514:	3301      	adds	r3, #1
    3516:	d10a      	bne.n	352e <_gpio_set_pin_function+0x3e>
		hri_port_write_PINCFG_PMUXEN_bit(PORT, port, pin, false);
    3518:	230e      	movs	r3, #14
    351a:	18fb      	adds	r3, r7, r3
    351c:	781a      	ldrb	r2, [r3, #0]
    351e:	230f      	movs	r3, #15
    3520:	18fb      	adds	r3, r7, r3
    3522:	7819      	ldrb	r1, [r3, #0]
    3524:	481b      	ldr	r0, [pc, #108]	; (3594 <_gpio_set_pin_function+0xa4>)
    3526:	2300      	movs	r3, #0
    3528:	f7ff fe1f 	bl	316a <hri_port_write_PINCFG_PMUXEN_bit>
		} else {
			// Even numbered pin
			hri_port_write_PMUX_PMUXE_bf(PORT, port, pin >> 1, function & 0xffff);
		}
	}
}
    352c:	e02e      	b.n	358c <_gpio_set_pin_function+0x9c>
		hri_port_write_PINCFG_PMUXEN_bit(PORT, port, pin, true);
    352e:	230e      	movs	r3, #14
    3530:	18fb      	adds	r3, r7, r3
    3532:	781a      	ldrb	r2, [r3, #0]
    3534:	230f      	movs	r3, #15
    3536:	18fb      	adds	r3, r7, r3
    3538:	7819      	ldrb	r1, [r3, #0]
    353a:	4816      	ldr	r0, [pc, #88]	; (3594 <_gpio_set_pin_function+0xa4>)
    353c:	2301      	movs	r3, #1
    353e:	f7ff fe14 	bl	316a <hri_port_write_PINCFG_PMUXEN_bit>
		if (pin & 1) {
    3542:	230e      	movs	r3, #14
    3544:	18fb      	adds	r3, r7, r3
    3546:	781b      	ldrb	r3, [r3, #0]
    3548:	2201      	movs	r2, #1
    354a:	4013      	ands	r3, r2
    354c:	d00f      	beq.n	356e <_gpio_set_pin_function+0x7e>
			hri_port_write_PMUX_PMUXO_bf(PORT, port, pin >> 1, function & 0xffff);
    354e:	230e      	movs	r3, #14
    3550:	18fb      	adds	r3, r7, r3
    3552:	781b      	ldrb	r3, [r3, #0]
    3554:	085b      	lsrs	r3, r3, #1
    3556:	b2da      	uxtb	r2, r3
    3558:	683b      	ldr	r3, [r7, #0]
    355a:	b2d8      	uxtb	r0, r3
    355c:	230f      	movs	r3, #15
    355e:	18fb      	adds	r3, r7, r3
    3560:	7819      	ldrb	r1, [r3, #0]
    3562:	4c0c      	ldr	r4, [pc, #48]	; (3594 <_gpio_set_pin_function+0xa4>)
    3564:	0003      	movs	r3, r0
    3566:	0020      	movs	r0, r4
    3568:	f7ff fdbc 	bl	30e4 <hri_port_write_PMUX_PMUXO_bf>
}
    356c:	e00e      	b.n	358c <_gpio_set_pin_function+0x9c>
			hri_port_write_PMUX_PMUXE_bf(PORT, port, pin >> 1, function & 0xffff);
    356e:	230e      	movs	r3, #14
    3570:	18fb      	adds	r3, r7, r3
    3572:	781b      	ldrb	r3, [r3, #0]
    3574:	085b      	lsrs	r3, r3, #1
    3576:	b2da      	uxtb	r2, r3
    3578:	683b      	ldr	r3, [r7, #0]
    357a:	b2d8      	uxtb	r0, r3
    357c:	230f      	movs	r3, #15
    357e:	18fb      	adds	r3, r7, r3
    3580:	7819      	ldrb	r1, [r3, #0]
    3582:	4c04      	ldr	r4, [pc, #16]	; (3594 <_gpio_set_pin_function+0xa4>)
    3584:	0003      	movs	r3, r0
    3586:	0020      	movs	r0, r4
    3588:	f7ff fd68 	bl	305c <hri_port_write_PMUX_PMUXE_bf>
}
    358c:	46c0      	nop			; (mov r8, r8)
    358e:	46bd      	mov	sp, r7
    3590:	b005      	add	sp, #20
    3592:	bd90      	pop	{r4, r7, pc}
    3594:	41004400 	.word	0x41004400

00003598 <gpio_set_pin_pull_mode>:
 * \param[in] pull_mode GPIO_PULL_DOWN = Pull pin low with internal resistor
 *                      GPIO_PULL_UP   = Pull pin high with internal resistor
 *                      GPIO_PULL_OFF  = Disable pin pull mode
 */
static inline void gpio_set_pin_pull_mode(const uint8_t pin, const enum gpio_pull_mode pull_mode)
{
    3598:	b580      	push	{r7, lr}
    359a:	b082      	sub	sp, #8
    359c:	af00      	add	r7, sp, #0
    359e:	0002      	movs	r2, r0
    35a0:	1dfb      	adds	r3, r7, #7
    35a2:	701a      	strb	r2, [r3, #0]
    35a4:	1dbb      	adds	r3, r7, #6
    35a6:	1c0a      	adds	r2, r1, #0
    35a8:	701a      	strb	r2, [r3, #0]
	_gpio_set_pin_pull_mode((enum gpio_port)GPIO_PORT(pin), pin & 0x1F, pull_mode);
    35aa:	1dfb      	adds	r3, r7, #7
    35ac:	781b      	ldrb	r3, [r3, #0]
    35ae:	095b      	lsrs	r3, r3, #5
    35b0:	b2d8      	uxtb	r0, r3
    35b2:	1dfb      	adds	r3, r7, #7
    35b4:	781b      	ldrb	r3, [r3, #0]
    35b6:	221f      	movs	r2, #31
    35b8:	4013      	ands	r3, r2
    35ba:	b2d9      	uxtb	r1, r3
    35bc:	1dbb      	adds	r3, r7, #6
    35be:	781b      	ldrb	r3, [r3, #0]
    35c0:	001a      	movs	r2, r3
    35c2:	f7ff ff27 	bl	3414 <_gpio_set_pin_pull_mode>
}
    35c6:	46c0      	nop			; (mov r8, r8)
    35c8:	46bd      	mov	sp, r7
    35ca:	b002      	add	sp, #8
    35cc:	bd80      	pop	{r7, pc}

000035ce <gpio_set_pin_function>:
 * \param[in] function  The pin function is given by a 32-bit wide bitfield
 *                      found in the header files for the device
 *
 */
static inline void gpio_set_pin_function(const uint32_t pin, uint32_t function)
{
    35ce:	b580      	push	{r7, lr}
    35d0:	b082      	sub	sp, #8
    35d2:	af00      	add	r7, sp, #0
    35d4:	6078      	str	r0, [r7, #4]
    35d6:	6039      	str	r1, [r7, #0]
	_gpio_set_pin_function(pin, function);
    35d8:	683a      	ldr	r2, [r7, #0]
    35da:	687b      	ldr	r3, [r7, #4]
    35dc:	0011      	movs	r1, r2
    35de:	0018      	movs	r0, r3
    35e0:	f7ff ff86 	bl	34f0 <_gpio_set_pin_function>
}
    35e4:	46c0      	nop			; (mov r8, r8)
    35e6:	46bd      	mov	sp, r7
    35e8:	b002      	add	sp, #8
    35ea:	bd80      	pop	{r7, pc}

000035ec <gpio_set_pin_direction>:
 *                      GPIO_DIRECTION_OUT = Data direction out
 *                      GPIO_DIRECTION_OFF = Disables the pin
 *                      (low power state)
 */
static inline void gpio_set_pin_direction(const uint8_t pin, const enum gpio_direction direction)
{
    35ec:	b580      	push	{r7, lr}
    35ee:	b082      	sub	sp, #8
    35f0:	af00      	add	r7, sp, #0
    35f2:	0002      	movs	r2, r0
    35f4:	1dfb      	adds	r3, r7, #7
    35f6:	701a      	strb	r2, [r3, #0]
    35f8:	1dbb      	adds	r3, r7, #6
    35fa:	1c0a      	adds	r2, r1, #0
    35fc:	701a      	strb	r2, [r3, #0]
	_gpio_set_direction((enum gpio_port)GPIO_PORT(pin), 1U << GPIO_PIN(pin), direction);
    35fe:	1dfb      	adds	r3, r7, #7
    3600:	781b      	ldrb	r3, [r3, #0]
    3602:	095b      	lsrs	r3, r3, #5
    3604:	b2d8      	uxtb	r0, r3
    3606:	1dfb      	adds	r3, r7, #7
    3608:	781b      	ldrb	r3, [r3, #0]
    360a:	221f      	movs	r2, #31
    360c:	4013      	ands	r3, r2
    360e:	2201      	movs	r2, #1
    3610:	409a      	lsls	r2, r3
    3612:	0011      	movs	r1, r2
    3614:	1dbb      	adds	r3, r7, #6
    3616:	781b      	ldrb	r3, [r3, #0]
    3618:	001a      	movs	r2, r3
    361a:	f7ff fe53 	bl	32c4 <_gpio_set_direction>
}
    361e:	46c0      	nop			; (mov r8, r8)
    3620:	46bd      	mov	sp, r7
    3622:	b002      	add	sp, #8
    3624:	bd80      	pop	{r7, pc}

00003626 <gpio_set_pin_level>:
 * \param[in] pin       The pin number for device
 * \param[in] level true  = Pin level set to "high" state
 *                  false = Pin level set to "low" state
 */
static inline void gpio_set_pin_level(const uint8_t pin, const bool level)
{
    3626:	b580      	push	{r7, lr}
    3628:	b082      	sub	sp, #8
    362a:	af00      	add	r7, sp, #0
    362c:	0002      	movs	r2, r0
    362e:	1dfb      	adds	r3, r7, #7
    3630:	701a      	strb	r2, [r3, #0]
    3632:	1dbb      	adds	r3, r7, #6
    3634:	1c0a      	adds	r2, r1, #0
    3636:	701a      	strb	r2, [r3, #0]
	_gpio_set_level((enum gpio_port)GPIO_PORT(pin), 1U << GPIO_PIN(pin), level);
    3638:	1dfb      	adds	r3, r7, #7
    363a:	781b      	ldrb	r3, [r3, #0]
    363c:	095b      	lsrs	r3, r3, #5
    363e:	b2d8      	uxtb	r0, r3
    3640:	1dfb      	adds	r3, r7, #7
    3642:	781b      	ldrb	r3, [r3, #0]
    3644:	221f      	movs	r2, #31
    3646:	4013      	ands	r3, r2
    3648:	2201      	movs	r2, #1
    364a:	409a      	lsls	r2, r3
    364c:	0011      	movs	r1, r2
    364e:	1dbb      	adds	r3, r7, #6
    3650:	781b      	ldrb	r3, [r3, #0]
    3652:	001a      	movs	r2, r3
    3654:	f7ff feba 	bl	33cc <_gpio_set_level>
}
    3658:	46c0      	nop			; (mov r8, r8)
    365a:	46bd      	mov	sp, r7
    365c:	b002      	add	sp, #8
    365e:	bd80      	pop	{r7, pc}

00003660 <init_mcu>:
 * This function calls the various initialization functions.
 * Currently the following initialization functions are supported:
 *  - System clock initialization
 */
static inline void init_mcu(void)
{
    3660:	b580      	push	{r7, lr}
    3662:	af00      	add	r7, sp, #0
	_init_chip();
    3664:	f000 fe5e 	bl	4324 <_init_chip>
}
    3668:	46c0      	nop			; (mov r8, r8)
    366a:	46bd      	mov	sp, r7
    366c:	bd80      	pop	{r7, pc}
	...

00003670 <_gclk_enable_channel>:
 *
 * \param[in] channel The channel to enable clock for
 * \param[in] source The clock source for the given channel
 */
static inline void _gclk_enable_channel(const uint8_t channel, const uint8_t source)
{
    3670:	b580      	push	{r7, lr}
    3672:	b082      	sub	sp, #8
    3674:	af00      	add	r7, sp, #0
    3676:	0002      	movs	r2, r0
    3678:	1dfb      	adds	r3, r7, #7
    367a:	701a      	strb	r2, [r3, #0]
    367c:	1dbb      	adds	r3, r7, #6
    367e:	1c0a      	adds	r2, r1, #0
    3680:	701a      	strb	r2, [r3, #0]

	hri_gclk_write_CLKCTRL_reg(GCLK,
	                           GCLK_CLKCTRL_ID(channel) | GCLK_CLKCTRL_GEN(source) | (1 << GCLK_CLKCTRL_CLKEN_Pos));
    3682:	1dfb      	adds	r3, r7, #7
    3684:	781b      	ldrb	r3, [r3, #0]
    3686:	b29b      	uxth	r3, r3
    3688:	223f      	movs	r2, #63	; 0x3f
    368a:	4013      	ands	r3, r2
    368c:	b29a      	uxth	r2, r3
    368e:	1dbb      	adds	r3, r7, #6
    3690:	781b      	ldrb	r3, [r3, #0]
    3692:	b29b      	uxth	r3, r3
    3694:	021b      	lsls	r3, r3, #8
    3696:	b299      	uxth	r1, r3
    3698:	23f0      	movs	r3, #240	; 0xf0
    369a:	011b      	lsls	r3, r3, #4
    369c:	400b      	ands	r3, r1
    369e:	b29b      	uxth	r3, r3
    36a0:	4313      	orrs	r3, r2
    36a2:	b29b      	uxth	r3, r3
	hri_gclk_write_CLKCTRL_reg(GCLK,
    36a4:	2280      	movs	r2, #128	; 0x80
    36a6:	01d2      	lsls	r2, r2, #7
    36a8:	4313      	orrs	r3, r2
    36aa:	b29b      	uxth	r3, r3
    36ac:	4a04      	ldr	r2, [pc, #16]	; (36c0 <_gclk_enable_channel+0x50>)
    36ae:	0019      	movs	r1, r3
    36b0:	0010      	movs	r0, r2
    36b2:	f7ff fc6c 	bl	2f8e <hri_gclk_write_CLKCTRL_reg>
}
    36b6:	46c0      	nop			; (mov r8, r8)
    36b8:	46bd      	mov	sp, r7
    36ba:	b002      	add	sp, #8
    36bc:	bd80      	pop	{r7, pc}
    36be:	46c0      	nop			; (mov r8, r8)
    36c0:	40000c00 	.word	0x40000c00

000036c4 <_pm_get_ahb_index>:
 * \param[in] module Module to get index for
 *
 * \return index of the given module if succeeds, ERR_INVALID_ARG otherwise
 */
static inline int32_t _pm_get_ahb_index(const void *const module)
{
    36c4:	b580      	push	{r7, lr}
    36c6:	b082      	sub	sp, #8
    36c8:	af00      	add	r7, sp, #0
    36ca:	6078      	str	r0, [r7, #4]
	if ((uint32_t)module == (uint32_t)PM_BUS_APBA) {
    36cc:	687b      	ldr	r3, [r7, #4]
    36ce:	2b01      	cmp	r3, #1
    36d0:	d101      	bne.n	36d6 <_pm_get_ahb_index+0x12>
		return 0;
    36d2:	2300      	movs	r3, #0
    36d4:	e017      	b.n	3706 <_pm_get_ahb_index+0x42>
	} else if ((uint32_t)module == (uint32_t)PM_BUS_APBB) {
    36d6:	687b      	ldr	r3, [r7, #4]
    36d8:	2b02      	cmp	r3, #2
    36da:	d101      	bne.n	36e0 <_pm_get_ahb_index+0x1c>
		return 1;
    36dc:	2301      	movs	r3, #1
    36de:	e012      	b.n	3706 <_pm_get_ahb_index+0x42>
	} else if ((uint32_t)module == (uint32_t)PM_BUS_APBC) {
    36e0:	687b      	ldr	r3, [r7, #4]
    36e2:	2b03      	cmp	r3, #3
    36e4:	d101      	bne.n	36ea <_pm_get_ahb_index+0x26>
		return 2;
    36e6:	2302      	movs	r3, #2
    36e8:	e00d      	b.n	3706 <_pm_get_ahb_index+0x42>
	}
	if ((uint32_t)module == (uint32_t)DSU) {
    36ea:	687b      	ldr	r3, [r7, #4]
    36ec:	4a08      	ldr	r2, [pc, #32]	; (3710 <_pm_get_ahb_index+0x4c>)
    36ee:	4293      	cmp	r3, r2
    36f0:	d101      	bne.n	36f6 <_pm_get_ahb_index+0x32>
		return 3;
    36f2:	2303      	movs	r3, #3
    36f4:	e007      	b.n	3706 <_pm_get_ahb_index+0x42>
	} else if ((uint32_t)module == (uint32_t)NVMCTRL) {
    36f6:	687b      	ldr	r3, [r7, #4]
    36f8:	4a06      	ldr	r2, [pc, #24]	; (3714 <_pm_get_ahb_index+0x50>)
    36fa:	4293      	cmp	r3, r2
    36fc:	d101      	bne.n	3702 <_pm_get_ahb_index+0x3e>
		return 4;
    36fe:	2304      	movs	r3, #4
    3700:	e001      	b.n	3706 <_pm_get_ahb_index+0x42>
	}

	return ERR_INVALID_ARG;
    3702:	230d      	movs	r3, #13
    3704:	425b      	negs	r3, r3
}
    3706:	0018      	movs	r0, r3
    3708:	46bd      	mov	sp, r7
    370a:	b002      	add	sp, #8
    370c:	bd80      	pop	{r7, pc}
    370e:	46c0      	nop			; (mov r8, r8)
    3710:	41002000 	.word	0x41002000
    3714:	41004000 	.word	0x41004000

00003718 <_pm_get_apbb_index>:
 * \param[in] module Module to get index for
 *
 * \return index of the given module if succeeds, ERR_INVALID_ARG otherwise
 */
static inline int32_t _pm_get_apbb_index(const void *const module)
{
    3718:	b580      	push	{r7, lr}
    371a:	b082      	sub	sp, #8
    371c:	af00      	add	r7, sp, #0
    371e:	6078      	str	r0, [r7, #4]
	if ((uint32_t)module == (uint32_t)PAC1) {
    3720:	687a      	ldr	r2, [r7, #4]
    3722:	2382      	movs	r3, #130	; 0x82
    3724:	05db      	lsls	r3, r3, #23
    3726:	429a      	cmp	r2, r3
    3728:	d101      	bne.n	372e <_pm_get_apbb_index+0x16>
		return 0;
    372a:	2300      	movs	r3, #0
    372c:	e013      	b.n	3756 <_pm_get_apbb_index+0x3e>
	} else if ((uint32_t)module == (uint32_t)DSU) {
    372e:	687b      	ldr	r3, [r7, #4]
    3730:	4a0b      	ldr	r2, [pc, #44]	; (3760 <_pm_get_apbb_index+0x48>)
    3732:	4293      	cmp	r3, r2
    3734:	d101      	bne.n	373a <_pm_get_apbb_index+0x22>
		return 1;
    3736:	2301      	movs	r3, #1
    3738:	e00d      	b.n	3756 <_pm_get_apbb_index+0x3e>
	} else if ((uint32_t)module == (uint32_t)NVMCTRL) {
    373a:	687b      	ldr	r3, [r7, #4]
    373c:	4a09      	ldr	r2, [pc, #36]	; (3764 <_pm_get_apbb_index+0x4c>)
    373e:	4293      	cmp	r3, r2
    3740:	d101      	bne.n	3746 <_pm_get_apbb_index+0x2e>
		return 2;
    3742:	2302      	movs	r3, #2
    3744:	e007      	b.n	3756 <_pm_get_apbb_index+0x3e>
	}
	if ((uint32_t)module == (uint32_t)PORT) {
    3746:	687b      	ldr	r3, [r7, #4]
    3748:	4a07      	ldr	r2, [pc, #28]	; (3768 <_pm_get_apbb_index+0x50>)
    374a:	4293      	cmp	r3, r2
    374c:	d101      	bne.n	3752 <_pm_get_apbb_index+0x3a>
		return 3;
    374e:	2303      	movs	r3, #3
    3750:	e001      	b.n	3756 <_pm_get_apbb_index+0x3e>
	}

	return ERR_INVALID_ARG;
    3752:	230d      	movs	r3, #13
    3754:	425b      	negs	r3, r3
}
    3756:	0018      	movs	r0, r3
    3758:	46bd      	mov	sp, r7
    375a:	b002      	add	sp, #8
    375c:	bd80      	pop	{r7, pc}
    375e:	46c0      	nop			; (mov r8, r8)
    3760:	41002000 	.word	0x41002000
    3764:	41004000 	.word	0x41004000
    3768:	41004400 	.word	0x41004400

0000376c <_pm_enable_bus_clock>:
 *
 * \param[in] bus A bus to enable clock on
 * \param[in] module A hardware module to enable clock for
 */
static inline void _pm_enable_bus_clock(const enum _pm_bus bus, const void *const module)
{
    376c:	b580      	push	{r7, lr}
    376e:	b084      	sub	sp, #16
    3770:	af00      	add	r7, sp, #0
    3772:	0002      	movs	r2, r0
    3774:	6039      	str	r1, [r7, #0]
    3776:	1dfb      	adds	r3, r7, #7
    3778:	701a      	strb	r2, [r3, #0]
	uint32_t peripheral = ((uint32_t)module & 0x0000ff00) >> 10;
    377a:	683b      	ldr	r3, [r7, #0]
    377c:	0a9b      	lsrs	r3, r3, #10
    377e:	223f      	movs	r2, #63	; 0x3f
    3780:	4013      	ands	r3, r2
    3782:	60fb      	str	r3, [r7, #12]

	switch (bus) {
    3784:	1dfb      	adds	r3, r7, #7
    3786:	781b      	ldrb	r3, [r3, #0]
    3788:	2b01      	cmp	r3, #1
    378a:	d01e      	beq.n	37ca <_pm_enable_bus_clock+0x5e>
    378c:	dc02      	bgt.n	3794 <_pm_enable_bus_clock+0x28>
    378e:	2b00      	cmp	r3, #0
    3790:	d005      	beq.n	379e <_pm_enable_bus_clock+0x32>
    3792:	e044      	b.n	381e <_pm_enable_bus_clock+0xb2>
    3794:	2b02      	cmp	r3, #2
    3796:	d022      	beq.n	37de <_pm_enable_bus_clock+0x72>
    3798:	2b03      	cmp	r3, #3
    379a:	d036      	beq.n	380a <_pm_enable_bus_clock+0x9e>
    379c:	e03f      	b.n	381e <_pm_enable_bus_clock+0xb2>
	case PM_BUS_AHB:
		if (_pm_get_ahb_index(module) >= 0) {
    379e:	683b      	ldr	r3, [r7, #0]
    37a0:	0018      	movs	r0, r3
    37a2:	f7ff ff8f 	bl	36c4 <_pm_get_ahb_index>
    37a6:	1e03      	subs	r3, r0, #0
    37a8:	db40      	blt.n	382c <_pm_enable_bus_clock+0xc0>
			peripheral = (uint32_t)_pm_get_ahb_index(module);
    37aa:	683b      	ldr	r3, [r7, #0]
    37ac:	0018      	movs	r0, r3
    37ae:	f7ff ff89 	bl	36c4 <_pm_get_ahb_index>
    37b2:	0003      	movs	r3, r0
    37b4:	60fb      	str	r3, [r7, #12]
			PM->AHBMASK.reg |= 1 << peripheral;
    37b6:	4b21      	ldr	r3, [pc, #132]	; (383c <_pm_enable_bus_clock+0xd0>)
    37b8:	4a20      	ldr	r2, [pc, #128]	; (383c <_pm_enable_bus_clock+0xd0>)
    37ba:	6952      	ldr	r2, [r2, #20]
    37bc:	2001      	movs	r0, #1
    37be:	68f9      	ldr	r1, [r7, #12]
    37c0:	4088      	lsls	r0, r1
    37c2:	0001      	movs	r1, r0
    37c4:	430a      	orrs	r2, r1
    37c6:	615a      	str	r2, [r3, #20]
		}
		break;
    37c8:	e030      	b.n	382c <_pm_enable_bus_clock+0xc0>
	case PM_BUS_APBA:
		PM->APBAMASK.reg |= 1 << peripheral;
    37ca:	4b1c      	ldr	r3, [pc, #112]	; (383c <_pm_enable_bus_clock+0xd0>)
    37cc:	4a1b      	ldr	r2, [pc, #108]	; (383c <_pm_enable_bus_clock+0xd0>)
    37ce:	6992      	ldr	r2, [r2, #24]
    37d0:	2001      	movs	r0, #1
    37d2:	68f9      	ldr	r1, [r7, #12]
    37d4:	4088      	lsls	r0, r1
    37d6:	0001      	movs	r1, r0
    37d8:	430a      	orrs	r2, r1
    37da:	619a      	str	r2, [r3, #24]
		break;
    37dc:	e029      	b.n	3832 <_pm_enable_bus_clock+0xc6>
	case PM_BUS_APBB:
		if (_pm_get_apbb_index(module) >= 0) {
    37de:	683b      	ldr	r3, [r7, #0]
    37e0:	0018      	movs	r0, r3
    37e2:	f7ff ff99 	bl	3718 <_pm_get_apbb_index>
    37e6:	1e03      	subs	r3, r0, #0
    37e8:	db22      	blt.n	3830 <_pm_enable_bus_clock+0xc4>
			peripheral = (uint32_t)_pm_get_apbb_index(module);
    37ea:	683b      	ldr	r3, [r7, #0]
    37ec:	0018      	movs	r0, r3
    37ee:	f7ff ff93 	bl	3718 <_pm_get_apbb_index>
    37f2:	0003      	movs	r3, r0
    37f4:	60fb      	str	r3, [r7, #12]
			PM->APBBMASK.reg |= 1 << peripheral;
    37f6:	4b11      	ldr	r3, [pc, #68]	; (383c <_pm_enable_bus_clock+0xd0>)
    37f8:	4a10      	ldr	r2, [pc, #64]	; (383c <_pm_enable_bus_clock+0xd0>)
    37fa:	69d2      	ldr	r2, [r2, #28]
    37fc:	2001      	movs	r0, #1
    37fe:	68f9      	ldr	r1, [r7, #12]
    3800:	4088      	lsls	r0, r1
    3802:	0001      	movs	r1, r0
    3804:	430a      	orrs	r2, r1
    3806:	61da      	str	r2, [r3, #28]
		}
		break;
    3808:	e012      	b.n	3830 <_pm_enable_bus_clock+0xc4>
	case PM_BUS_APBC:
		PM->APBCMASK.reg |= 1 << peripheral;
    380a:	4b0c      	ldr	r3, [pc, #48]	; (383c <_pm_enable_bus_clock+0xd0>)
    380c:	4a0b      	ldr	r2, [pc, #44]	; (383c <_pm_enable_bus_clock+0xd0>)
    380e:	6a12      	ldr	r2, [r2, #32]
    3810:	2001      	movs	r0, #1
    3812:	68f9      	ldr	r1, [r7, #12]
    3814:	4088      	lsls	r0, r1
    3816:	0001      	movs	r1, r0
    3818:	430a      	orrs	r2, r1
    381a:	621a      	str	r2, [r3, #32]
		break;
    381c:	e009      	b.n	3832 <_pm_enable_bus_clock+0xc6>
	default:
		ASSERT(false);
    381e:	4b08      	ldr	r3, [pc, #32]	; (3840 <_pm_enable_bus_clock+0xd4>)
    3820:	228d      	movs	r2, #141	; 0x8d
    3822:	0019      	movs	r1, r3
    3824:	2000      	movs	r0, #0
    3826:	f000 fcaf 	bl	4188 <assert>
		break;
    382a:	e002      	b.n	3832 <_pm_enable_bus_clock+0xc6>
		break;
    382c:	46c0      	nop			; (mov r8, r8)
    382e:	e000      	b.n	3832 <_pm_enable_bus_clock+0xc6>
		break;
    3830:	46c0      	nop			; (mov r8, r8)
	}
}
    3832:	46c0      	nop			; (mov r8, r8)
    3834:	46bd      	mov	sp, r7
    3836:	b004      	add	sp, #16
    3838:	bd80      	pop	{r7, pc}
    383a:	46c0      	nop			; (mov r8, r8)
    383c:	40000400 	.word	0x40000400
    3840:	00007d94 	.word	0x00007d94

00003844 <EXTERNAL_IRQ_0_init>:
//struct spi_m_sync_descriptor RF_SPI;

struct usart_sync_descriptor DEBUG_SERIAL;

void EXTERNAL_IRQ_0_init(void)
{
    3844:	b580      	push	{r7, lr}
    3846:	af00      	add	r7, sp, #0
	_gclk_enable_channel(EIC_GCLK_ID, CONF_GCLK_EIC_SRC);
    3848:	2100      	movs	r1, #0
    384a:	2003      	movs	r0, #3
    384c:	f7ff ff10 	bl	3670 <_gclk_enable_channel>

	// Set pin direction to input
	gpio_set_pin_direction(BTN, GPIO_DIRECTION_IN);
    3850:	2101      	movs	r1, #1
    3852:	2021      	movs	r0, #33	; 0x21
    3854:	f7ff feca 	bl	35ec <gpio_set_pin_direction>

	gpio_set_pin_pull_mode(BTN,
    3858:	2100      	movs	r1, #0
    385a:	2021      	movs	r0, #33	; 0x21
    385c:	f7ff fe9c 	bl	3598 <gpio_set_pin_pull_mode>
	                       // <GPIO_PULL_OFF"> Off
	                       // <GPIO_PULL_UP"> Pull-up
	                       // <GPIO_PULL_DOWN"> Pull-down
	                       GPIO_PULL_OFF);

	gpio_set_pin_function(BTN, PINMUX_PB01A_EIC_EXTINT1);
    3860:	2384      	movs	r3, #132	; 0x84
    3862:	039b      	lsls	r3, r3, #14
    3864:	0019      	movs	r1, r3
    3866:	2021      	movs	r0, #33	; 0x21
    3868:	f7ff feb1 	bl	35ce <gpio_set_pin_function>

	// Set pin direction to input
	gpio_set_pin_direction(RTC_IRQ, GPIO_DIRECTION_IN);
    386c:	2101      	movs	r1, #1
    386e:	200a      	movs	r0, #10
    3870:	f7ff febc 	bl	35ec <gpio_set_pin_direction>

	gpio_set_pin_pull_mode(RTC_IRQ,
    3874:	2100      	movs	r1, #0
    3876:	200a      	movs	r0, #10
    3878:	f7ff fe8e 	bl	3598 <gpio_set_pin_pull_mode>
	                       // <GPIO_PULL_OFF"> Off
	                       // <GPIO_PULL_UP"> Pull-up
	                       // <GPIO_PULL_DOWN"> Pull-down
	                       GPIO_PULL_OFF);

	gpio_set_pin_function(RTC_IRQ, PINMUX_PA10A_EIC_EXTINT10);
    387c:	23a0      	movs	r3, #160	; 0xa0
    387e:	031b      	lsls	r3, r3, #12
    3880:	0019      	movs	r1, r3
    3882:	200a      	movs	r0, #10
    3884:	f7ff fea3 	bl	35ce <gpio_set_pin_function>

	// Set pin direction to input
	

	ext_irq_init();
    3888:	f000 f8b8 	bl	39fc <ext_irq_init>
}
    388c:	46c0      	nop			; (mov r8, r8)
    388e:	46bd      	mov	sp, r7
    3890:	bd80      	pop	{r7, pc}
	...

00003894 <DEBUG_SERIAL_PORT_init>:
	//spi_m_sync_init(&RF_SPI, SERCOM1);
	//RF_SPI_PORT_init();
//}

void DEBUG_SERIAL_PORT_init(void)
{
    3894:	b580      	push	{r7, lr}
    3896:	af00      	add	r7, sp, #0
	gpio_set_pin_function(PA16, PINMUX_PA16D_SERCOM3_PAD0);
    3898:	4b06      	ldr	r3, [pc, #24]	; (38b4 <DEBUG_SERIAL_PORT_init+0x20>)
    389a:	0019      	movs	r1, r3
    389c:	2010      	movs	r0, #16
    389e:	f7ff fe96 	bl	35ce <gpio_set_pin_function>
	gpio_set_pin_function(PA17, PINMUX_PA17D_SERCOM3_PAD1);
    38a2:	4b05      	ldr	r3, [pc, #20]	; (38b8 <DEBUG_SERIAL_PORT_init+0x24>)
    38a4:	0019      	movs	r1, r3
    38a6:	2011      	movs	r0, #17
    38a8:	f7ff fe91 	bl	35ce <gpio_set_pin_function>
}
    38ac:	46c0      	nop			; (mov r8, r8)
    38ae:	46bd      	mov	sp, r7
    38b0:	bd80      	pop	{r7, pc}
    38b2:	46c0      	nop			; (mov r8, r8)
    38b4:	00100003 	.word	0x00100003
    38b8:	00110003 	.word	0x00110003

000038bc <DEBUG_SERIAL_CLOCK_init>:

void DEBUG_SERIAL_CLOCK_init(void)
{
    38bc:	b580      	push	{r7, lr}
    38be:	af00      	add	r7, sp, #0
	_pm_enable_bus_clock(PM_BUS_APBC, SERCOM3);
    38c0:	4b05      	ldr	r3, [pc, #20]	; (38d8 <DEBUG_SERIAL_CLOCK_init+0x1c>)
    38c2:	0019      	movs	r1, r3
    38c4:	2003      	movs	r0, #3
    38c6:	f7ff ff51 	bl	376c <_pm_enable_bus_clock>
	_gclk_enable_channel(SERCOM3_GCLK_ID_CORE, CONF_GCLK_SERCOM3_CORE_SRC);
    38ca:	2100      	movs	r1, #0
    38cc:	2010      	movs	r0, #16
    38ce:	f7ff fecf 	bl	3670 <_gclk_enable_channel>
}
    38d2:	46c0      	nop			; (mov r8, r8)
    38d4:	46bd      	mov	sp, r7
    38d6:	bd80      	pop	{r7, pc}
    38d8:	42001400 	.word	0x42001400

000038dc <DEBUG_SERIAL_init>:

void DEBUG_SERIAL_init(void)
{
    38dc:	b580      	push	{r7, lr}
    38de:	af00      	add	r7, sp, #0
	DEBUG_SERIAL_CLOCK_init();
    38e0:	f7ff ffec 	bl	38bc <DEBUG_SERIAL_CLOCK_init>
	usart_sync_init(&DEBUG_SERIAL, SERCOM3, (void *)NULL);
    38e4:	4905      	ldr	r1, [pc, #20]	; (38fc <DEBUG_SERIAL_init+0x20>)
    38e6:	4b06      	ldr	r3, [pc, #24]	; (3900 <DEBUG_SERIAL_init+0x24>)
    38e8:	2200      	movs	r2, #0
    38ea:	0018      	movs	r0, r3
    38ec:	f000 fb6a 	bl	3fc4 <usart_sync_init>
	DEBUG_SERIAL_PORT_init();
    38f0:	f7ff ffd0 	bl	3894 <DEBUG_SERIAL_PORT_init>
}
    38f4:	46c0      	nop			; (mov r8, r8)
    38f6:	46bd      	mov	sp, r7
    38f8:	bd80      	pop	{r7, pc}
    38fa:	46c0      	nop			; (mov r8, r8)
    38fc:	42001400 	.word	0x42001400
    3900:	200007c4 	.word	0x200007c4

00003904 <delay_driver_init>:

void delay_driver_init(void)
{
    3904:	b580      	push	{r7, lr}
    3906:	af00      	add	r7, sp, #0
	delay_init(SysTick);
    3908:	4b03      	ldr	r3, [pc, #12]	; (3918 <delay_driver_init+0x14>)
    390a:	0018      	movs	r0, r3
    390c:	f000 f84c 	bl	39a8 <delay_init>
}
    3910:	46c0      	nop			; (mov r8, r8)
    3912:	46bd      	mov	sp, r7
    3914:	bd80      	pop	{r7, pc}
    3916:	46c0      	nop			; (mov r8, r8)
    3918:	e000e010 	.word	0xe000e010

0000391c <system_init>:

void system_init(void)
{
    391c:	b580      	push	{r7, lr}
    391e:	af00      	add	r7, sp, #0
	init_mcu();
    3920:	f7ff fe9e 	bl	3660 <init_mcu>


	gpio_set_pin_level(LED_G, false);
    3924:	2100      	movs	r1, #0
    3926:	2020      	movs	r0, #32
    3928:	f7ff fe7d 	bl	3626 <gpio_set_pin_level>
	gpio_set_pin_direction(LED_G, GPIO_DIRECTION_OUT);
    392c:	2102      	movs	r1, #2
    392e:	2020      	movs	r0, #32
    3930:	f7ff fe5c 	bl	35ec <gpio_set_pin_direction>
	gpio_set_pin_function(LED_G, GPIO_PIN_FUNCTION_OFF);
    3934:	2301      	movs	r3, #1
    3936:	425b      	negs	r3, r3
    3938:	0019      	movs	r1, r3
    393a:	2020      	movs	r0, #32
    393c:	f7ff fe47 	bl	35ce <gpio_set_pin_function>

	gpio_set_pin_level(IO4,
    3940:	2100      	movs	r1, #0
    3942:	2027      	movs	r0, #39	; 0x27
    3944:	f7ff fe6f 	bl	3626 <gpio_set_pin_level>
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(IO4, GPIO_DIRECTION_OUT);
    3948:	2102      	movs	r1, #2
    394a:	2027      	movs	r0, #39	; 0x27
    394c:	f7ff fe4e 	bl	35ec <gpio_set_pin_direction>
	gpio_set_pin_function(IO4, GPIO_PIN_FUNCTION_OFF);
    3950:	2301      	movs	r3, #1
    3952:	425b      	negs	r3, r3
    3954:	0019      	movs	r1, r3
    3956:	2027      	movs	r0, #39	; 0x27
    3958:	f7ff fe39 	bl	35ce <gpio_set_pin_function>


	gpio_set_pin_level(IO3,
    395c:	2100      	movs	r1, #0
    395e:	2028      	movs	r0, #40	; 0x28
    3960:	f7ff fe61 	bl	3626 <gpio_set_pin_level>
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(IO3, GPIO_DIRECTION_OUT);
    3964:	2102      	movs	r1, #2
    3966:	2028      	movs	r0, #40	; 0x28
    3968:	f7ff fe40 	bl	35ec <gpio_set_pin_direction>
	gpio_set_pin_function(IO3, GPIO_PIN_FUNCTION_OFF);
    396c:	2301      	movs	r3, #1
    396e:	425b      	negs	r3, r3
    3970:	0019      	movs	r1, r3
    3972:	2028      	movs	r0, #40	; 0x28
    3974:	f7ff fe2b 	bl	35ce <gpio_set_pin_function>
	// GPIO on PB31

	gpio_set_pin_level(LED_R,
    3978:	2101      	movs	r1, #1
    397a:	203f      	movs	r0, #63	; 0x3f
    397c:	f7ff fe53 	bl	3626 <gpio_set_pin_level>
	                   // <false"> Low
	                   // <true"> High
	                   true);

	// Set pin direction to output
	gpio_set_pin_direction(LED_R, GPIO_DIRECTION_OUT);
    3980:	2102      	movs	r1, #2
    3982:	203f      	movs	r0, #63	; 0x3f
    3984:	f7ff fe32 	bl	35ec <gpio_set_pin_direction>

	gpio_set_pin_function(LED_R, GPIO_PIN_FUNCTION_OFF);
    3988:	2301      	movs	r3, #1
    398a:	425b      	negs	r3, r3
    398c:	0019      	movs	r1, r3
    398e:	203f      	movs	r0, #63	; 0x3f
    3990:	f7ff fe1d 	bl	35ce <gpio_set_pin_function>

	EXTERNAL_IRQ_0_init();
    3994:	f7ff ff56 	bl	3844 <EXTERNAL_IRQ_0_init>

	//EXT_SPI_init();

	//RF_SPI_init();

	DEBUG_SERIAL_init();
    3998:	f7ff ffa0 	bl	38dc <DEBUG_SERIAL_init>

	delay_driver_init();
    399c:	f7ff ffb2 	bl	3904 <delay_driver_init>
}
    39a0:	46c0      	nop			; (mov r8, r8)
    39a2:	46bd      	mov	sp, r7
    39a4:	bd80      	pop	{r7, pc}
	...

000039a8 <delay_init>:

/**
 * \brief Initialize Delay driver
 */
void delay_init(void *const hw)
{
    39a8:	b580      	push	{r7, lr}
    39aa:	b082      	sub	sp, #8
    39ac:	af00      	add	r7, sp, #0
    39ae:	6078      	str	r0, [r7, #4]
	_delay_init(hardware = hw);
    39b0:	4b05      	ldr	r3, [pc, #20]	; (39c8 <delay_init+0x20>)
    39b2:	687a      	ldr	r2, [r7, #4]
    39b4:	601a      	str	r2, [r3, #0]
    39b6:	4b04      	ldr	r3, [pc, #16]	; (39c8 <delay_init+0x20>)
    39b8:	681b      	ldr	r3, [r3, #0]
    39ba:	0018      	movs	r0, r3
    39bc:	f001 ffe4 	bl	5988 <_delay_init>
}
    39c0:	46c0      	nop			; (mov r8, r8)
    39c2:	46bd      	mov	sp, r7
    39c4:	b002      	add	sp, #8
    39c6:	bd80      	pop	{r7, pc}
    39c8:	20000794 	.word	0x20000794

000039cc <delay_ms>:

/**
 * \brief Perform delay in ms
 */
void delay_ms(const uint16_t ms)
{
    39cc:	b590      	push	{r4, r7, lr}
    39ce:	b083      	sub	sp, #12
    39d0:	af00      	add	r7, sp, #0
    39d2:	0002      	movs	r2, r0
    39d4:	1dbb      	adds	r3, r7, #6
    39d6:	801a      	strh	r2, [r3, #0]
	_delay_cycles(hardware, _get_cycles_for_ms(ms));
    39d8:	4b07      	ldr	r3, [pc, #28]	; (39f8 <delay_ms+0x2c>)
    39da:	681c      	ldr	r4, [r3, #0]
    39dc:	1dbb      	adds	r3, r7, #6
    39de:	881b      	ldrh	r3, [r3, #0]
    39e0:	0018      	movs	r0, r3
    39e2:	f000 fc79 	bl	42d8 <_get_cycles_for_ms>
    39e6:	0003      	movs	r3, r0
    39e8:	0019      	movs	r1, r3
    39ea:	0020      	movs	r0, r4
    39ec:	f001 ffd8 	bl	59a0 <_delay_cycles>
}
    39f0:	46c0      	nop			; (mov r8, r8)
    39f2:	46bd      	mov	sp, r7
    39f4:	b003      	add	sp, #12
    39f6:	bd90      	pop	{r4, r7, pc}
    39f8:	20000794 	.word	0x20000794

000039fc <ext_irq_init>:

/**
 * \brief Initialize external irq component if any
 */
int32_t ext_irq_init(void)
{
    39fc:	b580      	push	{r7, lr}
    39fe:	b082      	sub	sp, #8
    3a00:	af00      	add	r7, sp, #0
	uint16_t i;

	for (i = 0; i < EXT_IRQ_AMOUNT; i++) {
    3a02:	1dbb      	adds	r3, r7, #6
    3a04:	2200      	movs	r2, #0
    3a06:	801a      	strh	r2, [r3, #0]
    3a08:	e013      	b.n	3a32 <ext_irq_init+0x36>
		ext_irqs[i].pin = 0xFFFFFFFF;
    3a0a:	1dbb      	adds	r3, r7, #6
    3a0c:	881b      	ldrh	r3, [r3, #0]
    3a0e:	4a0f      	ldr	r2, [pc, #60]	; (3a4c <ext_irq_init+0x50>)
    3a10:	00db      	lsls	r3, r3, #3
    3a12:	18d3      	adds	r3, r2, r3
    3a14:	3304      	adds	r3, #4
    3a16:	2201      	movs	r2, #1
    3a18:	4252      	negs	r2, r2
    3a1a:	601a      	str	r2, [r3, #0]
		ext_irqs[i].cb  = NULL;
    3a1c:	1dbb      	adds	r3, r7, #6
    3a1e:	881a      	ldrh	r2, [r3, #0]
    3a20:	4b0a      	ldr	r3, [pc, #40]	; (3a4c <ext_irq_init+0x50>)
    3a22:	00d2      	lsls	r2, r2, #3
    3a24:	2100      	movs	r1, #0
    3a26:	50d1      	str	r1, [r2, r3]
	for (i = 0; i < EXT_IRQ_AMOUNT; i++) {
    3a28:	1dbb      	adds	r3, r7, #6
    3a2a:	881a      	ldrh	r2, [r3, #0]
    3a2c:	1dbb      	adds	r3, r7, #6
    3a2e:	3201      	adds	r2, #1
    3a30:	801a      	strh	r2, [r3, #0]
    3a32:	1dbb      	adds	r3, r7, #6
    3a34:	881b      	ldrh	r3, [r3, #0]
    3a36:	2b02      	cmp	r3, #2
    3a38:	d9e7      	bls.n	3a0a <ext_irq_init+0xe>
	}

	return _ext_irq_init(process_ext_irq);
    3a3a:	4b05      	ldr	r3, [pc, #20]	; (3a50 <ext_irq_init+0x54>)
    3a3c:	0018      	movs	r0, r3
    3a3e:	f000 fdab 	bl	4598 <_ext_irq_init>
    3a42:	0003      	movs	r3, r0
}
    3a44:	0018      	movs	r0, r3
    3a46:	46bd      	mov	sp, r7
    3a48:	b002      	add	sp, #8
    3a4a:	bd80      	pop	{r7, pc}
    3a4c:	20000798 	.word	0x20000798
    3a50:	00003c29 	.word	0x00003c29

00003a54 <ext_irq_register>:

/**
 * \brief Register callback for the given external interrupt
 */
int32_t ext_irq_register(const uint32_t pin, ext_irq_cb_t cb)
{
    3a54:	b580      	push	{r7, lr}
    3a56:	b086      	sub	sp, #24
    3a58:	af00      	add	r7, sp, #0
    3a5a:	6078      	str	r0, [r7, #4]
    3a5c:	6039      	str	r1, [r7, #0]
	uint8_t i = 0, j = 0;
    3a5e:	2317      	movs	r3, #23
    3a60:	18fb      	adds	r3, r7, r3
    3a62:	2200      	movs	r2, #0
    3a64:	701a      	strb	r2, [r3, #0]
    3a66:	2316      	movs	r3, #22
    3a68:	18fb      	adds	r3, r7, r3
    3a6a:	2200      	movs	r2, #0
    3a6c:	701a      	strb	r2, [r3, #0]
	bool    found = false;
    3a6e:	2315      	movs	r3, #21
    3a70:	18fb      	adds	r3, r7, r3
    3a72:	2200      	movs	r2, #0
    3a74:	701a      	strb	r2, [r3, #0]

	for (; i < EXT_IRQ_AMOUNT; i++) {
    3a76:	e01d      	b.n	3ab4 <ext_irq_register+0x60>
		if (ext_irqs[i].pin == pin) {
    3a78:	2317      	movs	r3, #23
    3a7a:	18fb      	adds	r3, r7, r3
    3a7c:	781b      	ldrb	r3, [r3, #0]
    3a7e:	4a69      	ldr	r2, [pc, #420]	; (3c24 <ext_irq_register+0x1d0>)
    3a80:	00db      	lsls	r3, r3, #3
    3a82:	18d3      	adds	r3, r2, r3
    3a84:	3304      	adds	r3, #4
    3a86:	681a      	ldr	r2, [r3, #0]
    3a88:	687b      	ldr	r3, [r7, #4]
    3a8a:	429a      	cmp	r2, r3
    3a8c:	d10b      	bne.n	3aa6 <ext_irq_register+0x52>
			ext_irqs[i].cb = cb;
    3a8e:	2317      	movs	r3, #23
    3a90:	18fb      	adds	r3, r7, r3
    3a92:	781a      	ldrb	r2, [r3, #0]
    3a94:	4b63      	ldr	r3, [pc, #396]	; (3c24 <ext_irq_register+0x1d0>)
    3a96:	00d2      	lsls	r2, r2, #3
    3a98:	6839      	ldr	r1, [r7, #0]
    3a9a:	50d1      	str	r1, [r2, r3]
			found          = true;
    3a9c:	2315      	movs	r3, #21
    3a9e:	18fb      	adds	r3, r7, r3
    3aa0:	2201      	movs	r2, #1
    3aa2:	701a      	strb	r2, [r3, #0]
			break;
    3aa4:	e00b      	b.n	3abe <ext_irq_register+0x6a>
	for (; i < EXT_IRQ_AMOUNT; i++) {
    3aa6:	2317      	movs	r3, #23
    3aa8:	18fb      	adds	r3, r7, r3
    3aaa:	781a      	ldrb	r2, [r3, #0]
    3aac:	2317      	movs	r3, #23
    3aae:	18fb      	adds	r3, r7, r3
    3ab0:	3201      	adds	r2, #1
    3ab2:	701a      	strb	r2, [r3, #0]
    3ab4:	2317      	movs	r3, #23
    3ab6:	18fb      	adds	r3, r7, r3
    3ab8:	781b      	ldrb	r3, [r3, #0]
    3aba:	2b02      	cmp	r3, #2
    3abc:	d9dc      	bls.n	3a78 <ext_irq_register+0x24>
		}
	}

	if (NULL == cb) {
    3abe:	683b      	ldr	r3, [r7, #0]
    3ac0:	2b00      	cmp	r3, #0
    3ac2:	d111      	bne.n	3ae8 <ext_irq_register+0x94>
		if (!found) {
    3ac4:	2315      	movs	r3, #21
    3ac6:	18fb      	adds	r3, r7, r3
    3ac8:	781b      	ldrb	r3, [r3, #0]
    3aca:	2201      	movs	r2, #1
    3acc:	4053      	eors	r3, r2
    3ace:	b2db      	uxtb	r3, r3
    3ad0:	2b00      	cmp	r3, #0
    3ad2:	d002      	beq.n	3ada <ext_irq_register+0x86>
			return ERR_INVALID_ARG;
    3ad4:	230d      	movs	r3, #13
    3ad6:	425b      	negs	r3, r3
    3ad8:	e09f      	b.n	3c1a <ext_irq_register+0x1c6>
		}
		return _ext_irq_enable(pin, false);
    3ada:	687b      	ldr	r3, [r7, #4]
    3adc:	2100      	movs	r1, #0
    3ade:	0018      	movs	r0, r3
    3ae0:	f000 fdb6 	bl	4650 <_ext_irq_enable>
    3ae4:	0003      	movs	r3, r0
    3ae6:	e098      	b.n	3c1a <ext_irq_register+0x1c6>
	}

	if (!found) {
    3ae8:	2315      	movs	r3, #21
    3aea:	18fb      	adds	r3, r7, r3
    3aec:	781b      	ldrb	r3, [r3, #0]
    3aee:	2201      	movs	r2, #1
    3af0:	4053      	eors	r3, r2
    3af2:	b2db      	uxtb	r3, r3
    3af4:	2b00      	cmp	r3, #0
    3af6:	d100      	bne.n	3afa <ext_irq_register+0xa6>
    3af8:	e07e      	b.n	3bf8 <ext_irq_register+0x1a4>
		for (i = 0; i < EXT_IRQ_AMOUNT; i++) {
    3afa:	2317      	movs	r3, #23
    3afc:	18fb      	adds	r3, r7, r3
    3afe:	2200      	movs	r2, #0
    3b00:	701a      	strb	r2, [r3, #0]
    3b02:	e023      	b.n	3b4c <ext_irq_register+0xf8>
			if (NULL == ext_irqs[i].cb) {
    3b04:	2317      	movs	r3, #23
    3b06:	18fb      	adds	r3, r7, r3
    3b08:	781a      	ldrb	r2, [r3, #0]
    3b0a:	4b46      	ldr	r3, [pc, #280]	; (3c24 <ext_irq_register+0x1d0>)
    3b0c:	00d2      	lsls	r2, r2, #3
    3b0e:	58d3      	ldr	r3, [r2, r3]
    3b10:	2b00      	cmp	r3, #0
    3b12:	d114      	bne.n	3b3e <ext_irq_register+0xea>
				ext_irqs[i].cb  = cb;
    3b14:	2317      	movs	r3, #23
    3b16:	18fb      	adds	r3, r7, r3
    3b18:	781a      	ldrb	r2, [r3, #0]
    3b1a:	4b42      	ldr	r3, [pc, #264]	; (3c24 <ext_irq_register+0x1d0>)
    3b1c:	00d2      	lsls	r2, r2, #3
    3b1e:	6839      	ldr	r1, [r7, #0]
    3b20:	50d1      	str	r1, [r2, r3]
				ext_irqs[i].pin = pin;
    3b22:	2317      	movs	r3, #23
    3b24:	18fb      	adds	r3, r7, r3
    3b26:	781b      	ldrb	r3, [r3, #0]
    3b28:	4a3e      	ldr	r2, [pc, #248]	; (3c24 <ext_irq_register+0x1d0>)
    3b2a:	00db      	lsls	r3, r3, #3
    3b2c:	18d3      	adds	r3, r2, r3
    3b2e:	3304      	adds	r3, #4
    3b30:	687a      	ldr	r2, [r7, #4]
    3b32:	601a      	str	r2, [r3, #0]
				found           = true;
    3b34:	2315      	movs	r3, #21
    3b36:	18fb      	adds	r3, r7, r3
    3b38:	2201      	movs	r2, #1
    3b3a:	701a      	strb	r2, [r3, #0]
				break;
    3b3c:	e00b      	b.n	3b56 <ext_irq_register+0x102>
		for (i = 0; i < EXT_IRQ_AMOUNT; i++) {
    3b3e:	2317      	movs	r3, #23
    3b40:	18fb      	adds	r3, r7, r3
    3b42:	781a      	ldrb	r2, [r3, #0]
    3b44:	2317      	movs	r3, #23
    3b46:	18fb      	adds	r3, r7, r3
    3b48:	3201      	adds	r2, #1
    3b4a:	701a      	strb	r2, [r3, #0]
    3b4c:	2317      	movs	r3, #23
    3b4e:	18fb      	adds	r3, r7, r3
    3b50:	781b      	ldrb	r3, [r3, #0]
    3b52:	2b02      	cmp	r3, #2
    3b54:	d9d6      	bls.n	3b04 <ext_irq_register+0xb0>
			}
		}
		for (; (j < EXT_IRQ_AMOUNT) && (i < EXT_IRQ_AMOUNT); j++) {
    3b56:	e045      	b.n	3be4 <ext_irq_register+0x190>
			if ((ext_irqs[i].pin < ext_irqs[j].pin) && (ext_irqs[j].pin != 0xFFFFFFFF)) {
    3b58:	2317      	movs	r3, #23
    3b5a:	18fb      	adds	r3, r7, r3
    3b5c:	781b      	ldrb	r3, [r3, #0]
    3b5e:	4a31      	ldr	r2, [pc, #196]	; (3c24 <ext_irq_register+0x1d0>)
    3b60:	00db      	lsls	r3, r3, #3
    3b62:	18d3      	adds	r3, r2, r3
    3b64:	3304      	adds	r3, #4
    3b66:	681a      	ldr	r2, [r3, #0]
    3b68:	2316      	movs	r3, #22
    3b6a:	18fb      	adds	r3, r7, r3
    3b6c:	781b      	ldrb	r3, [r3, #0]
    3b6e:	492d      	ldr	r1, [pc, #180]	; (3c24 <ext_irq_register+0x1d0>)
    3b70:	00db      	lsls	r3, r3, #3
    3b72:	18cb      	adds	r3, r1, r3
    3b74:	3304      	adds	r3, #4
    3b76:	681b      	ldr	r3, [r3, #0]
    3b78:	429a      	cmp	r2, r3
    3b7a:	d22c      	bcs.n	3bd6 <ext_irq_register+0x182>
    3b7c:	2316      	movs	r3, #22
    3b7e:	18fb      	adds	r3, r7, r3
    3b80:	781b      	ldrb	r3, [r3, #0]
    3b82:	4a28      	ldr	r2, [pc, #160]	; (3c24 <ext_irq_register+0x1d0>)
    3b84:	00db      	lsls	r3, r3, #3
    3b86:	18d3      	adds	r3, r2, r3
    3b88:	3304      	adds	r3, #4
    3b8a:	681b      	ldr	r3, [r3, #0]
    3b8c:	3301      	adds	r3, #1
    3b8e:	d022      	beq.n	3bd6 <ext_irq_register+0x182>
				struct ext_irq tmp = ext_irqs[j];
    3b90:	2316      	movs	r3, #22
    3b92:	18fb      	adds	r3, r7, r3
    3b94:	781b      	ldrb	r3, [r3, #0]
    3b96:	220c      	movs	r2, #12
    3b98:	18ba      	adds	r2, r7, r2
    3b9a:	4922      	ldr	r1, [pc, #136]	; (3c24 <ext_irq_register+0x1d0>)
    3b9c:	00db      	lsls	r3, r3, #3
    3b9e:	18cb      	adds	r3, r1, r3
    3ba0:	cb03      	ldmia	r3!, {r0, r1}
    3ba2:	c203      	stmia	r2!, {r0, r1}

				ext_irqs[j] = ext_irqs[i];
    3ba4:	2316      	movs	r3, #22
    3ba6:	18fb      	adds	r3, r7, r3
    3ba8:	781b      	ldrb	r3, [r3, #0]
    3baa:	2217      	movs	r2, #23
    3bac:	18ba      	adds	r2, r7, r2
    3bae:	7812      	ldrb	r2, [r2, #0]
    3bb0:	481c      	ldr	r0, [pc, #112]	; (3c24 <ext_irq_register+0x1d0>)
    3bb2:	00db      	lsls	r3, r3, #3
    3bb4:	491b      	ldr	r1, [pc, #108]	; (3c24 <ext_irq_register+0x1d0>)
    3bb6:	00d2      	lsls	r2, r2, #3
    3bb8:	18c3      	adds	r3, r0, r3
    3bba:	188a      	adds	r2, r1, r2
    3bbc:	ca03      	ldmia	r2!, {r0, r1}
    3bbe:	c303      	stmia	r3!, {r0, r1}
				ext_irqs[i] = tmp;
    3bc0:	2317      	movs	r3, #23
    3bc2:	18fb      	adds	r3, r7, r3
    3bc4:	781b      	ldrb	r3, [r3, #0]
    3bc6:	4a17      	ldr	r2, [pc, #92]	; (3c24 <ext_irq_register+0x1d0>)
    3bc8:	00db      	lsls	r3, r3, #3
    3bca:	210c      	movs	r1, #12
    3bcc:	1879      	adds	r1, r7, r1
    3bce:	18d3      	adds	r3, r2, r3
    3bd0:	000a      	movs	r2, r1
    3bd2:	ca03      	ldmia	r2!, {r0, r1}
    3bd4:	c303      	stmia	r3!, {r0, r1}
		for (; (j < EXT_IRQ_AMOUNT) && (i < EXT_IRQ_AMOUNT); j++) {
    3bd6:	2316      	movs	r3, #22
    3bd8:	18fb      	adds	r3, r7, r3
    3bda:	781a      	ldrb	r2, [r3, #0]
    3bdc:	2316      	movs	r3, #22
    3bde:	18fb      	adds	r3, r7, r3
    3be0:	3201      	adds	r2, #1
    3be2:	701a      	strb	r2, [r3, #0]
    3be4:	2316      	movs	r3, #22
    3be6:	18fb      	adds	r3, r7, r3
    3be8:	781b      	ldrb	r3, [r3, #0]
    3bea:	2b02      	cmp	r3, #2
    3bec:	d804      	bhi.n	3bf8 <ext_irq_register+0x1a4>
    3bee:	2317      	movs	r3, #23
    3bf0:	18fb      	adds	r3, r7, r3
    3bf2:	781b      	ldrb	r3, [r3, #0]
    3bf4:	2b02      	cmp	r3, #2
    3bf6:	d9af      	bls.n	3b58 <ext_irq_register+0x104>
			}
		}
	}

	if (!found) {
    3bf8:	2315      	movs	r3, #21
    3bfa:	18fb      	adds	r3, r7, r3
    3bfc:	781b      	ldrb	r3, [r3, #0]
    3bfe:	2201      	movs	r2, #1
    3c00:	4053      	eors	r3, r2
    3c02:	b2db      	uxtb	r3, r3
    3c04:	2b00      	cmp	r3, #0
    3c06:	d002      	beq.n	3c0e <ext_irq_register+0x1ba>
		return ERR_INVALID_ARG;
    3c08:	230d      	movs	r3, #13
    3c0a:	425b      	negs	r3, r3
    3c0c:	e005      	b.n	3c1a <ext_irq_register+0x1c6>
	}

	return _ext_irq_enable(pin, true);
    3c0e:	687b      	ldr	r3, [r7, #4]
    3c10:	2101      	movs	r1, #1
    3c12:	0018      	movs	r0, r3
    3c14:	f000 fd1c 	bl	4650 <_ext_irq_enable>
    3c18:	0003      	movs	r3, r0
}
    3c1a:	0018      	movs	r0, r3
    3c1c:	46bd      	mov	sp, r7
    3c1e:	b006      	add	sp, #24
    3c20:	bd80      	pop	{r7, pc}
    3c22:	46c0      	nop			; (mov r8, r8)
    3c24:	20000798 	.word	0x20000798

00003c28 <process_ext_irq>:
 * \brief Interrupt processing routine
 *
 * \param[in] pin The pin which triggered the interrupt
 */
static void process_ext_irq(const uint32_t pin)
{
    3c28:	b580      	push	{r7, lr}
    3c2a:	b084      	sub	sp, #16
    3c2c:	af00      	add	r7, sp, #0
    3c2e:	6078      	str	r0, [r7, #4]
	uint8_t lower = 0, middle, upper = EXT_IRQ_AMOUNT;
    3c30:	230f      	movs	r3, #15
    3c32:	18fb      	adds	r3, r7, r3
    3c34:	2200      	movs	r2, #0
    3c36:	701a      	strb	r2, [r3, #0]
    3c38:	230e      	movs	r3, #14
    3c3a:	18fb      	adds	r3, r7, r3
    3c3c:	2203      	movs	r2, #3
    3c3e:	701a      	strb	r2, [r3, #0]

	while (upper >= lower) {
    3c40:	e050      	b.n	3ce4 <process_ext_irq+0xbc>
		middle = (upper + lower) >> 1;
    3c42:	230e      	movs	r3, #14
    3c44:	18fb      	adds	r3, r7, r3
    3c46:	781a      	ldrb	r2, [r3, #0]
    3c48:	230f      	movs	r3, #15
    3c4a:	18fb      	adds	r3, r7, r3
    3c4c:	781b      	ldrb	r3, [r3, #0]
    3c4e:	18d3      	adds	r3, r2, r3
    3c50:	105a      	asrs	r2, r3, #1
    3c52:	230d      	movs	r3, #13
    3c54:	18fb      	adds	r3, r7, r3
    3c56:	701a      	strb	r2, [r3, #0]
		if (middle >= EXT_IRQ_AMOUNT) {
    3c58:	230d      	movs	r3, #13
    3c5a:	18fb      	adds	r3, r7, r3
    3c5c:	781b      	ldrb	r3, [r3, #0]
    3c5e:	2b02      	cmp	r3, #2
    3c60:	d849      	bhi.n	3cf6 <process_ext_irq+0xce>
			return;
		}

		if (ext_irqs[middle].pin == pin) {
    3c62:	230d      	movs	r3, #13
    3c64:	18fb      	adds	r3, r7, r3
    3c66:	781b      	ldrb	r3, [r3, #0]
    3c68:	4a26      	ldr	r2, [pc, #152]	; (3d04 <process_ext_irq+0xdc>)
    3c6a:	00db      	lsls	r3, r3, #3
    3c6c:	18d3      	adds	r3, r2, r3
    3c6e:	3304      	adds	r3, #4
    3c70:	681a      	ldr	r2, [r3, #0]
    3c72:	687b      	ldr	r3, [r7, #4]
    3c74:	429a      	cmp	r2, r3
    3c76:	d10f      	bne.n	3c98 <process_ext_irq+0x70>
			if (ext_irqs[middle].cb) {
    3c78:	230d      	movs	r3, #13
    3c7a:	18fb      	adds	r3, r7, r3
    3c7c:	781a      	ldrb	r2, [r3, #0]
    3c7e:	4b21      	ldr	r3, [pc, #132]	; (3d04 <process_ext_irq+0xdc>)
    3c80:	00d2      	lsls	r2, r2, #3
    3c82:	58d3      	ldr	r3, [r2, r3]
    3c84:	2b00      	cmp	r3, #0
    3c86:	d038      	beq.n	3cfa <process_ext_irq+0xd2>
				ext_irqs[middle].cb();
    3c88:	230d      	movs	r3, #13
    3c8a:	18fb      	adds	r3, r7, r3
    3c8c:	781a      	ldrb	r2, [r3, #0]
    3c8e:	4b1d      	ldr	r3, [pc, #116]	; (3d04 <process_ext_irq+0xdc>)
    3c90:	00d2      	lsls	r2, r2, #3
    3c92:	58d3      	ldr	r3, [r2, r3]
    3c94:	4798      	blx	r3
			}
			return;
    3c96:	e030      	b.n	3cfa <process_ext_irq+0xd2>
		}

		if (ext_irqs[middle].pin < pin) {
    3c98:	230d      	movs	r3, #13
    3c9a:	18fb      	adds	r3, r7, r3
    3c9c:	781b      	ldrb	r3, [r3, #0]
    3c9e:	4a19      	ldr	r2, [pc, #100]	; (3d04 <process_ext_irq+0xdc>)
    3ca0:	00db      	lsls	r3, r3, #3
    3ca2:	18d3      	adds	r3, r2, r3
    3ca4:	3304      	adds	r3, #4
    3ca6:	681a      	ldr	r2, [r3, #0]
    3ca8:	687b      	ldr	r3, [r7, #4]
    3caa:	429a      	cmp	r2, r3
    3cac:	d20d      	bcs.n	3cca <process_ext_irq+0xa2>
			lower = middle + 1;
    3cae:	230f      	movs	r3, #15
    3cb0:	18fb      	adds	r3, r7, r3
    3cb2:	220d      	movs	r2, #13
    3cb4:	18ba      	adds	r2, r7, r2
    3cb6:	7812      	ldrb	r2, [r2, #0]
    3cb8:	3201      	adds	r2, #1
    3cba:	701a      	strb	r2, [r3, #0]
    3cbc:	230e      	movs	r3, #14
    3cbe:	18fb      	adds	r3, r7, r3
    3cc0:	220e      	movs	r2, #14
    3cc2:	18ba      	adds	r2, r7, r2
    3cc4:	7812      	ldrb	r2, [r2, #0]
    3cc6:	701a      	strb	r2, [r3, #0]
    3cc8:	e00c      	b.n	3ce4 <process_ext_irq+0xbc>
		} else {
			upper = middle - 1;
    3cca:	230e      	movs	r3, #14
    3ccc:	18fb      	adds	r3, r7, r3
    3cce:	220d      	movs	r2, #13
    3cd0:	18ba      	adds	r2, r7, r2
    3cd2:	7812      	ldrb	r2, [r2, #0]
    3cd4:	3a01      	subs	r2, #1
    3cd6:	701a      	strb	r2, [r3, #0]
    3cd8:	230f      	movs	r3, #15
    3cda:	18fb      	adds	r3, r7, r3
    3cdc:	220f      	movs	r2, #15
    3cde:	18ba      	adds	r2, r7, r2
    3ce0:	7812      	ldrb	r2, [r2, #0]
    3ce2:	701a      	strb	r2, [r3, #0]
	while (upper >= lower) {
    3ce4:	230e      	movs	r3, #14
    3ce6:	18fa      	adds	r2, r7, r3
    3ce8:	230f      	movs	r3, #15
    3cea:	18fb      	adds	r3, r7, r3
    3cec:	7812      	ldrb	r2, [r2, #0]
    3cee:	781b      	ldrb	r3, [r3, #0]
    3cf0:	429a      	cmp	r2, r3
    3cf2:	d2a6      	bcs.n	3c42 <process_ext_irq+0x1a>
    3cf4:	e002      	b.n	3cfc <process_ext_irq+0xd4>
			return;
    3cf6:	46c0      	nop			; (mov r8, r8)
    3cf8:	e000      	b.n	3cfc <process_ext_irq+0xd4>
			return;
    3cfa:	46c0      	nop			; (mov r8, r8)
		}
	}
}
    3cfc:	46bd      	mov	sp, r7
    3cfe:	b004      	add	sp, #16
    3d00:	bd80      	pop	{r7, pc}
    3d02:	46c0      	nop			; (mov r8, r8)
    3d04:	20000798 	.word	0x20000798

00003d08 <io_write>:

/**
 * \brief I/O write interface
 */
int32_t io_write(struct io_descriptor *const io_descr, const uint8_t *const buf, const uint16_t length)
{
    3d08:	b580      	push	{r7, lr}
    3d0a:	b084      	sub	sp, #16
    3d0c:	af00      	add	r7, sp, #0
    3d0e:	60f8      	str	r0, [r7, #12]
    3d10:	60b9      	str	r1, [r7, #8]
    3d12:	1dbb      	adds	r3, r7, #6
    3d14:	801a      	strh	r2, [r3, #0]
	ASSERT(io_descr && buf);
    3d16:	68fb      	ldr	r3, [r7, #12]
    3d18:	2b00      	cmp	r3, #0
    3d1a:	d004      	beq.n	3d26 <io_write+0x1e>
    3d1c:	68bb      	ldr	r3, [r7, #8]
    3d1e:	2b00      	cmp	r3, #0
    3d20:	d001      	beq.n	3d26 <io_write+0x1e>
    3d22:	2301      	movs	r3, #1
    3d24:	e000      	b.n	3d28 <io_write+0x20>
    3d26:	2300      	movs	r3, #0
    3d28:	1c1a      	adds	r2, r3, #0
    3d2a:	2301      	movs	r3, #1
    3d2c:	4013      	ands	r3, r2
    3d2e:	b2db      	uxtb	r3, r3
    3d30:	4908      	ldr	r1, [pc, #32]	; (3d54 <io_write+0x4c>)
    3d32:	2234      	movs	r2, #52	; 0x34
    3d34:	0018      	movs	r0, r3
    3d36:	f000 fa27 	bl	4188 <assert>
	return io_descr->write(io_descr, buf, length);
    3d3a:	68fb      	ldr	r3, [r7, #12]
    3d3c:	681b      	ldr	r3, [r3, #0]
    3d3e:	1dba      	adds	r2, r7, #6
    3d40:	8812      	ldrh	r2, [r2, #0]
    3d42:	68b9      	ldr	r1, [r7, #8]
    3d44:	68f8      	ldr	r0, [r7, #12]
    3d46:	4798      	blx	r3
    3d48:	0003      	movs	r3, r0
}
    3d4a:	0018      	movs	r0, r3
    3d4c:	46bd      	mov	sp, r7
    3d4e:	b004      	add	sp, #16
    3d50:	bd80      	pop	{r7, pc}
    3d52:	46c0      	nop			; (mov r8, r8)
    3d54:	00007dac 	.word	0x00007dac

00003d58 <io_read>:

/**
 * \brief I/O read interface
 */
int32_t io_read(struct io_descriptor *const io_descr, uint8_t *const buf, const uint16_t length)
{
    3d58:	b580      	push	{r7, lr}
    3d5a:	b084      	sub	sp, #16
    3d5c:	af00      	add	r7, sp, #0
    3d5e:	60f8      	str	r0, [r7, #12]
    3d60:	60b9      	str	r1, [r7, #8]
    3d62:	1dbb      	adds	r3, r7, #6
    3d64:	801a      	strh	r2, [r3, #0]
	ASSERT(io_descr && buf);
    3d66:	68fb      	ldr	r3, [r7, #12]
    3d68:	2b00      	cmp	r3, #0
    3d6a:	d004      	beq.n	3d76 <io_read+0x1e>
    3d6c:	68bb      	ldr	r3, [r7, #8]
    3d6e:	2b00      	cmp	r3, #0
    3d70:	d001      	beq.n	3d76 <io_read+0x1e>
    3d72:	2301      	movs	r3, #1
    3d74:	e000      	b.n	3d78 <io_read+0x20>
    3d76:	2300      	movs	r3, #0
    3d78:	1c1a      	adds	r2, r3, #0
    3d7a:	2301      	movs	r3, #1
    3d7c:	4013      	ands	r3, r2
    3d7e:	b2db      	uxtb	r3, r3
    3d80:	4908      	ldr	r1, [pc, #32]	; (3da4 <io_read+0x4c>)
    3d82:	223d      	movs	r2, #61	; 0x3d
    3d84:	0018      	movs	r0, r3
    3d86:	f000 f9ff 	bl	4188 <assert>
	return io_descr->read(io_descr, buf, length);
    3d8a:	68fb      	ldr	r3, [r7, #12]
    3d8c:	685b      	ldr	r3, [r3, #4]
    3d8e:	1dba      	adds	r2, r7, #6
    3d90:	8812      	ldrh	r2, [r2, #0]
    3d92:	68b9      	ldr	r1, [r7, #8]
    3d94:	68f8      	ldr	r0, [r7, #12]
    3d96:	4798      	blx	r3
    3d98:	0003      	movs	r3, r0
}
    3d9a:	0018      	movs	r0, r3
    3d9c:	46bd      	mov	sp, r7
    3d9e:	b004      	add	sp, #16
    3da0:	bd80      	pop	{r7, pc}
    3da2:	46c0      	nop			; (mov r8, r8)
    3da4:	00007dac 	.word	0x00007dac

00003da8 <spi_m_sync_init>:
	ASSERT(spi);
	spi->func = (struct _spi_m_sync_hpl_interface *)func;
}

int32_t spi_m_sync_init(struct spi_m_sync_descriptor *spi, void *const hw)
{
    3da8:	b580      	push	{r7, lr}
    3daa:	b084      	sub	sp, #16
    3dac:	af00      	add	r7, sp, #0
    3dae:	6078      	str	r0, [r7, #4]
    3db0:	6039      	str	r1, [r7, #0]
	int32_t rc = 0;
    3db2:	2300      	movs	r3, #0
    3db4:	60fb      	str	r3, [r7, #12]
	ASSERT(spi && hw);
    3db6:	687b      	ldr	r3, [r7, #4]
    3db8:	2b00      	cmp	r3, #0
    3dba:	d004      	beq.n	3dc6 <spi_m_sync_init+0x1e>
    3dbc:	683b      	ldr	r3, [r7, #0]
    3dbe:	2b00      	cmp	r3, #0
    3dc0:	d001      	beq.n	3dc6 <spi_m_sync_init+0x1e>
    3dc2:	2301      	movs	r3, #1
    3dc4:	e000      	b.n	3dc8 <spi_m_sync_init+0x20>
    3dc6:	2300      	movs	r3, #0
    3dc8:	1c1a      	adds	r2, r3, #0
    3dca:	2301      	movs	r3, #1
    3dcc:	4013      	ands	r3, r2
    3dce:	b2db      	uxtb	r3, r3
    3dd0:	4911      	ldr	r1, [pc, #68]	; (3e18 <spi_m_sync_init+0x70>)
    3dd2:	2240      	movs	r2, #64	; 0x40
    3dd4:	0018      	movs	r0, r3
    3dd6:	f000 f9d7 	bl	4188 <assert>
	spi->dev.prvt = (void *)hw;
    3dda:	687b      	ldr	r3, [r7, #4]
    3ddc:	683a      	ldr	r2, [r7, #0]
    3dde:	605a      	str	r2, [r3, #4]
	rc            = _spi_m_sync_init(&spi->dev, hw);
    3de0:	687b      	ldr	r3, [r7, #4]
    3de2:	3304      	adds	r3, #4
    3de4:	683a      	ldr	r2, [r7, #0]
    3de6:	0011      	movs	r1, r2
    3de8:	0018      	movs	r0, r3
    3dea:	f001 f9fd 	bl	51e8 <_spi_m_sync_init>
    3dee:	0003      	movs	r3, r0
    3df0:	60fb      	str	r3, [r7, #12]

	if (rc < 0) {
    3df2:	68fb      	ldr	r3, [r7, #12]
    3df4:	2b00      	cmp	r3, #0
    3df6:	da01      	bge.n	3dfc <spi_m_sync_init+0x54>
		return rc;
    3df8:	68fb      	ldr	r3, [r7, #12]
    3dfa:	e009      	b.n	3e10 <spi_m_sync_init+0x68>
	}

	spi->flags    = SPI_DEACTIVATE_NEXT;
    3dfc:	687b      	ldr	r3, [r7, #4]
    3dfe:	4a07      	ldr	r2, [pc, #28]	; (3e1c <spi_m_sync_init+0x74>)
    3e00:	829a      	strh	r2, [r3, #20]
	spi->io.read  = _spi_m_sync_io_read;
    3e02:	687b      	ldr	r3, [r7, #4]
    3e04:	4a06      	ldr	r2, [pc, #24]	; (3e20 <spi_m_sync_init+0x78>)
    3e06:	611a      	str	r2, [r3, #16]
	spi->io.write = _spi_m_sync_io_write;
    3e08:	687b      	ldr	r3, [r7, #4]
    3e0a:	4a06      	ldr	r2, [pc, #24]	; (3e24 <spi_m_sync_init+0x7c>)
    3e0c:	60da      	str	r2, [r3, #12]

	return ERR_NONE;
    3e0e:	2300      	movs	r3, #0
}
    3e10:	0018      	movs	r0, r3
    3e12:	46bd      	mov	sp, r7
    3e14:	b004      	add	sp, #16
    3e16:	bd80      	pop	{r7, pc}
    3e18:	00007dc0 	.word	0x00007dc0
    3e1c:	ffff8000 	.word	0xffff8000
    3e20:	00003e59 	.word	0x00003e59
    3e24:	00003eb5 	.word	0x00003eb5

00003e28 <spi_m_sync_enable>:
	ASSERT(spi);
	_spi_m_sync_deinit(&spi->dev);
}

void spi_m_sync_enable(struct spi_m_sync_descriptor *spi)
{
    3e28:	b580      	push	{r7, lr}
    3e2a:	b082      	sub	sp, #8
    3e2c:	af00      	add	r7, sp, #0
    3e2e:	6078      	str	r0, [r7, #4]
	ASSERT(spi);
    3e30:	687b      	ldr	r3, [r7, #4]
    3e32:	1e5a      	subs	r2, r3, #1
    3e34:	4193      	sbcs	r3, r2
    3e36:	b2db      	uxtb	r3, r3
    3e38:	4906      	ldr	r1, [pc, #24]	; (3e54 <spi_m_sync_enable+0x2c>)
    3e3a:	2257      	movs	r2, #87	; 0x57
    3e3c:	0018      	movs	r0, r3
    3e3e:	f000 f9a3 	bl	4188 <assert>
	_spi_m_sync_enable(&spi->dev);
    3e42:	687b      	ldr	r3, [r7, #4]
    3e44:	3304      	adds	r3, #4
    3e46:	0018      	movs	r0, r3
    3e48:	f001 fa4c 	bl	52e4 <_spi_m_sync_enable>
}
    3e4c:	46c0      	nop			; (mov r8, r8)
    3e4e:	46bd      	mov	sp, r7
    3e50:	b002      	add	sp, #8
    3e52:	bd80      	pop	{r7, pc}
    3e54:	00007dc0 	.word	0x00007dc0

00003e58 <_spi_m_sync_io_read>:
 *  \return Operation status.
 *  \retval size Success.
 *  \retval >=0 Time out, with number of characters read.
 */
static int32_t _spi_m_sync_io_read(struct io_descriptor *io, uint8_t *buf, const uint16_t length)
{
    3e58:	b580      	push	{r7, lr}
    3e5a:	b088      	sub	sp, #32
    3e5c:	af00      	add	r7, sp, #0
    3e5e:	60f8      	str	r0, [r7, #12]
    3e60:	60b9      	str	r1, [r7, #8]
    3e62:	1dbb      	adds	r3, r7, #6
    3e64:	801a      	strh	r2, [r3, #0]
	ASSERT(io);
    3e66:	68fb      	ldr	r3, [r7, #12]
    3e68:	1e5a      	subs	r2, r3, #1
    3e6a:	4193      	sbcs	r3, r2
    3e6c:	b2db      	uxtb	r3, r3
    3e6e:	4910      	ldr	r1, [pc, #64]	; (3eb0 <_spi_m_sync_io_read+0x58>)
    3e70:	2287      	movs	r2, #135	; 0x87
    3e72:	0018      	movs	r0, r3
    3e74:	f000 f988 	bl	4188 <assert>

	struct spi_m_sync_descriptor *spi = CONTAINER_OF(io, struct spi_m_sync_descriptor, io);
    3e78:	68fb      	ldr	r3, [r7, #12]
    3e7a:	3b0c      	subs	r3, #12
    3e7c:	61fb      	str	r3, [r7, #28]
	struct spi_xfer               xfer;

	xfer.rxbuf = buf;
    3e7e:	2310      	movs	r3, #16
    3e80:	18fb      	adds	r3, r7, r3
    3e82:	68ba      	ldr	r2, [r7, #8]
    3e84:	605a      	str	r2, [r3, #4]
	xfer.txbuf = 0;
    3e86:	2310      	movs	r3, #16
    3e88:	18fb      	adds	r3, r7, r3
    3e8a:	2200      	movs	r2, #0
    3e8c:	601a      	str	r2, [r3, #0]
	xfer.size  = length;
    3e8e:	1dbb      	adds	r3, r7, #6
    3e90:	881a      	ldrh	r2, [r3, #0]
    3e92:	2310      	movs	r3, #16
    3e94:	18fb      	adds	r3, r7, r3
    3e96:	609a      	str	r2, [r3, #8]

	return spi_m_sync_transfer(spi, &xfer);
    3e98:	2310      	movs	r3, #16
    3e9a:	18fa      	adds	r2, r7, r3
    3e9c:	69fb      	ldr	r3, [r7, #28]
    3e9e:	0011      	movs	r1, r2
    3ea0:	0018      	movs	r0, r3
    3ea2:	f000 f835 	bl	3f10 <spi_m_sync_transfer>
    3ea6:	0003      	movs	r3, r0
}
    3ea8:	0018      	movs	r0, r3
    3eaa:	46bd      	mov	sp, r7
    3eac:	b008      	add	sp, #32
    3eae:	bd80      	pop	{r7, pc}
    3eb0:	00007dc0 	.word	0x00007dc0

00003eb4 <_spi_m_sync_io_write>:
 *  \return Operation status.
 *  \retval size Success.
 *  \retval >=0 Timeout, with number of characters transferred.
 */
static int32_t _spi_m_sync_io_write(struct io_descriptor *const io, const uint8_t *const buf, const uint16_t length)
{
    3eb4:	b580      	push	{r7, lr}
    3eb6:	b088      	sub	sp, #32
    3eb8:	af00      	add	r7, sp, #0
    3eba:	60f8      	str	r0, [r7, #12]
    3ebc:	60b9      	str	r1, [r7, #8]
    3ebe:	1dbb      	adds	r3, r7, #6
    3ec0:	801a      	strh	r2, [r3, #0]
	ASSERT(io);
    3ec2:	68fb      	ldr	r3, [r7, #12]
    3ec4:	1e5a      	subs	r2, r3, #1
    3ec6:	4193      	sbcs	r3, r2
    3ec8:	b2db      	uxtb	r3, r3
    3eca:	4910      	ldr	r1, [pc, #64]	; (3f0c <_spi_m_sync_io_write+0x58>)
    3ecc:	22a3      	movs	r2, #163	; 0xa3
    3ece:	0018      	movs	r0, r3
    3ed0:	f000 f95a 	bl	4188 <assert>

	struct spi_m_sync_descriptor *spi = CONTAINER_OF(io, struct spi_m_sync_descriptor, io);
    3ed4:	68fb      	ldr	r3, [r7, #12]
    3ed6:	3b0c      	subs	r3, #12
    3ed8:	61fb      	str	r3, [r7, #28]
	struct spi_xfer               xfer;

	xfer.rxbuf = 0;
    3eda:	2310      	movs	r3, #16
    3edc:	18fb      	adds	r3, r7, r3
    3ede:	2200      	movs	r2, #0
    3ee0:	605a      	str	r2, [r3, #4]
	xfer.txbuf = (uint8_t *)buf;
    3ee2:	2310      	movs	r3, #16
    3ee4:	18fb      	adds	r3, r7, r3
    3ee6:	68ba      	ldr	r2, [r7, #8]
    3ee8:	601a      	str	r2, [r3, #0]
	xfer.size  = length;
    3eea:	1dbb      	adds	r3, r7, #6
    3eec:	881a      	ldrh	r2, [r3, #0]
    3eee:	2310      	movs	r3, #16
    3ef0:	18fb      	adds	r3, r7, r3
    3ef2:	609a      	str	r2, [r3, #8]

	return spi_m_sync_transfer(spi, &xfer);
    3ef4:	2310      	movs	r3, #16
    3ef6:	18fa      	adds	r2, r7, r3
    3ef8:	69fb      	ldr	r3, [r7, #28]
    3efa:	0011      	movs	r1, r2
    3efc:	0018      	movs	r0, r3
    3efe:	f000 f807 	bl	3f10 <spi_m_sync_transfer>
    3f02:	0003      	movs	r3, r0
}
    3f04:	0018      	movs	r0, r3
    3f06:	46bd      	mov	sp, r7
    3f08:	b008      	add	sp, #32
    3f0a:	bd80      	pop	{r7, pc}
    3f0c:	00007dc0 	.word	0x00007dc0

00003f10 <spi_m_sync_transfer>:

int32_t spi_m_sync_transfer(struct spi_m_sync_descriptor *spi, const struct spi_xfer *p_xfer)
{
    3f10:	b580      	push	{r7, lr}
    3f12:	b086      	sub	sp, #24
    3f14:	af00      	add	r7, sp, #0
    3f16:	6078      	str	r0, [r7, #4]
    3f18:	6039      	str	r1, [r7, #0]
	struct spi_msg msg;

	ASSERT(spi && p_xfer);
    3f1a:	687b      	ldr	r3, [r7, #4]
    3f1c:	2b00      	cmp	r3, #0
    3f1e:	d004      	beq.n	3f2a <spi_m_sync_transfer+0x1a>
    3f20:	683b      	ldr	r3, [r7, #0]
    3f22:	2b00      	cmp	r3, #0
    3f24:	d001      	beq.n	3f2a <spi_m_sync_transfer+0x1a>
    3f26:	2301      	movs	r3, #1
    3f28:	e000      	b.n	3f2c <spi_m_sync_transfer+0x1c>
    3f2a:	2300      	movs	r3, #0
    3f2c:	1c1a      	adds	r2, r3, #0
    3f2e:	2301      	movs	r3, #1
    3f30:	4013      	ands	r3, r2
    3f32:	b2db      	uxtb	r3, r3
    3f34:	4910      	ldr	r1, [pc, #64]	; (3f78 <spi_m_sync_transfer+0x68>)
    3f36:	22b3      	movs	r2, #179	; 0xb3
    3f38:	0018      	movs	r0, r3
    3f3a:	f000 f925 	bl	4188 <assert>

	msg.txbuf = p_xfer->txbuf;
    3f3e:	683b      	ldr	r3, [r7, #0]
    3f40:	681a      	ldr	r2, [r3, #0]
    3f42:	230c      	movs	r3, #12
    3f44:	18fb      	adds	r3, r7, r3
    3f46:	601a      	str	r2, [r3, #0]
	msg.rxbuf = p_xfer->rxbuf;
    3f48:	683b      	ldr	r3, [r7, #0]
    3f4a:	685a      	ldr	r2, [r3, #4]
    3f4c:	230c      	movs	r3, #12
    3f4e:	18fb      	adds	r3, r7, r3
    3f50:	605a      	str	r2, [r3, #4]
	msg.size  = p_xfer->size;
    3f52:	683b      	ldr	r3, [r7, #0]
    3f54:	689a      	ldr	r2, [r3, #8]
    3f56:	230c      	movs	r3, #12
    3f58:	18fb      	adds	r3, r7, r3
    3f5a:	609a      	str	r2, [r3, #8]
	return _spi_m_sync_trans(&spi->dev, &msg);
    3f5c:	687b      	ldr	r3, [r7, #4]
    3f5e:	3304      	adds	r3, #4
    3f60:	220c      	movs	r2, #12
    3f62:	18ba      	adds	r2, r7, r2
    3f64:	0011      	movs	r1, r2
    3f66:	0018      	movs	r0, r3
    3f68:	f001 fa68 	bl	543c <_spi_m_sync_trans>
    3f6c:	0003      	movs	r3, r0
}
    3f6e:	0018      	movs	r0, r3
    3f70:	46bd      	mov	sp, r7
    3f72:	b006      	add	sp, #24
    3f74:	bd80      	pop	{r7, pc}
    3f76:	46c0      	nop			; (mov r8, r8)
    3f78:	00007dc0 	.word	0x00007dc0

00003f7c <spi_m_sync_get_io_descriptor>:

int32_t spi_m_sync_get_io_descriptor(struct spi_m_sync_descriptor *const spi, struct io_descriptor **io)
{
    3f7c:	b580      	push	{r7, lr}
    3f7e:	b082      	sub	sp, #8
    3f80:	af00      	add	r7, sp, #0
    3f82:	6078      	str	r0, [r7, #4]
    3f84:	6039      	str	r1, [r7, #0]
	ASSERT(spi && io);
    3f86:	687b      	ldr	r3, [r7, #4]
    3f88:	2b00      	cmp	r3, #0
    3f8a:	d004      	beq.n	3f96 <spi_m_sync_get_io_descriptor+0x1a>
    3f8c:	683b      	ldr	r3, [r7, #0]
    3f8e:	2b00      	cmp	r3, #0
    3f90:	d001      	beq.n	3f96 <spi_m_sync_get_io_descriptor+0x1a>
    3f92:	2301      	movs	r3, #1
    3f94:	e000      	b.n	3f98 <spi_m_sync_get_io_descriptor+0x1c>
    3f96:	2300      	movs	r3, #0
    3f98:	1c1a      	adds	r2, r3, #0
    3f9a:	2301      	movs	r3, #1
    3f9c:	4013      	ands	r3, r2
    3f9e:	b2db      	uxtb	r3, r3
    3fa0:	4907      	ldr	r1, [pc, #28]	; (3fc0 <spi_m_sync_get_io_descriptor+0x44>)
    3fa2:	22bd      	movs	r2, #189	; 0xbd
    3fa4:	0018      	movs	r0, r3
    3fa6:	f000 f8ef 	bl	4188 <assert>
	*io = &spi->io;
    3faa:	687b      	ldr	r3, [r7, #4]
    3fac:	330c      	adds	r3, #12
    3fae:	001a      	movs	r2, r3
    3fb0:	683b      	ldr	r3, [r7, #0]
    3fb2:	601a      	str	r2, [r3, #0]
	return 0;
    3fb4:	2300      	movs	r3, #0
}
    3fb6:	0018      	movs	r0, r3
    3fb8:	46bd      	mov	sp, r7
    3fba:	b002      	add	sp, #8
    3fbc:	bd80      	pop	{r7, pc}
    3fbe:	46c0      	nop			; (mov r8, r8)
    3fc0:	00007dc0 	.word	0x00007dc0

00003fc4 <usart_sync_init>:

/**
 * \brief Initialize usart interface
 */
int32_t usart_sync_init(struct usart_sync_descriptor *const descr, void *const hw, void *const func)
{
    3fc4:	b580      	push	{r7, lr}
    3fc6:	b086      	sub	sp, #24
    3fc8:	af00      	add	r7, sp, #0
    3fca:	60f8      	str	r0, [r7, #12]
    3fcc:	60b9      	str	r1, [r7, #8]
    3fce:	607a      	str	r2, [r7, #4]
	int32_t init_status;
	ASSERT(descr && hw);
    3fd0:	68fb      	ldr	r3, [r7, #12]
    3fd2:	2b00      	cmp	r3, #0
    3fd4:	d004      	beq.n	3fe0 <usart_sync_init+0x1c>
    3fd6:	68bb      	ldr	r3, [r7, #8]
    3fd8:	2b00      	cmp	r3, #0
    3fda:	d001      	beq.n	3fe0 <usart_sync_init+0x1c>
    3fdc:	2301      	movs	r3, #1
    3fde:	e000      	b.n	3fe2 <usart_sync_init+0x1e>
    3fe0:	2300      	movs	r3, #0
    3fe2:	1c1a      	adds	r2, r3, #0
    3fe4:	2301      	movs	r3, #1
    3fe6:	4013      	ands	r3, r2
    3fe8:	b2db      	uxtb	r3, r3
    3fea:	490f      	ldr	r1, [pc, #60]	; (4028 <usart_sync_init+0x64>)
    3fec:	2234      	movs	r2, #52	; 0x34
    3fee:	0018      	movs	r0, r3
    3ff0:	f000 f8ca 	bl	4188 <assert>
	init_status = _usart_sync_init(&descr->device, hw);
    3ff4:	68fb      	ldr	r3, [r7, #12]
    3ff6:	3308      	adds	r3, #8
    3ff8:	68ba      	ldr	r2, [r7, #8]
    3ffa:	0011      	movs	r1, r2
    3ffc:	0018      	movs	r0, r3
    3ffe:	f000 fec7 	bl	4d90 <_usart_sync_init>
    4002:	0003      	movs	r3, r0
    4004:	617b      	str	r3, [r7, #20]
	if (init_status) {
    4006:	697b      	ldr	r3, [r7, #20]
    4008:	2b00      	cmp	r3, #0
    400a:	d001      	beq.n	4010 <usart_sync_init+0x4c>
		return init_status;
    400c:	697b      	ldr	r3, [r7, #20]
    400e:	e006      	b.n	401e <usart_sync_init+0x5a>
	}

	descr->io.read  = usart_sync_read;
    4010:	68fb      	ldr	r3, [r7, #12]
    4012:	4a06      	ldr	r2, [pc, #24]	; (402c <usart_sync_init+0x68>)
    4014:	605a      	str	r2, [r3, #4]
	descr->io.write = usart_sync_write;
    4016:	68fb      	ldr	r3, [r7, #12]
    4018:	4a05      	ldr	r2, [pc, #20]	; (4030 <usart_sync_init+0x6c>)
    401a:	601a      	str	r2, [r3, #0]

	return ERR_NONE;
    401c:	2300      	movs	r3, #0
}
    401e:	0018      	movs	r0, r3
    4020:	46bd      	mov	sp, r7
    4022:	b006      	add	sp, #24
    4024:	bd80      	pop	{r7, pc}
    4026:	46c0      	nop			; (mov r8, r8)
    4028:	00007ddc 	.word	0x00007ddc
    402c:	000040f9 	.word	0x000040f9
    4030:	00004035 	.word	0x00004035

00004034 <usart_sync_write>:
 * \param[in] length The number of bytes to write
 *
 * \return The number of bytes written.
 */
static int32_t usart_sync_write(struct io_descriptor *const io_descr, const uint8_t *const buf, const uint16_t length)
{
    4034:	b580      	push	{r7, lr}
    4036:	b086      	sub	sp, #24
    4038:	af00      	add	r7, sp, #0
    403a:	60f8      	str	r0, [r7, #12]
    403c:	60b9      	str	r1, [r7, #8]
    403e:	1dbb      	adds	r3, r7, #6
    4040:	801a      	strh	r2, [r3, #0]
	uint32_t                      offset = 0;
    4042:	2300      	movs	r3, #0
    4044:	617b      	str	r3, [r7, #20]
	struct usart_sync_descriptor *descr  = CONTAINER_OF(io_descr, struct usart_sync_descriptor, io);
    4046:	68fb      	ldr	r3, [r7, #12]
    4048:	613b      	str	r3, [r7, #16]

	ASSERT(io_descr && buf && length);
    404a:	68fb      	ldr	r3, [r7, #12]
    404c:	2b00      	cmp	r3, #0
    404e:	d008      	beq.n	4062 <usart_sync_write+0x2e>
    4050:	68bb      	ldr	r3, [r7, #8]
    4052:	2b00      	cmp	r3, #0
    4054:	d005      	beq.n	4062 <usart_sync_write+0x2e>
    4056:	1dbb      	adds	r3, r7, #6
    4058:	881b      	ldrh	r3, [r3, #0]
    405a:	2b00      	cmp	r3, #0
    405c:	d001      	beq.n	4062 <usart_sync_write+0x2e>
    405e:	2301      	movs	r3, #1
    4060:	e000      	b.n	4064 <usart_sync_write+0x30>
    4062:	2300      	movs	r3, #0
    4064:	1c1a      	adds	r2, r3, #0
    4066:	2301      	movs	r3, #1
    4068:	4013      	ands	r3, r2
    406a:	b2db      	uxtb	r3, r3
    406c:	4921      	ldr	r1, [pc, #132]	; (40f4 <usart_sync_write+0xc0>)
    406e:	22f1      	movs	r2, #241	; 0xf1
    4070:	0018      	movs	r0, r3
    4072:	f000 f889 	bl	4188 <assert>
	while (!_usart_sync_is_ready_to_send(&descr->device))
    4076:	46c0      	nop			; (mov r8, r8)
    4078:	693b      	ldr	r3, [r7, #16]
    407a:	3308      	adds	r3, #8
    407c:	0018      	movs	r0, r3
    407e:	f000 fec6 	bl	4e0e <_usart_sync_is_ready_to_send>
    4082:	0003      	movs	r3, r0
    4084:	001a      	movs	r2, r3
    4086:	2301      	movs	r3, #1
    4088:	4053      	eors	r3, r2
    408a:	b2db      	uxtb	r3, r3
    408c:	2b00      	cmp	r3, #0
    408e:	d1f3      	bne.n	4078 <usart_sync_write+0x44>
		;
	do {
		_usart_sync_write_byte(&descr->device, buf[offset]);
    4090:	693b      	ldr	r3, [r7, #16]
    4092:	3308      	adds	r3, #8
    4094:	0018      	movs	r0, r3
    4096:	68ba      	ldr	r2, [r7, #8]
    4098:	697b      	ldr	r3, [r7, #20]
    409a:	18d3      	adds	r3, r2, r3
    409c:	781b      	ldrb	r3, [r3, #0]
    409e:	0019      	movs	r1, r3
    40a0:	f000 fe92 	bl	4dc8 <_usart_sync_write_byte>
		while (!_usart_sync_is_ready_to_send(&descr->device))
    40a4:	46c0      	nop			; (mov r8, r8)
    40a6:	693b      	ldr	r3, [r7, #16]
    40a8:	3308      	adds	r3, #8
    40aa:	0018      	movs	r0, r3
    40ac:	f000 feaf 	bl	4e0e <_usart_sync_is_ready_to_send>
    40b0:	0003      	movs	r3, r0
    40b2:	001a      	movs	r2, r3
    40b4:	2301      	movs	r3, #1
    40b6:	4053      	eors	r3, r2
    40b8:	b2db      	uxtb	r3, r3
    40ba:	2b00      	cmp	r3, #0
    40bc:	d1f3      	bne.n	40a6 <usart_sync_write+0x72>
			;
	} while (++offset < length);
    40be:	697b      	ldr	r3, [r7, #20]
    40c0:	3301      	adds	r3, #1
    40c2:	617b      	str	r3, [r7, #20]
    40c4:	1dbb      	adds	r3, r7, #6
    40c6:	881b      	ldrh	r3, [r3, #0]
    40c8:	697a      	ldr	r2, [r7, #20]
    40ca:	429a      	cmp	r2, r3
    40cc:	d3e0      	bcc.n	4090 <usart_sync_write+0x5c>
	while (!_usart_sync_is_transmit_done(&descr->device))
    40ce:	46c0      	nop			; (mov r8, r8)
    40d0:	693b      	ldr	r3, [r7, #16]
    40d2:	3308      	adds	r3, #8
    40d4:	0018      	movs	r0, r3
    40d6:	f000 fea8 	bl	4e2a <_usart_sync_is_transmit_done>
    40da:	0003      	movs	r3, r0
    40dc:	001a      	movs	r2, r3
    40de:	2301      	movs	r3, #1
    40e0:	4053      	eors	r3, r2
    40e2:	b2db      	uxtb	r3, r3
    40e4:	2b00      	cmp	r3, #0
    40e6:	d1f3      	bne.n	40d0 <usart_sync_write+0x9c>
		;
	return (int32_t)offset;
    40e8:	697b      	ldr	r3, [r7, #20]
}
    40ea:	0018      	movs	r0, r3
    40ec:	46bd      	mov	sp, r7
    40ee:	b006      	add	sp, #24
    40f0:	bd80      	pop	{r7, pc}
    40f2:	46c0      	nop			; (mov r8, r8)
    40f4:	00007ddc 	.word	0x00007ddc

000040f8 <usart_sync_read>:
 * \param[in] length The size of a buffer
 *
 * \return The number of bytes read.
 */
static int32_t usart_sync_read(struct io_descriptor *const io_descr, uint8_t *const buf, const uint16_t length)
{
    40f8:	b590      	push	{r4, r7, lr}
    40fa:	b087      	sub	sp, #28
    40fc:	af00      	add	r7, sp, #0
    40fe:	60f8      	str	r0, [r7, #12]
    4100:	60b9      	str	r1, [r7, #8]
    4102:	1dbb      	adds	r3, r7, #6
    4104:	801a      	strh	r2, [r3, #0]
	uint32_t                      offset = 0;
    4106:	2300      	movs	r3, #0
    4108:	617b      	str	r3, [r7, #20]
	struct usart_sync_descriptor *descr  = CONTAINER_OF(io_descr, struct usart_sync_descriptor, io);
    410a:	68fb      	ldr	r3, [r7, #12]
    410c:	613b      	str	r3, [r7, #16]

	ASSERT(io_descr && buf && length);
    410e:	68fb      	ldr	r3, [r7, #12]
    4110:	2b00      	cmp	r3, #0
    4112:	d008      	beq.n	4126 <usart_sync_read+0x2e>
    4114:	68bb      	ldr	r3, [r7, #8]
    4116:	2b00      	cmp	r3, #0
    4118:	d005      	beq.n	4126 <usart_sync_read+0x2e>
    411a:	1dbb      	adds	r3, r7, #6
    411c:	881b      	ldrh	r3, [r3, #0]
    411e:	2b00      	cmp	r3, #0
    4120:	d001      	beq.n	4126 <usart_sync_read+0x2e>
    4122:	2301      	movs	r3, #1
    4124:	e000      	b.n	4128 <usart_sync_read+0x30>
    4126:	2300      	movs	r3, #0
    4128:	1c1a      	adds	r2, r3, #0
    412a:	2301      	movs	r3, #1
    412c:	4013      	ands	r3, r2
    412e:	b2d8      	uxtb	r0, r3
    4130:	2386      	movs	r3, #134	; 0x86
    4132:	005a      	lsls	r2, r3, #1
    4134:	4b13      	ldr	r3, [pc, #76]	; (4184 <usart_sync_read+0x8c>)
    4136:	0019      	movs	r1, r3
    4138:	f000 f826 	bl	4188 <assert>
	do {
		while (!_usart_sync_is_byte_received(&descr->device))
    413c:	46c0      	nop			; (mov r8, r8)
    413e:	693b      	ldr	r3, [r7, #16]
    4140:	3308      	adds	r3, #8
    4142:	0018      	movs	r0, r3
    4144:	f000 fe7f 	bl	4e46 <_usart_sync_is_byte_received>
    4148:	0003      	movs	r3, r0
    414a:	001a      	movs	r2, r3
    414c:	2301      	movs	r3, #1
    414e:	4053      	eors	r3, r2
    4150:	b2db      	uxtb	r3, r3
    4152:	2b00      	cmp	r3, #0
    4154:	d1f3      	bne.n	413e <usart_sync_read+0x46>
			;
		buf[offset] = _usart_sync_read_byte(&descr->device);
    4156:	68ba      	ldr	r2, [r7, #8]
    4158:	697b      	ldr	r3, [r7, #20]
    415a:	18d4      	adds	r4, r2, r3
    415c:	693b      	ldr	r3, [r7, #16]
    415e:	3308      	adds	r3, #8
    4160:	0018      	movs	r0, r3
    4162:	f000 fe45 	bl	4df0 <_usart_sync_read_byte>
    4166:	0003      	movs	r3, r0
    4168:	7023      	strb	r3, [r4, #0]
	} while (++offset < length);
    416a:	697b      	ldr	r3, [r7, #20]
    416c:	3301      	adds	r3, #1
    416e:	617b      	str	r3, [r7, #20]
    4170:	1dbb      	adds	r3, r7, #6
    4172:	881b      	ldrh	r3, [r3, #0]
    4174:	697a      	ldr	r2, [r7, #20]
    4176:	429a      	cmp	r2, r3
    4178:	d3e0      	bcc.n	413c <usart_sync_read+0x44>

	return (int32_t)offset;
    417a:	697b      	ldr	r3, [r7, #20]
}
    417c:	0018      	movs	r0, r3
    417e:	46bd      	mov	sp, r7
    4180:	b007      	add	sp, #28
    4182:	bd90      	pop	{r4, r7, pc}
    4184:	00007ddc 	.word	0x00007ddc

00004188 <assert>:

/**
 * \brief Assert function
 */
void assert(const bool condition, const char *const file, const int line)
{
    4188:	b580      	push	{r7, lr}
    418a:	b084      	sub	sp, #16
    418c:	af00      	add	r7, sp, #0
    418e:	60b9      	str	r1, [r7, #8]
    4190:	607a      	str	r2, [r7, #4]
    4192:	230f      	movs	r3, #15
    4194:	18fb      	adds	r3, r7, r3
    4196:	1c02      	adds	r2, r0, #0
    4198:	701a      	strb	r2, [r3, #0]
	if (!(condition)) {
    419a:	230f      	movs	r3, #15
    419c:	18fb      	adds	r3, r7, r3
    419e:	781b      	ldrb	r3, [r3, #0]
    41a0:	2201      	movs	r2, #1
    41a2:	4053      	eors	r3, r2
    41a4:	b2db      	uxtb	r3, r3
    41a6:	2b00      	cmp	r3, #0
    41a8:	d000      	beq.n	41ac <assert+0x24>
		__asm("BKPT #0");
    41aa:	be00      	bkpt	0x0000
	}
	(void)file;
	(void)line;
}
    41ac:	46c0      	nop			; (mov r8, r8)
    41ae:	46bd      	mov	sp, r7
    41b0:	b004      	add	sp, #16
    41b2:	bd80      	pop	{r7, pc}

000041b4 <_sbrk>:

/**
 * \brief Replacement of C library of _sbrk
 */
extern caddr_t _sbrk(int incr)
{
    41b4:	b580      	push	{r7, lr}
    41b6:	b084      	sub	sp, #16
    41b8:	af00      	add	r7, sp, #0
    41ba:	6078      	str	r0, [r7, #4]
	static unsigned char *heap = NULL;
	unsigned char *       prev_heap;

	if (heap == NULL) {
    41bc:	4b0a      	ldr	r3, [pc, #40]	; (41e8 <_sbrk+0x34>)
    41be:	681b      	ldr	r3, [r3, #0]
    41c0:	2b00      	cmp	r3, #0
    41c2:	d102      	bne.n	41ca <_sbrk+0x16>
		heap = (unsigned char *)&_end;
    41c4:	4b08      	ldr	r3, [pc, #32]	; (41e8 <_sbrk+0x34>)
    41c6:	4a09      	ldr	r2, [pc, #36]	; (41ec <_sbrk+0x38>)
    41c8:	601a      	str	r2, [r3, #0]
	}
	prev_heap = heap;
    41ca:	4b07      	ldr	r3, [pc, #28]	; (41e8 <_sbrk+0x34>)
    41cc:	681b      	ldr	r3, [r3, #0]
    41ce:	60fb      	str	r3, [r7, #12]

	heap += incr;
    41d0:	4b05      	ldr	r3, [pc, #20]	; (41e8 <_sbrk+0x34>)
    41d2:	681a      	ldr	r2, [r3, #0]
    41d4:	687b      	ldr	r3, [r7, #4]
    41d6:	18d2      	adds	r2, r2, r3
    41d8:	4b03      	ldr	r3, [pc, #12]	; (41e8 <_sbrk+0x34>)
    41da:	601a      	str	r2, [r3, #0]

	return (caddr_t)prev_heap;
    41dc:	68fb      	ldr	r3, [r7, #12]
}
    41de:	0018      	movs	r0, r3
    41e0:	46bd      	mov	sp, r7
    41e2:	b004      	add	sp, #16
    41e4:	bd80      	pop	{r7, pc}
    41e6:	46c0      	nop			; (mov r8, r8)
    41e8:	200007b0 	.word	0x200007b0
    41ec:	20002900 	.word	0x20002900

000041f0 <_get_cycles_for_ms_internal>:

/**
 * \brief Retrieve the amount of cycles to delay for the given amount of ms
 */
static inline uint32_t _get_cycles_for_ms_internal(const uint16_t ms, const uint32_t freq, const uint8_t power)
{
    41f0:	b590      	push	{r4, r7, lr}
    41f2:	b083      	sub	sp, #12
    41f4:	af00      	add	r7, sp, #0
    41f6:	6039      	str	r1, [r7, #0]
    41f8:	0011      	movs	r1, r2
    41fa:	1dbb      	adds	r3, r7, #6
    41fc:	1c02      	adds	r2, r0, #0
    41fe:	801a      	strh	r2, [r3, #0]
    4200:	1d7b      	adds	r3, r7, #5
    4202:	1c0a      	adds	r2, r1, #0
    4204:	701a      	strb	r2, [r3, #0]
	switch (power) {
    4206:	1d7b      	adds	r3, r7, #5
    4208:	781b      	ldrb	r3, [r3, #0]
    420a:	3b04      	subs	r3, #4
    420c:	2b04      	cmp	r3, #4
    420e:	d84c      	bhi.n	42aa <_get_cycles_for_ms_internal+0xba>
    4210:	009a      	lsls	r2, r3, #2
    4212:	4b2e      	ldr	r3, [pc, #184]	; (42cc <_get_cycles_for_ms_internal+0xdc>)
    4214:	18d3      	adds	r3, r2, r3
    4216:	681b      	ldr	r3, [r3, #0]
    4218:	469f      	mov	pc, r3
	case 8:
		return (ms * (freq / 100000)) * 100;
    421a:	1dbb      	adds	r3, r7, #6
    421c:	881c      	ldrh	r4, [r3, #0]
    421e:	683b      	ldr	r3, [r7, #0]
    4220:	492b      	ldr	r1, [pc, #172]	; (42d0 <_get_cycles_for_ms_internal+0xe0>)
    4222:	0018      	movs	r0, r3
    4224:	f002 fe1a 	bl	6e5c <__udivsi3>
    4228:	0003      	movs	r3, r0
    422a:	4363      	muls	r3, r4
    422c:	2264      	movs	r2, #100	; 0x64
    422e:	4353      	muls	r3, r2
    4230:	e047      	b.n	42c2 <_get_cycles_for_ms_internal+0xd2>
	case 7:
		return (ms * (freq / 10000)) * 10;
    4232:	1dbb      	adds	r3, r7, #6
    4234:	881c      	ldrh	r4, [r3, #0]
    4236:	683b      	ldr	r3, [r7, #0]
    4238:	4926      	ldr	r1, [pc, #152]	; (42d4 <_get_cycles_for_ms_internal+0xe4>)
    423a:	0018      	movs	r0, r3
    423c:	f002 fe0e 	bl	6e5c <__udivsi3>
    4240:	0003      	movs	r3, r0
    4242:	4363      	muls	r3, r4
    4244:	001a      	movs	r2, r3
    4246:	0013      	movs	r3, r2
    4248:	009b      	lsls	r3, r3, #2
    424a:	189b      	adds	r3, r3, r2
    424c:	005b      	lsls	r3, r3, #1
    424e:	e038      	b.n	42c2 <_get_cycles_for_ms_internal+0xd2>
	case 6:
		return (ms * (freq / 1000));
    4250:	1dbb      	adds	r3, r7, #6
    4252:	881c      	ldrh	r4, [r3, #0]
    4254:	683a      	ldr	r2, [r7, #0]
    4256:	23fa      	movs	r3, #250	; 0xfa
    4258:	0099      	lsls	r1, r3, #2
    425a:	0010      	movs	r0, r2
    425c:	f002 fdfe 	bl	6e5c <__udivsi3>
    4260:	0003      	movs	r3, r0
    4262:	4363      	muls	r3, r4
    4264:	e02d      	b.n	42c2 <_get_cycles_for_ms_internal+0xd2>
	case 5:
		return (ms * (freq / 100) - 1) / 10 + 1;
    4266:	1dbb      	adds	r3, r7, #6
    4268:	881c      	ldrh	r4, [r3, #0]
    426a:	683b      	ldr	r3, [r7, #0]
    426c:	2164      	movs	r1, #100	; 0x64
    426e:	0018      	movs	r0, r3
    4270:	f002 fdf4 	bl	6e5c <__udivsi3>
    4274:	0003      	movs	r3, r0
    4276:	4363      	muls	r3, r4
    4278:	3b01      	subs	r3, #1
    427a:	210a      	movs	r1, #10
    427c:	0018      	movs	r0, r3
    427e:	f002 fded 	bl	6e5c <__udivsi3>
    4282:	0003      	movs	r3, r0
    4284:	3301      	adds	r3, #1
    4286:	e01c      	b.n	42c2 <_get_cycles_for_ms_internal+0xd2>
	case 4:
		return (ms * (freq / 10) - 1) / 100 + 1;
    4288:	1dbb      	adds	r3, r7, #6
    428a:	881c      	ldrh	r4, [r3, #0]
    428c:	683b      	ldr	r3, [r7, #0]
    428e:	210a      	movs	r1, #10
    4290:	0018      	movs	r0, r3
    4292:	f002 fde3 	bl	6e5c <__udivsi3>
    4296:	0003      	movs	r3, r0
    4298:	4363      	muls	r3, r4
    429a:	3b01      	subs	r3, #1
    429c:	2164      	movs	r1, #100	; 0x64
    429e:	0018      	movs	r0, r3
    42a0:	f002 fddc 	bl	6e5c <__udivsi3>
    42a4:	0003      	movs	r3, r0
    42a6:	3301      	adds	r3, #1
    42a8:	e00b      	b.n	42c2 <_get_cycles_for_ms_internal+0xd2>
	default:
		return (ms * freq - 1) / 1000 + 1;
    42aa:	1dbb      	adds	r3, r7, #6
    42ac:	881b      	ldrh	r3, [r3, #0]
    42ae:	683a      	ldr	r2, [r7, #0]
    42b0:	4353      	muls	r3, r2
    42b2:	1e5a      	subs	r2, r3, #1
    42b4:	23fa      	movs	r3, #250	; 0xfa
    42b6:	0099      	lsls	r1, r3, #2
    42b8:	0010      	movs	r0, r2
    42ba:	f002 fdcf 	bl	6e5c <__udivsi3>
    42be:	0003      	movs	r3, r0
    42c0:	3301      	adds	r3, #1
	}
}
    42c2:	0018      	movs	r0, r3
    42c4:	46bd      	mov	sp, r7
    42c6:	b003      	add	sp, #12
    42c8:	bd90      	pop	{r4, r7, pc}
    42ca:	46c0      	nop			; (mov r8, r8)
    42cc:	00007df8 	.word	0x00007df8
    42d0:	000186a0 	.word	0x000186a0
    42d4:	00002710 	.word	0x00002710

000042d8 <_get_cycles_for_ms>:

/**
 * \brief Retrieve the amount of cycles to delay for the given amount of ms
 */
uint32_t _get_cycles_for_ms(const uint16_t ms)
{
    42d8:	b580      	push	{r7, lr}
    42da:	b082      	sub	sp, #8
    42dc:	af00      	add	r7, sp, #0
    42de:	0002      	movs	r2, r0
    42e0:	1dbb      	adds	r3, r7, #6
    42e2:	801a      	strh	r2, [r3, #0]
	return _get_cycles_for_ms_internal(ms, CONF_CPU_FREQUENCY, CPU_FREQ_POWER);
    42e4:	4905      	ldr	r1, [pc, #20]	; (42fc <_get_cycles_for_ms+0x24>)
    42e6:	1dbb      	adds	r3, r7, #6
    42e8:	881b      	ldrh	r3, [r3, #0]
    42ea:	2208      	movs	r2, #8
    42ec:	0018      	movs	r0, r3
    42ee:	f7ff ff7f 	bl	41f0 <_get_cycles_for_ms_internal>
    42f2:	0003      	movs	r3, r0
}
    42f4:	0018      	movs	r0, r3
    42f6:	46bd      	mov	sp, r7
    42f8:	b002      	add	sp, #8
    42fa:	bd80      	pop	{r7, pc}
    42fc:	02dc6c00 	.word	0x02dc6c00

00004300 <hri_nvmctrl_set_CTRLB_RWS_bf>:
	((Nvmctrl *)hw)->CTRLB.reg ^= NVMCTRL_CTRLB_CACHEDIS;
	NVMCTRL_CRITICAL_SECTION_LEAVE();
}

static inline void hri_nvmctrl_set_CTRLB_RWS_bf(const void *const hw, hri_nvmctrl_ctrlb_reg_t mask)
{
    4300:	b580      	push	{r7, lr}
    4302:	b082      	sub	sp, #8
    4304:	af00      	add	r7, sp, #0
    4306:	6078      	str	r0, [r7, #4]
    4308:	6039      	str	r1, [r7, #0]
	NVMCTRL_CRITICAL_SECTION_ENTER();
	((Nvmctrl *)hw)->CTRLB.reg |= NVMCTRL_CTRLB_RWS(mask);
    430a:	687b      	ldr	r3, [r7, #4]
    430c:	685a      	ldr	r2, [r3, #4]
    430e:	683b      	ldr	r3, [r7, #0]
    4310:	005b      	lsls	r3, r3, #1
    4312:	211e      	movs	r1, #30
    4314:	400b      	ands	r3, r1
    4316:	431a      	orrs	r2, r3
    4318:	687b      	ldr	r3, [r7, #4]
    431a:	605a      	str	r2, [r3, #4]
	NVMCTRL_CRITICAL_SECTION_LEAVE();
}
    431c:	46c0      	nop			; (mov r8, r8)
    431e:	46bd      	mov	sp, r7
    4320:	b002      	add	sp, #8
    4322:	bd80      	pop	{r7, pc}

00004324 <_init_chip>:

/**
 * \brief Initialize the hardware abstraction layer
 */
void _init_chip(void)
{
    4324:	b580      	push	{r7, lr}
    4326:	af00      	add	r7, sp, #0
	hri_nvmctrl_set_CTRLB_RWS_bf(NVMCTRL, CONF_NVM_WAIT_STATE);
    4328:	4b09      	ldr	r3, [pc, #36]	; (4350 <_init_chip+0x2c>)
    432a:	2103      	movs	r1, #3
    432c:	0018      	movs	r0, r3
    432e:	f7ff ffe7 	bl	4300 <hri_nvmctrl_set_CTRLB_RWS_bf>

	_pm_init();
    4332:	f000 fb6b 	bl	4a0c <_pm_init>
	_sysctrl_init_sources();
    4336:	f001 fa31 	bl	579c <_sysctrl_init_sources>
#if _GCLK_INIT_1ST
	_gclk_init_generators_by_fref(_GCLK_INIT_1ST);
    433a:	2008      	movs	r0, #8
    433c:	f000 fada 	bl	48f4 <_gclk_init_generators_by_fref>
#endif
	_sysctrl_init_referenced_generators();
    4340:	f001 fa9e 	bl	5880 <_sysctrl_init_referenced_generators>
	_gclk_init_generators_by_fref(_GCLK_INIT_LAST);
    4344:	20f7      	movs	r0, #247	; 0xf7
    4346:	f000 fad5 	bl	48f4 <_gclk_init_generators_by_fref>
}
    434a:	46c0      	nop			; (mov r8, r8)
    434c:	46bd      	mov	sp, r7
    434e:	bd80      	pop	{r7, pc}
    4350:	41004000 	.word	0x41004000

00004354 <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
    4354:	b580      	push	{r7, lr}
    4356:	b082      	sub	sp, #8
    4358:	af00      	add	r7, sp, #0
    435a:	0002      	movs	r2, r0
    435c:	1dfb      	adds	r3, r7, #7
    435e:	701a      	strb	r2, [r3, #0]
  if ((int32_t)(IRQn) >= 0)
    4360:	1dfb      	adds	r3, r7, #7
    4362:	781b      	ldrb	r3, [r3, #0]
    4364:	2b7f      	cmp	r3, #127	; 0x7f
    4366:	d809      	bhi.n	437c <__NVIC_EnableIRQ+0x28>
  {
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    4368:	4b06      	ldr	r3, [pc, #24]	; (4384 <__NVIC_EnableIRQ+0x30>)
    436a:	1dfa      	adds	r2, r7, #7
    436c:	7812      	ldrb	r2, [r2, #0]
    436e:	0011      	movs	r1, r2
    4370:	221f      	movs	r2, #31
    4372:	400a      	ands	r2, r1
    4374:	2101      	movs	r1, #1
    4376:	4091      	lsls	r1, r2
    4378:	000a      	movs	r2, r1
    437a:	601a      	str	r2, [r3, #0]
  }
}
    437c:	46c0      	nop			; (mov r8, r8)
    437e:	46bd      	mov	sp, r7
    4380:	b002      	add	sp, #8
    4382:	bd80      	pop	{r7, pc}
    4384:	e000e100 	.word	0xe000e100

00004388 <__NVIC_DisableIRQ>:
  \details Disables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
    4388:	b580      	push	{r7, lr}
    438a:	b082      	sub	sp, #8
    438c:	af00      	add	r7, sp, #0
    438e:	0002      	movs	r2, r0
    4390:	1dfb      	adds	r3, r7, #7
    4392:	701a      	strb	r2, [r3, #0]
  if ((int32_t)(IRQn) >= 0)
    4394:	1dfb      	adds	r3, r7, #7
    4396:	781b      	ldrb	r3, [r3, #0]
    4398:	2b7f      	cmp	r3, #127	; 0x7f
    439a:	d80e      	bhi.n	43ba <__NVIC_DisableIRQ+0x32>
  {
    NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    439c:	4909      	ldr	r1, [pc, #36]	; (43c4 <__NVIC_DisableIRQ+0x3c>)
    439e:	1dfb      	adds	r3, r7, #7
    43a0:	781b      	ldrb	r3, [r3, #0]
    43a2:	001a      	movs	r2, r3
    43a4:	231f      	movs	r3, #31
    43a6:	4013      	ands	r3, r2
    43a8:	2201      	movs	r2, #1
    43aa:	409a      	lsls	r2, r3
    43ac:	0013      	movs	r3, r2
    43ae:	2280      	movs	r2, #128	; 0x80
    43b0:	508b      	str	r3, [r1, r2]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
    43b2:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    43b6:	f3bf 8f6f 	isb	sy
    __DSB();
    __ISB();
  }
}
    43ba:	46c0      	nop			; (mov r8, r8)
    43bc:	46bd      	mov	sp, r7
    43be:	b002      	add	sp, #8
    43c0:	bd80      	pop	{r7, pc}
    43c2:	46c0      	nop			; (mov r8, r8)
    43c4:	e000e100 	.word	0xe000e100

000043c8 <__NVIC_ClearPendingIRQ>:
  \details Clears the pending bit of a device specific interrupt in the NVIC pending register.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
    43c8:	b580      	push	{r7, lr}
    43ca:	b082      	sub	sp, #8
    43cc:	af00      	add	r7, sp, #0
    43ce:	0002      	movs	r2, r0
    43d0:	1dfb      	adds	r3, r7, #7
    43d2:	701a      	strb	r2, [r3, #0]
  if ((int32_t)(IRQn) >= 0)
    43d4:	1dfb      	adds	r3, r7, #7
    43d6:	781b      	ldrb	r3, [r3, #0]
    43d8:	2b7f      	cmp	r3, #127	; 0x7f
    43da:	d80a      	bhi.n	43f2 <__NVIC_ClearPendingIRQ+0x2a>
  {
    NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    43dc:	4907      	ldr	r1, [pc, #28]	; (43fc <__NVIC_ClearPendingIRQ+0x34>)
    43de:	1dfb      	adds	r3, r7, #7
    43e0:	781b      	ldrb	r3, [r3, #0]
    43e2:	001a      	movs	r2, r3
    43e4:	231f      	movs	r3, #31
    43e6:	4013      	ands	r3, r2
    43e8:	2201      	movs	r2, #1
    43ea:	409a      	lsls	r2, r3
    43ec:	23c0      	movs	r3, #192	; 0xc0
    43ee:	005b      	lsls	r3, r3, #1
    43f0:	50ca      	str	r2, [r1, r3]
  }
}
    43f2:	46c0      	nop			; (mov r8, r8)
    43f4:	46bd      	mov	sp, r7
    43f6:	b002      	add	sp, #8
    43f8:	bd80      	pop	{r7, pc}
    43fa:	46c0      	nop			; (mov r8, r8)
    43fc:	e000e100 	.word	0xe000e100

00004400 <hri_eic_wait_for_sync>:
typedef uint8_t  hri_eic_nmictrl_reg_t;
typedef uint8_t  hri_eic_nmiflag_reg_t;
typedef uint8_t  hri_eic_status_reg_t;

static inline void hri_eic_wait_for_sync(const void *const hw)
{
    4400:	b580      	push	{r7, lr}
    4402:	b082      	sub	sp, #8
    4404:	af00      	add	r7, sp, #0
    4406:	6078      	str	r0, [r7, #4]
	while (((const Eic *)hw)->STATUS.bit.SYNCBUSY)
    4408:	46c0      	nop			; (mov r8, r8)
    440a:	687b      	ldr	r3, [r7, #4]
    440c:	785b      	ldrb	r3, [r3, #1]
    440e:	061b      	lsls	r3, r3, #24
    4410:	0fdb      	lsrs	r3, r3, #31
    4412:	b2db      	uxtb	r3, r3
    4414:	2b00      	cmp	r3, #0
    4416:	d1f8      	bne.n	440a <hri_eic_wait_for_sync+0xa>
		;
}
    4418:	46c0      	nop			; (mov r8, r8)
    441a:	46bd      	mov	sp, r7
    441c:	b002      	add	sp, #8
    441e:	bd80      	pop	{r7, pc}

00004420 <hri_eic_read_INTFLAG_reg>:
	tmp &= mask;
	return tmp;
}

static inline hri_eic_intflag_reg_t hri_eic_read_INTFLAG_reg(const void *const hw)
{
    4420:	b580      	push	{r7, lr}
    4422:	b082      	sub	sp, #8
    4424:	af00      	add	r7, sp, #0
    4426:	6078      	str	r0, [r7, #4]
	return ((Eic *)hw)->INTFLAG.reg;
    4428:	687b      	ldr	r3, [r7, #4]
    442a:	691b      	ldr	r3, [r3, #16]
}
    442c:	0018      	movs	r0, r3
    442e:	46bd      	mov	sp, r7
    4430:	b002      	add	sp, #8
    4432:	bd80      	pop	{r7, pc}

00004434 <hri_eic_clear_INTFLAG_reg>:

static inline void hri_eic_clear_INTFLAG_reg(const void *const hw, hri_eic_intflag_reg_t mask)
{
    4434:	b580      	push	{r7, lr}
    4436:	b082      	sub	sp, #8
    4438:	af00      	add	r7, sp, #0
    443a:	6078      	str	r0, [r7, #4]
    443c:	6039      	str	r1, [r7, #0]
	((Eic *)hw)->INTFLAG.reg = mask;
    443e:	687b      	ldr	r3, [r7, #4]
    4440:	683a      	ldr	r2, [r7, #0]
    4442:	611a      	str	r2, [r3, #16]
}
    4444:	46c0      	nop			; (mov r8, r8)
    4446:	46bd      	mov	sp, r7
    4448:	b002      	add	sp, #8
    444a:	bd80      	pop	{r7, pc}

0000444c <hri_eic_set_INTEN_reg>:
{
	((Eic *)hw)->INTENCLR.reg = EIC_INTENSET_EXTINT15;
}

static inline void hri_eic_set_INTEN_reg(const void *const hw, hri_eic_intenset_reg_t mask)
{
    444c:	b580      	push	{r7, lr}
    444e:	b082      	sub	sp, #8
    4450:	af00      	add	r7, sp, #0
    4452:	6078      	str	r0, [r7, #4]
    4454:	6039      	str	r1, [r7, #0]
	((Eic *)hw)->INTENSET.reg = mask;
    4456:	687b      	ldr	r3, [r7, #4]
    4458:	683a      	ldr	r2, [r7, #0]
    445a:	60da      	str	r2, [r3, #12]
}
    445c:	46c0      	nop			; (mov r8, r8)
    445e:	46bd      	mov	sp, r7
    4460:	b002      	add	sp, #8
    4462:	bd80      	pop	{r7, pc}

00004464 <hri_eic_read_INTEN_reg>:
	tmp &= mask;
	return tmp;
}

static inline hri_eic_intenset_reg_t hri_eic_read_INTEN_reg(const void *const hw)
{
    4464:	b580      	push	{r7, lr}
    4466:	b082      	sub	sp, #8
    4468:	af00      	add	r7, sp, #0
    446a:	6078      	str	r0, [r7, #4]
	return ((Eic *)hw)->INTENSET.reg;
    446c:	687b      	ldr	r3, [r7, #4]
    446e:	68db      	ldr	r3, [r3, #12]
}
    4470:	0018      	movs	r0, r3
    4472:	46bd      	mov	sp, r7
    4474:	b002      	add	sp, #8
    4476:	bd80      	pop	{r7, pc}

00004478 <hri_eic_clear_INTEN_reg>:
	((Eic *)hw)->INTENSET.reg = data;
	((Eic *)hw)->INTENCLR.reg = ~data;
}

static inline void hri_eic_clear_INTEN_reg(const void *const hw, hri_eic_intenset_reg_t mask)
{
    4478:	b580      	push	{r7, lr}
    447a:	b082      	sub	sp, #8
    447c:	af00      	add	r7, sp, #0
    447e:	6078      	str	r0, [r7, #4]
    4480:	6039      	str	r1, [r7, #0]
	((Eic *)hw)->INTENCLR.reg = mask;
    4482:	687b      	ldr	r3, [r7, #4]
    4484:	683a      	ldr	r2, [r7, #0]
    4486:	609a      	str	r2, [r3, #8]
}
    4488:	46c0      	nop			; (mov r8, r8)
    448a:	46bd      	mov	sp, r7
    448c:	b002      	add	sp, #8
    448e:	bd80      	pop	{r7, pc}

00004490 <hri_eic_set_CTRL_ENABLE_bit>:
	tmp = (tmp & EIC_CTRL_SWRST) >> EIC_CTRL_SWRST_Pos;
	return (bool)tmp;
}

static inline void hri_eic_set_CTRL_ENABLE_bit(const void *const hw)
{
    4490:	b580      	push	{r7, lr}
    4492:	b082      	sub	sp, #8
    4494:	af00      	add	r7, sp, #0
    4496:	6078      	str	r0, [r7, #4]
	EIC_CRITICAL_SECTION_ENTER();
	((Eic *)hw)->CTRL.reg |= EIC_CTRL_ENABLE;
    4498:	687b      	ldr	r3, [r7, #4]
    449a:	781b      	ldrb	r3, [r3, #0]
    449c:	b2db      	uxtb	r3, r3
    449e:	2202      	movs	r2, #2
    44a0:	4313      	orrs	r3, r2
    44a2:	b2da      	uxtb	r2, r3
    44a4:	687b      	ldr	r3, [r7, #4]
    44a6:	701a      	strb	r2, [r3, #0]
	hri_eic_wait_for_sync(hw);
    44a8:	687b      	ldr	r3, [r7, #4]
    44aa:	0018      	movs	r0, r3
    44ac:	f7ff ffa8 	bl	4400 <hri_eic_wait_for_sync>
	EIC_CRITICAL_SECTION_LEAVE();
}
    44b0:	46c0      	nop			; (mov r8, r8)
    44b2:	46bd      	mov	sp, r7
    44b4:	b002      	add	sp, #8
    44b6:	bd80      	pop	{r7, pc}

000044b8 <hri_eic_get_CTRL_reg>:
	hri_eic_wait_for_sync(hw);
	EIC_CRITICAL_SECTION_LEAVE();
}

static inline hri_eic_ctrl_reg_t hri_eic_get_CTRL_reg(const void *const hw, hri_eic_ctrl_reg_t mask)
{
    44b8:	b580      	push	{r7, lr}
    44ba:	b084      	sub	sp, #16
    44bc:	af00      	add	r7, sp, #0
    44be:	6078      	str	r0, [r7, #4]
    44c0:	000a      	movs	r2, r1
    44c2:	1cfb      	adds	r3, r7, #3
    44c4:	701a      	strb	r2, [r3, #0]
	uint8_t tmp;
	hri_eic_wait_for_sync(hw);
    44c6:	687b      	ldr	r3, [r7, #4]
    44c8:	0018      	movs	r0, r3
    44ca:	f7ff ff99 	bl	4400 <hri_eic_wait_for_sync>
	tmp = ((Eic *)hw)->CTRL.reg;
    44ce:	230f      	movs	r3, #15
    44d0:	18fb      	adds	r3, r7, r3
    44d2:	687a      	ldr	r2, [r7, #4]
    44d4:	7812      	ldrb	r2, [r2, #0]
    44d6:	701a      	strb	r2, [r3, #0]
	tmp &= mask;
    44d8:	230f      	movs	r3, #15
    44da:	18fb      	adds	r3, r7, r3
    44dc:	220f      	movs	r2, #15
    44de:	18ba      	adds	r2, r7, r2
    44e0:	1cf9      	adds	r1, r7, #3
    44e2:	7812      	ldrb	r2, [r2, #0]
    44e4:	7809      	ldrb	r1, [r1, #0]
    44e6:	400a      	ands	r2, r1
    44e8:	701a      	strb	r2, [r3, #0]
	return tmp;
    44ea:	230f      	movs	r3, #15
    44ec:	18fb      	adds	r3, r7, r3
    44ee:	781b      	ldrb	r3, [r3, #0]
}
    44f0:	0018      	movs	r0, r3
    44f2:	46bd      	mov	sp, r7
    44f4:	b004      	add	sp, #16
    44f6:	bd80      	pop	{r7, pc}

000044f8 <hri_eic_write_CTRL_reg>:

static inline void hri_eic_write_CTRL_reg(const void *const hw, hri_eic_ctrl_reg_t data)
{
    44f8:	b580      	push	{r7, lr}
    44fa:	b082      	sub	sp, #8
    44fc:	af00      	add	r7, sp, #0
    44fe:	6078      	str	r0, [r7, #4]
    4500:	000a      	movs	r2, r1
    4502:	1cfb      	adds	r3, r7, #3
    4504:	701a      	strb	r2, [r3, #0]
	EIC_CRITICAL_SECTION_ENTER();
	((Eic *)hw)->CTRL.reg = data;
    4506:	687b      	ldr	r3, [r7, #4]
    4508:	1cfa      	adds	r2, r7, #3
    450a:	7812      	ldrb	r2, [r2, #0]
    450c:	701a      	strb	r2, [r3, #0]
	hri_eic_wait_for_sync(hw);
    450e:	687b      	ldr	r3, [r7, #4]
    4510:	0018      	movs	r0, r3
    4512:	f7ff ff75 	bl	4400 <hri_eic_wait_for_sync>
	EIC_CRITICAL_SECTION_LEAVE();
}
    4516:	46c0      	nop			; (mov r8, r8)
    4518:	46bd      	mov	sp, r7
    451a:	b002      	add	sp, #8
    451c:	bd80      	pop	{r7, pc}

0000451e <hri_eic_write_NMICTRL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_eic_write_NMICTRL_reg(const void *const hw, hri_eic_nmictrl_reg_t data)
{
    451e:	b580      	push	{r7, lr}
    4520:	b082      	sub	sp, #8
    4522:	af00      	add	r7, sp, #0
    4524:	6078      	str	r0, [r7, #4]
    4526:	000a      	movs	r2, r1
    4528:	1cfb      	adds	r3, r7, #3
    452a:	701a      	strb	r2, [r3, #0]
	EIC_CRITICAL_SECTION_ENTER();
	((Eic *)hw)->NMICTRL.reg = data;
    452c:	687b      	ldr	r3, [r7, #4]
    452e:	1cfa      	adds	r2, r7, #3
    4530:	7812      	ldrb	r2, [r2, #0]
    4532:	709a      	strb	r2, [r3, #2]
	EIC_CRITICAL_SECTION_LEAVE();
}
    4534:	46c0      	nop			; (mov r8, r8)
    4536:	46bd      	mov	sp, r7
    4538:	b002      	add	sp, #8
    453a:	bd80      	pop	{r7, pc}

0000453c <hri_eic_write_EVCTRL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_eic_write_EVCTRL_reg(const void *const hw, hri_eic_evctrl_reg_t data)
{
    453c:	b580      	push	{r7, lr}
    453e:	b082      	sub	sp, #8
    4540:	af00      	add	r7, sp, #0
    4542:	6078      	str	r0, [r7, #4]
    4544:	6039      	str	r1, [r7, #0]
	EIC_CRITICAL_SECTION_ENTER();
	((Eic *)hw)->EVCTRL.reg = data;
    4546:	687b      	ldr	r3, [r7, #4]
    4548:	683a      	ldr	r2, [r7, #0]
    454a:	605a      	str	r2, [r3, #4]
	EIC_CRITICAL_SECTION_LEAVE();
}
    454c:	46c0      	nop			; (mov r8, r8)
    454e:	46bd      	mov	sp, r7
    4550:	b002      	add	sp, #8
    4552:	bd80      	pop	{r7, pc}

00004554 <hri_eic_write_WAKEUP_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_eic_write_WAKEUP_reg(const void *const hw, hri_eic_wakeup_reg_t data)
{
    4554:	b580      	push	{r7, lr}
    4556:	b082      	sub	sp, #8
    4558:	af00      	add	r7, sp, #0
    455a:	6078      	str	r0, [r7, #4]
    455c:	6039      	str	r1, [r7, #0]
	EIC_CRITICAL_SECTION_ENTER();
	((Eic *)hw)->WAKEUP.reg = data;
    455e:	687b      	ldr	r3, [r7, #4]
    4560:	683a      	ldr	r2, [r7, #0]
    4562:	615a      	str	r2, [r3, #20]
	EIC_CRITICAL_SECTION_LEAVE();
}
    4564:	46c0      	nop			; (mov r8, r8)
    4566:	46bd      	mov	sp, r7
    4568:	b002      	add	sp, #8
    456a:	bd80      	pop	{r7, pc}

0000456c <hri_eic_write_CONFIG_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_eic_write_CONFIG_reg(const void *const hw, uint8_t index, hri_eic_config_reg_t data)
{
    456c:	b580      	push	{r7, lr}
    456e:	b084      	sub	sp, #16
    4570:	af00      	add	r7, sp, #0
    4572:	60f8      	str	r0, [r7, #12]
    4574:	607a      	str	r2, [r7, #4]
    4576:	230b      	movs	r3, #11
    4578:	18fb      	adds	r3, r7, r3
    457a:	1c0a      	adds	r2, r1, #0
    457c:	701a      	strb	r2, [r3, #0]
	EIC_CRITICAL_SECTION_ENTER();
	((Eic *)hw)->CONFIG[index].reg = data;
    457e:	230b      	movs	r3, #11
    4580:	18fb      	adds	r3, r7, r3
    4582:	781a      	ldrb	r2, [r3, #0]
    4584:	68fb      	ldr	r3, [r7, #12]
    4586:	3206      	adds	r2, #6
    4588:	0092      	lsls	r2, r2, #2
    458a:	6879      	ldr	r1, [r7, #4]
    458c:	50d1      	str	r1, [r2, r3]
	EIC_CRITICAL_SECTION_LEAVE();
}
    458e:	46c0      	nop			; (mov r8, r8)
    4590:	46bd      	mov	sp, r7
    4592:	b004      	add	sp, #16
    4594:	bd80      	pop	{r7, pc}
	...

00004598 <_ext_irq_init>:

/**
 * \brief Initialize external interrupt module
 */
int32_t _ext_irq_init(void (*cb)(const uint32_t pin))
{
    4598:	b580      	push	{r7, lr}
    459a:	b082      	sub	sp, #8
    459c:	af00      	add	r7, sp, #0
    459e:	6078      	str	r0, [r7, #4]
	hri_eic_wait_for_sync(EIC);
    45a0:	4b28      	ldr	r3, [pc, #160]	; (4644 <_ext_irq_init+0xac>)
    45a2:	0018      	movs	r0, r3
    45a4:	f7ff ff2c 	bl	4400 <hri_eic_wait_for_sync>
	if (hri_eic_get_CTRL_reg(EIC, EIC_CTRL_ENABLE)) {
    45a8:	4b26      	ldr	r3, [pc, #152]	; (4644 <_ext_irq_init+0xac>)
    45aa:	2102      	movs	r1, #2
    45ac:	0018      	movs	r0, r3
    45ae:	f7ff ff83 	bl	44b8 <hri_eic_get_CTRL_reg>
    45b2:	1e03      	subs	r3, r0, #0
    45b4:	d008      	beq.n	45c8 <_ext_irq_init+0x30>
		hri_eic_write_CTRL_reg(EIC, 0);
    45b6:	4b23      	ldr	r3, [pc, #140]	; (4644 <_ext_irq_init+0xac>)
    45b8:	2100      	movs	r1, #0
    45ba:	0018      	movs	r0, r3
    45bc:	f7ff ff9c 	bl	44f8 <hri_eic_write_CTRL_reg>
		hri_eic_wait_for_sync(EIC);
    45c0:	4b20      	ldr	r3, [pc, #128]	; (4644 <_ext_irq_init+0xac>)
    45c2:	0018      	movs	r0, r3
    45c4:	f7ff ff1c 	bl	4400 <hri_eic_wait_for_sync>
	}
	hri_eic_write_CTRL_reg(EIC, EIC_CTRL_SWRST);
    45c8:	4b1e      	ldr	r3, [pc, #120]	; (4644 <_ext_irq_init+0xac>)
    45ca:	2101      	movs	r1, #1
    45cc:	0018      	movs	r0, r3
    45ce:	f7ff ff93 	bl	44f8 <hri_eic_write_CTRL_reg>
	hri_eic_wait_for_sync(EIC);
    45d2:	4b1c      	ldr	r3, [pc, #112]	; (4644 <_ext_irq_init+0xac>)
    45d4:	0018      	movs	r0, r3
    45d6:	f7ff ff13 	bl	4400 <hri_eic_wait_for_sync>

	hri_eic_write_NMICTRL_reg(
    45da:	4b1a      	ldr	r3, [pc, #104]	; (4644 <_ext_irq_init+0xac>)
    45dc:	2100      	movs	r1, #0
    45de:	0018      	movs	r0, r3
    45e0:	f7ff ff9d 	bl	451e <hri_eic_write_NMICTRL_reg>
	    EIC, (CONF_EIC_NMIFILTEN << EIC_NMICTRL_NMIFILTEN_Pos) | EIC_NMICTRL_NMISENSE(CONF_EIC_NMISENSE));
	hri_eic_write_EVCTRL_reg(EIC,
    45e4:	2380      	movs	r3, #128	; 0x80
    45e6:	00db      	lsls	r3, r3, #3
    45e8:	4a16      	ldr	r2, [pc, #88]	; (4644 <_ext_irq_init+0xac>)
    45ea:	0019      	movs	r1, r3
    45ec:	0010      	movs	r0, r2
    45ee:	f7ff ffa5 	bl	453c <hri_eic_write_EVCTRL_reg>
	                             | (CONF_EIC_EXTINTEO6 << 6) | (CONF_EIC_EXTINTEO7 << 7) | (CONF_EIC_EXTINTEO8 << 8)
	                             | (CONF_EIC_EXTINTEO9 << 9) | (CONF_EIC_EXTINTEO10 << 10) | (CONF_EIC_EXTINTEO11 << 11)
	                             | (CONF_EIC_EXTINTEO12 << 12) | (CONF_EIC_EXTINTEO13 << 13)
	                             | (CONF_EIC_EXTINTEO14 << 14) | (CONF_EIC_EXTINTEO15 << 15) | 0);

	hri_eic_write_WAKEUP_reg(EIC,
    45f2:	2380      	movs	r3, #128	; 0x80
    45f4:	01db      	lsls	r3, r3, #7
    45f6:	4a13      	ldr	r2, [pc, #76]	; (4644 <_ext_irq_init+0xac>)
    45f8:	0019      	movs	r1, r3
    45fa:	0010      	movs	r0, r2
    45fc:	f7ff ffaa 	bl	4554 <hri_eic_write_WAKEUP_reg>
	                             | (CONF_EIC_WAKEUPEN3 << 3) | (CONF_EIC_WAKEUPEN4 << 4) | (CONF_EIC_WAKEUPEN5 << 5)
	                             | (CONF_EIC_WAKEUPEN6 << 6) | (CONF_EIC_WAKEUPEN7 << 7) | (CONF_EIC_WAKEUPEN8 << 8)
	                             | (CONF_EIC_WAKEUPEN9 << 9) | (CONF_EIC_WAKEUPEN10 << 10) | (CONF_EIC_WAKEUPEN11 << 11)
	                             | (CONF_EIC_WAKEUPEN12 << 12) | (CONF_EIC_WAKEUPEN13 << 13)
	                             | (CONF_EIC_WAKEUPEN14 << 14) | (CONF_EIC_WAKEUPEN15 << 15) | 0);
	hri_eic_write_CONFIG_reg(EIC,
    4600:	4b10      	ldr	r3, [pc, #64]	; (4644 <_ext_irq_init+0xac>)
    4602:	2290      	movs	r2, #144	; 0x90
    4604:	2100      	movs	r1, #0
    4606:	0018      	movs	r0, r3
    4608:	f7ff ffb0 	bl	456c <hri_eic_write_CONFIG_reg>
	                             | (CONF_EIC_FILTEN5 << EIC_CONFIG_FILTEN5_Pos) | EIC_CONFIG_SENSE5(CONF_EIC_SENSE5)
	                             | (CONF_EIC_FILTEN6 << EIC_CONFIG_FILTEN6_Pos) | EIC_CONFIG_SENSE6(CONF_EIC_SENSE6)
	                             | (CONF_EIC_FILTEN7 << EIC_CONFIG_FILTEN7_Pos) | EIC_CONFIG_SENSE7(CONF_EIC_SENSE7)
	                             | 0);

	hri_eic_write_CONFIG_reg(EIC,
    460c:	4a0e      	ldr	r2, [pc, #56]	; (4648 <_ext_irq_init+0xb0>)
    460e:	4b0d      	ldr	r3, [pc, #52]	; (4644 <_ext_irq_init+0xac>)
    4610:	2101      	movs	r1, #1
    4612:	0018      	movs	r0, r3
    4614:	f7ff ffaa 	bl	456c <hri_eic_write_CONFIG_reg>
	                             | (CONF_EIC_FILTEN13 << EIC_CONFIG_FILTEN5_Pos) | EIC_CONFIG_SENSE5(CONF_EIC_SENSE13)
	                             | (CONF_EIC_FILTEN14 << EIC_CONFIG_FILTEN6_Pos) | EIC_CONFIG_SENSE6(CONF_EIC_SENSE14)
	                             | (CONF_EIC_FILTEN15 << EIC_CONFIG_FILTEN7_Pos) | EIC_CONFIG_SENSE7(CONF_EIC_SENSE15)
	                             | 0);

	hri_eic_set_CTRL_ENABLE_bit(EIC);
    4618:	4b0a      	ldr	r3, [pc, #40]	; (4644 <_ext_irq_init+0xac>)
    461a:	0018      	movs	r0, r3
    461c:	f7ff ff38 	bl	4490 <hri_eic_set_CTRL_ENABLE_bit>

	NVIC_DisableIRQ(EIC_IRQn);
    4620:	2004      	movs	r0, #4
    4622:	f7ff feb1 	bl	4388 <__NVIC_DisableIRQ>
	NVIC_ClearPendingIRQ(EIC_IRQn);
    4626:	2004      	movs	r0, #4
    4628:	f7ff fece 	bl	43c8 <__NVIC_ClearPendingIRQ>
	NVIC_EnableIRQ(EIC_IRQn);
    462c:	2004      	movs	r0, #4
    462e:	f7ff fe91 	bl	4354 <__NVIC_EnableIRQ>

	callback = cb;
    4632:	4b06      	ldr	r3, [pc, #24]	; (464c <_ext_irq_init+0xb4>)
    4634:	687a      	ldr	r2, [r7, #4]
    4636:	601a      	str	r2, [r3, #0]

	return ERR_NONE;
    4638:	2300      	movs	r3, #0
}
    463a:	0018      	movs	r0, r3
    463c:	46bd      	mov	sp, r7
    463e:	b002      	add	sp, #8
    4640:	bd80      	pop	{r7, pc}
    4642:	46c0      	nop			; (mov r8, r8)
    4644:	40001800 	.word	0x40001800
    4648:	01000200 	.word	0x01000200
    464c:	200007b4 	.word	0x200007b4

00004650 <_ext_irq_enable>:

/**
 * \brief Enable / disable external irq
 */
int32_t _ext_irq_enable(const uint32_t pin, const bool enable)
{
    4650:	b580      	push	{r7, lr}
    4652:	b084      	sub	sp, #16
    4654:	af00      	add	r7, sp, #0
    4656:	6078      	str	r0, [r7, #4]
    4658:	000a      	movs	r2, r1
    465a:	1cfb      	adds	r3, r7, #3
    465c:	701a      	strb	r2, [r3, #0]
	uint8_t extint = INVALID_EXTINT_NUMBER;
    465e:	230f      	movs	r3, #15
    4660:	18fb      	adds	r3, r7, r3
    4662:	22ff      	movs	r2, #255	; 0xff
    4664:	701a      	strb	r2, [r3, #0]
	uint8_t i      = 0;
    4666:	230e      	movs	r3, #14
    4668:	18fb      	adds	r3, r7, r3
    466a:	2200      	movs	r2, #0
    466c:	701a      	strb	r2, [r3, #0]

	for (; i < ARRAY_SIZE(_map); i++) {
    466e:	e01b      	b.n	46a8 <_ext_irq_enable+0x58>
		if (_map[i].pin == pin) {
    4670:	230e      	movs	r3, #14
    4672:	18fb      	adds	r3, r7, r3
    4674:	781b      	ldrb	r3, [r3, #0]
    4676:	4a28      	ldr	r2, [pc, #160]	; (4718 <_ext_irq_enable+0xc8>)
    4678:	00db      	lsls	r3, r3, #3
    467a:	18d3      	adds	r3, r2, r3
    467c:	3304      	adds	r3, #4
    467e:	681a      	ldr	r2, [r3, #0]
    4680:	687b      	ldr	r3, [r7, #4]
    4682:	429a      	cmp	r2, r3
    4684:	d109      	bne.n	469a <_ext_irq_enable+0x4a>
			extint = _map[i].extint;
    4686:	230e      	movs	r3, #14
    4688:	18fb      	adds	r3, r7, r3
    468a:	7819      	ldrb	r1, [r3, #0]
    468c:	230f      	movs	r3, #15
    468e:	18fb      	adds	r3, r7, r3
    4690:	4a21      	ldr	r2, [pc, #132]	; (4718 <_ext_irq_enable+0xc8>)
    4692:	00c9      	lsls	r1, r1, #3
    4694:	5c8a      	ldrb	r2, [r1, r2]
    4696:	701a      	strb	r2, [r3, #0]
			break;
    4698:	e00b      	b.n	46b2 <_ext_irq_enable+0x62>
	for (; i < ARRAY_SIZE(_map); i++) {
    469a:	230e      	movs	r3, #14
    469c:	18fb      	adds	r3, r7, r3
    469e:	781a      	ldrb	r2, [r3, #0]
    46a0:	230e      	movs	r3, #14
    46a2:	18fb      	adds	r3, r7, r3
    46a4:	3201      	adds	r2, #1
    46a6:	701a      	strb	r2, [r3, #0]
    46a8:	230e      	movs	r3, #14
    46aa:	18fb      	adds	r3, r7, r3
    46ac:	781b      	ldrb	r3, [r3, #0]
    46ae:	2b02      	cmp	r3, #2
    46b0:	d9de      	bls.n	4670 <_ext_irq_enable+0x20>
		}
	}
	if (INVALID_EXTINT_NUMBER == extint) {
    46b2:	230f      	movs	r3, #15
    46b4:	18fb      	adds	r3, r7, r3
    46b6:	781b      	ldrb	r3, [r3, #0]
    46b8:	2bff      	cmp	r3, #255	; 0xff
    46ba:	d102      	bne.n	46c2 <_ext_irq_enable+0x72>
		return ERR_INVALID_ARG;
    46bc:	230d      	movs	r3, #13
    46be:	425b      	negs	r3, r3
    46c0:	e026      	b.n	4710 <_ext_irq_enable+0xc0>
	}

	if (enable) {
    46c2:	1cfb      	adds	r3, r7, #3
    46c4:	781b      	ldrb	r3, [r3, #0]
    46c6:	2b00      	cmp	r3, #0
    46c8:	d00b      	beq.n	46e2 <_ext_irq_enable+0x92>
		hri_eic_set_INTEN_reg(EIC, 1ul << extint);
    46ca:	230f      	movs	r3, #15
    46cc:	18fb      	adds	r3, r7, r3
    46ce:	781b      	ldrb	r3, [r3, #0]
    46d0:	2201      	movs	r2, #1
    46d2:	409a      	lsls	r2, r3
    46d4:	0013      	movs	r3, r2
    46d6:	4a11      	ldr	r2, [pc, #68]	; (471c <_ext_irq_enable+0xcc>)
    46d8:	0019      	movs	r1, r3
    46da:	0010      	movs	r0, r2
    46dc:	f7ff feb6 	bl	444c <hri_eic_set_INTEN_reg>
    46e0:	e015      	b.n	470e <_ext_irq_enable+0xbe>
	} else {
		hri_eic_clear_INTEN_reg(EIC, 1ul << extint);
    46e2:	230f      	movs	r3, #15
    46e4:	18fb      	adds	r3, r7, r3
    46e6:	781b      	ldrb	r3, [r3, #0]
    46e8:	2201      	movs	r2, #1
    46ea:	409a      	lsls	r2, r3
    46ec:	0013      	movs	r3, r2
    46ee:	4a0b      	ldr	r2, [pc, #44]	; (471c <_ext_irq_enable+0xcc>)
    46f0:	0019      	movs	r1, r3
    46f2:	0010      	movs	r0, r2
    46f4:	f7ff fec0 	bl	4478 <hri_eic_clear_INTEN_reg>
		hri_eic_clear_INTFLAG_reg(EIC, 1ul << extint);
    46f8:	230f      	movs	r3, #15
    46fa:	18fb      	adds	r3, r7, r3
    46fc:	781b      	ldrb	r3, [r3, #0]
    46fe:	2201      	movs	r2, #1
    4700:	409a      	lsls	r2, r3
    4702:	0013      	movs	r3, r2
    4704:	4a05      	ldr	r2, [pc, #20]	; (471c <_ext_irq_enable+0xcc>)
    4706:	0019      	movs	r1, r3
    4708:	0010      	movs	r0, r2
    470a:	f7ff fe93 	bl	4434 <hri_eic_clear_INTFLAG_reg>
	}

	return ERR_NONE;
    470e:	2300      	movs	r3, #0
}
    4710:	0018      	movs	r0, r3
    4712:	46bd      	mov	sp, r7
    4714:	b004      	add	sp, #16
    4716:	bd80      	pop	{r7, pc}
    4718:	00007e0c 	.word	0x00007e0c
    471c:	40001800 	.word	0x40001800

00004720 <EIC_Handler>:

/**
 * \brief EIC interrupt handler
 */
void EIC_Handler(void)
{
    4720:	b590      	push	{r4, r7, lr}
    4722:	b085      	sub	sp, #20
    4724:	af00      	add	r7, sp, #0
	volatile uint32_t flags = hri_eic_read_INTFLAG_reg(EIC) & hri_eic_read_INTEN_reg(EIC);
    4726:	4b59      	ldr	r3, [pc, #356]	; (488c <EIC_Handler+0x16c>)
    4728:	0018      	movs	r0, r3
    472a:	f7ff fe79 	bl	4420 <hri_eic_read_INTFLAG_reg>
    472e:	0004      	movs	r4, r0
    4730:	4b56      	ldr	r3, [pc, #344]	; (488c <EIC_Handler+0x16c>)
    4732:	0018      	movs	r0, r3
    4734:	f7ff fe96 	bl	4464 <hri_eic_read_INTEN_reg>
    4738:	0003      	movs	r3, r0
    473a:	4023      	ands	r3, r4
    473c:	603b      	str	r3, [r7, #0]
	int8_t            pos;
	uint32_t          pin = INVALID_PIN_NUMBER;
    473e:	2301      	movs	r3, #1
    4740:	425b      	negs	r3, r3
    4742:	60bb      	str	r3, [r7, #8]

	hri_eic_clear_INTFLAG_reg(EIC, flags);
    4744:	683b      	ldr	r3, [r7, #0]
    4746:	4a51      	ldr	r2, [pc, #324]	; (488c <EIC_Handler+0x16c>)
    4748:	0019      	movs	r1, r3
    474a:	0010      	movs	r0, r2
    474c:	f7ff fe72 	bl	4434 <hri_eic_clear_INTFLAG_reg>

	ASSERT(callback);
    4750:	4b4f      	ldr	r3, [pc, #316]	; (4890 <EIC_Handler+0x170>)
    4752:	681b      	ldr	r3, [r3, #0]
    4754:	1e5a      	subs	r2, r3, #1
    4756:	4193      	sbcs	r3, r2
    4758:	b2db      	uxtb	r3, r3
    475a:	494e      	ldr	r1, [pc, #312]	; (4894 <EIC_Handler+0x174>)
    475c:	22d2      	movs	r2, #210	; 0xd2
    475e:	0018      	movs	r0, r3
    4760:	f7ff fd12 	bl	4188 <assert>

	while (flags) {
    4764:	e08a      	b.n	487c <EIC_Handler+0x15c>
		pos = ffs(flags) - 1;
    4766:	683b      	ldr	r3, [r7, #0]
    4768:	0018      	movs	r0, r3
    476a:	f002 fc03 	bl	6f74 <ffs>
    476e:	0003      	movs	r3, r0
    4770:	b2db      	uxtb	r3, r3
    4772:	3b01      	subs	r3, #1
    4774:	b2da      	uxtb	r2, r3
    4776:	230f      	movs	r3, #15
    4778:	18fb      	adds	r3, r7, r3
    477a:	701a      	strb	r2, [r3, #0]
		while (-1 != pos) {
    477c:	e066      	b.n	484c <EIC_Handler+0x12c>
			uint8_t lower = 0, middle, upper = EXT_IRQ_AMOUNT;
    477e:	1dfb      	adds	r3, r7, #7
    4780:	2200      	movs	r2, #0
    4782:	701a      	strb	r2, [r3, #0]
    4784:	1dbb      	adds	r3, r7, #6
    4786:	2203      	movs	r2, #3
    4788:	701a      	strb	r2, [r3, #0]

			while (upper >= lower) {
    478a:	e03b      	b.n	4804 <EIC_Handler+0xe4>
				middle = (upper + lower) >> 1;
    478c:	1dbb      	adds	r3, r7, #6
    478e:	781a      	ldrb	r2, [r3, #0]
    4790:	1dfb      	adds	r3, r7, #7
    4792:	781b      	ldrb	r3, [r3, #0]
    4794:	18d3      	adds	r3, r2, r3
    4796:	105a      	asrs	r2, r3, #1
    4798:	1d7b      	adds	r3, r7, #5
    479a:	701a      	strb	r2, [r3, #0]
				if (_map[middle].extint == pos) {
    479c:	1d7b      	adds	r3, r7, #5
    479e:	781a      	ldrb	r2, [r3, #0]
    47a0:	4b3d      	ldr	r3, [pc, #244]	; (4898 <EIC_Handler+0x178>)
    47a2:	00d2      	lsls	r2, r2, #3
    47a4:	5cd3      	ldrb	r3, [r2, r3]
    47a6:	001a      	movs	r2, r3
    47a8:	230f      	movs	r3, #15
    47aa:	18fb      	adds	r3, r7, r3
    47ac:	781b      	ldrb	r3, [r3, #0]
    47ae:	b25b      	sxtb	r3, r3
    47b0:	429a      	cmp	r2, r3
    47b2:	d108      	bne.n	47c6 <EIC_Handler+0xa6>
					pin = _map[middle].pin;
    47b4:	1d7b      	adds	r3, r7, #5
    47b6:	781b      	ldrb	r3, [r3, #0]
    47b8:	4a37      	ldr	r2, [pc, #220]	; (4898 <EIC_Handler+0x178>)
    47ba:	00db      	lsls	r3, r3, #3
    47bc:	18d3      	adds	r3, r2, r3
    47be:	3304      	adds	r3, #4
    47c0:	681b      	ldr	r3, [r3, #0]
    47c2:	60bb      	str	r3, [r7, #8]
					break;
    47c4:	e024      	b.n	4810 <EIC_Handler+0xf0>
				}
				if (_map[middle].extint < pos) {
    47c6:	1d7b      	adds	r3, r7, #5
    47c8:	781a      	ldrb	r2, [r3, #0]
    47ca:	4b33      	ldr	r3, [pc, #204]	; (4898 <EIC_Handler+0x178>)
    47cc:	00d2      	lsls	r2, r2, #3
    47ce:	5cd3      	ldrb	r3, [r2, r3]
    47d0:	001a      	movs	r2, r3
    47d2:	230f      	movs	r3, #15
    47d4:	18fb      	adds	r3, r7, r3
    47d6:	781b      	ldrb	r3, [r3, #0]
    47d8:	b25b      	sxtb	r3, r3
    47da:	429a      	cmp	r2, r3
    47dc:	da09      	bge.n	47f2 <EIC_Handler+0xd2>
					lower = middle + 1;
    47de:	1dfb      	adds	r3, r7, #7
    47e0:	1d7a      	adds	r2, r7, #5
    47e2:	7812      	ldrb	r2, [r2, #0]
    47e4:	3201      	adds	r2, #1
    47e6:	701a      	strb	r2, [r3, #0]
    47e8:	1dbb      	adds	r3, r7, #6
    47ea:	1dba      	adds	r2, r7, #6
    47ec:	7812      	ldrb	r2, [r2, #0]
    47ee:	701a      	strb	r2, [r3, #0]
    47f0:	e008      	b.n	4804 <EIC_Handler+0xe4>
				} else {
					upper = middle - 1;
    47f2:	1dbb      	adds	r3, r7, #6
    47f4:	1d7a      	adds	r2, r7, #5
    47f6:	7812      	ldrb	r2, [r2, #0]
    47f8:	3a01      	subs	r2, #1
    47fa:	701a      	strb	r2, [r3, #0]
    47fc:	1dfb      	adds	r3, r7, #7
    47fe:	1dfa      	adds	r2, r7, #7
    4800:	7812      	ldrb	r2, [r2, #0]
    4802:	701a      	strb	r2, [r3, #0]
			while (upper >= lower) {
    4804:	1dba      	adds	r2, r7, #6
    4806:	1dfb      	adds	r3, r7, #7
    4808:	7812      	ldrb	r2, [r2, #0]
    480a:	781b      	ldrb	r3, [r3, #0]
    480c:	429a      	cmp	r2, r3
    480e:	d2bd      	bcs.n	478c <EIC_Handler+0x6c>
				}
			}

			if (INVALID_PIN_NUMBER != pin) {
    4810:	68bb      	ldr	r3, [r7, #8]
    4812:	3301      	adds	r3, #1
    4814:	d004      	beq.n	4820 <EIC_Handler+0x100>
				callback(pin);
    4816:	4b1e      	ldr	r3, [pc, #120]	; (4890 <EIC_Handler+0x170>)
    4818:	681b      	ldr	r3, [r3, #0]
    481a:	68ba      	ldr	r2, [r7, #8]
    481c:	0010      	movs	r0, r2
    481e:	4798      	blx	r3
			}
			flags &= ~(1ul << pos);
    4820:	230f      	movs	r3, #15
    4822:	18fb      	adds	r3, r7, r3
    4824:	781b      	ldrb	r3, [r3, #0]
    4826:	b25b      	sxtb	r3, r3
    4828:	2201      	movs	r2, #1
    482a:	409a      	lsls	r2, r3
    482c:	0013      	movs	r3, r2
    482e:	43db      	mvns	r3, r3
    4830:	683a      	ldr	r2, [r7, #0]
    4832:	4013      	ands	r3, r2
    4834:	603b      	str	r3, [r7, #0]
			pos = ffs(flags) - 1;
    4836:	683b      	ldr	r3, [r7, #0]
    4838:	0018      	movs	r0, r3
    483a:	f002 fb9b 	bl	6f74 <ffs>
    483e:	0003      	movs	r3, r0
    4840:	b2db      	uxtb	r3, r3
    4842:	3b01      	subs	r3, #1
    4844:	b2da      	uxtb	r2, r3
    4846:	230f      	movs	r3, #15
    4848:	18fb      	adds	r3, r7, r3
    484a:	701a      	strb	r2, [r3, #0]
		while (-1 != pos) {
    484c:	230f      	movs	r3, #15
    484e:	18fb      	adds	r3, r7, r3
    4850:	781b      	ldrb	r3, [r3, #0]
    4852:	b25b      	sxtb	r3, r3
    4854:	3301      	adds	r3, #1
    4856:	d192      	bne.n	477e <EIC_Handler+0x5e>
		}
		flags = hri_eic_read_INTFLAG_reg(EIC) & hri_eic_read_INTEN_reg(EIC);
    4858:	4b0c      	ldr	r3, [pc, #48]	; (488c <EIC_Handler+0x16c>)
    485a:	0018      	movs	r0, r3
    485c:	f7ff fde0 	bl	4420 <hri_eic_read_INTFLAG_reg>
    4860:	0004      	movs	r4, r0
    4862:	4b0a      	ldr	r3, [pc, #40]	; (488c <EIC_Handler+0x16c>)
    4864:	0018      	movs	r0, r3
    4866:	f7ff fdfd 	bl	4464 <hri_eic_read_INTEN_reg>
    486a:	0003      	movs	r3, r0
    486c:	4023      	ands	r3, r4
    486e:	603b      	str	r3, [r7, #0]
		hri_eic_clear_INTFLAG_reg(EIC, flags);
    4870:	683b      	ldr	r3, [r7, #0]
    4872:	4a06      	ldr	r2, [pc, #24]	; (488c <EIC_Handler+0x16c>)
    4874:	0019      	movs	r1, r3
    4876:	0010      	movs	r0, r2
    4878:	f7ff fddc 	bl	4434 <hri_eic_clear_INTFLAG_reg>
	while (flags) {
    487c:	683b      	ldr	r3, [r7, #0]
    487e:	2b00      	cmp	r3, #0
    4880:	d000      	beq.n	4884 <EIC_Handler+0x164>
    4882:	e770      	b.n	4766 <EIC_Handler+0x46>
	}
}
    4884:	46c0      	nop			; (mov r8, r8)
    4886:	46bd      	mov	sp, r7
    4888:	b005      	add	sp, #20
    488a:	bd90      	pop	{r4, r7, pc}
    488c:	40001800 	.word	0x40001800
    4890:	200007b4 	.word	0x200007b4
    4894:	00007e24 	.word	0x00007e24
    4898:	00007e0c 	.word	0x00007e0c

0000489c <hri_gclk_wait_for_sync>:
{
    489c:	b580      	push	{r7, lr}
    489e:	b082      	sub	sp, #8
    48a0:	af00      	add	r7, sp, #0
    48a2:	6078      	str	r0, [r7, #4]
	while (((const Gclk *)hw)->STATUS.bit.SYNCBUSY)
    48a4:	46c0      	nop			; (mov r8, r8)
    48a6:	687b      	ldr	r3, [r7, #4]
    48a8:	785b      	ldrb	r3, [r3, #1]
    48aa:	061b      	lsls	r3, r3, #24
    48ac:	0fdb      	lsrs	r3, r3, #31
    48ae:	b2db      	uxtb	r3, r3
    48b0:	2b00      	cmp	r3, #0
    48b2:	d1f8      	bne.n	48a6 <hri_gclk_wait_for_sync+0xa>
}
    48b4:	46c0      	nop			; (mov r8, r8)
    48b6:	46bd      	mov	sp, r7
    48b8:	b002      	add	sp, #8
    48ba:	bd80      	pop	{r7, pc}

000048bc <hri_gclk_write_GENCTRL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_gclk_write_GENCTRL_reg(const void *const hw, hri_gclk_genctrl_reg_t data)
{
    48bc:	b580      	push	{r7, lr}
    48be:	b082      	sub	sp, #8
    48c0:	af00      	add	r7, sp, #0
    48c2:	6078      	str	r0, [r7, #4]
    48c4:	6039      	str	r1, [r7, #0]
	GCLK_CRITICAL_SECTION_ENTER();
	((Gclk *)hw)->GENCTRL.reg = data;
    48c6:	687b      	ldr	r3, [r7, #4]
    48c8:	683a      	ldr	r2, [r7, #0]
    48ca:	605a      	str	r2, [r3, #4]
	hri_gclk_wait_for_sync(hw);
    48cc:	687b      	ldr	r3, [r7, #4]
    48ce:	0018      	movs	r0, r3
    48d0:	f7ff ffe4 	bl	489c <hri_gclk_wait_for_sync>
	GCLK_CRITICAL_SECTION_LEAVE();
}
    48d4:	46c0      	nop			; (mov r8, r8)
    48d6:	46bd      	mov	sp, r7
    48d8:	b002      	add	sp, #8
    48da:	bd80      	pop	{r7, pc}

000048dc <hri_gclk_write_GENDIV_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_gclk_write_GENDIV_reg(const void *const hw, hri_gclk_gendiv_reg_t data)
{
    48dc:	b580      	push	{r7, lr}
    48de:	b082      	sub	sp, #8
    48e0:	af00      	add	r7, sp, #0
    48e2:	6078      	str	r0, [r7, #4]
    48e4:	6039      	str	r1, [r7, #0]
	GCLK_CRITICAL_SECTION_ENTER();
	((Gclk *)hw)->GENDIV.reg = data;
    48e6:	687b      	ldr	r3, [r7, #4]
    48e8:	683a      	ldr	r2, [r7, #0]
    48ea:	609a      	str	r2, [r3, #8]
	GCLK_CRITICAL_SECTION_LEAVE();
}
    48ec:	46c0      	nop			; (mov r8, r8)
    48ee:	46bd      	mov	sp, r7
    48f0:	b002      	add	sp, #8
    48f2:	bd80      	pop	{r7, pc}

000048f4 <_gclk_init_generators_by_fref>:
	        | CONF_GCLK_GEN_7_SRC | GCLK_GENCTRL_ID(7));
#endif
}

void _gclk_init_generators_by_fref(uint32_t bm)
{
    48f4:	b580      	push	{r7, lr}
    48f6:	b082      	sub	sp, #8
    48f8:	af00      	add	r7, sp, #0
    48fa:	6078      	str	r0, [r7, #4]

#if CONF_GCLK_GENERATOR_0_CONFIG == 1
	if (bm & (1ul << 0)) {
    48fc:	687b      	ldr	r3, [r7, #4]
    48fe:	2201      	movs	r2, #1
    4900:	4013      	ands	r3, r2
    4902:	d00c      	beq.n	491e <_gclk_init_generators_by_fref+0x2a>
		hri_gclk_write_GENDIV_reg(GCLK, GCLK_GENDIV_DIV(CONF_GCLK_GEN_0_DIV) | GCLK_GENDIV_ID(0));
    4904:	2380      	movs	r3, #128	; 0x80
    4906:	005b      	lsls	r3, r3, #1
    4908:	4a0f      	ldr	r2, [pc, #60]	; (4948 <_gclk_init_generators_by_fref+0x54>)
    490a:	0019      	movs	r1, r3
    490c:	0010      	movs	r0, r2
    490e:	f7ff ffe5 	bl	48dc <hri_gclk_write_GENDIV_reg>
		hri_gclk_write_GENCTRL_reg(
    4912:	4a0e      	ldr	r2, [pc, #56]	; (494c <_gclk_init_generators_by_fref+0x58>)
    4914:	4b0c      	ldr	r3, [pc, #48]	; (4948 <_gclk_init_generators_by_fref+0x54>)
    4916:	0011      	movs	r1, r2
    4918:	0018      	movs	r0, r3
    491a:	f7ff ffcf 	bl	48bc <hri_gclk_write_GENCTRL_reg>
		        | (CONF_GCLK_GENERATOR_2_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_2_SRC | GCLK_GENCTRL_ID(2));
	}
#endif

#if CONF_GCLK_GENERATOR_3_CONFIG == 1
	if (bm & (1ul << 3)) {
    491e:	687b      	ldr	r3, [r7, #4]
    4920:	2208      	movs	r2, #8
    4922:	4013      	ands	r3, r2
    4924:	d00c      	beq.n	4940 <_gclk_init_generators_by_fref+0x4c>
		hri_gclk_write_GENDIV_reg(GCLK, GCLK_GENDIV_DIV(CONF_GCLK_GEN_3_DIV) | GCLK_GENDIV_ID(3));
    4926:	2304      	movs	r3, #4
    4928:	33ff      	adds	r3, #255	; 0xff
    492a:	4a07      	ldr	r2, [pc, #28]	; (4948 <_gclk_init_generators_by_fref+0x54>)
    492c:	0019      	movs	r1, r3
    492e:	0010      	movs	r0, r2
    4930:	f7ff ffd4 	bl	48dc <hri_gclk_write_GENDIV_reg>
		hri_gclk_write_GENCTRL_reg(
    4934:	4a06      	ldr	r2, [pc, #24]	; (4950 <_gclk_init_generators_by_fref+0x5c>)
    4936:	4b04      	ldr	r3, [pc, #16]	; (4948 <_gclk_init_generators_by_fref+0x54>)
    4938:	0011      	movs	r1, r2
    493a:	0018      	movs	r0, r3
    493c:	f7ff ffbe 	bl	48bc <hri_gclk_write_GENCTRL_reg>
		        | (CONF_GCLK_GEN_7_DIVSEL << GCLK_GENCTRL_DIVSEL_Pos) | (CONF_GCLK_GEN_7_OE << GCLK_GENCTRL_OE_Pos)
		        | (CONF_GCLK_GEN_7_OOV << GCLK_GENCTRL_OOV_Pos) | (CONF_GCLK_GEN_7_IDC << GCLK_GENCTRL_IDC_Pos)
		        | (CONF_GCLK_GENERATOR_7_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_7_SRC | GCLK_GENCTRL_ID(7));
	}
#endif
}
    4940:	46c0      	nop			; (mov r8, r8)
    4942:	46bd      	mov	sp, r7
    4944:	b002      	add	sp, #8
    4946:	bd80      	pop	{r7, pc}
    4948:	40000c00 	.word	0x40000c00
    494c:	00010700 	.word	0x00010700
    4950:	00010403 	.word	0x00010403

00004954 <hri_pm_set_CPUSEL_CPUDIV_bf>:
{
	return ((Pm *)hw)->SLEEP.reg;
}

static inline void hri_pm_set_CPUSEL_CPUDIV_bf(const void *const hw, hri_pm_cpusel_reg_t mask)
{
    4954:	b580      	push	{r7, lr}
    4956:	b082      	sub	sp, #8
    4958:	af00      	add	r7, sp, #0
    495a:	6078      	str	r0, [r7, #4]
    495c:	000a      	movs	r2, r1
    495e:	1cfb      	adds	r3, r7, #3
    4960:	701a      	strb	r2, [r3, #0]
	PM_CRITICAL_SECTION_ENTER();
	((Pm *)hw)->CPUSEL.reg |= PM_CPUSEL_CPUDIV(mask);
    4962:	687b      	ldr	r3, [r7, #4]
    4964:	7a1b      	ldrb	r3, [r3, #8]
    4966:	b2da      	uxtb	r2, r3
    4968:	1cfb      	adds	r3, r7, #3
    496a:	781b      	ldrb	r3, [r3, #0]
    496c:	2107      	movs	r1, #7
    496e:	400b      	ands	r3, r1
    4970:	b2db      	uxtb	r3, r3
    4972:	4313      	orrs	r3, r2
    4974:	b2da      	uxtb	r2, r3
    4976:	687b      	ldr	r3, [r7, #4]
    4978:	721a      	strb	r2, [r3, #8]
	PM_CRITICAL_SECTION_LEAVE();
}
    497a:	46c0      	nop			; (mov r8, r8)
    497c:	46bd      	mov	sp, r7
    497e:	b002      	add	sp, #8
    4980:	bd80      	pop	{r7, pc}

00004982 <hri_pm_set_APBASEL_APBADIV_bf>:
{
	return ((Pm *)hw)->CPUSEL.reg;
}

static inline void hri_pm_set_APBASEL_APBADIV_bf(const void *const hw, hri_pm_apbasel_reg_t mask)
{
    4982:	b580      	push	{r7, lr}
    4984:	b082      	sub	sp, #8
    4986:	af00      	add	r7, sp, #0
    4988:	6078      	str	r0, [r7, #4]
    498a:	000a      	movs	r2, r1
    498c:	1cfb      	adds	r3, r7, #3
    498e:	701a      	strb	r2, [r3, #0]
	PM_CRITICAL_SECTION_ENTER();
	((Pm *)hw)->APBASEL.reg |= PM_APBASEL_APBADIV(mask);
    4990:	687b      	ldr	r3, [r7, #4]
    4992:	7a5b      	ldrb	r3, [r3, #9]
    4994:	b2da      	uxtb	r2, r3
    4996:	1cfb      	adds	r3, r7, #3
    4998:	781b      	ldrb	r3, [r3, #0]
    499a:	2107      	movs	r1, #7
    499c:	400b      	ands	r3, r1
    499e:	b2db      	uxtb	r3, r3
    49a0:	4313      	orrs	r3, r2
    49a2:	b2da      	uxtb	r2, r3
    49a4:	687b      	ldr	r3, [r7, #4]
    49a6:	725a      	strb	r2, [r3, #9]
	PM_CRITICAL_SECTION_LEAVE();
}
    49a8:	46c0      	nop			; (mov r8, r8)
    49aa:	46bd      	mov	sp, r7
    49ac:	b002      	add	sp, #8
    49ae:	bd80      	pop	{r7, pc}

000049b0 <hri_pm_set_APBBSEL_APBBDIV_bf>:
{
	return ((Pm *)hw)->APBASEL.reg;
}

static inline void hri_pm_set_APBBSEL_APBBDIV_bf(const void *const hw, hri_pm_apbbsel_reg_t mask)
{
    49b0:	b580      	push	{r7, lr}
    49b2:	b082      	sub	sp, #8
    49b4:	af00      	add	r7, sp, #0
    49b6:	6078      	str	r0, [r7, #4]
    49b8:	000a      	movs	r2, r1
    49ba:	1cfb      	adds	r3, r7, #3
    49bc:	701a      	strb	r2, [r3, #0]
	PM_CRITICAL_SECTION_ENTER();
	((Pm *)hw)->APBBSEL.reg |= PM_APBBSEL_APBBDIV(mask);
    49be:	687b      	ldr	r3, [r7, #4]
    49c0:	7a9b      	ldrb	r3, [r3, #10]
    49c2:	b2da      	uxtb	r2, r3
    49c4:	1cfb      	adds	r3, r7, #3
    49c6:	781b      	ldrb	r3, [r3, #0]
    49c8:	2107      	movs	r1, #7
    49ca:	400b      	ands	r3, r1
    49cc:	b2db      	uxtb	r3, r3
    49ce:	4313      	orrs	r3, r2
    49d0:	b2da      	uxtb	r2, r3
    49d2:	687b      	ldr	r3, [r7, #4]
    49d4:	729a      	strb	r2, [r3, #10]
	PM_CRITICAL_SECTION_LEAVE();
}
    49d6:	46c0      	nop			; (mov r8, r8)
    49d8:	46bd      	mov	sp, r7
    49da:	b002      	add	sp, #8
    49dc:	bd80      	pop	{r7, pc}

000049de <hri_pm_set_APBCSEL_APBCDIV_bf>:
{
	return ((Pm *)hw)->APBBSEL.reg;
}

static inline void hri_pm_set_APBCSEL_APBCDIV_bf(const void *const hw, hri_pm_apbcsel_reg_t mask)
{
    49de:	b580      	push	{r7, lr}
    49e0:	b082      	sub	sp, #8
    49e2:	af00      	add	r7, sp, #0
    49e4:	6078      	str	r0, [r7, #4]
    49e6:	000a      	movs	r2, r1
    49e8:	1cfb      	adds	r3, r7, #3
    49ea:	701a      	strb	r2, [r3, #0]
	PM_CRITICAL_SECTION_ENTER();
	((Pm *)hw)->APBCSEL.reg |= PM_APBCSEL_APBCDIV(mask);
    49ec:	687b      	ldr	r3, [r7, #4]
    49ee:	7adb      	ldrb	r3, [r3, #11]
    49f0:	b2da      	uxtb	r2, r3
    49f2:	1cfb      	adds	r3, r7, #3
    49f4:	781b      	ldrb	r3, [r3, #0]
    49f6:	2107      	movs	r1, #7
    49f8:	400b      	ands	r3, r1
    49fa:	b2db      	uxtb	r3, r3
    49fc:	4313      	orrs	r3, r2
    49fe:	b2da      	uxtb	r2, r3
    4a00:	687b      	ldr	r3, [r7, #4]
    4a02:	72da      	strb	r2, [r3, #11]
	PM_CRITICAL_SECTION_LEAVE();
}
    4a04:	46c0      	nop			; (mov r8, r8)
    4a06:	46bd      	mov	sp, r7
    4a08:	b002      	add	sp, #8
    4a0a:	bd80      	pop	{r7, pc}

00004a0c <_pm_init>:

/**
 * \brief Power Manager Init
 */
void _pm_init(void)
{
    4a0c:	b580      	push	{r7, lr}
    4a0e:	af00      	add	r7, sp, #0
	hri_pm_set_CPUSEL_CPUDIV_bf(PM, CONF_CPU_DIV);
    4a10:	4b0b      	ldr	r3, [pc, #44]	; (4a40 <_pm_init+0x34>)
    4a12:	2100      	movs	r1, #0
    4a14:	0018      	movs	r0, r3
    4a16:	f7ff ff9d 	bl	4954 <hri_pm_set_CPUSEL_CPUDIV_bf>
	hri_pm_set_APBASEL_APBADIV_bf(PM, CONF_APBA_DIV);
    4a1a:	4b09      	ldr	r3, [pc, #36]	; (4a40 <_pm_init+0x34>)
    4a1c:	2100      	movs	r1, #0
    4a1e:	0018      	movs	r0, r3
    4a20:	f7ff ffaf 	bl	4982 <hri_pm_set_APBASEL_APBADIV_bf>
	hri_pm_set_APBBSEL_APBBDIV_bf(PM, CONF_APBB_DIV);
    4a24:	4b06      	ldr	r3, [pc, #24]	; (4a40 <_pm_init+0x34>)
    4a26:	2100      	movs	r1, #0
    4a28:	0018      	movs	r0, r3
    4a2a:	f7ff ffc1 	bl	49b0 <hri_pm_set_APBBSEL_APBBDIV_bf>
	hri_pm_set_APBCSEL_APBCDIV_bf(PM, CONF_APBC_DIV);
    4a2e:	4b04      	ldr	r3, [pc, #16]	; (4a40 <_pm_init+0x34>)
    4a30:	2100      	movs	r1, #0
    4a32:	0018      	movs	r0, r3
    4a34:	f7ff ffd3 	bl	49de <hri_pm_set_APBCSEL_APBCDIV_bf>
}
    4a38:	46c0      	nop			; (mov r8, r8)
    4a3a:	46bd      	mov	sp, r7
    4a3c:	bd80      	pop	{r7, pc}
    4a3e:	46c0      	nop			; (mov r8, r8)
    4a40:	40000400 	.word	0x40000400

00004a44 <hri_sercomspi_wait_for_sync>:
{
	return ((const Sercom *)hw)->I2CS.STATUS.bit.SYNCBUSY;
}

static inline void hri_sercomspi_wait_for_sync(const void *const hw)
{
    4a44:	b580      	push	{r7, lr}
    4a46:	b082      	sub	sp, #8
    4a48:	af00      	add	r7, sp, #0
    4a4a:	6078      	str	r0, [r7, #4]
	while (((const Sercom *)hw)->SPI.STATUS.bit.SYNCBUSY)
    4a4c:	46c0      	nop			; (mov r8, r8)
    4a4e:	687b      	ldr	r3, [r7, #4]
    4a50:	8a1b      	ldrh	r3, [r3, #16]
    4a52:	041b      	lsls	r3, r3, #16
    4a54:	0fdb      	lsrs	r3, r3, #31
    4a56:	b2db      	uxtb	r3, r3
    4a58:	2b00      	cmp	r3, #0
    4a5a:	d1f8      	bne.n	4a4e <hri_sercomspi_wait_for_sync+0xa>
		;
}
    4a5c:	46c0      	nop			; (mov r8, r8)
    4a5e:	46bd      	mov	sp, r7
    4a60:	b002      	add	sp, #8
    4a62:	bd80      	pop	{r7, pc}

00004a64 <hri_sercomspi_is_syncing>:

static inline bool hri_sercomspi_is_syncing(const void *const hw)
{
    4a64:	b580      	push	{r7, lr}
    4a66:	b082      	sub	sp, #8
    4a68:	af00      	add	r7, sp, #0
    4a6a:	6078      	str	r0, [r7, #4]
	return ((const Sercom *)hw)->SPI.STATUS.bit.SYNCBUSY;
    4a6c:	687b      	ldr	r3, [r7, #4]
    4a6e:	8a1b      	ldrh	r3, [r3, #16]
    4a70:	041b      	lsls	r3, r3, #16
    4a72:	0fdb      	lsrs	r3, r3, #31
    4a74:	b2db      	uxtb	r3, r3
    4a76:	1e5a      	subs	r2, r3, #1
    4a78:	4193      	sbcs	r3, r2
    4a7a:	b2db      	uxtb	r3, r3
}
    4a7c:	0018      	movs	r0, r3
    4a7e:	46bd      	mov	sp, r7
    4a80:	b002      	add	sp, #8
    4a82:	bd80      	pop	{r7, pc}

00004a84 <hri_sercomusart_wait_for_sync>:

static inline void hri_sercomusart_wait_for_sync(const void *const hw)
{
    4a84:	b580      	push	{r7, lr}
    4a86:	b082      	sub	sp, #8
    4a88:	af00      	add	r7, sp, #0
    4a8a:	6078      	str	r0, [r7, #4]
	while (((const Sercom *)hw)->USART.STATUS.bit.SYNCBUSY)
    4a8c:	46c0      	nop			; (mov r8, r8)
    4a8e:	687b      	ldr	r3, [r7, #4]
    4a90:	8a1b      	ldrh	r3, [r3, #16]
    4a92:	041b      	lsls	r3, r3, #16
    4a94:	0fdb      	lsrs	r3, r3, #31
    4a96:	b2db      	uxtb	r3, r3
    4a98:	2b00      	cmp	r3, #0
    4a9a:	d1f8      	bne.n	4a8e <hri_sercomusart_wait_for_sync+0xa>
		;
}
    4a9c:	46c0      	nop			; (mov r8, r8)
    4a9e:	46bd      	mov	sp, r7
    4aa0:	b002      	add	sp, #8
    4aa2:	bd80      	pop	{r7, pc}

00004aa4 <hri_sercomspi_get_INTFLAG_reg>:
	((Sercom *)hw)->SPI.INTFLAG.reg = SERCOM_SPI_INTFLAG_RXC;
}

static inline hri_sercomspi_intflag_reg_t hri_sercomspi_get_INTFLAG_reg(const void *const           hw,
                                                                        hri_sercomspi_intflag_reg_t mask)
{
    4aa4:	b580      	push	{r7, lr}
    4aa6:	b084      	sub	sp, #16
    4aa8:	af00      	add	r7, sp, #0
    4aaa:	6078      	str	r0, [r7, #4]
    4aac:	000a      	movs	r2, r1
    4aae:	1cfb      	adds	r3, r7, #3
    4ab0:	701a      	strb	r2, [r3, #0]
	uint8_t tmp;
	tmp = ((Sercom *)hw)->SPI.INTFLAG.reg;
    4ab2:	230f      	movs	r3, #15
    4ab4:	18fb      	adds	r3, r7, r3
    4ab6:	687a      	ldr	r2, [r7, #4]
    4ab8:	7b92      	ldrb	r2, [r2, #14]
    4aba:	701a      	strb	r2, [r3, #0]
	tmp &= mask;
    4abc:	230f      	movs	r3, #15
    4abe:	18fb      	adds	r3, r7, r3
    4ac0:	220f      	movs	r2, #15
    4ac2:	18ba      	adds	r2, r7, r2
    4ac4:	1cf9      	adds	r1, r7, #3
    4ac6:	7812      	ldrb	r2, [r2, #0]
    4ac8:	7809      	ldrb	r1, [r1, #0]
    4aca:	400a      	ands	r2, r1
    4acc:	701a      	strb	r2, [r3, #0]
	return tmp;
    4ace:	230f      	movs	r3, #15
    4ad0:	18fb      	adds	r3, r7, r3
    4ad2:	781b      	ldrb	r3, [r3, #0]
}
    4ad4:	0018      	movs	r0, r3
    4ad6:	46bd      	mov	sp, r7
    4ad8:	b004      	add	sp, #16
    4ada:	bd80      	pop	{r7, pc}

00004adc <hri_sercomspi_read_INTFLAG_reg>:

static inline hri_sercomspi_intflag_reg_t hri_sercomspi_read_INTFLAG_reg(const void *const hw)
{
    4adc:	b580      	push	{r7, lr}
    4ade:	b082      	sub	sp, #8
    4ae0:	af00      	add	r7, sp, #0
    4ae2:	6078      	str	r0, [r7, #4]
	return ((Sercom *)hw)->SPI.INTFLAG.reg;
    4ae4:	687b      	ldr	r3, [r7, #4]
    4ae6:	7b9b      	ldrb	r3, [r3, #14]
    4ae8:	b2db      	uxtb	r3, r3
}
    4aea:	0018      	movs	r0, r3
    4aec:	46bd      	mov	sp, r7
    4aee:	b002      	add	sp, #8
    4af0:	bd80      	pop	{r7, pc}

00004af2 <hri_sercomspi_clear_INTFLAG_reg>:

static inline void hri_sercomspi_clear_INTFLAG_reg(const void *const hw, hri_sercomspi_intflag_reg_t mask)
{
    4af2:	b580      	push	{r7, lr}
    4af4:	b082      	sub	sp, #8
    4af6:	af00      	add	r7, sp, #0
    4af8:	6078      	str	r0, [r7, #4]
    4afa:	000a      	movs	r2, r1
    4afc:	1cfb      	adds	r3, r7, #3
    4afe:	701a      	strb	r2, [r3, #0]
	((Sercom *)hw)->SPI.INTFLAG.reg = mask;
    4b00:	687b      	ldr	r3, [r7, #4]
    4b02:	1cfa      	adds	r2, r7, #3
    4b04:	7812      	ldrb	r2, [r2, #0]
    4b06:	739a      	strb	r2, [r3, #14]
}
    4b08:	46c0      	nop			; (mov r8, r8)
    4b0a:	46bd      	mov	sp, r7
    4b0c:	b002      	add	sp, #8
    4b0e:	bd80      	pop	{r7, pc}

00004b10 <hri_sercomusart_get_interrupt_DRE_bit>:
{
	((Sercom *)hw)->USART.INTFLAG.reg = SERCOM_USART_INTFLAG_RXS;
}

static inline bool hri_sercomusart_get_interrupt_DRE_bit(const void *const hw)
{
    4b10:	b580      	push	{r7, lr}
    4b12:	b082      	sub	sp, #8
    4b14:	af00      	add	r7, sp, #0
    4b16:	6078      	str	r0, [r7, #4]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_DRE) >> SERCOM_USART_INTFLAG_DRE_Pos;
    4b18:	687b      	ldr	r3, [r7, #4]
    4b1a:	7b9b      	ldrb	r3, [r3, #14]
    4b1c:	b2db      	uxtb	r3, r3
    4b1e:	001a      	movs	r2, r3
    4b20:	2301      	movs	r3, #1
    4b22:	4013      	ands	r3, r2
    4b24:	1e5a      	subs	r2, r3, #1
    4b26:	4193      	sbcs	r3, r2
    4b28:	b2db      	uxtb	r3, r3
}
    4b2a:	0018      	movs	r0, r3
    4b2c:	46bd      	mov	sp, r7
    4b2e:	b002      	add	sp, #8
    4b30:	bd80      	pop	{r7, pc}

00004b32 <hri_sercomusart_get_interrupt_TXC_bit>:
{
	((Sercom *)hw)->USART.INTFLAG.reg = SERCOM_USART_INTFLAG_DRE;
}

static inline bool hri_sercomusart_get_interrupt_TXC_bit(const void *const hw)
{
    4b32:	b580      	push	{r7, lr}
    4b34:	b082      	sub	sp, #8
    4b36:	af00      	add	r7, sp, #0
    4b38:	6078      	str	r0, [r7, #4]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_TXC) >> SERCOM_USART_INTFLAG_TXC_Pos;
    4b3a:	687b      	ldr	r3, [r7, #4]
    4b3c:	7b9b      	ldrb	r3, [r3, #14]
    4b3e:	b2db      	uxtb	r3, r3
    4b40:	085b      	lsrs	r3, r3, #1
    4b42:	2201      	movs	r2, #1
    4b44:	4013      	ands	r3, r2
    4b46:	1e5a      	subs	r2, r3, #1
    4b48:	4193      	sbcs	r3, r2
    4b4a:	b2db      	uxtb	r3, r3
}
    4b4c:	0018      	movs	r0, r3
    4b4e:	46bd      	mov	sp, r7
    4b50:	b002      	add	sp, #8
    4b52:	bd80      	pop	{r7, pc}

00004b54 <hri_sercomusart_get_interrupt_RXC_bit>:
{
	((Sercom *)hw)->USART.INTFLAG.reg = SERCOM_USART_INTFLAG_TXC;
}

static inline bool hri_sercomusart_get_interrupt_RXC_bit(const void *const hw)
{
    4b54:	b580      	push	{r7, lr}
    4b56:	b082      	sub	sp, #8
    4b58:	af00      	add	r7, sp, #0
    4b5a:	6078      	str	r0, [r7, #4]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_RXC) >> SERCOM_USART_INTFLAG_RXC_Pos;
    4b5c:	687b      	ldr	r3, [r7, #4]
    4b5e:	7b9b      	ldrb	r3, [r3, #14]
    4b60:	b2db      	uxtb	r3, r3
    4b62:	089b      	lsrs	r3, r3, #2
    4b64:	2201      	movs	r2, #1
    4b66:	4013      	ands	r3, r2
    4b68:	1e5a      	subs	r2, r3, #1
    4b6a:	4193      	sbcs	r3, r2
    4b6c:	b2db      	uxtb	r3, r3
}
    4b6e:	0018      	movs	r0, r3
    4b70:	46bd      	mov	sp, r7
    4b72:	b002      	add	sp, #8
    4b74:	bd80      	pop	{r7, pc}

00004b76 <hri_sercomspi_set_CTRLA_ENABLE_bit>:
	tmp = (tmp & SERCOM_SPI_CTRLA_SWRST) >> SERCOM_SPI_CTRLA_SWRST_Pos;
	return (bool)tmp;
}

static inline void hri_sercomspi_set_CTRLA_ENABLE_bit(const void *const hw)
{
    4b76:	b580      	push	{r7, lr}
    4b78:	b082      	sub	sp, #8
    4b7a:	af00      	add	r7, sp, #0
    4b7c:	6078      	str	r0, [r7, #4]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->SPI.CTRLA.reg |= SERCOM_SPI_CTRLA_ENABLE;
    4b7e:	687b      	ldr	r3, [r7, #4]
    4b80:	681b      	ldr	r3, [r3, #0]
    4b82:	2202      	movs	r2, #2
    4b84:	431a      	orrs	r2, r3
    4b86:	687b      	ldr	r3, [r7, #4]
    4b88:	601a      	str	r2, [r3, #0]
	hri_sercomspi_wait_for_sync(hw);
    4b8a:	687b      	ldr	r3, [r7, #4]
    4b8c:	0018      	movs	r0, r3
    4b8e:	f7ff ff59 	bl	4a44 <hri_sercomspi_wait_for_sync>
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    4b92:	46c0      	nop			; (mov r8, r8)
    4b94:	46bd      	mov	sp, r7
    4b96:	b002      	add	sp, #8
    4b98:	bd80      	pop	{r7, pc}

00004b9a <hri_sercomspi_get_CTRLA_ENABLE_bit>:

static inline bool hri_sercomspi_get_CTRLA_ENABLE_bit(const void *const hw)
{
    4b9a:	b580      	push	{r7, lr}
    4b9c:	b084      	sub	sp, #16
    4b9e:	af00      	add	r7, sp, #0
    4ba0:	6078      	str	r0, [r7, #4]
	uint32_t tmp;
	hri_sercomspi_wait_for_sync(hw);
    4ba2:	687b      	ldr	r3, [r7, #4]
    4ba4:	0018      	movs	r0, r3
    4ba6:	f7ff ff4d 	bl	4a44 <hri_sercomspi_wait_for_sync>
	tmp = ((Sercom *)hw)->SPI.CTRLA.reg;
    4baa:	687b      	ldr	r3, [r7, #4]
    4bac:	681b      	ldr	r3, [r3, #0]
    4bae:	60fb      	str	r3, [r7, #12]
	tmp = (tmp & SERCOM_SPI_CTRLA_ENABLE) >> SERCOM_SPI_CTRLA_ENABLE_Pos;
    4bb0:	68fb      	ldr	r3, [r7, #12]
    4bb2:	085b      	lsrs	r3, r3, #1
    4bb4:	2201      	movs	r2, #1
    4bb6:	4013      	ands	r3, r2
    4bb8:	60fb      	str	r3, [r7, #12]
	return (bool)tmp;
    4bba:	68fb      	ldr	r3, [r7, #12]
    4bbc:	1e5a      	subs	r2, r3, #1
    4bbe:	4193      	sbcs	r3, r2
    4bc0:	b2db      	uxtb	r3, r3
}
    4bc2:	0018      	movs	r0, r3
    4bc4:	46bd      	mov	sp, r7
    4bc6:	b004      	add	sp, #16
    4bc8:	bd80      	pop	{r7, pc}

00004bca <hri_sercomspi_get_CTRLA_reg>:
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline hri_sercomspi_ctrla_reg_t hri_sercomspi_get_CTRLA_reg(const void *const         hw,
                                                                    hri_sercomspi_ctrla_reg_t mask)
{
    4bca:	b580      	push	{r7, lr}
    4bcc:	b084      	sub	sp, #16
    4bce:	af00      	add	r7, sp, #0
    4bd0:	6078      	str	r0, [r7, #4]
    4bd2:	6039      	str	r1, [r7, #0]
	uint32_t tmp;
	hri_sercomspi_wait_for_sync(hw);
    4bd4:	687b      	ldr	r3, [r7, #4]
    4bd6:	0018      	movs	r0, r3
    4bd8:	f7ff ff34 	bl	4a44 <hri_sercomspi_wait_for_sync>
	tmp = ((Sercom *)hw)->SPI.CTRLA.reg;
    4bdc:	687b      	ldr	r3, [r7, #4]
    4bde:	681b      	ldr	r3, [r3, #0]
    4be0:	60fb      	str	r3, [r7, #12]
	tmp &= mask;
    4be2:	68fb      	ldr	r3, [r7, #12]
    4be4:	683a      	ldr	r2, [r7, #0]
    4be6:	4013      	ands	r3, r2
    4be8:	60fb      	str	r3, [r7, #12]
	return tmp;
    4bea:	68fb      	ldr	r3, [r7, #12]
}
    4bec:	0018      	movs	r0, r3
    4bee:	46bd      	mov	sp, r7
    4bf0:	b004      	add	sp, #16
    4bf2:	bd80      	pop	{r7, pc}

00004bf4 <hri_sercomspi_write_CTRLA_reg>:

static inline void hri_sercomspi_write_CTRLA_reg(const void *const hw, hri_sercomspi_ctrla_reg_t data)
{
    4bf4:	b580      	push	{r7, lr}
    4bf6:	b082      	sub	sp, #8
    4bf8:	af00      	add	r7, sp, #0
    4bfa:	6078      	str	r0, [r7, #4]
    4bfc:	6039      	str	r1, [r7, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->SPI.CTRLA.reg = data;
    4bfe:	687b      	ldr	r3, [r7, #4]
    4c00:	683a      	ldr	r2, [r7, #0]
    4c02:	601a      	str	r2, [r3, #0]
	hri_sercomspi_wait_for_sync(hw);
    4c04:	687b      	ldr	r3, [r7, #4]
    4c06:	0018      	movs	r0, r3
    4c08:	f7ff ff1c 	bl	4a44 <hri_sercomspi_wait_for_sync>
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    4c0c:	46c0      	nop			; (mov r8, r8)
    4c0e:	46bd      	mov	sp, r7
    4c10:	b002      	add	sp, #8
    4c12:	bd80      	pop	{r7, pc}

00004c14 <hri_sercomusart_get_CTRLA_reg>:
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline hri_sercomusart_ctrla_reg_t hri_sercomusart_get_CTRLA_reg(const void *const           hw,
                                                                        hri_sercomusart_ctrla_reg_t mask)
{
    4c14:	b580      	push	{r7, lr}
    4c16:	b084      	sub	sp, #16
    4c18:	af00      	add	r7, sp, #0
    4c1a:	6078      	str	r0, [r7, #4]
    4c1c:	6039      	str	r1, [r7, #0]
	uint32_t tmp;
	hri_sercomusart_wait_for_sync(hw);
    4c1e:	687b      	ldr	r3, [r7, #4]
    4c20:	0018      	movs	r0, r3
    4c22:	f7ff ff2f 	bl	4a84 <hri_sercomusart_wait_for_sync>
	tmp = ((Sercom *)hw)->USART.CTRLA.reg;
    4c26:	687b      	ldr	r3, [r7, #4]
    4c28:	681b      	ldr	r3, [r3, #0]
    4c2a:	60fb      	str	r3, [r7, #12]
	tmp &= mask;
    4c2c:	68fb      	ldr	r3, [r7, #12]
    4c2e:	683a      	ldr	r2, [r7, #0]
    4c30:	4013      	ands	r3, r2
    4c32:	60fb      	str	r3, [r7, #12]
	return tmp;
    4c34:	68fb      	ldr	r3, [r7, #12]
}
    4c36:	0018      	movs	r0, r3
    4c38:	46bd      	mov	sp, r7
    4c3a:	b004      	add	sp, #16
    4c3c:	bd80      	pop	{r7, pc}

00004c3e <hri_sercomusart_write_CTRLA_reg>:

static inline void hri_sercomusart_write_CTRLA_reg(const void *const hw, hri_sercomusart_ctrla_reg_t data)
{
    4c3e:	b580      	push	{r7, lr}
    4c40:	b082      	sub	sp, #8
    4c42:	af00      	add	r7, sp, #0
    4c44:	6078      	str	r0, [r7, #4]
    4c46:	6039      	str	r1, [r7, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.CTRLA.reg = data;
    4c48:	687b      	ldr	r3, [r7, #4]
    4c4a:	683a      	ldr	r2, [r7, #0]
    4c4c:	601a      	str	r2, [r3, #0]
	hri_sercomusart_wait_for_sync(hw);
    4c4e:	687b      	ldr	r3, [r7, #4]
    4c50:	0018      	movs	r0, r3
    4c52:	f7ff ff17 	bl	4a84 <hri_sercomusart_wait_for_sync>
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    4c56:	46c0      	nop			; (mov r8, r8)
    4c58:	46bd      	mov	sp, r7
    4c5a:	b002      	add	sp, #8
    4c5c:	bd80      	pop	{r7, pc}

00004c5e <hri_sercomspi_write_CTRLB_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomspi_write_CTRLB_reg(const void *const hw, hri_sercomspi_ctrlb_reg_t data)
{
    4c5e:	b580      	push	{r7, lr}
    4c60:	b082      	sub	sp, #8
    4c62:	af00      	add	r7, sp, #0
    4c64:	6078      	str	r0, [r7, #4]
    4c66:	6039      	str	r1, [r7, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->SPI.CTRLB.reg = data;
    4c68:	687b      	ldr	r3, [r7, #4]
    4c6a:	683a      	ldr	r2, [r7, #0]
    4c6c:	605a      	str	r2, [r3, #4]
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    4c6e:	46c0      	nop			; (mov r8, r8)
    4c70:	46bd      	mov	sp, r7
    4c72:	b002      	add	sp, #8
    4c74:	bd80      	pop	{r7, pc}

00004c76 <hri_sercomusart_write_CTRLB_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomusart_write_CTRLB_reg(const void *const hw, hri_sercomusart_ctrlb_reg_t data)
{
    4c76:	b580      	push	{r7, lr}
    4c78:	b082      	sub	sp, #8
    4c7a:	af00      	add	r7, sp, #0
    4c7c:	6078      	str	r0, [r7, #4]
    4c7e:	6039      	str	r1, [r7, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.CTRLB.reg = data;
    4c80:	687b      	ldr	r3, [r7, #4]
    4c82:	683a      	ldr	r2, [r7, #0]
    4c84:	605a      	str	r2, [r3, #4]
	hri_sercomusart_wait_for_sync(hw);
    4c86:	687b      	ldr	r3, [r7, #4]
    4c88:	0018      	movs	r0, r3
    4c8a:	f7ff fefb 	bl	4a84 <hri_sercomusart_wait_for_sync>
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    4c8e:	46c0      	nop			; (mov r8, r8)
    4c90:	46bd      	mov	sp, r7
    4c92:	b002      	add	sp, #8
    4c94:	bd80      	pop	{r7, pc}

00004c96 <hri_sercomspi_write_DBGCTRL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomspi_write_DBGCTRL_reg(const void *const hw, hri_sercomspi_dbgctrl_reg_t data)
{
    4c96:	b580      	push	{r7, lr}
    4c98:	b082      	sub	sp, #8
    4c9a:	af00      	add	r7, sp, #0
    4c9c:	6078      	str	r0, [r7, #4]
    4c9e:	000a      	movs	r2, r1
    4ca0:	1cfb      	adds	r3, r7, #3
    4ca2:	701a      	strb	r2, [r3, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->SPI.DBGCTRL.reg = data;
    4ca4:	687b      	ldr	r3, [r7, #4]
    4ca6:	1cfa      	adds	r2, r7, #3
    4ca8:	7812      	ldrb	r2, [r2, #0]
    4caa:	721a      	strb	r2, [r3, #8]
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    4cac:	46c0      	nop			; (mov r8, r8)
    4cae:	46bd      	mov	sp, r7
    4cb0:	b002      	add	sp, #8
    4cb2:	bd80      	pop	{r7, pc}

00004cb4 <hri_sercomusart_write_DBGCTRL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomusart_write_DBGCTRL_reg(const void *const hw, hri_sercomusart_dbgctrl_reg_t data)
{
    4cb4:	b580      	push	{r7, lr}
    4cb6:	b082      	sub	sp, #8
    4cb8:	af00      	add	r7, sp, #0
    4cba:	6078      	str	r0, [r7, #4]
    4cbc:	000a      	movs	r2, r1
    4cbe:	1cfb      	adds	r3, r7, #3
    4cc0:	701a      	strb	r2, [r3, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.DBGCTRL.reg = data;
    4cc2:	687b      	ldr	r3, [r7, #4]
    4cc4:	1cfa      	adds	r2, r7, #3
    4cc6:	7812      	ldrb	r2, [r2, #0]
    4cc8:	721a      	strb	r2, [r3, #8]
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    4cca:	46c0      	nop			; (mov r8, r8)
    4ccc:	46bd      	mov	sp, r7
    4cce:	b002      	add	sp, #8
    4cd0:	bd80      	pop	{r7, pc}

00004cd2 <hri_sercomspi_write_BAUD_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomspi_write_BAUD_reg(const void *const hw, hri_sercomspi_baud_reg_t data)
{
    4cd2:	b580      	push	{r7, lr}
    4cd4:	b082      	sub	sp, #8
    4cd6:	af00      	add	r7, sp, #0
    4cd8:	6078      	str	r0, [r7, #4]
    4cda:	000a      	movs	r2, r1
    4cdc:	1cfb      	adds	r3, r7, #3
    4cde:	701a      	strb	r2, [r3, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->SPI.BAUD.reg = data;
    4ce0:	687b      	ldr	r3, [r7, #4]
    4ce2:	1cfa      	adds	r2, r7, #3
    4ce4:	7812      	ldrb	r2, [r2, #0]
    4ce6:	729a      	strb	r2, [r3, #10]
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    4ce8:	46c0      	nop			; (mov r8, r8)
    4cea:	46bd      	mov	sp, r7
    4cec:	b002      	add	sp, #8
    4cee:	bd80      	pop	{r7, pc}

00004cf0 <hri_sercomusart_write_BAUD_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomusart_write_BAUD_reg(const void *const hw, hri_sercomusart_baud_reg_t data)
{
    4cf0:	b580      	push	{r7, lr}
    4cf2:	b082      	sub	sp, #8
    4cf4:	af00      	add	r7, sp, #0
    4cf6:	6078      	str	r0, [r7, #4]
    4cf8:	000a      	movs	r2, r1
    4cfa:	1cbb      	adds	r3, r7, #2
    4cfc:	801a      	strh	r2, [r3, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.BAUD.reg = data;
    4cfe:	687b      	ldr	r3, [r7, #4]
    4d00:	1cba      	adds	r2, r7, #2
    4d02:	8812      	ldrh	r2, [r2, #0]
    4d04:	815a      	strh	r2, [r3, #10]
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    4d06:	46c0      	nop			; (mov r8, r8)
    4d08:	46bd      	mov	sp, r7
    4d0a:	b002      	add	sp, #8
    4d0c:	bd80      	pop	{r7, pc}

00004d0e <hri_sercomspi_write_ADDR_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomspi_write_ADDR_reg(const void *const hw, hri_sercomspi_addr_reg_t data)
{
    4d0e:	b580      	push	{r7, lr}
    4d10:	b082      	sub	sp, #8
    4d12:	af00      	add	r7, sp, #0
    4d14:	6078      	str	r0, [r7, #4]
    4d16:	6039      	str	r1, [r7, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->SPI.ADDR.reg = data;
    4d18:	687b      	ldr	r3, [r7, #4]
    4d1a:	683a      	ldr	r2, [r7, #0]
    4d1c:	615a      	str	r2, [r3, #20]
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    4d1e:	46c0      	nop			; (mov r8, r8)
    4d20:	46bd      	mov	sp, r7
    4d22:	b002      	add	sp, #8
    4d24:	bd80      	pop	{r7, pc}

00004d26 <hri_sercomspi_write_DATA_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomspi_write_DATA_reg(const void *const hw, hri_sercomspi_data_reg_t data)
{
    4d26:	b580      	push	{r7, lr}
    4d28:	b082      	sub	sp, #8
    4d2a:	af00      	add	r7, sp, #0
    4d2c:	6078      	str	r0, [r7, #4]
    4d2e:	000a      	movs	r2, r1
    4d30:	1cbb      	adds	r3, r7, #2
    4d32:	801a      	strh	r2, [r3, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->SPI.DATA.reg = data;
    4d34:	687b      	ldr	r3, [r7, #4]
    4d36:	1cba      	adds	r2, r7, #2
    4d38:	8812      	ldrh	r2, [r2, #0]
    4d3a:	831a      	strh	r2, [r3, #24]
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    4d3c:	46c0      	nop			; (mov r8, r8)
    4d3e:	46bd      	mov	sp, r7
    4d40:	b002      	add	sp, #8
    4d42:	bd80      	pop	{r7, pc}

00004d44 <hri_sercomspi_read_DATA_reg>:
	((Sercom *)hw)->SPI.DATA.reg ^= mask;
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline hri_sercomspi_data_reg_t hri_sercomspi_read_DATA_reg(const void *const hw)
{
    4d44:	b580      	push	{r7, lr}
    4d46:	b082      	sub	sp, #8
    4d48:	af00      	add	r7, sp, #0
    4d4a:	6078      	str	r0, [r7, #4]
	return ((Sercom *)hw)->SPI.DATA.reg;
    4d4c:	687b      	ldr	r3, [r7, #4]
    4d4e:	8b1b      	ldrh	r3, [r3, #24]
    4d50:	b29b      	uxth	r3, r3
}
    4d52:	0018      	movs	r0, r3
    4d54:	46bd      	mov	sp, r7
    4d56:	b002      	add	sp, #8
    4d58:	bd80      	pop	{r7, pc}

00004d5a <hri_sercomusart_write_DATA_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomusart_write_DATA_reg(const void *const hw, hri_sercomusart_data_reg_t data)
{
    4d5a:	b580      	push	{r7, lr}
    4d5c:	b082      	sub	sp, #8
    4d5e:	af00      	add	r7, sp, #0
    4d60:	6078      	str	r0, [r7, #4]
    4d62:	000a      	movs	r2, r1
    4d64:	1cbb      	adds	r3, r7, #2
    4d66:	801a      	strh	r2, [r3, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.DATA.reg = data;
    4d68:	687b      	ldr	r3, [r7, #4]
    4d6a:	1cba      	adds	r2, r7, #2
    4d6c:	8812      	ldrh	r2, [r2, #0]
    4d6e:	831a      	strh	r2, [r3, #24]
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    4d70:	46c0      	nop			; (mov r8, r8)
    4d72:	46bd      	mov	sp, r7
    4d74:	b002      	add	sp, #8
    4d76:	bd80      	pop	{r7, pc}

00004d78 <hri_sercomusart_read_DATA_reg>:
	((Sercom *)hw)->USART.DATA.reg ^= mask;
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline hri_sercomusart_data_reg_t hri_sercomusart_read_DATA_reg(const void *const hw)
{
    4d78:	b580      	push	{r7, lr}
    4d7a:	b082      	sub	sp, #8
    4d7c:	af00      	add	r7, sp, #0
    4d7e:	6078      	str	r0, [r7, #4]
	return ((Sercom *)hw)->USART.DATA.reg;
    4d80:	687b      	ldr	r3, [r7, #4]
    4d82:	8b1b      	ldrh	r3, [r3, #24]
    4d84:	b29b      	uxth	r3, r3
}
    4d86:	0018      	movs	r0, r3
    4d88:	46bd      	mov	sp, r7
    4d8a:	b002      	add	sp, #8
    4d8c:	bd80      	pop	{r7, pc}
	...

00004d90 <_usart_sync_init>:

/**
 * \brief Initialize synchronous SERCOM USART
 */
int32_t _usart_sync_init(struct _usart_sync_device *const device, void *const hw)
{
    4d90:	b580      	push	{r7, lr}
    4d92:	b082      	sub	sp, #8
    4d94:	af00      	add	r7, sp, #0
    4d96:	6078      	str	r0, [r7, #4]
    4d98:	6039      	str	r1, [r7, #0]
	ASSERT(device);
    4d9a:	687b      	ldr	r3, [r7, #4]
    4d9c:	1e5a      	subs	r2, r3, #1
    4d9e:	4193      	sbcs	r3, r2
    4da0:	b2db      	uxtb	r3, r3
    4da2:	4908      	ldr	r1, [pc, #32]	; (4dc4 <_usart_sync_init+0x34>)
    4da4:	22a1      	movs	r2, #161	; 0xa1
    4da6:	0018      	movs	r0, r3
    4da8:	f7ff f9ee 	bl	4188 <assert>

	device->hw = hw;
    4dac:	687b      	ldr	r3, [r7, #4]
    4dae:	683a      	ldr	r2, [r7, #0]
    4db0:	601a      	str	r2, [r3, #0]

	return _usart_init(hw);
    4db2:	683b      	ldr	r3, [r7, #0]
    4db4:	0018      	movs	r0, r3
    4db6:	f000 f8a3 	bl	4f00 <_usart_init>
    4dba:	0003      	movs	r3, r0
}
    4dbc:	0018      	movs	r0, r3
    4dbe:	46bd      	mov	sp, r7
    4dc0:	b002      	add	sp, #8
    4dc2:	bd80      	pop	{r7, pc}
    4dc4:	00007e3c 	.word	0x00007e3c

00004dc8 <_usart_sync_write_byte>:

/**
 * \brief Write a byte to the given SERCOM USART instance
 */
void _usart_sync_write_byte(struct _usart_sync_device *const device, uint8_t data)
{
    4dc8:	b580      	push	{r7, lr}
    4dca:	b082      	sub	sp, #8
    4dcc:	af00      	add	r7, sp, #0
    4dce:	6078      	str	r0, [r7, #4]
    4dd0:	000a      	movs	r2, r1
    4dd2:	1cfb      	adds	r3, r7, #3
    4dd4:	701a      	strb	r2, [r3, #0]
	hri_sercomusart_write_DATA_reg(device->hw, data);
    4dd6:	687b      	ldr	r3, [r7, #4]
    4dd8:	681a      	ldr	r2, [r3, #0]
    4dda:	1cfb      	adds	r3, r7, #3
    4ddc:	781b      	ldrb	r3, [r3, #0]
    4dde:	b29b      	uxth	r3, r3
    4de0:	0019      	movs	r1, r3
    4de2:	0010      	movs	r0, r2
    4de4:	f7ff ffb9 	bl	4d5a <hri_sercomusart_write_DATA_reg>
}
    4de8:	46c0      	nop			; (mov r8, r8)
    4dea:	46bd      	mov	sp, r7
    4dec:	b002      	add	sp, #8
    4dee:	bd80      	pop	{r7, pc}

00004df0 <_usart_sync_read_byte>:

/**
 * \brief Read a byte from the given SERCOM USART instance
 */
uint8_t _usart_sync_read_byte(const struct _usart_sync_device *const device)
{
    4df0:	b580      	push	{r7, lr}
    4df2:	b082      	sub	sp, #8
    4df4:	af00      	add	r7, sp, #0
    4df6:	6078      	str	r0, [r7, #4]
	return hri_sercomusart_read_DATA_reg(device->hw);
    4df8:	687b      	ldr	r3, [r7, #4]
    4dfa:	681b      	ldr	r3, [r3, #0]
    4dfc:	0018      	movs	r0, r3
    4dfe:	f7ff ffbb 	bl	4d78 <hri_sercomusart_read_DATA_reg>
    4e02:	0003      	movs	r3, r0
    4e04:	b2db      	uxtb	r3, r3
}
    4e06:	0018      	movs	r0, r3
    4e08:	46bd      	mov	sp, r7
    4e0a:	b002      	add	sp, #8
    4e0c:	bd80      	pop	{r7, pc}

00004e0e <_usart_sync_is_ready_to_send>:

/**
 * \brief Check if USART is ready to send next byte
 */
bool _usart_sync_is_ready_to_send(const struct _usart_sync_device *const device)
{
    4e0e:	b580      	push	{r7, lr}
    4e10:	b082      	sub	sp, #8
    4e12:	af00      	add	r7, sp, #0
    4e14:	6078      	str	r0, [r7, #4]
	return hri_sercomusart_get_interrupt_DRE_bit(device->hw);
    4e16:	687b      	ldr	r3, [r7, #4]
    4e18:	681b      	ldr	r3, [r3, #0]
    4e1a:	0018      	movs	r0, r3
    4e1c:	f7ff fe78 	bl	4b10 <hri_sercomusart_get_interrupt_DRE_bit>
    4e20:	0003      	movs	r3, r0
}
    4e22:	0018      	movs	r0, r3
    4e24:	46bd      	mov	sp, r7
    4e26:	b002      	add	sp, #8
    4e28:	bd80      	pop	{r7, pc}

00004e2a <_usart_sync_is_transmit_done>:

/**
 * \brief Check if USART transmission complete
 */
bool _usart_sync_is_transmit_done(const struct _usart_sync_device *const device)
{
    4e2a:	b580      	push	{r7, lr}
    4e2c:	b082      	sub	sp, #8
    4e2e:	af00      	add	r7, sp, #0
    4e30:	6078      	str	r0, [r7, #4]
	return hri_sercomusart_get_interrupt_TXC_bit(device->hw);
    4e32:	687b      	ldr	r3, [r7, #4]
    4e34:	681b      	ldr	r3, [r3, #0]
    4e36:	0018      	movs	r0, r3
    4e38:	f7ff fe7b 	bl	4b32 <hri_sercomusart_get_interrupt_TXC_bit>
    4e3c:	0003      	movs	r3, r0
}
    4e3e:	0018      	movs	r0, r3
    4e40:	46bd      	mov	sp, r7
    4e42:	b002      	add	sp, #8
    4e44:	bd80      	pop	{r7, pc}

00004e46 <_usart_sync_is_byte_received>:

/**
 * \brief Check if there is data received by USART
 */
bool _usart_sync_is_byte_received(const struct _usart_sync_device *const device)
{
    4e46:	b580      	push	{r7, lr}
    4e48:	b082      	sub	sp, #8
    4e4a:	af00      	add	r7, sp, #0
    4e4c:	6078      	str	r0, [r7, #4]
	return hri_sercomusart_get_interrupt_RXC_bit(device->hw);
    4e4e:	687b      	ldr	r3, [r7, #4]
    4e50:	681b      	ldr	r3, [r3, #0]
    4e52:	0018      	movs	r0, r3
    4e54:	f7ff fe7e 	bl	4b54 <hri_sercomusart_get_interrupt_RXC_bit>
    4e58:	0003      	movs	r3, r0
}
    4e5a:	0018      	movs	r0, r3
    4e5c:	46bd      	mov	sp, r7
    4e5e:	b002      	add	sp, #8
    4e60:	bd80      	pop	{r7, pc}
	...

00004e64 <_sercom_get_hardware_index>:

/**
 * \brief Retrieve ordinal number of the given sercom hardware instance
 */
static uint8_t _sercom_get_hardware_index(const void *const hw)
{
    4e64:	b580      	push	{r7, lr}
    4e66:	b082      	sub	sp, #8
    4e68:	af00      	add	r7, sp, #0
    4e6a:	6078      	str	r0, [r7, #4]
#ifdef _UNIT_TEST_
	return ((uint32_t)hw - (uint32_t)SERCOM0) / sizeof(Sercom);
#endif

	return ((uint32_t)hw - (uint32_t)SERCOM0) >> 10;
    4e6c:	687b      	ldr	r3, [r7, #4]
    4e6e:	4a04      	ldr	r2, [pc, #16]	; (4e80 <_sercom_get_hardware_index+0x1c>)
    4e70:	4694      	mov	ip, r2
    4e72:	4463      	add	r3, ip
    4e74:	0a9b      	lsrs	r3, r3, #10
    4e76:	b2db      	uxtb	r3, r3
}
    4e78:	0018      	movs	r0, r3
    4e7a:	46bd      	mov	sp, r7
    4e7c:	b002      	add	sp, #8
    4e7e:	bd80      	pop	{r7, pc}
    4e80:	bdfff800 	.word	0xbdfff800

00004e84 <_get_sercom_index>:
 * \param[in] hw The pointer to hardware instance

 * \return The ordinal number of the given sercom hardware instance
 */
static uint8_t _get_sercom_index(const void *const hw)
{
    4e84:	b590      	push	{r4, r7, lr}
    4e86:	b085      	sub	sp, #20
    4e88:	af00      	add	r7, sp, #0
    4e8a:	6078      	str	r0, [r7, #4]
	uint8_t sercom_offset = _sercom_get_hardware_index(hw);
    4e8c:	230e      	movs	r3, #14
    4e8e:	18fc      	adds	r4, r7, r3
    4e90:	687b      	ldr	r3, [r7, #4]
    4e92:	0018      	movs	r0, r3
    4e94:	f7ff ffe6 	bl	4e64 <_sercom_get_hardware_index>
    4e98:	0003      	movs	r3, r0
    4e9a:	7023      	strb	r3, [r4, #0]
	uint8_t i;

	for (i = 0; i < ARRAY_SIZE(_usarts); i++) {
    4e9c:	230f      	movs	r3, #15
    4e9e:	18fb      	adds	r3, r7, r3
    4ea0:	2200      	movs	r2, #0
    4ea2:	701a      	strb	r2, [r3, #0]
    4ea4:	e015      	b.n	4ed2 <_get_sercom_index+0x4e>
		if (_usarts[i].number == sercom_offset) {
    4ea6:	230f      	movs	r3, #15
    4ea8:	18fb      	adds	r3, r7, r3
    4eaa:	781a      	ldrb	r2, [r3, #0]
    4eac:	4b11      	ldr	r3, [pc, #68]	; (4ef4 <_get_sercom_index+0x70>)
    4eae:	0112      	lsls	r2, r2, #4
    4eb0:	5cd3      	ldrb	r3, [r2, r3]
    4eb2:	220e      	movs	r2, #14
    4eb4:	18ba      	adds	r2, r7, r2
    4eb6:	7812      	ldrb	r2, [r2, #0]
    4eb8:	429a      	cmp	r2, r3
    4eba:	d103      	bne.n	4ec4 <_get_sercom_index+0x40>
			return i;
    4ebc:	230f      	movs	r3, #15
    4ebe:	18fb      	adds	r3, r7, r3
    4ec0:	781b      	ldrb	r3, [r3, #0]
    4ec2:	e012      	b.n	4eea <_get_sercom_index+0x66>
	for (i = 0; i < ARRAY_SIZE(_usarts); i++) {
    4ec4:	230f      	movs	r3, #15
    4ec6:	18fb      	adds	r3, r7, r3
    4ec8:	781a      	ldrb	r2, [r3, #0]
    4eca:	230f      	movs	r3, #15
    4ecc:	18fb      	adds	r3, r7, r3
    4ece:	3201      	adds	r2, #1
    4ed0:	701a      	strb	r2, [r3, #0]
    4ed2:	230f      	movs	r3, #15
    4ed4:	18fb      	adds	r3, r7, r3
    4ed6:	781b      	ldrb	r3, [r3, #0]
    4ed8:	2b00      	cmp	r3, #0
    4eda:	d0e4      	beq.n	4ea6 <_get_sercom_index+0x22>
		}
	}

	ASSERT(false);
    4edc:	4a06      	ldr	r2, [pc, #24]	; (4ef8 <_get_sercom_index+0x74>)
    4ede:	4b07      	ldr	r3, [pc, #28]	; (4efc <_get_sercom_index+0x78>)
    4ee0:	0019      	movs	r1, r3
    4ee2:	2000      	movs	r0, #0
    4ee4:	f7ff f950 	bl	4188 <assert>
	return 0;
    4ee8:	2300      	movs	r3, #0
}
    4eea:	0018      	movs	r0, r3
    4eec:	46bd      	mov	sp, r7
    4eee:	b005      	add	sp, #20
    4ef0:	bd90      	pop	{r4, r7, pc}
    4ef2:	46c0      	nop			; (mov r8, r8)
    4ef4:	20000000 	.word	0x20000000
    4ef8:	0000022a 	.word	0x0000022a
    4efc:	00007e3c 	.word	0x00007e3c

00004f00 <_usart_init>:
 * \param[in] hw The pointer to hardware instance
 *
 * \return The status of initialization
 */
static int32_t _usart_init(void *const hw)
{
    4f00:	b590      	push	{r4, r7, lr}
    4f02:	b085      	sub	sp, #20
    4f04:	af00      	add	r7, sp, #0
    4f06:	6078      	str	r0, [r7, #4]
	uint8_t i = _get_sercom_index(hw);
    4f08:	230f      	movs	r3, #15
    4f0a:	18fc      	adds	r4, r7, r3
    4f0c:	687b      	ldr	r3, [r7, #4]
    4f0e:	0018      	movs	r0, r3
    4f10:	f7ff ffb8 	bl	4e84 <_get_sercom_index>
    4f14:	0003      	movs	r3, r0
    4f16:	7023      	strb	r3, [r4, #0]

	hri_sercomusart_wait_for_sync(hw);
    4f18:	687b      	ldr	r3, [r7, #4]
    4f1a:	0018      	movs	r0, r3
    4f1c:	f7ff fdb2 	bl	4a84 <hri_sercomusart_wait_for_sync>
	if (hri_sercomusart_get_CTRLA_reg(hw, SERCOM_USART_CTRLA_ENABLE)) {
    4f20:	687b      	ldr	r3, [r7, #4]
    4f22:	2102      	movs	r1, #2
    4f24:	0018      	movs	r0, r3
    4f26:	f7ff fe75 	bl	4c14 <hri_sercomusart_get_CTRLA_reg>
    4f2a:	1e03      	subs	r3, r0, #0
    4f2c:	d008      	beq.n	4f40 <_usart_init+0x40>
		hri_sercomusart_write_CTRLA_reg(hw, 0);
    4f2e:	687b      	ldr	r3, [r7, #4]
    4f30:	2100      	movs	r1, #0
    4f32:	0018      	movs	r0, r3
    4f34:	f7ff fe83 	bl	4c3e <hri_sercomusart_write_CTRLA_reg>
		hri_sercomusart_wait_for_sync(hw);
    4f38:	687b      	ldr	r3, [r7, #4]
    4f3a:	0018      	movs	r0, r3
    4f3c:	f7ff fda2 	bl	4a84 <hri_sercomusart_wait_for_sync>
	}
	hri_sercomusart_write_CTRLA_reg(hw, SERCOM_USART_CTRLA_SWRST);
    4f40:	687b      	ldr	r3, [r7, #4]
    4f42:	2101      	movs	r1, #1
    4f44:	0018      	movs	r0, r3
    4f46:	f7ff fe7a 	bl	4c3e <hri_sercomusart_write_CTRLA_reg>
	hri_sercomusart_wait_for_sync(hw);
    4f4a:	687b      	ldr	r3, [r7, #4]
    4f4c:	0018      	movs	r0, r3
    4f4e:	f7ff fd99 	bl	4a84 <hri_sercomusart_wait_for_sync>

	hri_sercomusart_write_CTRLA_reg(hw, _usarts[i].ctrl_a);
    4f52:	230f      	movs	r3, #15
    4f54:	18fb      	adds	r3, r7, r3
    4f56:	781b      	ldrb	r3, [r3, #0]
    4f58:	4a1a      	ldr	r2, [pc, #104]	; (4fc4 <_usart_init+0xc4>)
    4f5a:	011b      	lsls	r3, r3, #4
    4f5c:	18d3      	adds	r3, r2, r3
    4f5e:	3304      	adds	r3, #4
    4f60:	681a      	ldr	r2, [r3, #0]
    4f62:	687b      	ldr	r3, [r7, #4]
    4f64:	0011      	movs	r1, r2
    4f66:	0018      	movs	r0, r3
    4f68:	f7ff fe69 	bl	4c3e <hri_sercomusart_write_CTRLA_reg>
	hri_sercomusart_write_CTRLB_reg(hw, _usarts[i].ctrl_b);
    4f6c:	230f      	movs	r3, #15
    4f6e:	18fb      	adds	r3, r7, r3
    4f70:	781b      	ldrb	r3, [r3, #0]
    4f72:	4a14      	ldr	r2, [pc, #80]	; (4fc4 <_usart_init+0xc4>)
    4f74:	011b      	lsls	r3, r3, #4
    4f76:	18d3      	adds	r3, r2, r3
    4f78:	3308      	adds	r3, #8
    4f7a:	681a      	ldr	r2, [r3, #0]
    4f7c:	687b      	ldr	r3, [r7, #4]
    4f7e:	0011      	movs	r1, r2
    4f80:	0018      	movs	r0, r3
    4f82:	f7ff fe78 	bl	4c76 <hri_sercomusart_write_CTRLB_reg>
	hri_sercomusart_write_BAUD_reg(hw, _usarts[i].baud);
    4f86:	230f      	movs	r3, #15
    4f88:	18fb      	adds	r3, r7, r3
    4f8a:	781b      	ldrb	r3, [r3, #0]
    4f8c:	4a0d      	ldr	r2, [pc, #52]	; (4fc4 <_usart_init+0xc4>)
    4f8e:	011b      	lsls	r3, r3, #4
    4f90:	18d3      	adds	r3, r2, r3
    4f92:	330c      	adds	r3, #12
    4f94:	881a      	ldrh	r2, [r3, #0]
    4f96:	687b      	ldr	r3, [r7, #4]
    4f98:	0011      	movs	r1, r2
    4f9a:	0018      	movs	r0, r3
    4f9c:	f7ff fea8 	bl	4cf0 <hri_sercomusart_write_BAUD_reg>
	hri_sercomusart_write_DBGCTRL_reg(hw, _usarts[i].debug_ctrl);
    4fa0:	230f      	movs	r3, #15
    4fa2:	18fb      	adds	r3, r7, r3
    4fa4:	781b      	ldrb	r3, [r3, #0]
    4fa6:	4a07      	ldr	r2, [pc, #28]	; (4fc4 <_usart_init+0xc4>)
    4fa8:	011b      	lsls	r3, r3, #4
    4faa:	18d3      	adds	r3, r2, r3
    4fac:	330e      	adds	r3, #14
    4fae:	781a      	ldrb	r2, [r3, #0]
    4fb0:	687b      	ldr	r3, [r7, #4]
    4fb2:	0011      	movs	r1, r2
    4fb4:	0018      	movs	r0, r3
    4fb6:	f7ff fe7d 	bl	4cb4 <hri_sercomusart_write_DBGCTRL_reg>

	return ERR_NONE;
    4fba:	2300      	movs	r3, #0
}
    4fbc:	0018      	movs	r0, r3
    4fbe:	46bd      	mov	sp, r7
    4fc0:	b005      	add	sp, #20
    4fc2:	bd90      	pop	{r4, r7, pc}
    4fc4:	20000000 	.word	0x20000000

00004fc8 <_spi_sync_enable>:
 *  \param[in] hw Pointer to the hardware register base.
 *
 * \return Enabling status
 */
static int32_t _spi_sync_enable(void *const hw)
{
    4fc8:	b580      	push	{r7, lr}
    4fca:	b082      	sub	sp, #8
    4fcc:	af00      	add	r7, sp, #0
    4fce:	6078      	str	r0, [r7, #4]
	if (hri_sercomspi_is_syncing(hw)) {
    4fd0:	687b      	ldr	r3, [r7, #4]
    4fd2:	0018      	movs	r0, r3
    4fd4:	f7ff fd46 	bl	4a64 <hri_sercomspi_is_syncing>
    4fd8:	1e03      	subs	r3, r0, #0
    4fda:	d002      	beq.n	4fe2 <_spi_sync_enable+0x1a>
		return ERR_BUSY;
    4fdc:	2304      	movs	r3, #4
    4fde:	425b      	negs	r3, r3
    4fe0:	e004      	b.n	4fec <_spi_sync_enable+0x24>
	}

	hri_sercomspi_set_CTRLA_ENABLE_bit(hw);
    4fe2:	687b      	ldr	r3, [r7, #4]
    4fe4:	0018      	movs	r0, r3
    4fe6:	f7ff fdc6 	bl	4b76 <hri_sercomspi_set_CTRLA_ENABLE_bit>

	return ERR_NONE;
    4fea:	2300      	movs	r3, #0
}
    4fec:	0018      	movs	r0, r3
    4fee:	46bd      	mov	sp, r7
    4ff0:	b002      	add	sp, #8
    4ff2:	bd80      	pop	{r7, pc}

00004ff4 <_spi_load_regs_master>:
 *  are ignored.
 *  \param[in, out] hw Pointer to the hardware register base.
 *  \param[in] regs Pointer to register configuration values.
 */
static inline void _spi_load_regs_master(void *const hw, const struct sercomspi_regs_cfg *regs)
{
    4ff4:	b580      	push	{r7, lr}
    4ff6:	b082      	sub	sp, #8
    4ff8:	af00      	add	r7, sp, #0
    4ffa:	6078      	str	r0, [r7, #4]
    4ffc:	6039      	str	r1, [r7, #0]
	ASSERT(hw && regs);
    4ffe:	687b      	ldr	r3, [r7, #4]
    5000:	2b00      	cmp	r3, #0
    5002:	d004      	beq.n	500e <_spi_load_regs_master+0x1a>
    5004:	683b      	ldr	r3, [r7, #0]
    5006:	2b00      	cmp	r3, #0
    5008:	d001      	beq.n	500e <_spi_load_regs_master+0x1a>
    500a:	2301      	movs	r3, #1
    500c:	e000      	b.n	5010 <_spi_load_regs_master+0x1c>
    500e:	2300      	movs	r3, #0
    5010:	1c1a      	adds	r2, r3, #0
    5012:	2301      	movs	r3, #1
    5014:	4013      	ands	r3, r2
    5016:	b2db      	uxtb	r3, r3
    5018:	4a1f      	ldr	r2, [pc, #124]	; (5098 <_spi_load_regs_master+0xa4>)
    501a:	4920      	ldr	r1, [pc, #128]	; (509c <_spi_load_regs_master+0xa8>)
    501c:	0018      	movs	r0, r3
    501e:	f7ff f8b3 	bl	4188 <assert>
	hri_sercomspi_write_CTRLA_reg(
	    hw, regs->ctrla & ~(SERCOM_SPI_CTRLA_IBON | SERCOM_SPI_CTRLA_ENABLE | SERCOM_SPI_CTRLA_SWRST));
    5022:	683b      	ldr	r3, [r7, #0]
    5024:	781a      	ldrb	r2, [r3, #0]
    5026:	7859      	ldrb	r1, [r3, #1]
    5028:	0209      	lsls	r1, r1, #8
    502a:	430a      	orrs	r2, r1
    502c:	7899      	ldrb	r1, [r3, #2]
    502e:	0409      	lsls	r1, r1, #16
    5030:	430a      	orrs	r2, r1
    5032:	78db      	ldrb	r3, [r3, #3]
    5034:	061b      	lsls	r3, r3, #24
    5036:	4313      	orrs	r3, r2
    5038:	001a      	movs	r2, r3
	hri_sercomspi_write_CTRLA_reg(
    503a:	4b19      	ldr	r3, [pc, #100]	; (50a0 <_spi_load_regs_master+0xac>)
    503c:	401a      	ands	r2, r3
    503e:	687b      	ldr	r3, [r7, #4]
    5040:	0011      	movs	r1, r2
    5042:	0018      	movs	r0, r3
    5044:	f7ff fdd6 	bl	4bf4 <hri_sercomspi_write_CTRLA_reg>
	hri_sercomspi_write_CTRLB_reg(
	    hw, (regs->ctrlb & ~(SERCOM_SPI_CTRLB_AMODE_Msk | SERCOM_SPI_CTRLB_PLOADEN)) | (SERCOM_SPI_CTRLB_RXEN));
    5048:	683b      	ldr	r3, [r7, #0]
    504a:	791a      	ldrb	r2, [r3, #4]
    504c:	7959      	ldrb	r1, [r3, #5]
    504e:	0209      	lsls	r1, r1, #8
    5050:	430a      	orrs	r2, r1
    5052:	7999      	ldrb	r1, [r3, #6]
    5054:	0409      	lsls	r1, r1, #16
    5056:	430a      	orrs	r2, r1
    5058:	79db      	ldrb	r3, [r3, #7]
    505a:	061b      	lsls	r3, r3, #24
    505c:	4313      	orrs	r3, r2
    505e:	001a      	movs	r2, r3
    5060:	4b10      	ldr	r3, [pc, #64]	; (50a4 <_spi_load_regs_master+0xb0>)
    5062:	4013      	ands	r3, r2
	hri_sercomspi_write_CTRLB_reg(
    5064:	2280      	movs	r2, #128	; 0x80
    5066:	0292      	lsls	r2, r2, #10
    5068:	431a      	orrs	r2, r3
    506a:	687b      	ldr	r3, [r7, #4]
    506c:	0011      	movs	r1, r2
    506e:	0018      	movs	r0, r3
    5070:	f7ff fdf5 	bl	4c5e <hri_sercomspi_write_CTRLB_reg>
	hri_sercomspi_write_BAUD_reg(hw, regs->baud);
    5074:	683b      	ldr	r3, [r7, #0]
    5076:	7b1a      	ldrb	r2, [r3, #12]
    5078:	687b      	ldr	r3, [r7, #4]
    507a:	0011      	movs	r1, r2
    507c:	0018      	movs	r0, r3
    507e:	f7ff fe28 	bl	4cd2 <hri_sercomspi_write_BAUD_reg>
	hri_sercomspi_write_DBGCTRL_reg(hw, regs->dbgctrl);
    5082:	683b      	ldr	r3, [r7, #0]
    5084:	7b5a      	ldrb	r2, [r3, #13]
    5086:	687b      	ldr	r3, [r7, #4]
    5088:	0011      	movs	r1, r2
    508a:	0018      	movs	r0, r3
    508c:	f7ff fe03 	bl	4c96 <hri_sercomspi_write_DBGCTRL_reg>
}
    5090:	46c0      	nop			; (mov r8, r8)
    5092:	46bd      	mov	sp, r7
    5094:	b002      	add	sp, #8
    5096:	bd80      	pop	{r7, pc}
    5098:	00000872 	.word	0x00000872
    509c:	00007e3c 	.word	0x00007e3c
    50a0:	fffffefc 	.word	0xfffffefc
    50a4:	fffd3fbf 	.word	0xfffd3fbf

000050a8 <_spi_load_regs_slave>:
 *  are ignored.
 *  \param[in, out] hw Pointer to the hardware register base.
 *  \param[in] regs Pointer to register configuration values.
 */
static inline void _spi_load_regs_slave(void *const hw, const struct sercomspi_regs_cfg *regs)
{
    50a8:	b580      	push	{r7, lr}
    50aa:	b082      	sub	sp, #8
    50ac:	af00      	add	r7, sp, #0
    50ae:	6078      	str	r0, [r7, #4]
    50b0:	6039      	str	r1, [r7, #0]
	ASSERT(hw && regs);
    50b2:	687b      	ldr	r3, [r7, #4]
    50b4:	2b00      	cmp	r3, #0
    50b6:	d004      	beq.n	50c2 <_spi_load_regs_slave+0x1a>
    50b8:	683b      	ldr	r3, [r7, #0]
    50ba:	2b00      	cmp	r3, #0
    50bc:	d001      	beq.n	50c2 <_spi_load_regs_slave+0x1a>
    50be:	2301      	movs	r3, #1
    50c0:	e000      	b.n	50c4 <_spi_load_regs_slave+0x1c>
    50c2:	2300      	movs	r3, #0
    50c4:	1c1a      	adds	r2, r3, #0
    50c6:	2301      	movs	r3, #1
    50c8:	4013      	ands	r3, r2
    50ca:	b2db      	uxtb	r3, r3
    50cc:	4a26      	ldr	r2, [pc, #152]	; (5168 <_spi_load_regs_slave+0xc0>)
    50ce:	4927      	ldr	r1, [pc, #156]	; (516c <_spi_load_regs_slave+0xc4>)
    50d0:	0018      	movs	r0, r3
    50d2:	f7ff f859 	bl	4188 <assert>
	hri_sercomspi_write_CTRLA_reg(
	    hw, regs->ctrla & ~(SERCOM_SPI_CTRLA_IBON | SERCOM_SPI_CTRLA_ENABLE | SERCOM_SPI_CTRLA_SWRST));
    50d6:	683b      	ldr	r3, [r7, #0]
    50d8:	781a      	ldrb	r2, [r3, #0]
    50da:	7859      	ldrb	r1, [r3, #1]
    50dc:	0209      	lsls	r1, r1, #8
    50de:	430a      	orrs	r2, r1
    50e0:	7899      	ldrb	r1, [r3, #2]
    50e2:	0409      	lsls	r1, r1, #16
    50e4:	430a      	orrs	r2, r1
    50e6:	78db      	ldrb	r3, [r3, #3]
    50e8:	061b      	lsls	r3, r3, #24
    50ea:	4313      	orrs	r3, r2
    50ec:	001a      	movs	r2, r3
	hri_sercomspi_write_CTRLA_reg(
    50ee:	4b20      	ldr	r3, [pc, #128]	; (5170 <_spi_load_regs_slave+0xc8>)
    50f0:	401a      	ands	r2, r3
    50f2:	687b      	ldr	r3, [r7, #4]
    50f4:	0011      	movs	r1, r2
    50f6:	0018      	movs	r0, r3
    50f8:	f7ff fd7c 	bl	4bf4 <hri_sercomspi_write_CTRLA_reg>
	hri_sercomspi_write_CTRLB_reg(hw, regs->ctrlb | (SERCOM_SPI_CTRLB_RXEN | SERCOM_SPI_CTRLB_PLOADEN));
    50fc:	683b      	ldr	r3, [r7, #0]
    50fe:	791a      	ldrb	r2, [r3, #4]
    5100:	7959      	ldrb	r1, [r3, #5]
    5102:	0209      	lsls	r1, r1, #8
    5104:	430a      	orrs	r2, r1
    5106:	7999      	ldrb	r1, [r3, #6]
    5108:	0409      	lsls	r1, r1, #16
    510a:	430a      	orrs	r2, r1
    510c:	79db      	ldrb	r3, [r3, #7]
    510e:	061b      	lsls	r3, r3, #24
    5110:	4313      	orrs	r3, r2
    5112:	001a      	movs	r2, r3
    5114:	4b17      	ldr	r3, [pc, #92]	; (5174 <_spi_load_regs_slave+0xcc>)
    5116:	431a      	orrs	r2, r3
    5118:	687b      	ldr	r3, [r7, #4]
    511a:	0011      	movs	r1, r2
    511c:	0018      	movs	r0, r3
    511e:	f7ff fd9e 	bl	4c5e <hri_sercomspi_write_CTRLB_reg>
	hri_sercomspi_write_ADDR_reg(hw, regs->addr);
    5122:	683b      	ldr	r3, [r7, #0]
    5124:	7a1a      	ldrb	r2, [r3, #8]
    5126:	7a59      	ldrb	r1, [r3, #9]
    5128:	0209      	lsls	r1, r1, #8
    512a:	430a      	orrs	r2, r1
    512c:	7a99      	ldrb	r1, [r3, #10]
    512e:	0409      	lsls	r1, r1, #16
    5130:	430a      	orrs	r2, r1
    5132:	7adb      	ldrb	r3, [r3, #11]
    5134:	061b      	lsls	r3, r3, #24
    5136:	4313      	orrs	r3, r2
    5138:	001a      	movs	r2, r3
    513a:	687b      	ldr	r3, [r7, #4]
    513c:	0011      	movs	r1, r2
    513e:	0018      	movs	r0, r3
    5140:	f7ff fde5 	bl	4d0e <hri_sercomspi_write_ADDR_reg>
	hri_sercomspi_write_DBGCTRL_reg(hw, regs->dbgctrl);
    5144:	683b      	ldr	r3, [r7, #0]
    5146:	7b5a      	ldrb	r2, [r3, #13]
    5148:	687b      	ldr	r3, [r7, #4]
    514a:	0011      	movs	r1, r2
    514c:	0018      	movs	r0, r3
    514e:	f7ff fda2 	bl	4c96 <hri_sercomspi_write_DBGCTRL_reg>
	while (hri_sercomspi_is_syncing(hw))
    5152:	46c0      	nop			; (mov r8, r8)
    5154:	687b      	ldr	r3, [r7, #4]
    5156:	0018      	movs	r0, r3
    5158:	f7ff fc84 	bl	4a64 <hri_sercomspi_is_syncing>
    515c:	1e03      	subs	r3, r0, #0
    515e:	d1f9      	bne.n	5154 <_spi_load_regs_slave+0xac>
		;
}
    5160:	46c0      	nop			; (mov r8, r8)
    5162:	46bd      	mov	sp, r7
    5164:	b002      	add	sp, #8
    5166:	bd80      	pop	{r7, pc}
    5168:	00000883 	.word	0x00000883
    516c:	00007e3c 	.word	0x00007e3c
    5170:	fffffefc 	.word	0xfffffefc
    5174:	00020040 	.word	0x00020040

00005178 <_spi_get_regs>:
/** \brief Return the pointer to register settings of specific SERCOM
 *  \param[in] hw_addr The hardware register base address.
 *  \return Pointer to register settings of specific SERCOM.
 */
static inline const struct sercomspi_regs_cfg *_spi_get_regs(const uint32_t hw_addr)
{
    5178:	b590      	push	{r4, r7, lr}
    517a:	b085      	sub	sp, #20
    517c:	af00      	add	r7, sp, #0
    517e:	6078      	str	r0, [r7, #4]
	uint8_t n = _sercom_get_hardware_index((const void *)hw_addr);
    5180:	687b      	ldr	r3, [r7, #4]
    5182:	220e      	movs	r2, #14
    5184:	18bc      	adds	r4, r7, r2
    5186:	0018      	movs	r0, r3
    5188:	f7ff fe6c 	bl	4e64 <_sercom_get_hardware_index>
    518c:	0003      	movs	r3, r0
    518e:	7023      	strb	r3, [r4, #0]
	uint8_t i;

	for (i = 0; i < sizeof(sercomspi_regs) / sizeof(struct sercomspi_regs_cfg); i++) {
    5190:	230f      	movs	r3, #15
    5192:	18fb      	adds	r3, r7, r3
    5194:	2200      	movs	r2, #0
    5196:	701a      	strb	r2, [r3, #0]
    5198:	e01a      	b.n	51d0 <_spi_get_regs+0x58>
		if (sercomspi_regs[i].n == n) {
    519a:	230f      	movs	r3, #15
    519c:	18fb      	adds	r3, r7, r3
    519e:	781b      	ldrb	r3, [r3, #0]
    51a0:	4a10      	ldr	r2, [pc, #64]	; (51e4 <_spi_get_regs+0x6c>)
    51a2:	011b      	lsls	r3, r3, #4
    51a4:	18d3      	adds	r3, r2, r3
    51a6:	330f      	adds	r3, #15
    51a8:	781b      	ldrb	r3, [r3, #0]
    51aa:	220e      	movs	r2, #14
    51ac:	18ba      	adds	r2, r7, r2
    51ae:	7812      	ldrb	r2, [r2, #0]
    51b0:	429a      	cmp	r2, r3
    51b2:	d106      	bne.n	51c2 <_spi_get_regs+0x4a>
			return &sercomspi_regs[i];
    51b4:	230f      	movs	r3, #15
    51b6:	18fb      	adds	r3, r7, r3
    51b8:	781b      	ldrb	r3, [r3, #0]
    51ba:	011a      	lsls	r2, r3, #4
    51bc:	4b09      	ldr	r3, [pc, #36]	; (51e4 <_spi_get_regs+0x6c>)
    51be:	18d3      	adds	r3, r2, r3
    51c0:	e00c      	b.n	51dc <_spi_get_regs+0x64>
	for (i = 0; i < sizeof(sercomspi_regs) / sizeof(struct sercomspi_regs_cfg); i++) {
    51c2:	230f      	movs	r3, #15
    51c4:	18fb      	adds	r3, r7, r3
    51c6:	781a      	ldrb	r2, [r3, #0]
    51c8:	230f      	movs	r3, #15
    51ca:	18fb      	adds	r3, r7, r3
    51cc:	3201      	adds	r2, #1
    51ce:	701a      	strb	r2, [r3, #0]
    51d0:	230f      	movs	r3, #15
    51d2:	18fb      	adds	r3, r7, r3
    51d4:	781b      	ldrb	r3, [r3, #0]
    51d6:	2b01      	cmp	r3, #1
    51d8:	d9df      	bls.n	519a <_spi_get_regs+0x22>
		}
	}

	return NULL;
    51da:	2300      	movs	r3, #0
}
    51dc:	0018      	movs	r0, r3
    51de:	46bd      	mov	sp, r7
    51e0:	b005      	add	sp, #20
    51e2:	bd90      	pop	{r4, r7, pc}
    51e4:	00007e58 	.word	0x00007e58

000051e8 <_spi_m_sync_init>:

int32_t _spi_m_sync_init(struct _spi_m_sync_dev *dev, void *const hw)
{
    51e8:	b580      	push	{r7, lr}
    51ea:	b084      	sub	sp, #16
    51ec:	af00      	add	r7, sp, #0
    51ee:	6078      	str	r0, [r7, #4]
    51f0:	6039      	str	r1, [r7, #0]
	const struct sercomspi_regs_cfg *regs = _spi_get_regs((uint32_t)hw);
    51f2:	683b      	ldr	r3, [r7, #0]
    51f4:	0018      	movs	r0, r3
    51f6:	f7ff ffbf 	bl	5178 <_spi_get_regs>
    51fa:	0003      	movs	r3, r0
    51fc:	60fb      	str	r3, [r7, #12]

	ASSERT(dev && hw);
    51fe:	687b      	ldr	r3, [r7, #4]
    5200:	2b00      	cmp	r3, #0
    5202:	d004      	beq.n	520e <_spi_m_sync_init+0x26>
    5204:	683b      	ldr	r3, [r7, #0]
    5206:	2b00      	cmp	r3, #0
    5208:	d001      	beq.n	520e <_spi_m_sync_init+0x26>
    520a:	2301      	movs	r3, #1
    520c:	e000      	b.n	5210 <_spi_m_sync_init+0x28>
    520e:	2300      	movs	r3, #0
    5210:	1c1a      	adds	r2, r3, #0
    5212:	2301      	movs	r3, #1
    5214:	4013      	ands	r3, r2
    5216:	b2db      	uxtb	r3, r3
    5218:	4a30      	ldr	r2, [pc, #192]	; (52dc <_spi_m_sync_init+0xf4>)
    521a:	4931      	ldr	r1, [pc, #196]	; (52e0 <_spi_m_sync_init+0xf8>)
    521c:	0018      	movs	r0, r3
    521e:	f7fe ffb3 	bl	4188 <assert>

	if (regs == NULL) {
    5222:	68fb      	ldr	r3, [r7, #12]
    5224:	2b00      	cmp	r3, #0
    5226:	d102      	bne.n	522e <_spi_m_sync_init+0x46>
		return ERR_INVALID_ARG;
    5228:	230d      	movs	r3, #13
    522a:	425b      	negs	r3, r3
    522c:	e051      	b.n	52d2 <_spi_m_sync_init+0xea>
	}

	hri_sercomspi_wait_for_sync(hw);
    522e:	683b      	ldr	r3, [r7, #0]
    5230:	0018      	movs	r0, r3
    5232:	f7ff fc07 	bl	4a44 <hri_sercomspi_wait_for_sync>
	if (hri_sercomspi_get_CTRLA_reg(hw, SERCOM_SPI_CTRLA_ENABLE)) {
    5236:	683b      	ldr	r3, [r7, #0]
    5238:	2102      	movs	r1, #2
    523a:	0018      	movs	r0, r3
    523c:	f7ff fcc5 	bl	4bca <hri_sercomspi_get_CTRLA_reg>
    5240:	1e03      	subs	r3, r0, #0
    5242:	d008      	beq.n	5256 <_spi_m_sync_init+0x6e>
		hri_sercomspi_write_CTRLA_reg(hw, 0);
    5244:	683b      	ldr	r3, [r7, #0]
    5246:	2100      	movs	r1, #0
    5248:	0018      	movs	r0, r3
    524a:	f7ff fcd3 	bl	4bf4 <hri_sercomspi_write_CTRLA_reg>
		hri_sercomspi_wait_for_sync(hw);
    524e:	683b      	ldr	r3, [r7, #0]
    5250:	0018      	movs	r0, r3
    5252:	f7ff fbf7 	bl	4a44 <hri_sercomspi_wait_for_sync>
	}
	hri_sercomspi_write_CTRLA_reg(hw, SERCOM_SPI_CTRLA_SWRST);
    5256:	683b      	ldr	r3, [r7, #0]
    5258:	2101      	movs	r1, #1
    525a:	0018      	movs	r0, r3
    525c:	f7ff fcca 	bl	4bf4 <hri_sercomspi_write_CTRLA_reg>
	hri_sercomspi_wait_for_sync(hw);
    5260:	683b      	ldr	r3, [r7, #0]
    5262:	0018      	movs	r0, r3
    5264:	f7ff fbee 	bl	4a44 <hri_sercomspi_wait_for_sync>

	dev->prvt = hw;
    5268:	687b      	ldr	r3, [r7, #4]
    526a:	683a      	ldr	r2, [r7, #0]
    526c:	601a      	str	r2, [r3, #0]

	if ((regs->ctrla & SERCOM_SPI_CTRLA_MODE_Msk) == SERCOM_USART_CTRLA_MODE_SPI_SLAVE) {
    526e:	68fb      	ldr	r3, [r7, #12]
    5270:	781a      	ldrb	r2, [r3, #0]
    5272:	7859      	ldrb	r1, [r3, #1]
    5274:	0209      	lsls	r1, r1, #8
    5276:	430a      	orrs	r2, r1
    5278:	7899      	ldrb	r1, [r3, #2]
    527a:	0409      	lsls	r1, r1, #16
    527c:	430a      	orrs	r2, r1
    527e:	78db      	ldrb	r3, [r3, #3]
    5280:	061b      	lsls	r3, r3, #24
    5282:	4313      	orrs	r3, r2
    5284:	001a      	movs	r2, r3
    5286:	231c      	movs	r3, #28
    5288:	4013      	ands	r3, r2
    528a:	2b08      	cmp	r3, #8
    528c:	d106      	bne.n	529c <_spi_m_sync_init+0xb4>
		_spi_load_regs_slave(hw, regs);
    528e:	68fa      	ldr	r2, [r7, #12]
    5290:	683b      	ldr	r3, [r7, #0]
    5292:	0011      	movs	r1, r2
    5294:	0018      	movs	r0, r3
    5296:	f7ff ff07 	bl	50a8 <_spi_load_regs_slave>
    529a:	e005      	b.n	52a8 <_spi_m_sync_init+0xc0>
	} else {
		_spi_load_regs_master(hw, regs);
    529c:	68fa      	ldr	r2, [r7, #12]
    529e:	683b      	ldr	r3, [r7, #0]
    52a0:	0011      	movs	r1, r2
    52a2:	0018      	movs	r0, r3
    52a4:	f7ff fea6 	bl	4ff4 <_spi_load_regs_master>
	}

	/* Load character size from default hardware configuration */
	dev->char_size = ((regs->ctrlb & SERCOM_SPI_CTRLB_CHSIZE_Msk) == 0) ? 1 : 2;
    52a8:	68fb      	ldr	r3, [r7, #12]
    52aa:	791a      	ldrb	r2, [r3, #4]
    52ac:	7959      	ldrb	r1, [r3, #5]
    52ae:	0209      	lsls	r1, r1, #8
    52b0:	430a      	orrs	r2, r1
    52b2:	7999      	ldrb	r1, [r3, #6]
    52b4:	0409      	lsls	r1, r1, #16
    52b6:	430a      	orrs	r2, r1
    52b8:	79db      	ldrb	r3, [r3, #7]
    52ba:	061b      	lsls	r3, r3, #24
    52bc:	4313      	orrs	r3, r2
    52be:	001a      	movs	r2, r3
    52c0:	2307      	movs	r3, #7
    52c2:	4013      	ands	r3, r2
    52c4:	d101      	bne.n	52ca <_spi_m_sync_init+0xe2>
    52c6:	2201      	movs	r2, #1
    52c8:	e000      	b.n	52cc <_spi_m_sync_init+0xe4>
    52ca:	2202      	movs	r2, #2
    52cc:	687b      	ldr	r3, [r7, #4]
    52ce:	711a      	strb	r2, [r3, #4]

	return ERR_NONE;
    52d0:	2300      	movs	r3, #0
}
    52d2:	0018      	movs	r0, r3
    52d4:	46bd      	mov	sp, r7
    52d6:	b004      	add	sp, #16
    52d8:	bd80      	pop	{r7, pc}
    52da:	46c0      	nop			; (mov r8, r8)
    52dc:	000008a3 	.word	0x000008a3
    52e0:	00007e3c 	.word	0x00007e3c

000052e4 <_spi_m_sync_enable>:

	return _spi_deinit(hw);
}

int32_t _spi_m_sync_enable(struct _spi_m_sync_dev *dev)
{
    52e4:	b580      	push	{r7, lr}
    52e6:	b082      	sub	sp, #8
    52e8:	af00      	add	r7, sp, #0
    52ea:	6078      	str	r0, [r7, #4]
	ASSERT(dev && dev->prvt);
    52ec:	687b      	ldr	r3, [r7, #4]
    52ee:	2b00      	cmp	r3, #0
    52f0:	d005      	beq.n	52fe <_spi_m_sync_enable+0x1a>
    52f2:	687b      	ldr	r3, [r7, #4]
    52f4:	681b      	ldr	r3, [r3, #0]
    52f6:	2b00      	cmp	r3, #0
    52f8:	d001      	beq.n	52fe <_spi_m_sync_enable+0x1a>
    52fa:	2301      	movs	r3, #1
    52fc:	e000      	b.n	5300 <_spi_m_sync_enable+0x1c>
    52fe:	2300      	movs	r3, #0
    5300:	1c1a      	adds	r2, r3, #0
    5302:	2301      	movs	r3, #1
    5304:	4013      	ands	r3, r2
    5306:	b2db      	uxtb	r3, r3
    5308:	4a07      	ldr	r2, [pc, #28]	; (5328 <_spi_m_sync_enable+0x44>)
    530a:	4908      	ldr	r1, [pc, #32]	; (532c <_spi_m_sync_enable+0x48>)
    530c:	0018      	movs	r0, r3
    530e:	f7fe ff3b 	bl	4188 <assert>

	return _spi_sync_enable(dev->prvt);
    5312:	687b      	ldr	r3, [r7, #4]
    5314:	681b      	ldr	r3, [r3, #0]
    5316:	0018      	movs	r0, r3
    5318:	f7ff fe56 	bl	4fc8 <_spi_sync_enable>
    531c:	0003      	movs	r3, r0
}
    531e:	0018      	movs	r0, r3
    5320:	46bd      	mov	sp, r7
    5322:	b002      	add	sp, #8
    5324:	bd80      	pop	{r7, pc}
    5326:	46c0      	nop			; (mov r8, r8)
    5328:	0000090a 	.word	0x0000090a
    532c:	00007e3c 	.word	0x00007e3c

00005330 <_spi_wait_bus_idle>:
	return _spi_set_data_order(dev->prvt, dord);
}

/** Wait until SPI bus idle. */
static inline void _spi_wait_bus_idle(void *const hw)
{
    5330:	b580      	push	{r7, lr}
    5332:	b082      	sub	sp, #8
    5334:	af00      	add	r7, sp, #0
    5336:	6078      	str	r0, [r7, #4]
	while (!(hri_sercomspi_get_INTFLAG_reg(hw, SERCOM_SPI_INTFLAG_TXC | SERCOM_SPI_INTFLAG_DRE))) {
    5338:	46c0      	nop			; (mov r8, r8)
    533a:	687b      	ldr	r3, [r7, #4]
    533c:	2103      	movs	r1, #3
    533e:	0018      	movs	r0, r3
    5340:	f7ff fbb0 	bl	4aa4 <hri_sercomspi_get_INTFLAG_reg>
    5344:	1e03      	subs	r3, r0, #0
    5346:	d0f8      	beq.n	533a <_spi_wait_bus_idle+0xa>
		;
	}
	hri_sercomspi_clear_INTFLAG_reg(hw, SERCOM_SPI_INTFLAG_TXC | SERCOM_SPI_INTFLAG_DRE);
    5348:	687b      	ldr	r3, [r7, #4]
    534a:	2103      	movs	r1, #3
    534c:	0018      	movs	r0, r3
    534e:	f7ff fbd0 	bl	4af2 <hri_sercomspi_clear_INTFLAG_reg>
}
    5352:	46c0      	nop			; (mov r8, r8)
    5354:	46bd      	mov	sp, r7
    5356:	b002      	add	sp, #8
    5358:	bd80      	pop	{r7, pc}

0000535a <_spi_rx_check>:
	uint8_t char_size;
};

/** Check interrupt flag of RXC and update transaction runtime information. */
static inline bool _spi_rx_check(void *const hw, const uint32_t iflag, struct _spi_trans_ctrl *ctrl)
{
    535a:	b580      	push	{r7, lr}
    535c:	b086      	sub	sp, #24
    535e:	af00      	add	r7, sp, #0
    5360:	60f8      	str	r0, [r7, #12]
    5362:	60b9      	str	r1, [r7, #8]
    5364:	607a      	str	r2, [r7, #4]
	uint32_t data;

	if (!(iflag & SERCOM_SPI_INTFLAG_RXC)) {
    5366:	68bb      	ldr	r3, [r7, #8]
    5368:	2204      	movs	r2, #4
    536a:	4013      	ands	r3, r2
    536c:	d101      	bne.n	5372 <_spi_rx_check+0x18>
		return false;
    536e:	2300      	movs	r3, #0
    5370:	e024      	b.n	53bc <_spi_rx_check+0x62>
	}

	data = hri_sercomspi_read_DATA_reg(hw);
    5372:	68fb      	ldr	r3, [r7, #12]
    5374:	0018      	movs	r0, r3
    5376:	f7ff fce5 	bl	4d44 <hri_sercomspi_read_DATA_reg>
    537a:	0003      	movs	r3, r0
    537c:	617b      	str	r3, [r7, #20]

	if (ctrl->rxbuf) {
    537e:	687b      	ldr	r3, [r7, #4]
    5380:	685b      	ldr	r3, [r3, #4]
    5382:	2b00      	cmp	r3, #0
    5384:	d014      	beq.n	53b0 <_spi_rx_check+0x56>
		*ctrl->rxbuf++ = (uint8_t)data;
    5386:	687b      	ldr	r3, [r7, #4]
    5388:	685b      	ldr	r3, [r3, #4]
    538a:	1c59      	adds	r1, r3, #1
    538c:	687a      	ldr	r2, [r7, #4]
    538e:	6051      	str	r1, [r2, #4]
    5390:	697a      	ldr	r2, [r7, #20]
    5392:	b2d2      	uxtb	r2, r2
    5394:	701a      	strb	r2, [r3, #0]

		if (ctrl->char_size > 1) {
    5396:	687b      	ldr	r3, [r7, #4]
    5398:	7c1b      	ldrb	r3, [r3, #16]
    539a:	2b01      	cmp	r3, #1
    539c:	d908      	bls.n	53b0 <_spi_rx_check+0x56>
			*ctrl->rxbuf++ = (uint8_t)(data >> 8);
    539e:	687b      	ldr	r3, [r7, #4]
    53a0:	685b      	ldr	r3, [r3, #4]
    53a2:	1c59      	adds	r1, r3, #1
    53a4:	687a      	ldr	r2, [r7, #4]
    53a6:	6051      	str	r1, [r2, #4]
    53a8:	697a      	ldr	r2, [r7, #20]
    53aa:	0a12      	lsrs	r2, r2, #8
    53ac:	b2d2      	uxtb	r2, r2
    53ae:	701a      	strb	r2, [r3, #0]
		}
	}

	ctrl->rxcnt++;
    53b0:	687b      	ldr	r3, [r7, #4]
    53b2:	68db      	ldr	r3, [r3, #12]
    53b4:	1c5a      	adds	r2, r3, #1
    53b6:	687b      	ldr	r3, [r7, #4]
    53b8:	60da      	str	r2, [r3, #12]
	return true;
    53ba:	2301      	movs	r3, #1
}
    53bc:	0018      	movs	r0, r3
    53be:	46bd      	mov	sp, r7
    53c0:	b006      	add	sp, #24
    53c2:	bd80      	pop	{r7, pc}

000053c4 <_spi_tx_check>:

/** Check interrupt flag of DRE and update transaction runtime information. */
static inline void _spi_tx_check(void *const hw, const uint32_t iflag, struct _spi_trans_ctrl *ctrl)
{
    53c4:	b580      	push	{r7, lr}
    53c6:	b086      	sub	sp, #24
    53c8:	af00      	add	r7, sp, #0
    53ca:	60f8      	str	r0, [r7, #12]
    53cc:	60b9      	str	r1, [r7, #8]
    53ce:	607a      	str	r2, [r7, #4]
	uint32_t data;

	if (!(SERCOM_SPI_INTFLAG_DRE & iflag)) {
    53d0:	68bb      	ldr	r3, [r7, #8]
    53d2:	2201      	movs	r2, #1
    53d4:	4013      	ands	r3, r2
    53d6:	d02b      	beq.n	5430 <_spi_tx_check+0x6c>
		return;
	}

	if (ctrl->txbuf) {
    53d8:	687b      	ldr	r3, [r7, #4]
    53da:	681b      	ldr	r3, [r3, #0]
    53dc:	2b00      	cmp	r3, #0
    53de:	d018      	beq.n	5412 <_spi_tx_check+0x4e>
		data = *ctrl->txbuf++;
    53e0:	687b      	ldr	r3, [r7, #4]
    53e2:	681b      	ldr	r3, [r3, #0]
    53e4:	1c59      	adds	r1, r3, #1
    53e6:	687a      	ldr	r2, [r7, #4]
    53e8:	6011      	str	r1, [r2, #0]
    53ea:	781b      	ldrb	r3, [r3, #0]
    53ec:	617b      	str	r3, [r7, #20]

		if (ctrl->char_size > 1) {
    53ee:	687b      	ldr	r3, [r7, #4]
    53f0:	7c1b      	ldrb	r3, [r3, #16]
    53f2:	2b01      	cmp	r3, #1
    53f4:	d90f      	bls.n	5416 <_spi_tx_check+0x52>
			data |= (*ctrl->txbuf) << 8;
    53f6:	687b      	ldr	r3, [r7, #4]
    53f8:	681b      	ldr	r3, [r3, #0]
    53fa:	781b      	ldrb	r3, [r3, #0]
    53fc:	021b      	lsls	r3, r3, #8
    53fe:	001a      	movs	r2, r3
    5400:	697b      	ldr	r3, [r7, #20]
    5402:	4313      	orrs	r3, r2
    5404:	617b      	str	r3, [r7, #20]
			ctrl->txbuf++;
    5406:	687b      	ldr	r3, [r7, #4]
    5408:	681b      	ldr	r3, [r3, #0]
    540a:	1c5a      	adds	r2, r3, #1
    540c:	687b      	ldr	r3, [r7, #4]
    540e:	601a      	str	r2, [r3, #0]
    5410:	e001      	b.n	5416 <_spi_tx_check+0x52>
		}
	} else {
		data = SPI_DUMMY_CHAR;
    5412:	4b09      	ldr	r3, [pc, #36]	; (5438 <_spi_tx_check+0x74>)
    5414:	617b      	str	r3, [r7, #20]
	}

	ctrl->txcnt++;
    5416:	687b      	ldr	r3, [r7, #4]
    5418:	689b      	ldr	r3, [r3, #8]
    541a:	1c5a      	adds	r2, r3, #1
    541c:	687b      	ldr	r3, [r7, #4]
    541e:	609a      	str	r2, [r3, #8]
	hri_sercomspi_write_DATA_reg(hw, data);
    5420:	697b      	ldr	r3, [r7, #20]
    5422:	b29a      	uxth	r2, r3
    5424:	68fb      	ldr	r3, [r7, #12]
    5426:	0011      	movs	r1, r2
    5428:	0018      	movs	r0, r3
    542a:	f7ff fc7c 	bl	4d26 <hri_sercomspi_write_DATA_reg>
    542e:	e000      	b.n	5432 <_spi_tx_check+0x6e>
		return;
    5430:	46c0      	nop			; (mov r8, r8)
}
    5432:	46bd      	mov	sp, r7
    5434:	b006      	add	sp, #24
    5436:	bd80      	pop	{r7, pc}
    5438:	000001ff 	.word	0x000001ff

0000543c <_spi_m_sync_trans>:

int32_t _spi_m_sync_trans(struct _spi_m_sync_dev *dev, const struct spi_msg *msg)
{
    543c:	b580      	push	{r7, lr}
    543e:	b08a      	sub	sp, #40	; 0x28
    5440:	af00      	add	r7, sp, #0
    5442:	6078      	str	r0, [r7, #4]
    5444:	6039      	str	r1, [r7, #0]
	void *                 hw   = dev->prvt;
    5446:	687b      	ldr	r3, [r7, #4]
    5448:	681b      	ldr	r3, [r3, #0]
    544a:	627b      	str	r3, [r7, #36]	; 0x24
	int32_t                rc   = 0;
    544c:	2300      	movs	r3, #0
    544e:	623b      	str	r3, [r7, #32]
	struct _spi_trans_ctrl ctrl = {msg->txbuf, msg->rxbuf, 0, 0, dev->char_size};
    5450:	683b      	ldr	r3, [r7, #0]
    5452:	681a      	ldr	r2, [r3, #0]
    5454:	2308      	movs	r3, #8
    5456:	18fb      	adds	r3, r7, r3
    5458:	601a      	str	r2, [r3, #0]
    545a:	683b      	ldr	r3, [r7, #0]
    545c:	685a      	ldr	r2, [r3, #4]
    545e:	2308      	movs	r3, #8
    5460:	18fb      	adds	r3, r7, r3
    5462:	605a      	str	r2, [r3, #4]
    5464:	2308      	movs	r3, #8
    5466:	18fb      	adds	r3, r7, r3
    5468:	2200      	movs	r2, #0
    546a:	609a      	str	r2, [r3, #8]
    546c:	2308      	movs	r3, #8
    546e:	18fb      	adds	r3, r7, r3
    5470:	2200      	movs	r2, #0
    5472:	60da      	str	r2, [r3, #12]
    5474:	687b      	ldr	r3, [r7, #4]
    5476:	791a      	ldrb	r2, [r3, #4]
    5478:	2308      	movs	r3, #8
    547a:	18fb      	adds	r3, r7, r3
    547c:	741a      	strb	r2, [r3, #16]

	ASSERT(dev && hw);
    547e:	687b      	ldr	r3, [r7, #4]
    5480:	2b00      	cmp	r3, #0
    5482:	d004      	beq.n	548e <_spi_m_sync_trans+0x52>
    5484:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    5486:	2b00      	cmp	r3, #0
    5488:	d001      	beq.n	548e <_spi_m_sync_trans+0x52>
    548a:	2301      	movs	r3, #1
    548c:	e000      	b.n	5490 <_spi_m_sync_trans+0x54>
    548e:	2300      	movs	r3, #0
    5490:	1c1a      	adds	r2, r3, #0
    5492:	2301      	movs	r3, #1
    5494:	4013      	ands	r3, r2
    5496:	b2db      	uxtb	r3, r3
    5498:	4a2d      	ldr	r2, [pc, #180]	; (5550 <_spi_m_sync_trans+0x114>)
    549a:	492e      	ldr	r1, [pc, #184]	; (5554 <_spi_m_sync_trans+0x118>)
    549c:	0018      	movs	r0, r3
    549e:	f7fe fe73 	bl	4188 <assert>

	/* If settings are not applied (pending), we can not go on */
	if (hri_sercomspi_is_syncing(hw)) {
    54a2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    54a4:	0018      	movs	r0, r3
    54a6:	f7ff fadd 	bl	4a64 <hri_sercomspi_is_syncing>
    54aa:	1e03      	subs	r3, r0, #0
    54ac:	d002      	beq.n	54b4 <_spi_m_sync_trans+0x78>
		return ERR_BUSY;
    54ae:	2304      	movs	r3, #4
    54b0:	425b      	negs	r3, r3
    54b2:	e048      	b.n	5546 <_spi_m_sync_trans+0x10a>
	}

	/* SPI must be enabled to start synchronous transfer */
	if (!hri_sercomspi_get_CTRLA_ENABLE_bit(hw)) {
    54b4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    54b6:	0018      	movs	r0, r3
    54b8:	f7ff fb6f 	bl	4b9a <hri_sercomspi_get_CTRLA_ENABLE_bit>
    54bc:	0003      	movs	r3, r0
    54be:	001a      	movs	r2, r3
    54c0:	2301      	movs	r3, #1
    54c2:	4053      	eors	r3, r2
    54c4:	b2db      	uxtb	r3, r3
    54c6:	2b00      	cmp	r3, #0
    54c8:	d002      	beq.n	54d0 <_spi_m_sync_trans+0x94>
		return ERR_NOT_INITIALIZED;
    54ca:	2314      	movs	r3, #20
    54cc:	425b      	negs	r3, r3
    54ce:	e03a      	b.n	5546 <_spi_m_sync_trans+0x10a>
	}

	for (;;) {
		uint32_t iflag = hri_sercomspi_read_INTFLAG_reg(hw);
    54d0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    54d2:	0018      	movs	r0, r3
    54d4:	f7ff fb02 	bl	4adc <hri_sercomspi_read_INTFLAG_reg>
    54d8:	0003      	movs	r3, r0
    54da:	61fb      	str	r3, [r7, #28]

		if (!_spi_rx_check(hw, iflag, &ctrl)) {
    54dc:	2308      	movs	r3, #8
    54de:	18fa      	adds	r2, r7, r3
    54e0:	69f9      	ldr	r1, [r7, #28]
    54e2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    54e4:	0018      	movs	r0, r3
    54e6:	f7ff ff38 	bl	535a <_spi_rx_check>
    54ea:	0003      	movs	r3, r0
    54ec:	001a      	movs	r2, r3
    54ee:	2301      	movs	r3, #1
    54f0:	4053      	eors	r3, r2
    54f2:	b2db      	uxtb	r3, r3
    54f4:	2b00      	cmp	r3, #0
    54f6:	d00e      	beq.n	5516 <_spi_m_sync_trans+0xda>
			/* In master mode, do not start next byte before previous byte received
			 * to make better output waveform */
			if (ctrl.rxcnt >= ctrl.txcnt) {
    54f8:	2308      	movs	r3, #8
    54fa:	18fb      	adds	r3, r7, r3
    54fc:	68da      	ldr	r2, [r3, #12]
    54fe:	2308      	movs	r3, #8
    5500:	18fb      	adds	r3, r7, r3
    5502:	689b      	ldr	r3, [r3, #8]
    5504:	429a      	cmp	r2, r3
    5506:	d306      	bcc.n	5516 <_spi_m_sync_trans+0xda>
				_spi_tx_check(hw, iflag, &ctrl);
    5508:	2308      	movs	r3, #8
    550a:	18fa      	adds	r2, r7, r3
    550c:	69f9      	ldr	r1, [r7, #28]
    550e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    5510:	0018      	movs	r0, r3
    5512:	f7ff ff57 	bl	53c4 <_spi_tx_check>
			}
		}

		if (ctrl.txcnt >= msg->size && ctrl.rxcnt >= msg->size) {
    5516:	2308      	movs	r3, #8
    5518:	18fb      	adds	r3, r7, r3
    551a:	689a      	ldr	r2, [r3, #8]
    551c:	683b      	ldr	r3, [r7, #0]
    551e:	689b      	ldr	r3, [r3, #8]
    5520:	429a      	cmp	r2, r3
    5522:	d3d5      	bcc.n	54d0 <_spi_m_sync_trans+0x94>
    5524:	2308      	movs	r3, #8
    5526:	18fb      	adds	r3, r7, r3
    5528:	68da      	ldr	r2, [r3, #12]
    552a:	683b      	ldr	r3, [r7, #0]
    552c:	689b      	ldr	r3, [r3, #8]
    552e:	429a      	cmp	r2, r3
    5530:	d3ce      	bcc.n	54d0 <_spi_m_sync_trans+0x94>
			rc = ctrl.txcnt;
    5532:	2308      	movs	r3, #8
    5534:	18fb      	adds	r3, r7, r3
    5536:	689b      	ldr	r3, [r3, #8]
    5538:	623b      	str	r3, [r7, #32]
			break;
    553a:	46c0      	nop			; (mov r8, r8)
		}
	}
	/* Wait until SPI bus idle */
	_spi_wait_bus_idle(hw);
    553c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    553e:	0018      	movs	r0, r3
    5540:	f7ff fef6 	bl	5330 <_spi_wait_bus_idle>

	return rc;
    5544:	6a3b      	ldr	r3, [r7, #32]
}
    5546:	0018      	movs	r0, r3
    5548:	46bd      	mov	sp, r7
    554a:	b00a      	add	sp, #40	; 0x28
    554c:	bd80      	pop	{r7, pc}
    554e:	46c0      	nop			; (mov r8, r8)
    5550:	00000a01 	.word	0x00000a01
    5554:	00007e3c 	.word	0x00007e3c

00005558 <hri_gclk_get_STATUS_SYNCBUSY_bit>:
{
    5558:	b580      	push	{r7, lr}
    555a:	b082      	sub	sp, #8
    555c:	af00      	add	r7, sp, #0
    555e:	6078      	str	r0, [r7, #4]
	return (((Gclk *)hw)->STATUS.reg & GCLK_STATUS_SYNCBUSY) >> GCLK_STATUS_SYNCBUSY_Pos;
    5560:	687b      	ldr	r3, [r7, #4]
    5562:	785b      	ldrb	r3, [r3, #1]
    5564:	b2db      	uxtb	r3, r3
    5566:	09db      	lsrs	r3, r3, #7
    5568:	2201      	movs	r2, #1
    556a:	4013      	ands	r3, r2
    556c:	1e5a      	subs	r2, r3, #1
    556e:	4193      	sbcs	r3, r2
    5570:	b2db      	uxtb	r3, r3
}
    5572:	0018      	movs	r0, r3
    5574:	46bd      	mov	sp, r7
    5576:	b002      	add	sp, #8
    5578:	bd80      	pop	{r7, pc}

0000557a <hri_sysctrl_get_PCLKSR_OSC32KRDY_bit>:
{
	return (((Sysctrl *)hw)->PCLKSR.reg & SYSCTRL_PCLKSR_XOSC32KRDY) >> SYSCTRL_PCLKSR_XOSC32KRDY_Pos;
}

static inline bool hri_sysctrl_get_PCLKSR_OSC32KRDY_bit(const void *const hw)
{
    557a:	b580      	push	{r7, lr}
    557c:	b082      	sub	sp, #8
    557e:	af00      	add	r7, sp, #0
    5580:	6078      	str	r0, [r7, #4]
	return (((Sysctrl *)hw)->PCLKSR.reg & SYSCTRL_PCLKSR_OSC32KRDY) >> SYSCTRL_PCLKSR_OSC32KRDY_Pos;
    5582:	687b      	ldr	r3, [r7, #4]
    5584:	68db      	ldr	r3, [r3, #12]
    5586:	089b      	lsrs	r3, r3, #2
    5588:	2201      	movs	r2, #1
    558a:	4013      	ands	r3, r2
    558c:	1e5a      	subs	r2, r3, #1
    558e:	4193      	sbcs	r3, r2
    5590:	b2db      	uxtb	r3, r3
}
    5592:	0018      	movs	r0, r3
    5594:	46bd      	mov	sp, r7
    5596:	b002      	add	sp, #8
    5598:	bd80      	pop	{r7, pc}

0000559a <hri_sysctrl_get_PCLKSR_OSC8MRDY_bit>:

static inline bool hri_sysctrl_get_PCLKSR_OSC8MRDY_bit(const void *const hw)
{
    559a:	b580      	push	{r7, lr}
    559c:	b082      	sub	sp, #8
    559e:	af00      	add	r7, sp, #0
    55a0:	6078      	str	r0, [r7, #4]
	return (((Sysctrl *)hw)->PCLKSR.reg & SYSCTRL_PCLKSR_OSC8MRDY) >> SYSCTRL_PCLKSR_OSC8MRDY_Pos;
    55a2:	687b      	ldr	r3, [r7, #4]
    55a4:	68db      	ldr	r3, [r3, #12]
    55a6:	08db      	lsrs	r3, r3, #3
    55a8:	2201      	movs	r2, #1
    55aa:	4013      	ands	r3, r2
    55ac:	1e5a      	subs	r2, r3, #1
    55ae:	4193      	sbcs	r3, r2
    55b0:	b2db      	uxtb	r3, r3
}
    55b2:	0018      	movs	r0, r3
    55b4:	46bd      	mov	sp, r7
    55b6:	b002      	add	sp, #8
    55b8:	bd80      	pop	{r7, pc}

000055ba <hri_sysctrl_get_PCLKSR_DFLLRDY_bit>:

static inline bool hri_sysctrl_get_PCLKSR_DFLLRDY_bit(const void *const hw)
{
    55ba:	b580      	push	{r7, lr}
    55bc:	b082      	sub	sp, #8
    55be:	af00      	add	r7, sp, #0
    55c0:	6078      	str	r0, [r7, #4]
	return (((Sysctrl *)hw)->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY) >> SYSCTRL_PCLKSR_DFLLRDY_Pos;
    55c2:	687b      	ldr	r3, [r7, #4]
    55c4:	68db      	ldr	r3, [r3, #12]
    55c6:	091b      	lsrs	r3, r3, #4
    55c8:	2201      	movs	r2, #1
    55ca:	4013      	ands	r3, r2
    55cc:	1e5a      	subs	r2, r3, #1
    55ce:	4193      	sbcs	r3, r2
    55d0:	b2db      	uxtb	r3, r3
}
    55d2:	0018      	movs	r0, r3
    55d4:	46bd      	mov	sp, r7
    55d6:	b002      	add	sp, #8
    55d8:	bd80      	pop	{r7, pc}

000055da <hri_sysctrl_get_PCLKSR_reg>:
{
	return (((Sysctrl *)hw)->PCLKSR.reg & SYSCTRL_PCLKSR_B33SRDY) >> SYSCTRL_PCLKSR_B33SRDY_Pos;
}

static inline hri_sysctrl_pclksr_reg_t hri_sysctrl_get_PCLKSR_reg(const void *const hw, hri_sysctrl_pclksr_reg_t mask)
{
    55da:	b580      	push	{r7, lr}
    55dc:	b084      	sub	sp, #16
    55de:	af00      	add	r7, sp, #0
    55e0:	6078      	str	r0, [r7, #4]
    55e2:	6039      	str	r1, [r7, #0]
	uint32_t tmp;
	tmp = ((Sysctrl *)hw)->PCLKSR.reg;
    55e4:	687b      	ldr	r3, [r7, #4]
    55e6:	68db      	ldr	r3, [r3, #12]
    55e8:	60fb      	str	r3, [r7, #12]
	tmp &= mask;
    55ea:	68fb      	ldr	r3, [r7, #12]
    55ec:	683a      	ldr	r2, [r7, #0]
    55ee:	4013      	ands	r3, r2
    55f0:	60fb      	str	r3, [r7, #12]
	return tmp;
    55f2:	68fb      	ldr	r3, [r7, #12]
}
    55f4:	0018      	movs	r0, r3
    55f6:	46bd      	mov	sp, r7
    55f8:	b004      	add	sp, #16
    55fa:	bd80      	pop	{r7, pc}

000055fc <hri_sysctrl_set_OSC32K_ONDEMAND_bit>:
	((Sysctrl *)hw)->OSC32K.reg ^= SYSCTRL_OSC32K_RUNSTDBY;
	SYSCTRL_CRITICAL_SECTION_LEAVE();
}

static inline void hri_sysctrl_set_OSC32K_ONDEMAND_bit(const void *const hw)
{
    55fc:	b580      	push	{r7, lr}
    55fe:	b082      	sub	sp, #8
    5600:	af00      	add	r7, sp, #0
    5602:	6078      	str	r0, [r7, #4]
	SYSCTRL_CRITICAL_SECTION_ENTER();
	((Sysctrl *)hw)->OSC32K.reg |= SYSCTRL_OSC32K_ONDEMAND;
    5604:	687b      	ldr	r3, [r7, #4]
    5606:	699b      	ldr	r3, [r3, #24]
    5608:	2280      	movs	r2, #128	; 0x80
    560a:	431a      	orrs	r2, r3
    560c:	687b      	ldr	r3, [r7, #4]
    560e:	619a      	str	r2, [r3, #24]
	SYSCTRL_CRITICAL_SECTION_LEAVE();
}
    5610:	46c0      	nop			; (mov r8, r8)
    5612:	46bd      	mov	sp, r7
    5614:	b002      	add	sp, #8
    5616:	bd80      	pop	{r7, pc}

00005618 <hri_sysctrl_read_OSC32K_CALIB_bf>:
	((Sysctrl *)hw)->OSC32K.reg ^= SYSCTRL_OSC32K_CALIB(mask);
	SYSCTRL_CRITICAL_SECTION_LEAVE();
}

static inline hri_sysctrl_osc32k_reg_t hri_sysctrl_read_OSC32K_CALIB_bf(const void *const hw)
{
    5618:	b580      	push	{r7, lr}
    561a:	b084      	sub	sp, #16
    561c:	af00      	add	r7, sp, #0
    561e:	6078      	str	r0, [r7, #4]
	uint32_t tmp;
	tmp = ((Sysctrl *)hw)->OSC32K.reg;
    5620:	687b      	ldr	r3, [r7, #4]
    5622:	699b      	ldr	r3, [r3, #24]
    5624:	60fb      	str	r3, [r7, #12]
	tmp = (tmp & SYSCTRL_OSC32K_CALIB_Msk) >> SYSCTRL_OSC32K_CALIB_Pos;
    5626:	68fb      	ldr	r3, [r7, #12]
    5628:	0c1b      	lsrs	r3, r3, #16
    562a:	227f      	movs	r2, #127	; 0x7f
    562c:	4013      	ands	r3, r2
    562e:	60fb      	str	r3, [r7, #12]
	return tmp;
    5630:	68fb      	ldr	r3, [r7, #12]
}
    5632:	0018      	movs	r0, r3
    5634:	46bd      	mov	sp, r7
    5636:	b004      	add	sp, #16
    5638:	bd80      	pop	{r7, pc}

0000563a <hri_sysctrl_write_OSC32K_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sysctrl_write_OSC32K_reg(const void *const hw, hri_sysctrl_osc32k_reg_t data)
{
    563a:	b580      	push	{r7, lr}
    563c:	b082      	sub	sp, #8
    563e:	af00      	add	r7, sp, #0
    5640:	6078      	str	r0, [r7, #4]
    5642:	6039      	str	r1, [r7, #0]
	SYSCTRL_CRITICAL_SECTION_ENTER();
	((Sysctrl *)hw)->OSC32K.reg = data;
    5644:	687b      	ldr	r3, [r7, #4]
    5646:	683a      	ldr	r2, [r7, #0]
    5648:	619a      	str	r2, [r3, #24]
	SYSCTRL_CRITICAL_SECTION_LEAVE();
}
    564a:	46c0      	nop			; (mov r8, r8)
    564c:	46bd      	mov	sp, r7
    564e:	b002      	add	sp, #8
    5650:	bd80      	pop	{r7, pc}

00005652 <hri_sysctrl_read_OSCULP32K_CALIB_bf>:
	((Sysctrl *)hw)->OSCULP32K.reg ^= SYSCTRL_OSCULP32K_CALIB(mask);
	SYSCTRL_CRITICAL_SECTION_LEAVE();
}

static inline hri_sysctrl_osculp32k_reg_t hri_sysctrl_read_OSCULP32K_CALIB_bf(const void *const hw)
{
    5652:	b580      	push	{r7, lr}
    5654:	b084      	sub	sp, #16
    5656:	af00      	add	r7, sp, #0
    5658:	6078      	str	r0, [r7, #4]
	uint8_t tmp;
	tmp = ((Sysctrl *)hw)->OSCULP32K.reg;
    565a:	230f      	movs	r3, #15
    565c:	18fb      	adds	r3, r7, r3
    565e:	687a      	ldr	r2, [r7, #4]
    5660:	7f12      	ldrb	r2, [r2, #28]
    5662:	701a      	strb	r2, [r3, #0]
	tmp = (tmp & SYSCTRL_OSCULP32K_CALIB_Msk) >> SYSCTRL_OSCULP32K_CALIB_Pos;
    5664:	230f      	movs	r3, #15
    5666:	18fb      	adds	r3, r7, r3
    5668:	220f      	movs	r2, #15
    566a:	18ba      	adds	r2, r7, r2
    566c:	7812      	ldrb	r2, [r2, #0]
    566e:	211f      	movs	r1, #31
    5670:	400a      	ands	r2, r1
    5672:	701a      	strb	r2, [r3, #0]
	return tmp;
    5674:	230f      	movs	r3, #15
    5676:	18fb      	adds	r3, r7, r3
    5678:	781b      	ldrb	r3, [r3, #0]
}
    567a:	0018      	movs	r0, r3
    567c:	46bd      	mov	sp, r7
    567e:	b004      	add	sp, #16
    5680:	bd80      	pop	{r7, pc}

00005682 <hri_sysctrl_write_OSCULP32K_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sysctrl_write_OSCULP32K_reg(const void *const hw, hri_sysctrl_osculp32k_reg_t data)
{
    5682:	b580      	push	{r7, lr}
    5684:	b082      	sub	sp, #8
    5686:	af00      	add	r7, sp, #0
    5688:	6078      	str	r0, [r7, #4]
    568a:	000a      	movs	r2, r1
    568c:	1cfb      	adds	r3, r7, #3
    568e:	701a      	strb	r2, [r3, #0]
	SYSCTRL_CRITICAL_SECTION_ENTER();
	((Sysctrl *)hw)->OSCULP32K.reg = data;
    5690:	687b      	ldr	r3, [r7, #4]
    5692:	1cfa      	adds	r2, r7, #3
    5694:	7812      	ldrb	r2, [r2, #0]
    5696:	771a      	strb	r2, [r3, #28]
	SYSCTRL_CRITICAL_SECTION_LEAVE();
}
    5698:	46c0      	nop			; (mov r8, r8)
    569a:	46bd      	mov	sp, r7
    569c:	b002      	add	sp, #8
    569e:	bd80      	pop	{r7, pc}

000056a0 <hri_sysctrl_set_OSC8M_ONDEMAND_bit>:
	((Sysctrl *)hw)->OSC8M.reg ^= SYSCTRL_OSC8M_RUNSTDBY;
	SYSCTRL_CRITICAL_SECTION_LEAVE();
}

static inline void hri_sysctrl_set_OSC8M_ONDEMAND_bit(const void *const hw)
{
    56a0:	b580      	push	{r7, lr}
    56a2:	b082      	sub	sp, #8
    56a4:	af00      	add	r7, sp, #0
    56a6:	6078      	str	r0, [r7, #4]
	SYSCTRL_CRITICAL_SECTION_ENTER();
	((Sysctrl *)hw)->OSC8M.reg |= SYSCTRL_OSC8M_ONDEMAND;
    56a8:	687b      	ldr	r3, [r7, #4]
    56aa:	6a1b      	ldr	r3, [r3, #32]
    56ac:	2280      	movs	r2, #128	; 0x80
    56ae:	431a      	orrs	r2, r3
    56b0:	687b      	ldr	r3, [r7, #4]
    56b2:	621a      	str	r2, [r3, #32]
	SYSCTRL_CRITICAL_SECTION_LEAVE();
}
    56b4:	46c0      	nop			; (mov r8, r8)
    56b6:	46bd      	mov	sp, r7
    56b8:	b002      	add	sp, #8
    56ba:	bd80      	pop	{r7, pc}

000056bc <hri_sysctrl_read_OSC8M_CALIB_bf>:
	((Sysctrl *)hw)->OSC8M.reg ^= SYSCTRL_OSC8M_CALIB(mask);
	SYSCTRL_CRITICAL_SECTION_LEAVE();
}

static inline hri_sysctrl_osc8m_reg_t hri_sysctrl_read_OSC8M_CALIB_bf(const void *const hw)
{
    56bc:	b580      	push	{r7, lr}
    56be:	b084      	sub	sp, #16
    56c0:	af00      	add	r7, sp, #0
    56c2:	6078      	str	r0, [r7, #4]
	uint32_t tmp;
	tmp = ((Sysctrl *)hw)->OSC8M.reg;
    56c4:	687b      	ldr	r3, [r7, #4]
    56c6:	6a1b      	ldr	r3, [r3, #32]
    56c8:	60fb      	str	r3, [r7, #12]
	tmp = (tmp & SYSCTRL_OSC8M_CALIB_Msk) >> SYSCTRL_OSC8M_CALIB_Pos;
    56ca:	68fb      	ldr	r3, [r7, #12]
    56cc:	0c1b      	lsrs	r3, r3, #16
    56ce:	051b      	lsls	r3, r3, #20
    56d0:	0d1b      	lsrs	r3, r3, #20
    56d2:	60fb      	str	r3, [r7, #12]
	return tmp;
    56d4:	68fb      	ldr	r3, [r7, #12]
}
    56d6:	0018      	movs	r0, r3
    56d8:	46bd      	mov	sp, r7
    56da:	b004      	add	sp, #16
    56dc:	bd80      	pop	{r7, pc}

000056de <hri_sysctrl_read_OSC8M_FRANGE_bf>:
	((Sysctrl *)hw)->OSC8M.reg ^= SYSCTRL_OSC8M_FRANGE(mask);
	SYSCTRL_CRITICAL_SECTION_LEAVE();
}

static inline hri_sysctrl_osc8m_reg_t hri_sysctrl_read_OSC8M_FRANGE_bf(const void *const hw)
{
    56de:	b580      	push	{r7, lr}
    56e0:	b084      	sub	sp, #16
    56e2:	af00      	add	r7, sp, #0
    56e4:	6078      	str	r0, [r7, #4]
	uint32_t tmp;
	tmp = ((Sysctrl *)hw)->OSC8M.reg;
    56e6:	687b      	ldr	r3, [r7, #4]
    56e8:	6a1b      	ldr	r3, [r3, #32]
    56ea:	60fb      	str	r3, [r7, #12]
	tmp = (tmp & SYSCTRL_OSC8M_FRANGE_Msk) >> SYSCTRL_OSC8M_FRANGE_Pos;
    56ec:	68fb      	ldr	r3, [r7, #12]
    56ee:	0f9b      	lsrs	r3, r3, #30
    56f0:	60fb      	str	r3, [r7, #12]
	return tmp;
    56f2:	68fb      	ldr	r3, [r7, #12]
}
    56f4:	0018      	movs	r0, r3
    56f6:	46bd      	mov	sp, r7
    56f8:	b004      	add	sp, #16
    56fa:	bd80      	pop	{r7, pc}

000056fc <hri_sysctrl_write_OSC8M_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sysctrl_write_OSC8M_reg(const void *const hw, hri_sysctrl_osc8m_reg_t data)
{
    56fc:	b580      	push	{r7, lr}
    56fe:	b082      	sub	sp, #8
    5700:	af00      	add	r7, sp, #0
    5702:	6078      	str	r0, [r7, #4]
    5704:	6039      	str	r1, [r7, #0]
	SYSCTRL_CRITICAL_SECTION_ENTER();
	((Sysctrl *)hw)->OSC8M.reg = data;
    5706:	687b      	ldr	r3, [r7, #4]
    5708:	683a      	ldr	r2, [r7, #0]
    570a:	621a      	str	r2, [r3, #32]
	SYSCTRL_CRITICAL_SECTION_LEAVE();
}
    570c:	46c0      	nop			; (mov r8, r8)
    570e:	46bd      	mov	sp, r7
    5710:	b002      	add	sp, #8
    5712:	bd80      	pop	{r7, pc}

00005714 <hri_sysctrl_get_DFLLCTRL_MODE_bit>:
	((Sysctrl *)hw)->DFLLCTRL.reg |= SYSCTRL_DFLLCTRL_MODE;
	SYSCTRL_CRITICAL_SECTION_LEAVE();
}

static inline bool hri_sysctrl_get_DFLLCTRL_MODE_bit(const void *const hw)
{
    5714:	b580      	push	{r7, lr}
    5716:	b084      	sub	sp, #16
    5718:	af00      	add	r7, sp, #0
    571a:	6078      	str	r0, [r7, #4]
	uint16_t tmp;
	tmp = ((Sysctrl *)hw)->DFLLCTRL.reg;
    571c:	230e      	movs	r3, #14
    571e:	18fb      	adds	r3, r7, r3
    5720:	687a      	ldr	r2, [r7, #4]
    5722:	8c92      	ldrh	r2, [r2, #36]	; 0x24
    5724:	801a      	strh	r2, [r3, #0]
	tmp = (tmp & SYSCTRL_DFLLCTRL_MODE) >> SYSCTRL_DFLLCTRL_MODE_Pos;
    5726:	230e      	movs	r3, #14
    5728:	18fb      	adds	r3, r7, r3
    572a:	881b      	ldrh	r3, [r3, #0]
    572c:	089b      	lsrs	r3, r3, #2
    572e:	b29a      	uxth	r2, r3
    5730:	230e      	movs	r3, #14
    5732:	18fb      	adds	r3, r7, r3
    5734:	2101      	movs	r1, #1
    5736:	400a      	ands	r2, r1
    5738:	801a      	strh	r2, [r3, #0]
	return (bool)tmp;
    573a:	230e      	movs	r3, #14
    573c:	18fb      	adds	r3, r7, r3
    573e:	881b      	ldrh	r3, [r3, #0]
    5740:	1e5a      	subs	r2, r3, #1
    5742:	4193      	sbcs	r3, r2
    5744:	b2db      	uxtb	r3, r3
}
    5746:	0018      	movs	r0, r3
    5748:	46bd      	mov	sp, r7
    574a:	b004      	add	sp, #16
    574c:	bd80      	pop	{r7, pc}

0000574e <hri_sysctrl_write_DFLLCTRL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sysctrl_write_DFLLCTRL_reg(const void *const hw, hri_sysctrl_dfllctrl_reg_t data)
{
    574e:	b580      	push	{r7, lr}
    5750:	b082      	sub	sp, #8
    5752:	af00      	add	r7, sp, #0
    5754:	6078      	str	r0, [r7, #4]
    5756:	000a      	movs	r2, r1
    5758:	1cbb      	adds	r3, r7, #2
    575a:	801a      	strh	r2, [r3, #0]
	SYSCTRL_CRITICAL_SECTION_ENTER();
	((Sysctrl *)hw)->DFLLCTRL.reg = data;
    575c:	687b      	ldr	r3, [r7, #4]
    575e:	1cba      	adds	r2, r7, #2
    5760:	8812      	ldrh	r2, [r2, #0]
    5762:	849a      	strh	r2, [r3, #36]	; 0x24
	SYSCTRL_CRITICAL_SECTION_LEAVE();
}
    5764:	46c0      	nop			; (mov r8, r8)
    5766:	46bd      	mov	sp, r7
    5768:	b002      	add	sp, #8
    576a:	bd80      	pop	{r7, pc}

0000576c <hri_sysctrl_write_DFLLVAL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sysctrl_write_DFLLVAL_reg(const void *const hw, hri_sysctrl_dfllval_reg_t data)
{
    576c:	b580      	push	{r7, lr}
    576e:	b082      	sub	sp, #8
    5770:	af00      	add	r7, sp, #0
    5772:	6078      	str	r0, [r7, #4]
    5774:	6039      	str	r1, [r7, #0]
	SYSCTRL_CRITICAL_SECTION_ENTER();
	((Sysctrl *)hw)->DFLLVAL.reg = data;
    5776:	687b      	ldr	r3, [r7, #4]
    5778:	683a      	ldr	r2, [r7, #0]
    577a:	629a      	str	r2, [r3, #40]	; 0x28
	SYSCTRL_CRITICAL_SECTION_LEAVE();
}
    577c:	46c0      	nop			; (mov r8, r8)
    577e:	46bd      	mov	sp, r7
    5780:	b002      	add	sp, #8
    5782:	bd80      	pop	{r7, pc}

00005784 <hri_sysctrl_write_DFLLMUL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sysctrl_write_DFLLMUL_reg(const void *const hw, hri_sysctrl_dfllmul_reg_t data)
{
    5784:	b580      	push	{r7, lr}
    5786:	b082      	sub	sp, #8
    5788:	af00      	add	r7, sp, #0
    578a:	6078      	str	r0, [r7, #4]
    578c:	6039      	str	r1, [r7, #0]
	SYSCTRL_CRITICAL_SECTION_ENTER();
	((Sysctrl *)hw)->DFLLMUL.reg = data;
    578e:	687b      	ldr	r3, [r7, #4]
    5790:	683a      	ldr	r2, [r7, #0]
    5792:	62da      	str	r2, [r3, #44]	; 0x2c
	SYSCTRL_CRITICAL_SECTION_LEAVE();
}
    5794:	46c0      	nop			; (mov r8, r8)
    5796:	46bd      	mov	sp, r7
    5798:	b002      	add	sp, #8
    579a:	bd80      	pop	{r7, pc}

0000579c <_sysctrl_init_sources>:
 * \brief Initializes clock generators
 *
 * All GCLK generators are running when this function returns.
 */
void _sysctrl_init_sources(void)
{
    579c:	b580      	push	{r7, lr}
    579e:	b082      	sub	sp, #8
    57a0:	af00      	add	r7, sp, #0
	void *   hw = (void *)SYSCTRL;
    57a2:	4b34      	ldr	r3, [pc, #208]	; (5874 <_sysctrl_init_sources+0xd8>)
    57a4:	607b      	str	r3, [r7, #4]
	        | (CONF_XOSC_RUNSTDBY << SYSCTRL_XOSC_RUNSTDBY_Pos) | (CONF_XOSC_XTALEN << SYSCTRL_XOSC_XTALEN_Pos)
	        | (CONF_XOSC_ENABLE << SYSCTRL_XOSC_ENABLE_Pos));
#endif

#if CONF_OSC8M_CONFIG == 1
	calib = hri_sysctrl_read_OSC8M_CALIB_bf(hw);
    57a6:	687b      	ldr	r3, [r7, #4]
    57a8:	0018      	movs	r0, r3
    57aa:	f7ff ff87 	bl	56bc <hri_sysctrl_read_OSC8M_CALIB_bf>
    57ae:	0002      	movs	r2, r0
    57b0:	1cbb      	adds	r3, r7, #2
    57b2:	801a      	strh	r2, [r3, #0]

	hri_sysctrl_write_OSC8M_reg(hw,
	                            SYSCTRL_OSC8M_FRANGE(hri_sysctrl_read_OSC8M_FRANGE_bf(hw)) |
    57b4:	687b      	ldr	r3, [r7, #4]
    57b6:	0018      	movs	r0, r3
    57b8:	f7ff ff91 	bl	56de <hri_sysctrl_read_OSC8M_FRANGE_bf>
    57bc:	0003      	movs	r3, r0
    57be:	079a      	lsls	r2, r3, #30
#if CONF_OSC8M_OVERWRITE_CALIBRATION == 1
	                                SYSCTRL_OSC8M_CALIB(CONF_OSC8M_CALIB) |
#else
	                                SYSCTRL_OSC8M_CALIB(calib) |
    57c0:	1cbb      	adds	r3, r7, #2
    57c2:	881b      	ldrh	r3, [r3, #0]
    57c4:	041b      	lsls	r3, r3, #16
    57c6:	0019      	movs	r1, r3
    57c8:	4b2b      	ldr	r3, [pc, #172]	; (5878 <_sysctrl_init_sources+0xdc>)
    57ca:	400b      	ands	r3, r1
	                            SYSCTRL_OSC8M_FRANGE(hri_sysctrl_read_OSC8M_FRANGE_bf(hw)) |
    57cc:	4313      	orrs	r3, r2
	hri_sysctrl_write_OSC8M_reg(hw,
    57ce:	4a2b      	ldr	r2, [pc, #172]	; (587c <_sysctrl_init_sources+0xe0>)
    57d0:	431a      	orrs	r2, r3
    57d2:	687b      	ldr	r3, [r7, #4]
    57d4:	0011      	movs	r1, r2
    57d6:	0018      	movs	r0, r3
    57d8:	f7ff ff90 	bl	56fc <hri_sysctrl_write_OSC8M_reg>
	                                | (CONF_OSC8M_RUNSTDBY << SYSCTRL_OSC8M_RUNSTDBY_Pos)
	                                | (CONF_OSC8M_ENABLE << SYSCTRL_OSC8M_ENABLE_Pos));
#endif

#if CONF_OSC32K_CONFIG == 1
	calib = hri_sysctrl_read_OSC32K_CALIB_bf(hw);
    57dc:	687b      	ldr	r3, [r7, #4]
    57de:	0018      	movs	r0, r3
    57e0:	f7ff ff1a 	bl	5618 <hri_sysctrl_read_OSC32K_CALIB_bf>
    57e4:	0002      	movs	r2, r0
    57e6:	1cbb      	adds	r3, r7, #2
    57e8:	801a      	strh	r2, [r3, #0]
	hri_sysctrl_write_OSC32K_reg(
	    hw,
#if CONF_OSC32K_OVERWRITE_CALIBRATION == 1
	    SYSCTRL_OSC32K_CALIB(CONF_OSC32K_CALIB) |
#else
	    SYSCTRL_OSC32K_CALIB(calib) |
    57ea:	1cbb      	adds	r3, r7, #2
    57ec:	881b      	ldrh	r3, [r3, #0]
    57ee:	041b      	lsls	r3, r3, #16
    57f0:	001a      	movs	r2, r3
#endif
	        (CONF_OSC32K_WRTLOCK << SYSCTRL_OSC32K_WRTLOCK_Pos) | SYSCTRL_OSC32K_STARTUP(CONF_OSC32K_STARTUP)
	        | (CONF_OSC32K_RUNSTDBY << SYSCTRL_OSC32K_RUNSTDBY_Pos) | (CONF_OSC32K_EN1K << SYSCTRL_OSC32K_EN1K_Pos)
    57f2:	23fe      	movs	r3, #254	; 0xfe
    57f4:	03db      	lsls	r3, r3, #15
    57f6:	4013      	ands	r3, r2
	        | (CONF_OSC32K_EN32K << SYSCTRL_OSC32K_EN32K_Pos) | (1 << SYSCTRL_OSC32K_ENABLE_Pos));
    57f8:	220e      	movs	r2, #14
    57fa:	431a      	orrs	r2, r3
	hri_sysctrl_write_OSC32K_reg(
    57fc:	687b      	ldr	r3, [r7, #4]
    57fe:	0011      	movs	r1, r2
    5800:	0018      	movs	r0, r3
    5802:	f7ff ff1a 	bl	563a <hri_sysctrl_write_OSC32K_reg>
	/* Enable OSC32K anyway since GCLK configuration may need it to sync */
	hri_sysctrl_set_OSC32K_ENABLE_bit(hw);
#endif

#if CONF_OSCULP32K_CONFIG == 1
	calib = hri_sysctrl_read_OSCULP32K_CALIB_bf(hw);
    5806:	687b      	ldr	r3, [r7, #4]
    5808:	0018      	movs	r0, r3
    580a:	f7ff ff22 	bl	5652 <hri_sysctrl_read_OSCULP32K_CALIB_bf>
    580e:	0003      	movs	r3, r0
    5810:	001a      	movs	r2, r3
    5812:	1cbb      	adds	r3, r7, #2
    5814:	801a      	strh	r2, [r3, #0]

	hri_sysctrl_write_OSCULP32K_reg(hw,
    5816:	1cbb      	adds	r3, r7, #2
    5818:	881b      	ldrh	r3, [r3, #0]
    581a:	b2db      	uxtb	r3, r3
    581c:	221f      	movs	r2, #31
    581e:	4013      	ands	r3, r2
    5820:	b2da      	uxtb	r2, r3
    5822:	687b      	ldr	r3, [r7, #4]
    5824:	0011      	movs	r1, r2
    5826:	0018      	movs	r0, r3
    5828:	f7ff ff2b 	bl	5682 <hri_sysctrl_write_OSCULP32K_reg>
#endif
#endif

#if CONF_OSC32K_CONFIG == 1
#if CONF_OSC32K_ENABLE == 1
	while (!hri_sysctrl_get_PCLKSR_OSC32KRDY_bit(hw))
    582c:	46c0      	nop			; (mov r8, r8)
    582e:	687b      	ldr	r3, [r7, #4]
    5830:	0018      	movs	r0, r3
    5832:	f7ff fea2 	bl	557a <hri_sysctrl_get_PCLKSR_OSC32KRDY_bit>
    5836:	0003      	movs	r3, r0
    5838:	001a      	movs	r2, r3
    583a:	2301      	movs	r3, #1
    583c:	4053      	eors	r3, r2
    583e:	b2db      	uxtb	r3, r3
    5840:	2b00      	cmp	r3, #0
    5842:	d1f4      	bne.n	582e <_sysctrl_init_sources+0x92>
		;
#endif
#if CONF_OSC32K_ONDEMAND == 1
	hri_sysctrl_set_OSC32K_ONDEMAND_bit(hw);
    5844:	687b      	ldr	r3, [r7, #4]
    5846:	0018      	movs	r0, r3
    5848:	f7ff fed8 	bl	55fc <hri_sysctrl_set_OSC32K_ONDEMAND_bit>
#endif
#endif

#if CONF_OSC8M_CONFIG == 1
#if CONF_OSC8M_ENABLE == 1
	while (!hri_sysctrl_get_PCLKSR_OSC8MRDY_bit(hw))
    584c:	46c0      	nop			; (mov r8, r8)
    584e:	687b      	ldr	r3, [r7, #4]
    5850:	0018      	movs	r0, r3
    5852:	f7ff fea2 	bl	559a <hri_sysctrl_get_PCLKSR_OSC8MRDY_bit>
    5856:	0003      	movs	r3, r0
    5858:	001a      	movs	r2, r3
    585a:	2301      	movs	r3, #1
    585c:	4053      	eors	r3, r2
    585e:	b2db      	uxtb	r3, r3
    5860:	2b00      	cmp	r3, #0
    5862:	d1f4      	bne.n	584e <_sysctrl_init_sources+0xb2>
		;
#endif
#if CONF_OSC8M_ONDEMAND == 1
	hri_sysctrl_set_OSC8M_ONDEMAND_bit(hw);
    5864:	687b      	ldr	r3, [r7, #4]
    5866:	0018      	movs	r0, r3
    5868:	f7ff ff1a 	bl	56a0 <hri_sysctrl_set_OSC8M_ONDEMAND_bit>
#endif
#endif

	(void)calib, (void)hw;
}
    586c:	46c0      	nop			; (mov r8, r8)
    586e:	46bd      	mov	sp, r7
    5870:	b002      	add	sp, #8
    5872:	bd80      	pop	{r7, pc}
    5874:	40000800 	.word	0x40000800
    5878:	0fff0000 	.word	0x0fff0000
    587c:	00000302 	.word	0x00000302

00005880 <_sysctrl_init_referenced_generators>:

void _sysctrl_init_referenced_generators(void)
{
    5880:	b580      	push	{r7, lr}
    5882:	b084      	sub	sp, #16
    5884:	af00      	add	r7, sp, #0
	void *hw = (void *)SYSCTRL;
    5886:	4b33      	ldr	r3, [pc, #204]	; (5954 <_sysctrl_init_referenced_generators+0xd4>)
    5888:	60fb      	str	r3, [r7, #12]
#if CONF_DFLL_MODE != CONF_DFLL_OPEN_LOOP_MODE
	hri_gclk_write_CLKCTRL_reg(GCLK,
	                           GCLK_CLKCTRL_ID(0) | GCLK_CLKCTRL_GEN(CONF_DFLL_GCLK) | (1 << GCLK_CLKCTRL_CLKEN_Pos));
#endif

	hri_sysctrl_write_DFLLCTRL_reg(hw, SYSCTRL_DFLLCTRL_ENABLE);
    588a:	68fb      	ldr	r3, [r7, #12]
    588c:	2102      	movs	r1, #2
    588e:	0018      	movs	r0, r3
    5890:	f7ff ff5d 	bl	574e <hri_sysctrl_write_DFLLCTRL_reg>
	while (!hri_sysctrl_get_PCLKSR_DFLLRDY_bit(hw))
    5894:	46c0      	nop			; (mov r8, r8)
    5896:	68fb      	ldr	r3, [r7, #12]
    5898:	0018      	movs	r0, r3
    589a:	f7ff fe8e 	bl	55ba <hri_sysctrl_get_PCLKSR_DFLLRDY_bit>
    589e:	0003      	movs	r3, r0
    58a0:	001a      	movs	r2, r3
    58a2:	2301      	movs	r3, #1
    58a4:	4053      	eors	r3, r2
    58a6:	b2db      	uxtb	r3, r3
    58a8:	2b00      	cmp	r3, #0
    58aa:	d1f4      	bne.n	5896 <_sysctrl_init_referenced_generators+0x16>
		;

	hri_sysctrl_write_DFLLMUL_reg(hw,
    58ac:	4a2a      	ldr	r2, [pc, #168]	; (5958 <_sysctrl_init_referenced_generators+0xd8>)
    58ae:	68fb      	ldr	r3, [r7, #12]
    58b0:	0011      	movs	r1, r2
    58b2:	0018      	movs	r0, r3
    58b4:	f7ff ff66 	bl	5784 <hri_sysctrl_write_DFLLMUL_reg>
	                              SYSCTRL_DFLLMUL_CSTEP(CONF_DFLL_CSTEP) | SYSCTRL_DFLLMUL_FSTEP(CONF_DFLL_FSTEP)
	                                  | SYSCTRL_DFLLMUL_MUL(CONF_DFLL_MUL));
	hri_sysctrl_write_DFLLVAL_reg(hw, CONF_DFLLVAL);
    58b8:	4b28      	ldr	r3, [pc, #160]	; (595c <_sysctrl_init_referenced_generators+0xdc>)
    58ba:	681b      	ldr	r3, [r3, #0]
    58bc:	0e9b      	lsrs	r3, r3, #26
    58be:	2b3f      	cmp	r3, #63	; 0x3f
    58c0:	d009      	beq.n	58d6 <_sysctrl_init_referenced_generators+0x56>
    58c2:	4b26      	ldr	r3, [pc, #152]	; (595c <_sysctrl_init_referenced_generators+0xdc>)
    58c4:	681b      	ldr	r3, [r3, #0]
    58c6:	0e9b      	lsrs	r3, r3, #26
    58c8:	029b      	lsls	r3, r3, #10
    58ca:	041b      	lsls	r3, r3, #16
    58cc:	0c1b      	lsrs	r3, r3, #16
    58ce:	2280      	movs	r2, #128	; 0x80
    58d0:	0092      	lsls	r2, r2, #2
    58d2:	4313      	orrs	r3, r2
    58d4:	e001      	b.n	58da <_sysctrl_init_referenced_generators+0x5a>
    58d6:	23fc      	movs	r3, #252	; 0xfc
    58d8:	01db      	lsls	r3, r3, #7
    58da:	68fa      	ldr	r2, [r7, #12]
    58dc:	0019      	movs	r1, r3
    58de:	0010      	movs	r0, r2
    58e0:	f7ff ff44 	bl	576c <hri_sysctrl_write_DFLLVAL_reg>

	hri_sysctrl_dfllctrl_reg_t tmp
    58e4:	230a      	movs	r3, #10
    58e6:	18fb      	adds	r3, r7, r3
    58e8:	2252      	movs	r2, #82	; 0x52
    58ea:	801a      	strh	r2, [r3, #0]
	    = (CONF_DFLL_QLDIS << SYSCTRL_DFLLCTRL_QLDIS_Pos) | (CONF_DFLL_CCDIS << SYSCTRL_DFLLCTRL_CCDIS_Pos)
	      | (CONF_DFLL_RUNSTDBY << SYSCTRL_DFLLCTRL_RUNSTDBY_Pos) | (CONF_DFLL_LLAW << SYSCTRL_DFLLCTRL_LLAW_Pos)
	      | (CONF_DFLL_STABLE << SYSCTRL_DFLLCTRL_STABLE_Pos) | (CONF_DFLL_MODE << SYSCTRL_DFLLCTRL_MODE_Pos)
	      | (CONF_DFLL_ENABLE << SYSCTRL_DFLLCTRL_ENABLE_Pos);

	hri_sysctrl_write_DFLLCTRL_reg(hw, tmp);
    58ec:	230a      	movs	r3, #10
    58ee:	18fb      	adds	r3, r7, r3
    58f0:	881a      	ldrh	r2, [r3, #0]
    58f2:	68fb      	ldr	r3, [r7, #12]
    58f4:	0011      	movs	r1, r2
    58f6:	0018      	movs	r0, r3
    58f8:	f7ff ff29 	bl	574e <hri_sysctrl_write_DFLLCTRL_reg>
#endif

#if CONF_DFLL_CONFIG == 1
#if CONF_DFLL_ENABLE == 1
	if (hri_sysctrl_get_DFLLCTRL_MODE_bit(hw)) {
    58fc:	68fb      	ldr	r3, [r7, #12]
    58fe:	0018      	movs	r0, r3
    5900:	f7ff ff08 	bl	5714 <hri_sysctrl_get_DFLLCTRL_MODE_bit>
    5904:	1e03      	subs	r3, r0, #0
    5906:	d00d      	beq.n	5924 <_sysctrl_init_referenced_generators+0xa4>
		hri_sysctrl_pclksr_reg_t status_mask
    5908:	23d0      	movs	r3, #208	; 0xd0
    590a:	607b      	str	r3, [r7, #4]
		    = SYSCTRL_PCLKSR_DFLLRDY | SYSCTRL_PCLKSR_DFLLLCKF | SYSCTRL_PCLKSR_DFLLLCKC;

		while (hri_sysctrl_get_PCLKSR_reg(hw, status_mask) != status_mask)
    590c:	46c0      	nop			; (mov r8, r8)
    590e:	687a      	ldr	r2, [r7, #4]
    5910:	68fb      	ldr	r3, [r7, #12]
    5912:	0011      	movs	r1, r2
    5914:	0018      	movs	r0, r3
    5916:	f7ff fe60 	bl	55da <hri_sysctrl_get_PCLKSR_reg>
    591a:	0002      	movs	r2, r0
    591c:	687b      	ldr	r3, [r7, #4]
    591e:	429a      	cmp	r2, r3
    5920:	d1f5      	bne.n	590e <_sysctrl_init_referenced_generators+0x8e>
    5922:	e00b      	b.n	593c <_sysctrl_init_referenced_generators+0xbc>
			;
	} else {
		while (!hri_sysctrl_get_PCLKSR_DFLLRDY_bit(hw))
    5924:	46c0      	nop			; (mov r8, r8)
    5926:	68fb      	ldr	r3, [r7, #12]
    5928:	0018      	movs	r0, r3
    592a:	f7ff fe46 	bl	55ba <hri_sysctrl_get_PCLKSR_DFLLRDY_bit>
    592e:	0003      	movs	r3, r0
    5930:	001a      	movs	r2, r3
    5932:	2301      	movs	r3, #1
    5934:	4053      	eors	r3, r2
    5936:	b2db      	uxtb	r3, r3
    5938:	2b00      	cmp	r3, #0
    593a:	d1f4      	bne.n	5926 <_sysctrl_init_referenced_generators+0xa6>
	hri_sysctrl_set_DFLLCTRL_ONDEMAND_bit(hw);
#endif
#endif

#if CONF_DFLL_CONFIG == 1
	while (hri_gclk_get_STATUS_SYNCBUSY_bit(GCLK))
    593c:	46c0      	nop			; (mov r8, r8)
    593e:	4b08      	ldr	r3, [pc, #32]	; (5960 <_sysctrl_init_referenced_generators+0xe0>)
    5940:	0018      	movs	r0, r3
    5942:	f7ff fe09 	bl	5558 <hri_gclk_get_STATUS_SYNCBUSY_bit>
    5946:	1e03      	subs	r3, r0, #0
    5948:	d1f9      	bne.n	593e <_sysctrl_init_referenced_generators+0xbe>
	/* Disable after all possible configurations needs sync written. */
	hri_sysctrl_clear_OSC32K_ENABLE_bit(hw);
#endif

	(void)hw;
}
    594a:	46c0      	nop			; (mov r8, r8)
    594c:	46bd      	mov	sp, r7
    594e:	b004      	add	sp, #16
    5950:	bd80      	pop	{r7, pc}
    5952:	46c0      	nop			; (mov r8, r8)
    5954:	40000800 	.word	0x40000800
    5958:	7c1f0000 	.word	0x7c1f0000
    595c:	00806024 	.word	0x00806024
    5960:	40000c00 	.word	0x40000c00

00005964 <_system_time_init>:

/**
 * \brief Initialize system time module
 */
void _system_time_init(void *const hw)
{
    5964:	b580      	push	{r7, lr}
    5966:	b082      	sub	sp, #8
    5968:	af00      	add	r7, sp, #0
    596a:	6078      	str	r0, [r7, #4]
	(void)hw;
	SysTick->LOAD = (0xFFFFFF << SysTick_LOAD_RELOAD_Pos);
    596c:	4b04      	ldr	r3, [pc, #16]	; (5980 <_system_time_init+0x1c>)
    596e:	4a05      	ldr	r2, [pc, #20]	; (5984 <_system_time_init+0x20>)
    5970:	605a      	str	r2, [r3, #4]
	SysTick->CTRL = (1 << SysTick_CTRL_ENABLE_Pos) | (CONF_SYSTICK_TICKINT << SysTick_CTRL_TICKINT_Pos)
    5972:	4b03      	ldr	r3, [pc, #12]	; (5980 <_system_time_init+0x1c>)
    5974:	2205      	movs	r2, #5
    5976:	601a      	str	r2, [r3, #0]
	                | (1 << SysTick_CTRL_CLKSOURCE_Pos);
}
    5978:	46c0      	nop			; (mov r8, r8)
    597a:	46bd      	mov	sp, r7
    597c:	b002      	add	sp, #8
    597e:	bd80      	pop	{r7, pc}
    5980:	e000e010 	.word	0xe000e010
    5984:	00ffffff 	.word	0x00ffffff

00005988 <_delay_init>:
/**
 * \brief Initialize delay functionality
 */
void _delay_init(void *const hw)
{
    5988:	b580      	push	{r7, lr}
    598a:	b082      	sub	sp, #8
    598c:	af00      	add	r7, sp, #0
    598e:	6078      	str	r0, [r7, #4]
	_system_time_init(hw);
    5990:	687b      	ldr	r3, [r7, #4]
    5992:	0018      	movs	r0, r3
    5994:	f7ff ffe6 	bl	5964 <_system_time_init>
}
    5998:	46c0      	nop			; (mov r8, r8)
    599a:	46bd      	mov	sp, r7
    599c:	b002      	add	sp, #8
    599e:	bd80      	pop	{r7, pc}

000059a0 <_delay_cycles>:
}
/**
 * \brief Delay loop to delay n number of cycles
 */
void _delay_cycles(void *const hw, uint32_t cycles)
{
    59a0:	b580      	push	{r7, lr}
    59a2:	b084      	sub	sp, #16
    59a4:	af00      	add	r7, sp, #0
    59a6:	6078      	str	r0, [r7, #4]
    59a8:	6039      	str	r1, [r7, #0]
	(void)hw;
	uint8_t  n   = cycles >> 24;
    59aa:	683b      	ldr	r3, [r7, #0]
    59ac:	0e1a      	lsrs	r2, r3, #24
    59ae:	230f      	movs	r3, #15
    59b0:	18fb      	adds	r3, r7, r3
    59b2:	701a      	strb	r2, [r3, #0]
	uint32_t buf = cycles;
    59b4:	683b      	ldr	r3, [r7, #0]
    59b6:	60bb      	str	r3, [r7, #8]

	while (n--) {
    59b8:	e011      	b.n	59de <_delay_cycles+0x3e>
		SysTick->LOAD = 0xFFFFFF;
    59ba:	4b16      	ldr	r3, [pc, #88]	; (5a14 <_delay_cycles+0x74>)
    59bc:	4a16      	ldr	r2, [pc, #88]	; (5a18 <_delay_cycles+0x78>)
    59be:	605a      	str	r2, [r3, #4]
		SysTick->VAL  = 0xFFFFFF;
    59c0:	4b14      	ldr	r3, [pc, #80]	; (5a14 <_delay_cycles+0x74>)
    59c2:	4a15      	ldr	r2, [pc, #84]	; (5a18 <_delay_cycles+0x78>)
    59c4:	609a      	str	r2, [r3, #8]
		while (!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk))
    59c6:	46c0      	nop			; (mov r8, r8)
    59c8:	4b12      	ldr	r3, [pc, #72]	; (5a14 <_delay_cycles+0x74>)
    59ca:	681a      	ldr	r2, [r3, #0]
    59cc:	2380      	movs	r3, #128	; 0x80
    59ce:	025b      	lsls	r3, r3, #9
    59d0:	4013      	ands	r3, r2
    59d2:	d0f9      	beq.n	59c8 <_delay_cycles+0x28>
			;
		buf -= 0xFFFFFF;
    59d4:	68bb      	ldr	r3, [r7, #8]
    59d6:	4a11      	ldr	r2, [pc, #68]	; (5a1c <_delay_cycles+0x7c>)
    59d8:	4694      	mov	ip, r2
    59da:	4463      	add	r3, ip
    59dc:	60bb      	str	r3, [r7, #8]
	while (n--) {
    59de:	230f      	movs	r3, #15
    59e0:	18fb      	adds	r3, r7, r3
    59e2:	781b      	ldrb	r3, [r3, #0]
    59e4:	220f      	movs	r2, #15
    59e6:	18ba      	adds	r2, r7, r2
    59e8:	1e59      	subs	r1, r3, #1
    59ea:	7011      	strb	r1, [r2, #0]
    59ec:	2b00      	cmp	r3, #0
    59ee:	d1e4      	bne.n	59ba <_delay_cycles+0x1a>
	}

	SysTick->LOAD = buf;
    59f0:	4b08      	ldr	r3, [pc, #32]	; (5a14 <_delay_cycles+0x74>)
    59f2:	68ba      	ldr	r2, [r7, #8]
    59f4:	605a      	str	r2, [r3, #4]
	SysTick->VAL  = buf;
    59f6:	4b07      	ldr	r3, [pc, #28]	; (5a14 <_delay_cycles+0x74>)
    59f8:	68ba      	ldr	r2, [r7, #8]
    59fa:	609a      	str	r2, [r3, #8]
	while (!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk))
    59fc:	46c0      	nop			; (mov r8, r8)
    59fe:	4b05      	ldr	r3, [pc, #20]	; (5a14 <_delay_cycles+0x74>)
    5a00:	681a      	ldr	r2, [r3, #0]
    5a02:	2380      	movs	r3, #128	; 0x80
    5a04:	025b      	lsls	r3, r3, #9
    5a06:	4013      	ands	r3, r2
    5a08:	d0f9      	beq.n	59fe <_delay_cycles+0x5e>
		;
}
    5a0a:	46c0      	nop			; (mov r8, r8)
    5a0c:	46bd      	mov	sp, r7
    5a0e:	b004      	add	sp, #16
    5a10:	bd80      	pop	{r7, pc}
    5a12:	46c0      	nop			; (mov r8, r8)
    5a14:	e000e010 	.word	0xe000e010
    5a18:	00ffffff 	.word	0x00ffffff
    5a1c:	ff000001 	.word	0xff000001

00005a20 <hri_gclk_write_CLKCTRL_reg>:
{
    5a20:	b580      	push	{r7, lr}
    5a22:	b082      	sub	sp, #8
    5a24:	af00      	add	r7, sp, #0
    5a26:	6078      	str	r0, [r7, #4]
    5a28:	000a      	movs	r2, r1
    5a2a:	1cbb      	adds	r3, r7, #2
    5a2c:	801a      	strh	r2, [r3, #0]
	((Gclk *)hw)->CLKCTRL.reg = data;
    5a2e:	687b      	ldr	r3, [r7, #4]
    5a30:	1cba      	adds	r2, r7, #2
    5a32:	8812      	ldrh	r2, [r2, #0]
    5a34:	805a      	strh	r2, [r3, #2]
}
    5a36:	46c0      	nop			; (mov r8, r8)
    5a38:	46bd      	mov	sp, r7
    5a3a:	b002      	add	sp, #8
    5a3c:	bd80      	pop	{r7, pc}

00005a3e <hri_port_set_DIR_reg>:
{
    5a3e:	b580      	push	{r7, lr}
    5a40:	b084      	sub	sp, #16
    5a42:	af00      	add	r7, sp, #0
    5a44:	60f8      	str	r0, [r7, #12]
    5a46:	607a      	str	r2, [r7, #4]
    5a48:	230b      	movs	r3, #11
    5a4a:	18fb      	adds	r3, r7, r3
    5a4c:	1c0a      	adds	r2, r1, #0
    5a4e:	701a      	strb	r2, [r3, #0]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    5a50:	230b      	movs	r3, #11
    5a52:	18fb      	adds	r3, r7, r3
    5a54:	781b      	ldrb	r3, [r3, #0]
    5a56:	68fa      	ldr	r2, [r7, #12]
    5a58:	01db      	lsls	r3, r3, #7
    5a5a:	18d3      	adds	r3, r2, r3
    5a5c:	3308      	adds	r3, #8
    5a5e:	687a      	ldr	r2, [r7, #4]
    5a60:	601a      	str	r2, [r3, #0]
}
    5a62:	46c0      	nop			; (mov r8, r8)
    5a64:	46bd      	mov	sp, r7
    5a66:	b004      	add	sp, #16
    5a68:	bd80      	pop	{r7, pc}

00005a6a <hri_port_clear_DIR_reg>:
{
    5a6a:	b580      	push	{r7, lr}
    5a6c:	b084      	sub	sp, #16
    5a6e:	af00      	add	r7, sp, #0
    5a70:	60f8      	str	r0, [r7, #12]
    5a72:	607a      	str	r2, [r7, #4]
    5a74:	230b      	movs	r3, #11
    5a76:	18fb      	adds	r3, r7, r3
    5a78:	1c0a      	adds	r2, r1, #0
    5a7a:	701a      	strb	r2, [r3, #0]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    5a7c:	230b      	movs	r3, #11
    5a7e:	18fb      	adds	r3, r7, r3
    5a80:	781b      	ldrb	r3, [r3, #0]
    5a82:	68fa      	ldr	r2, [r7, #12]
    5a84:	01db      	lsls	r3, r3, #7
    5a86:	18d3      	adds	r3, r2, r3
    5a88:	3304      	adds	r3, #4
    5a8a:	687a      	ldr	r2, [r7, #4]
    5a8c:	601a      	str	r2, [r3, #0]
}
    5a8e:	46c0      	nop			; (mov r8, r8)
    5a90:	46bd      	mov	sp, r7
    5a92:	b004      	add	sp, #16
    5a94:	bd80      	pop	{r7, pc}

00005a96 <hri_port_set_OUT_reg>:
{
    5a96:	b580      	push	{r7, lr}
    5a98:	b084      	sub	sp, #16
    5a9a:	af00      	add	r7, sp, #0
    5a9c:	60f8      	str	r0, [r7, #12]
    5a9e:	607a      	str	r2, [r7, #4]
    5aa0:	230b      	movs	r3, #11
    5aa2:	18fb      	adds	r3, r7, r3
    5aa4:	1c0a      	adds	r2, r1, #0
    5aa6:	701a      	strb	r2, [r3, #0]
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    5aa8:	230b      	movs	r3, #11
    5aaa:	18fb      	adds	r3, r7, r3
    5aac:	781b      	ldrb	r3, [r3, #0]
    5aae:	68fa      	ldr	r2, [r7, #12]
    5ab0:	01db      	lsls	r3, r3, #7
    5ab2:	18d3      	adds	r3, r2, r3
    5ab4:	3318      	adds	r3, #24
    5ab6:	687a      	ldr	r2, [r7, #4]
    5ab8:	601a      	str	r2, [r3, #0]
}
    5aba:	46c0      	nop			; (mov r8, r8)
    5abc:	46bd      	mov	sp, r7
    5abe:	b004      	add	sp, #16
    5ac0:	bd80      	pop	{r7, pc}

00005ac2 <hri_port_clear_OUT_reg>:
{
    5ac2:	b580      	push	{r7, lr}
    5ac4:	b084      	sub	sp, #16
    5ac6:	af00      	add	r7, sp, #0
    5ac8:	60f8      	str	r0, [r7, #12]
    5aca:	607a      	str	r2, [r7, #4]
    5acc:	230b      	movs	r3, #11
    5ace:	18fb      	adds	r3, r7, r3
    5ad0:	1c0a      	adds	r2, r1, #0
    5ad2:	701a      	strb	r2, [r3, #0]
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    5ad4:	230b      	movs	r3, #11
    5ad6:	18fb      	adds	r3, r7, r3
    5ad8:	781b      	ldrb	r3, [r3, #0]
    5ada:	68fa      	ldr	r2, [r7, #12]
    5adc:	01db      	lsls	r3, r3, #7
    5ade:	18d3      	adds	r3, r2, r3
    5ae0:	3314      	adds	r3, #20
    5ae2:	687a      	ldr	r2, [r7, #4]
    5ae4:	601a      	str	r2, [r3, #0]
}
    5ae6:	46c0      	nop			; (mov r8, r8)
    5ae8:	46bd      	mov	sp, r7
    5aea:	b004      	add	sp, #16
    5aec:	bd80      	pop	{r7, pc}

00005aee <hri_port_write_PMUX_PMUXE_bf>:
{
    5aee:	b590      	push	{r4, r7, lr}
    5af0:	b085      	sub	sp, #20
    5af2:	af00      	add	r7, sp, #0
    5af4:	6078      	str	r0, [r7, #4]
    5af6:	000c      	movs	r4, r1
    5af8:	0010      	movs	r0, r2
    5afa:	0019      	movs	r1, r3
    5afc:	1cfb      	adds	r3, r7, #3
    5afe:	1c22      	adds	r2, r4, #0
    5b00:	701a      	strb	r2, [r3, #0]
    5b02:	1cbb      	adds	r3, r7, #2
    5b04:	1c02      	adds	r2, r0, #0
    5b06:	701a      	strb	r2, [r3, #0]
    5b08:	1c7b      	adds	r3, r7, #1
    5b0a:	1c0a      	adds	r2, r1, #0
    5b0c:	701a      	strb	r2, [r3, #0]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
    5b0e:	1cfb      	adds	r3, r7, #3
    5b10:	7819      	ldrb	r1, [r3, #0]
    5b12:	1cbb      	adds	r3, r7, #2
    5b14:	781a      	ldrb	r2, [r3, #0]
    5b16:	230f      	movs	r3, #15
    5b18:	18fb      	adds	r3, r7, r3
    5b1a:	6878      	ldr	r0, [r7, #4]
    5b1c:	2430      	movs	r4, #48	; 0x30
    5b1e:	01c9      	lsls	r1, r1, #7
    5b20:	1841      	adds	r1, r0, r1
    5b22:	188a      	adds	r2, r1, r2
    5b24:	1912      	adds	r2, r2, r4
    5b26:	7812      	ldrb	r2, [r2, #0]
    5b28:	701a      	strb	r2, [r3, #0]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
    5b2a:	230f      	movs	r3, #15
    5b2c:	18fb      	adds	r3, r7, r3
    5b2e:	220f      	movs	r2, #15
    5b30:	18ba      	adds	r2, r7, r2
    5b32:	7812      	ldrb	r2, [r2, #0]
    5b34:	210f      	movs	r1, #15
    5b36:	438a      	bics	r2, r1
    5b38:	701a      	strb	r2, [r3, #0]
	tmp |= PORT_PMUX_PMUXE(data);
    5b3a:	1c7b      	adds	r3, r7, #1
    5b3c:	781b      	ldrb	r3, [r3, #0]
    5b3e:	220f      	movs	r2, #15
    5b40:	4013      	ands	r3, r2
    5b42:	b2d9      	uxtb	r1, r3
    5b44:	230f      	movs	r3, #15
    5b46:	18fb      	adds	r3, r7, r3
    5b48:	220f      	movs	r2, #15
    5b4a:	18ba      	adds	r2, r7, r2
    5b4c:	7812      	ldrb	r2, [r2, #0]
    5b4e:	430a      	orrs	r2, r1
    5b50:	701a      	strb	r2, [r3, #0]
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
    5b52:	1cfb      	adds	r3, r7, #3
    5b54:	781a      	ldrb	r2, [r3, #0]
    5b56:	1cbb      	adds	r3, r7, #2
    5b58:	781b      	ldrb	r3, [r3, #0]
    5b5a:	6879      	ldr	r1, [r7, #4]
    5b5c:	2030      	movs	r0, #48	; 0x30
    5b5e:	01d2      	lsls	r2, r2, #7
    5b60:	188a      	adds	r2, r1, r2
    5b62:	18d3      	adds	r3, r2, r3
    5b64:	181b      	adds	r3, r3, r0
    5b66:	220f      	movs	r2, #15
    5b68:	18ba      	adds	r2, r7, r2
    5b6a:	7812      	ldrb	r2, [r2, #0]
    5b6c:	701a      	strb	r2, [r3, #0]
}
    5b6e:	46c0      	nop			; (mov r8, r8)
    5b70:	46bd      	mov	sp, r7
    5b72:	b005      	add	sp, #20
    5b74:	bd90      	pop	{r4, r7, pc}

00005b76 <hri_port_write_PMUX_PMUXO_bf>:
{
    5b76:	b590      	push	{r4, r7, lr}
    5b78:	b085      	sub	sp, #20
    5b7a:	af00      	add	r7, sp, #0
    5b7c:	6078      	str	r0, [r7, #4]
    5b7e:	000c      	movs	r4, r1
    5b80:	0010      	movs	r0, r2
    5b82:	0019      	movs	r1, r3
    5b84:	1cfb      	adds	r3, r7, #3
    5b86:	1c22      	adds	r2, r4, #0
    5b88:	701a      	strb	r2, [r3, #0]
    5b8a:	1cbb      	adds	r3, r7, #2
    5b8c:	1c02      	adds	r2, r0, #0
    5b8e:	701a      	strb	r2, [r3, #0]
    5b90:	1c7b      	adds	r3, r7, #1
    5b92:	1c0a      	adds	r2, r1, #0
    5b94:	701a      	strb	r2, [r3, #0]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
    5b96:	1cfb      	adds	r3, r7, #3
    5b98:	7819      	ldrb	r1, [r3, #0]
    5b9a:	1cbb      	adds	r3, r7, #2
    5b9c:	781a      	ldrb	r2, [r3, #0]
    5b9e:	230f      	movs	r3, #15
    5ba0:	18fb      	adds	r3, r7, r3
    5ba2:	6878      	ldr	r0, [r7, #4]
    5ba4:	2430      	movs	r4, #48	; 0x30
    5ba6:	01c9      	lsls	r1, r1, #7
    5ba8:	1841      	adds	r1, r0, r1
    5baa:	188a      	adds	r2, r1, r2
    5bac:	1912      	adds	r2, r2, r4
    5bae:	7812      	ldrb	r2, [r2, #0]
    5bb0:	701a      	strb	r2, [r3, #0]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
    5bb2:	230f      	movs	r3, #15
    5bb4:	18fb      	adds	r3, r7, r3
    5bb6:	220f      	movs	r2, #15
    5bb8:	18ba      	adds	r2, r7, r2
    5bba:	7812      	ldrb	r2, [r2, #0]
    5bbc:	210f      	movs	r1, #15
    5bbe:	400a      	ands	r2, r1
    5bc0:	701a      	strb	r2, [r3, #0]
	tmp |= PORT_PMUX_PMUXO(data);
    5bc2:	1c7b      	adds	r3, r7, #1
    5bc4:	781b      	ldrb	r3, [r3, #0]
    5bc6:	011b      	lsls	r3, r3, #4
    5bc8:	b2d9      	uxtb	r1, r3
    5bca:	230f      	movs	r3, #15
    5bcc:	18fb      	adds	r3, r7, r3
    5bce:	220f      	movs	r2, #15
    5bd0:	18ba      	adds	r2, r7, r2
    5bd2:	7812      	ldrb	r2, [r2, #0]
    5bd4:	430a      	orrs	r2, r1
    5bd6:	701a      	strb	r2, [r3, #0]
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
    5bd8:	1cfb      	adds	r3, r7, #3
    5bda:	781a      	ldrb	r2, [r3, #0]
    5bdc:	1cbb      	adds	r3, r7, #2
    5bde:	781b      	ldrb	r3, [r3, #0]
    5be0:	6879      	ldr	r1, [r7, #4]
    5be2:	2030      	movs	r0, #48	; 0x30
    5be4:	01d2      	lsls	r2, r2, #7
    5be6:	188a      	adds	r2, r1, r2
    5be8:	18d3      	adds	r3, r2, r3
    5bea:	181b      	adds	r3, r3, r0
    5bec:	220f      	movs	r2, #15
    5bee:	18ba      	adds	r2, r7, r2
    5bf0:	7812      	ldrb	r2, [r2, #0]
    5bf2:	701a      	strb	r2, [r3, #0]
}
    5bf4:	46c0      	nop			; (mov r8, r8)
    5bf6:	46bd      	mov	sp, r7
    5bf8:	b005      	add	sp, #20
    5bfa:	bd90      	pop	{r4, r7, pc}

00005bfc <hri_port_write_PINCFG_PMUXEN_bit>:
{
    5bfc:	b590      	push	{r4, r7, lr}
    5bfe:	b085      	sub	sp, #20
    5c00:	af00      	add	r7, sp, #0
    5c02:	6078      	str	r0, [r7, #4]
    5c04:	000c      	movs	r4, r1
    5c06:	0010      	movs	r0, r2
    5c08:	0019      	movs	r1, r3
    5c0a:	1cfb      	adds	r3, r7, #3
    5c0c:	1c22      	adds	r2, r4, #0
    5c0e:	701a      	strb	r2, [r3, #0]
    5c10:	1cbb      	adds	r3, r7, #2
    5c12:	1c02      	adds	r2, r0, #0
    5c14:	701a      	strb	r2, [r3, #0]
    5c16:	1c7b      	adds	r3, r7, #1
    5c18:	1c0a      	adds	r2, r1, #0
    5c1a:	701a      	strb	r2, [r3, #0]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    5c1c:	1cfb      	adds	r3, r7, #3
    5c1e:	7819      	ldrb	r1, [r3, #0]
    5c20:	1cbb      	adds	r3, r7, #2
    5c22:	781a      	ldrb	r2, [r3, #0]
    5c24:	230f      	movs	r3, #15
    5c26:	18fb      	adds	r3, r7, r3
    5c28:	6878      	ldr	r0, [r7, #4]
    5c2a:	2440      	movs	r4, #64	; 0x40
    5c2c:	01c9      	lsls	r1, r1, #7
    5c2e:	1841      	adds	r1, r0, r1
    5c30:	188a      	adds	r2, r1, r2
    5c32:	1912      	adds	r2, r2, r4
    5c34:	7812      	ldrb	r2, [r2, #0]
    5c36:	701a      	strb	r2, [r3, #0]
	tmp &= ~PORT_PINCFG_PMUXEN;
    5c38:	230f      	movs	r3, #15
    5c3a:	18fb      	adds	r3, r7, r3
    5c3c:	220f      	movs	r2, #15
    5c3e:	18ba      	adds	r2, r7, r2
    5c40:	7812      	ldrb	r2, [r2, #0]
    5c42:	2101      	movs	r1, #1
    5c44:	438a      	bics	r2, r1
    5c46:	701a      	strb	r2, [r3, #0]
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
    5c48:	1c7b      	adds	r3, r7, #1
    5c4a:	7819      	ldrb	r1, [r3, #0]
    5c4c:	230f      	movs	r3, #15
    5c4e:	18fb      	adds	r3, r7, r3
    5c50:	220f      	movs	r2, #15
    5c52:	18ba      	adds	r2, r7, r2
    5c54:	7812      	ldrb	r2, [r2, #0]
    5c56:	430a      	orrs	r2, r1
    5c58:	701a      	strb	r2, [r3, #0]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    5c5a:	1cfb      	adds	r3, r7, #3
    5c5c:	781a      	ldrb	r2, [r3, #0]
    5c5e:	1cbb      	adds	r3, r7, #2
    5c60:	781b      	ldrb	r3, [r3, #0]
    5c62:	6879      	ldr	r1, [r7, #4]
    5c64:	2040      	movs	r0, #64	; 0x40
    5c66:	01d2      	lsls	r2, r2, #7
    5c68:	188a      	adds	r2, r1, r2
    5c6a:	18d3      	adds	r3, r2, r3
    5c6c:	181b      	adds	r3, r3, r0
    5c6e:	220f      	movs	r2, #15
    5c70:	18ba      	adds	r2, r7, r2
    5c72:	7812      	ldrb	r2, [r2, #0]
    5c74:	701a      	strb	r2, [r3, #0]
}
    5c76:	46c0      	nop			; (mov r8, r8)
    5c78:	46bd      	mov	sp, r7
    5c7a:	b005      	add	sp, #20
    5c7c:	bd90      	pop	{r4, r7, pc}

00005c7e <hri_port_set_PINCFG_PULLEN_bit>:
{
    5c7e:	b5b0      	push	{r4, r5, r7, lr}
    5c80:	b082      	sub	sp, #8
    5c82:	af00      	add	r7, sp, #0
    5c84:	6078      	str	r0, [r7, #4]
    5c86:	0008      	movs	r0, r1
    5c88:	0011      	movs	r1, r2
    5c8a:	1cfb      	adds	r3, r7, #3
    5c8c:	1c02      	adds	r2, r0, #0
    5c8e:	701a      	strb	r2, [r3, #0]
    5c90:	1cbb      	adds	r3, r7, #2
    5c92:	1c0a      	adds	r2, r1, #0
    5c94:	701a      	strb	r2, [r3, #0]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg |= PORT_PINCFG_PULLEN;
    5c96:	1cfb      	adds	r3, r7, #3
    5c98:	781a      	ldrb	r2, [r3, #0]
    5c9a:	1cbb      	adds	r3, r7, #2
    5c9c:	781b      	ldrb	r3, [r3, #0]
    5c9e:	1cf9      	adds	r1, r7, #3
    5ca0:	7808      	ldrb	r0, [r1, #0]
    5ca2:	1cb9      	adds	r1, r7, #2
    5ca4:	7809      	ldrb	r1, [r1, #0]
    5ca6:	687c      	ldr	r4, [r7, #4]
    5ca8:	2540      	movs	r5, #64	; 0x40
    5caa:	01c0      	lsls	r0, r0, #7
    5cac:	1820      	adds	r0, r4, r0
    5cae:	1841      	adds	r1, r0, r1
    5cb0:	1949      	adds	r1, r1, r5
    5cb2:	7809      	ldrb	r1, [r1, #0]
    5cb4:	b2c9      	uxtb	r1, r1
    5cb6:	2004      	movs	r0, #4
    5cb8:	4301      	orrs	r1, r0
    5cba:	b2cc      	uxtb	r4, r1
    5cbc:	6879      	ldr	r1, [r7, #4]
    5cbe:	2040      	movs	r0, #64	; 0x40
    5cc0:	01d2      	lsls	r2, r2, #7
    5cc2:	188a      	adds	r2, r1, r2
    5cc4:	18d3      	adds	r3, r2, r3
    5cc6:	181b      	adds	r3, r3, r0
    5cc8:	1c22      	adds	r2, r4, #0
    5cca:	701a      	strb	r2, [r3, #0]
}
    5ccc:	46c0      	nop			; (mov r8, r8)
    5cce:	46bd      	mov	sp, r7
    5cd0:	b002      	add	sp, #8
    5cd2:	bdb0      	pop	{r4, r5, r7, pc}

00005cd4 <hri_port_clear_PINCFG_PULLEN_bit>:
{
    5cd4:	b5b0      	push	{r4, r5, r7, lr}
    5cd6:	b082      	sub	sp, #8
    5cd8:	af00      	add	r7, sp, #0
    5cda:	6078      	str	r0, [r7, #4]
    5cdc:	0008      	movs	r0, r1
    5cde:	0011      	movs	r1, r2
    5ce0:	1cfb      	adds	r3, r7, #3
    5ce2:	1c02      	adds	r2, r0, #0
    5ce4:	701a      	strb	r2, [r3, #0]
    5ce6:	1cbb      	adds	r3, r7, #2
    5ce8:	1c0a      	adds	r2, r1, #0
    5cea:	701a      	strb	r2, [r3, #0]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
    5cec:	1cfb      	adds	r3, r7, #3
    5cee:	781a      	ldrb	r2, [r3, #0]
    5cf0:	1cbb      	adds	r3, r7, #2
    5cf2:	781b      	ldrb	r3, [r3, #0]
    5cf4:	1cf9      	adds	r1, r7, #3
    5cf6:	7808      	ldrb	r0, [r1, #0]
    5cf8:	1cb9      	adds	r1, r7, #2
    5cfa:	7809      	ldrb	r1, [r1, #0]
    5cfc:	687c      	ldr	r4, [r7, #4]
    5cfe:	2540      	movs	r5, #64	; 0x40
    5d00:	01c0      	lsls	r0, r0, #7
    5d02:	1820      	adds	r0, r4, r0
    5d04:	1841      	adds	r1, r0, r1
    5d06:	1949      	adds	r1, r1, r5
    5d08:	7809      	ldrb	r1, [r1, #0]
    5d0a:	b2c9      	uxtb	r1, r1
    5d0c:	2004      	movs	r0, #4
    5d0e:	4381      	bics	r1, r0
    5d10:	b2cc      	uxtb	r4, r1
    5d12:	6879      	ldr	r1, [r7, #4]
    5d14:	2040      	movs	r0, #64	; 0x40
    5d16:	01d2      	lsls	r2, r2, #7
    5d18:	188a      	adds	r2, r1, r2
    5d1a:	18d3      	adds	r3, r2, r3
    5d1c:	181b      	adds	r3, r3, r0
    5d1e:	1c22      	adds	r2, r4, #0
    5d20:	701a      	strb	r2, [r3, #0]
}
    5d22:	46c0      	nop			; (mov r8, r8)
    5d24:	46bd      	mov	sp, r7
    5d26:	b002      	add	sp, #8
    5d28:	bdb0      	pop	{r4, r5, r7, pc}

00005d2a <hri_port_write_WRCONFIG_reg>:
{
    5d2a:	b580      	push	{r7, lr}
    5d2c:	b084      	sub	sp, #16
    5d2e:	af00      	add	r7, sp, #0
    5d30:	60f8      	str	r0, [r7, #12]
    5d32:	607a      	str	r2, [r7, #4]
    5d34:	230b      	movs	r3, #11
    5d36:	18fb      	adds	r3, r7, r3
    5d38:	1c0a      	adds	r2, r1, #0
    5d3a:	701a      	strb	r2, [r3, #0]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    5d3c:	230b      	movs	r3, #11
    5d3e:	18fb      	adds	r3, r7, r3
    5d40:	781b      	ldrb	r3, [r3, #0]
    5d42:	68fa      	ldr	r2, [r7, #12]
    5d44:	01db      	lsls	r3, r3, #7
    5d46:	18d3      	adds	r3, r2, r3
    5d48:	3328      	adds	r3, #40	; 0x28
    5d4a:	687a      	ldr	r2, [r7, #4]
    5d4c:	601a      	str	r2, [r3, #0]
}
    5d4e:	46c0      	nop			; (mov r8, r8)
    5d50:	46bd      	mov	sp, r7
    5d52:	b004      	add	sp, #16
    5d54:	bd80      	pop	{r7, pc}
	...

00005d58 <_gpio_set_direction>:
{
    5d58:	b580      	push	{r7, lr}
    5d5a:	b082      	sub	sp, #8
    5d5c:	af00      	add	r7, sp, #0
    5d5e:	6039      	str	r1, [r7, #0]
    5d60:	0011      	movs	r1, r2
    5d62:	1dfb      	adds	r3, r7, #7
    5d64:	1c02      	adds	r2, r0, #0
    5d66:	701a      	strb	r2, [r3, #0]
    5d68:	1dbb      	adds	r3, r7, #6
    5d6a:	1c0a      	adds	r2, r1, #0
    5d6c:	701a      	strb	r2, [r3, #0]
	switch (direction) {
    5d6e:	1dbb      	adds	r3, r7, #6
    5d70:	781b      	ldrb	r3, [r3, #0]
    5d72:	2b01      	cmp	r3, #1
    5d74:	d023      	beq.n	5dbe <_gpio_set_direction+0x66>
    5d76:	2b02      	cmp	r3, #2
    5d78:	d03f      	beq.n	5dfa <_gpio_set_direction+0xa2>
    5d7a:	2b00      	cmp	r3, #0
    5d7c:	d15d      	bne.n	5e3a <_gpio_set_direction+0xe2>
		hri_port_clear_DIR_reg(PORT_IOBUS, port, mask);
    5d7e:	683a      	ldr	r2, [r7, #0]
    5d80:	1dfb      	adds	r3, r7, #7
    5d82:	7819      	ldrb	r1, [r3, #0]
    5d84:	23c0      	movs	r3, #192	; 0xc0
    5d86:	05db      	lsls	r3, r3, #23
    5d88:	0018      	movs	r0, r3
    5d8a:	f7ff fe6e 	bl	5a6a <hri_port_clear_DIR_reg>
		hri_port_write_WRCONFIG_reg(PORT, port, PORT_WRCONFIG_WRPINCFG | (mask & 0xffff));
    5d8e:	683b      	ldr	r3, [r7, #0]
    5d90:	041b      	lsls	r3, r3, #16
    5d92:	0c1b      	lsrs	r3, r3, #16
    5d94:	2280      	movs	r2, #128	; 0x80
    5d96:	05d2      	lsls	r2, r2, #23
    5d98:	431a      	orrs	r2, r3
    5d9a:	1dfb      	adds	r3, r7, #7
    5d9c:	781b      	ldrb	r3, [r3, #0]
    5d9e:	482c      	ldr	r0, [pc, #176]	; (5e50 <_gpio_set_direction+0xf8>)
    5da0:	0019      	movs	r1, r3
    5da2:	f7ff ffc2 	bl	5d2a <hri_port_write_WRCONFIG_reg>
		    PORT, port, PORT_WRCONFIG_HWSEL | PORT_WRCONFIG_WRPINCFG | ((mask & 0xffff0000) >> 16));
    5da6:	683b      	ldr	r3, [r7, #0]
    5da8:	0c1b      	lsrs	r3, r3, #16
		hri_port_write_WRCONFIG_reg(
    5daa:	22c0      	movs	r2, #192	; 0xc0
    5dac:	0612      	lsls	r2, r2, #24
    5dae:	431a      	orrs	r2, r3
    5db0:	1dfb      	adds	r3, r7, #7
    5db2:	781b      	ldrb	r3, [r3, #0]
    5db4:	4826      	ldr	r0, [pc, #152]	; (5e50 <_gpio_set_direction+0xf8>)
    5db6:	0019      	movs	r1, r3
    5db8:	f7ff ffb7 	bl	5d2a <hri_port_write_WRCONFIG_reg>
		break;
    5dbc:	e043      	b.n	5e46 <_gpio_set_direction+0xee>
		hri_port_clear_DIR_reg(PORT_IOBUS, port, mask);
    5dbe:	683a      	ldr	r2, [r7, #0]
    5dc0:	1dfb      	adds	r3, r7, #7
    5dc2:	7819      	ldrb	r1, [r3, #0]
    5dc4:	23c0      	movs	r3, #192	; 0xc0
    5dc6:	05db      	lsls	r3, r3, #23
    5dc8:	0018      	movs	r0, r3
    5dca:	f7ff fe4e 	bl	5a6a <hri_port_clear_DIR_reg>
		hri_port_write_WRCONFIG_reg(PORT, port, PORT_WRCONFIG_WRPINCFG | PORT_WRCONFIG_INEN | (mask & 0xffff));
    5dce:	683b      	ldr	r3, [r7, #0]
    5dd0:	041b      	lsls	r3, r3, #16
    5dd2:	0c1b      	lsrs	r3, r3, #16
    5dd4:	4a1f      	ldr	r2, [pc, #124]	; (5e54 <_gpio_set_direction+0xfc>)
    5dd6:	431a      	orrs	r2, r3
    5dd8:	1dfb      	adds	r3, r7, #7
    5dda:	781b      	ldrb	r3, [r3, #0]
    5ddc:	481c      	ldr	r0, [pc, #112]	; (5e50 <_gpio_set_direction+0xf8>)
    5dde:	0019      	movs	r1, r3
    5de0:	f7ff ffa3 	bl	5d2a <hri_port_write_WRCONFIG_reg>
		                                | ((mask & 0xffff0000) >> 16));
    5de4:	683b      	ldr	r3, [r7, #0]
    5de6:	0c1b      	lsrs	r3, r3, #16
		hri_port_write_WRCONFIG_reg(PORT,
    5de8:	4a1b      	ldr	r2, [pc, #108]	; (5e58 <_gpio_set_direction+0x100>)
    5dea:	431a      	orrs	r2, r3
    5dec:	1dfb      	adds	r3, r7, #7
    5dee:	781b      	ldrb	r3, [r3, #0]
    5df0:	4817      	ldr	r0, [pc, #92]	; (5e50 <_gpio_set_direction+0xf8>)
    5df2:	0019      	movs	r1, r3
    5df4:	f7ff ff99 	bl	5d2a <hri_port_write_WRCONFIG_reg>
		break;
    5df8:	e025      	b.n	5e46 <_gpio_set_direction+0xee>
		hri_port_set_DIR_reg(PORT_IOBUS, port, mask);
    5dfa:	683a      	ldr	r2, [r7, #0]
    5dfc:	1dfb      	adds	r3, r7, #7
    5dfe:	7819      	ldrb	r1, [r3, #0]
    5e00:	23c0      	movs	r3, #192	; 0xc0
    5e02:	05db      	lsls	r3, r3, #23
    5e04:	0018      	movs	r0, r3
    5e06:	f7ff fe1a 	bl	5a3e <hri_port_set_DIR_reg>
		hri_port_write_WRCONFIG_reg(PORT, port, PORT_WRCONFIG_WRPINCFG | (mask & 0xffff));
    5e0a:	683b      	ldr	r3, [r7, #0]
    5e0c:	041b      	lsls	r3, r3, #16
    5e0e:	0c1b      	lsrs	r3, r3, #16
    5e10:	2280      	movs	r2, #128	; 0x80
    5e12:	05d2      	lsls	r2, r2, #23
    5e14:	431a      	orrs	r2, r3
    5e16:	1dfb      	adds	r3, r7, #7
    5e18:	781b      	ldrb	r3, [r3, #0]
    5e1a:	480d      	ldr	r0, [pc, #52]	; (5e50 <_gpio_set_direction+0xf8>)
    5e1c:	0019      	movs	r1, r3
    5e1e:	f7ff ff84 	bl	5d2a <hri_port_write_WRCONFIG_reg>
		    PORT, port, PORT_WRCONFIG_HWSEL | PORT_WRCONFIG_WRPINCFG | ((mask & 0xffff0000) >> 16));
    5e22:	683b      	ldr	r3, [r7, #0]
    5e24:	0c1b      	lsrs	r3, r3, #16
		hri_port_write_WRCONFIG_reg(
    5e26:	22c0      	movs	r2, #192	; 0xc0
    5e28:	0612      	lsls	r2, r2, #24
    5e2a:	431a      	orrs	r2, r3
    5e2c:	1dfb      	adds	r3, r7, #7
    5e2e:	781b      	ldrb	r3, [r3, #0]
    5e30:	4807      	ldr	r0, [pc, #28]	; (5e50 <_gpio_set_direction+0xf8>)
    5e32:	0019      	movs	r1, r3
    5e34:	f7ff ff79 	bl	5d2a <hri_port_write_WRCONFIG_reg>
		break;
    5e38:	e005      	b.n	5e46 <_gpio_set_direction+0xee>
		ASSERT(false);
    5e3a:	4b08      	ldr	r3, [pc, #32]	; (5e5c <_gpio_set_direction+0x104>)
    5e3c:	2245      	movs	r2, #69	; 0x45
    5e3e:	0019      	movs	r1, r3
    5e40:	2000      	movs	r0, #0
    5e42:	f7fe f9a1 	bl	4188 <assert>
}
    5e46:	46c0      	nop			; (mov r8, r8)
    5e48:	46bd      	mov	sp, r7
    5e4a:	b002      	add	sp, #8
    5e4c:	bd80      	pop	{r7, pc}
    5e4e:	46c0      	nop			; (mov r8, r8)
    5e50:	41004400 	.word	0x41004400
    5e54:	40020000 	.word	0x40020000
    5e58:	c0020000 	.word	0xc0020000
    5e5c:	00007e78 	.word	0x00007e78

00005e60 <_gpio_set_level>:
{
    5e60:	b580      	push	{r7, lr}
    5e62:	b082      	sub	sp, #8
    5e64:	af00      	add	r7, sp, #0
    5e66:	6039      	str	r1, [r7, #0]
    5e68:	0011      	movs	r1, r2
    5e6a:	1dfb      	adds	r3, r7, #7
    5e6c:	1c02      	adds	r2, r0, #0
    5e6e:	701a      	strb	r2, [r3, #0]
    5e70:	1dbb      	adds	r3, r7, #6
    5e72:	1c0a      	adds	r2, r1, #0
    5e74:	701a      	strb	r2, [r3, #0]
	if (level) {
    5e76:	1dbb      	adds	r3, r7, #6
    5e78:	781b      	ldrb	r3, [r3, #0]
    5e7a:	2b00      	cmp	r3, #0
    5e7c:	d008      	beq.n	5e90 <_gpio_set_level+0x30>
		hri_port_set_OUT_reg(PORT_IOBUS, port, mask);
    5e7e:	683a      	ldr	r2, [r7, #0]
    5e80:	1dfb      	adds	r3, r7, #7
    5e82:	7819      	ldrb	r1, [r3, #0]
    5e84:	23c0      	movs	r3, #192	; 0xc0
    5e86:	05db      	lsls	r3, r3, #23
    5e88:	0018      	movs	r0, r3
    5e8a:	f7ff fe04 	bl	5a96 <hri_port_set_OUT_reg>
}
    5e8e:	e007      	b.n	5ea0 <_gpio_set_level+0x40>
		hri_port_clear_OUT_reg(PORT_IOBUS, port, mask);
    5e90:	683a      	ldr	r2, [r7, #0]
    5e92:	1dfb      	adds	r3, r7, #7
    5e94:	7819      	ldrb	r1, [r3, #0]
    5e96:	23c0      	movs	r3, #192	; 0xc0
    5e98:	05db      	lsls	r3, r3, #23
    5e9a:	0018      	movs	r0, r3
    5e9c:	f7ff fe11 	bl	5ac2 <hri_port_clear_OUT_reg>
}
    5ea0:	46c0      	nop			; (mov r8, r8)
    5ea2:	46bd      	mov	sp, r7
    5ea4:	b002      	add	sp, #8
    5ea6:	bd80      	pop	{r7, pc}

00005ea8 <_gpio_set_pin_pull_mode>:
{
    5ea8:	b590      	push	{r4, r7, lr}
    5eaa:	b083      	sub	sp, #12
    5eac:	af00      	add	r7, sp, #0
    5eae:	0004      	movs	r4, r0
    5eb0:	0008      	movs	r0, r1
    5eb2:	0011      	movs	r1, r2
    5eb4:	1dfb      	adds	r3, r7, #7
    5eb6:	1c22      	adds	r2, r4, #0
    5eb8:	701a      	strb	r2, [r3, #0]
    5eba:	1dbb      	adds	r3, r7, #6
    5ebc:	1c02      	adds	r2, r0, #0
    5ebe:	701a      	strb	r2, [r3, #0]
    5ec0:	1d7b      	adds	r3, r7, #5
    5ec2:	1c0a      	adds	r2, r1, #0
    5ec4:	701a      	strb	r2, [r3, #0]
	switch (pull_mode) {
    5ec6:	1d7b      	adds	r3, r7, #5
    5ec8:	781b      	ldrb	r3, [r3, #0]
    5eca:	2b01      	cmp	r3, #1
    5ecc:	d00c      	beq.n	5ee8 <_gpio_set_pin_pull_mode+0x40>
    5ece:	2b02      	cmp	r3, #2
    5ed0:	d029      	beq.n	5f26 <_gpio_set_pin_pull_mode+0x7e>
    5ed2:	2b00      	cmp	r3, #0
    5ed4:	d146      	bne.n	5f64 <_gpio_set_pin_pull_mode+0xbc>
		hri_port_clear_PINCFG_PULLEN_bit(PORT, port, pin);
    5ed6:	1dbb      	adds	r3, r7, #6
    5ed8:	781a      	ldrb	r2, [r3, #0]
    5eda:	1dfb      	adds	r3, r7, #7
    5edc:	781b      	ldrb	r3, [r3, #0]
    5ede:	4827      	ldr	r0, [pc, #156]	; (5f7c <_gpio_set_pin_pull_mode+0xd4>)
    5ee0:	0019      	movs	r1, r3
    5ee2:	f7ff fef7 	bl	5cd4 <hri_port_clear_PINCFG_PULLEN_bit>
		break;
    5ee6:	e044      	b.n	5f72 <_gpio_set_pin_pull_mode+0xca>
		hri_port_clear_DIR_reg(PORT_IOBUS, port, 1U << pin);
    5ee8:	1dbb      	adds	r3, r7, #6
    5eea:	781b      	ldrb	r3, [r3, #0]
    5eec:	2201      	movs	r2, #1
    5eee:	409a      	lsls	r2, r3
    5ef0:	1dfb      	adds	r3, r7, #7
    5ef2:	7819      	ldrb	r1, [r3, #0]
    5ef4:	23c0      	movs	r3, #192	; 0xc0
    5ef6:	05db      	lsls	r3, r3, #23
    5ef8:	0018      	movs	r0, r3
    5efa:	f7ff fdb6 	bl	5a6a <hri_port_clear_DIR_reg>
		hri_port_set_PINCFG_PULLEN_bit(PORT, port, pin);
    5efe:	1dbb      	adds	r3, r7, #6
    5f00:	781a      	ldrb	r2, [r3, #0]
    5f02:	1dfb      	adds	r3, r7, #7
    5f04:	781b      	ldrb	r3, [r3, #0]
    5f06:	481d      	ldr	r0, [pc, #116]	; (5f7c <_gpio_set_pin_pull_mode+0xd4>)
    5f08:	0019      	movs	r1, r3
    5f0a:	f7ff feb8 	bl	5c7e <hri_port_set_PINCFG_PULLEN_bit>
		hri_port_set_OUT_reg(PORT_IOBUS, port, 1U << pin);
    5f0e:	1dbb      	adds	r3, r7, #6
    5f10:	781b      	ldrb	r3, [r3, #0]
    5f12:	2201      	movs	r2, #1
    5f14:	409a      	lsls	r2, r3
    5f16:	1dfb      	adds	r3, r7, #7
    5f18:	7819      	ldrb	r1, [r3, #0]
    5f1a:	23c0      	movs	r3, #192	; 0xc0
    5f1c:	05db      	lsls	r3, r3, #23
    5f1e:	0018      	movs	r0, r3
    5f20:	f7ff fdb9 	bl	5a96 <hri_port_set_OUT_reg>
		break;
    5f24:	e025      	b.n	5f72 <_gpio_set_pin_pull_mode+0xca>
		hri_port_clear_DIR_reg(PORT_IOBUS, port, 1U << pin);
    5f26:	1dbb      	adds	r3, r7, #6
    5f28:	781b      	ldrb	r3, [r3, #0]
    5f2a:	2201      	movs	r2, #1
    5f2c:	409a      	lsls	r2, r3
    5f2e:	1dfb      	adds	r3, r7, #7
    5f30:	7819      	ldrb	r1, [r3, #0]
    5f32:	23c0      	movs	r3, #192	; 0xc0
    5f34:	05db      	lsls	r3, r3, #23
    5f36:	0018      	movs	r0, r3
    5f38:	f7ff fd97 	bl	5a6a <hri_port_clear_DIR_reg>
		hri_port_set_PINCFG_PULLEN_bit(PORT, port, pin);
    5f3c:	1dbb      	adds	r3, r7, #6
    5f3e:	781a      	ldrb	r2, [r3, #0]
    5f40:	1dfb      	adds	r3, r7, #7
    5f42:	781b      	ldrb	r3, [r3, #0]
    5f44:	480d      	ldr	r0, [pc, #52]	; (5f7c <_gpio_set_pin_pull_mode+0xd4>)
    5f46:	0019      	movs	r1, r3
    5f48:	f7ff fe99 	bl	5c7e <hri_port_set_PINCFG_PULLEN_bit>
		hri_port_clear_OUT_reg(PORT_IOBUS, port, 1U << pin);
    5f4c:	1dbb      	adds	r3, r7, #6
    5f4e:	781b      	ldrb	r3, [r3, #0]
    5f50:	2201      	movs	r2, #1
    5f52:	409a      	lsls	r2, r3
    5f54:	1dfb      	adds	r3, r7, #7
    5f56:	7819      	ldrb	r1, [r3, #0]
    5f58:	23c0      	movs	r3, #192	; 0xc0
    5f5a:	05db      	lsls	r3, r3, #23
    5f5c:	0018      	movs	r0, r3
    5f5e:	f7ff fdb0 	bl	5ac2 <hri_port_clear_OUT_reg>
		break;
    5f62:	e006      	b.n	5f72 <_gpio_set_pin_pull_mode+0xca>
		ASSERT(false);
    5f64:	4b06      	ldr	r3, [pc, #24]	; (5f80 <_gpio_set_pin_pull_mode+0xd8>)
    5f66:	2288      	movs	r2, #136	; 0x88
    5f68:	0019      	movs	r1, r3
    5f6a:	2000      	movs	r0, #0
    5f6c:	f7fe f90c 	bl	4188 <assert>
		break;
    5f70:	46c0      	nop			; (mov r8, r8)
}
    5f72:	46c0      	nop			; (mov r8, r8)
    5f74:	46bd      	mov	sp, r7
    5f76:	b003      	add	sp, #12
    5f78:	bd90      	pop	{r4, r7, pc}
    5f7a:	46c0      	nop			; (mov r8, r8)
    5f7c:	41004400 	.word	0x41004400
    5f80:	00007e78 	.word	0x00007e78

00005f84 <_gpio_set_pin_function>:
{
    5f84:	b590      	push	{r4, r7, lr}
    5f86:	b085      	sub	sp, #20
    5f88:	af00      	add	r7, sp, #0
    5f8a:	6078      	str	r0, [r7, #4]
    5f8c:	6039      	str	r1, [r7, #0]
	uint8_t port = GPIO_PORT(gpio);
    5f8e:	687b      	ldr	r3, [r7, #4]
    5f90:	095a      	lsrs	r2, r3, #5
    5f92:	230f      	movs	r3, #15
    5f94:	18fb      	adds	r3, r7, r3
    5f96:	701a      	strb	r2, [r3, #0]
	uint8_t pin  = GPIO_PIN(gpio);
    5f98:	687b      	ldr	r3, [r7, #4]
    5f9a:	b2da      	uxtb	r2, r3
    5f9c:	230e      	movs	r3, #14
    5f9e:	18fb      	adds	r3, r7, r3
    5fa0:	211f      	movs	r1, #31
    5fa2:	400a      	ands	r2, r1
    5fa4:	701a      	strb	r2, [r3, #0]
	if (function == GPIO_PIN_FUNCTION_OFF) {
    5fa6:	683b      	ldr	r3, [r7, #0]
    5fa8:	3301      	adds	r3, #1
    5faa:	d10a      	bne.n	5fc2 <_gpio_set_pin_function+0x3e>
		hri_port_write_PINCFG_PMUXEN_bit(PORT, port, pin, false);
    5fac:	230e      	movs	r3, #14
    5fae:	18fb      	adds	r3, r7, r3
    5fb0:	781a      	ldrb	r2, [r3, #0]
    5fb2:	230f      	movs	r3, #15
    5fb4:	18fb      	adds	r3, r7, r3
    5fb6:	7819      	ldrb	r1, [r3, #0]
    5fb8:	481b      	ldr	r0, [pc, #108]	; (6028 <_gpio_set_pin_function+0xa4>)
    5fba:	2300      	movs	r3, #0
    5fbc:	f7ff fe1e 	bl	5bfc <hri_port_write_PINCFG_PMUXEN_bit>
}
    5fc0:	e02e      	b.n	6020 <_gpio_set_pin_function+0x9c>
		hri_port_write_PINCFG_PMUXEN_bit(PORT, port, pin, true);
    5fc2:	230e      	movs	r3, #14
    5fc4:	18fb      	adds	r3, r7, r3
    5fc6:	781a      	ldrb	r2, [r3, #0]
    5fc8:	230f      	movs	r3, #15
    5fca:	18fb      	adds	r3, r7, r3
    5fcc:	7819      	ldrb	r1, [r3, #0]
    5fce:	4816      	ldr	r0, [pc, #88]	; (6028 <_gpio_set_pin_function+0xa4>)
    5fd0:	2301      	movs	r3, #1
    5fd2:	f7ff fe13 	bl	5bfc <hri_port_write_PINCFG_PMUXEN_bit>
		if (pin & 1) {
    5fd6:	230e      	movs	r3, #14
    5fd8:	18fb      	adds	r3, r7, r3
    5fda:	781b      	ldrb	r3, [r3, #0]
    5fdc:	2201      	movs	r2, #1
    5fde:	4013      	ands	r3, r2
    5fe0:	d00f      	beq.n	6002 <_gpio_set_pin_function+0x7e>
			hri_port_write_PMUX_PMUXO_bf(PORT, port, pin >> 1, function & 0xffff);
    5fe2:	230e      	movs	r3, #14
    5fe4:	18fb      	adds	r3, r7, r3
    5fe6:	781b      	ldrb	r3, [r3, #0]
    5fe8:	085b      	lsrs	r3, r3, #1
    5fea:	b2da      	uxtb	r2, r3
    5fec:	683b      	ldr	r3, [r7, #0]
    5fee:	b2d8      	uxtb	r0, r3
    5ff0:	230f      	movs	r3, #15
    5ff2:	18fb      	adds	r3, r7, r3
    5ff4:	7819      	ldrb	r1, [r3, #0]
    5ff6:	4c0c      	ldr	r4, [pc, #48]	; (6028 <_gpio_set_pin_function+0xa4>)
    5ff8:	0003      	movs	r3, r0
    5ffa:	0020      	movs	r0, r4
    5ffc:	f7ff fdbb 	bl	5b76 <hri_port_write_PMUX_PMUXO_bf>
}
    6000:	e00e      	b.n	6020 <_gpio_set_pin_function+0x9c>
			hri_port_write_PMUX_PMUXE_bf(PORT, port, pin >> 1, function & 0xffff);
    6002:	230e      	movs	r3, #14
    6004:	18fb      	adds	r3, r7, r3
    6006:	781b      	ldrb	r3, [r3, #0]
    6008:	085b      	lsrs	r3, r3, #1
    600a:	b2da      	uxtb	r2, r3
    600c:	683b      	ldr	r3, [r7, #0]
    600e:	b2d8      	uxtb	r0, r3
    6010:	230f      	movs	r3, #15
    6012:	18fb      	adds	r3, r7, r3
    6014:	7819      	ldrb	r1, [r3, #0]
    6016:	4c04      	ldr	r4, [pc, #16]	; (6028 <_gpio_set_pin_function+0xa4>)
    6018:	0003      	movs	r3, r0
    601a:	0020      	movs	r0, r4
    601c:	f7ff fd67 	bl	5aee <hri_port_write_PMUX_PMUXE_bf>
}
    6020:	46c0      	nop			; (mov r8, r8)
    6022:	46bd      	mov	sp, r7
    6024:	b005      	add	sp, #20
    6026:	bd90      	pop	{r4, r7, pc}
    6028:	41004400 	.word	0x41004400

0000602c <gpio_set_pin_pull_mode>:
{
    602c:	b580      	push	{r7, lr}
    602e:	b082      	sub	sp, #8
    6030:	af00      	add	r7, sp, #0
    6032:	0002      	movs	r2, r0
    6034:	1dfb      	adds	r3, r7, #7
    6036:	701a      	strb	r2, [r3, #0]
    6038:	1dbb      	adds	r3, r7, #6
    603a:	1c0a      	adds	r2, r1, #0
    603c:	701a      	strb	r2, [r3, #0]
	_gpio_set_pin_pull_mode((enum gpio_port)GPIO_PORT(pin), pin & 0x1F, pull_mode);
    603e:	1dfb      	adds	r3, r7, #7
    6040:	781b      	ldrb	r3, [r3, #0]
    6042:	095b      	lsrs	r3, r3, #5
    6044:	b2d8      	uxtb	r0, r3
    6046:	1dfb      	adds	r3, r7, #7
    6048:	781b      	ldrb	r3, [r3, #0]
    604a:	221f      	movs	r2, #31
    604c:	4013      	ands	r3, r2
    604e:	b2d9      	uxtb	r1, r3
    6050:	1dbb      	adds	r3, r7, #6
    6052:	781b      	ldrb	r3, [r3, #0]
    6054:	001a      	movs	r2, r3
    6056:	f7ff ff27 	bl	5ea8 <_gpio_set_pin_pull_mode>
}
    605a:	46c0      	nop			; (mov r8, r8)
    605c:	46bd      	mov	sp, r7
    605e:	b002      	add	sp, #8
    6060:	bd80      	pop	{r7, pc}

00006062 <gpio_set_pin_function>:
{
    6062:	b580      	push	{r7, lr}
    6064:	b082      	sub	sp, #8
    6066:	af00      	add	r7, sp, #0
    6068:	6078      	str	r0, [r7, #4]
    606a:	6039      	str	r1, [r7, #0]
	_gpio_set_pin_function(pin, function);
    606c:	683a      	ldr	r2, [r7, #0]
    606e:	687b      	ldr	r3, [r7, #4]
    6070:	0011      	movs	r1, r2
    6072:	0018      	movs	r0, r3
    6074:	f7ff ff86 	bl	5f84 <_gpio_set_pin_function>
}
    6078:	46c0      	nop			; (mov r8, r8)
    607a:	46bd      	mov	sp, r7
    607c:	b002      	add	sp, #8
    607e:	bd80      	pop	{r7, pc}

00006080 <gpio_set_pin_direction>:
{
    6080:	b580      	push	{r7, lr}
    6082:	b082      	sub	sp, #8
    6084:	af00      	add	r7, sp, #0
    6086:	0002      	movs	r2, r0
    6088:	1dfb      	adds	r3, r7, #7
    608a:	701a      	strb	r2, [r3, #0]
    608c:	1dbb      	adds	r3, r7, #6
    608e:	1c0a      	adds	r2, r1, #0
    6090:	701a      	strb	r2, [r3, #0]
	_gpio_set_direction((enum gpio_port)GPIO_PORT(pin), 1U << GPIO_PIN(pin), direction);
    6092:	1dfb      	adds	r3, r7, #7
    6094:	781b      	ldrb	r3, [r3, #0]
    6096:	095b      	lsrs	r3, r3, #5
    6098:	b2d8      	uxtb	r0, r3
    609a:	1dfb      	adds	r3, r7, #7
    609c:	781b      	ldrb	r3, [r3, #0]
    609e:	221f      	movs	r2, #31
    60a0:	4013      	ands	r3, r2
    60a2:	2201      	movs	r2, #1
    60a4:	409a      	lsls	r2, r3
    60a6:	0011      	movs	r1, r2
    60a8:	1dbb      	adds	r3, r7, #6
    60aa:	781b      	ldrb	r3, [r3, #0]
    60ac:	001a      	movs	r2, r3
    60ae:	f7ff fe53 	bl	5d58 <_gpio_set_direction>
}
    60b2:	46c0      	nop			; (mov r8, r8)
    60b4:	46bd      	mov	sp, r7
    60b6:	b002      	add	sp, #8
    60b8:	bd80      	pop	{r7, pc}

000060ba <gpio_set_pin_level>:
{
    60ba:	b580      	push	{r7, lr}
    60bc:	b082      	sub	sp, #8
    60be:	af00      	add	r7, sp, #0
    60c0:	0002      	movs	r2, r0
    60c2:	1dfb      	adds	r3, r7, #7
    60c4:	701a      	strb	r2, [r3, #0]
    60c6:	1dbb      	adds	r3, r7, #6
    60c8:	1c0a      	adds	r2, r1, #0
    60ca:	701a      	strb	r2, [r3, #0]
	_gpio_set_level((enum gpio_port)GPIO_PORT(pin), 1U << GPIO_PIN(pin), level);
    60cc:	1dfb      	adds	r3, r7, #7
    60ce:	781b      	ldrb	r3, [r3, #0]
    60d0:	095b      	lsrs	r3, r3, #5
    60d2:	b2d8      	uxtb	r0, r3
    60d4:	1dfb      	adds	r3, r7, #7
    60d6:	781b      	ldrb	r3, [r3, #0]
    60d8:	221f      	movs	r2, #31
    60da:	4013      	ands	r3, r2
    60dc:	2201      	movs	r2, #1
    60de:	409a      	lsls	r2, r3
    60e0:	0011      	movs	r1, r2
    60e2:	1dbb      	adds	r3, r7, #6
    60e4:	781b      	ldrb	r3, [r3, #0]
    60e6:	001a      	movs	r2, r3
    60e8:	f7ff feba 	bl	5e60 <_gpio_set_level>
}
    60ec:	46c0      	nop			; (mov r8, r8)
    60ee:	46bd      	mov	sp, r7
    60f0:	b002      	add	sp, #8
    60f2:	bd80      	pop	{r7, pc}

000060f4 <_gclk_enable_channel>:
{
    60f4:	b580      	push	{r7, lr}
    60f6:	b082      	sub	sp, #8
    60f8:	af00      	add	r7, sp, #0
    60fa:	0002      	movs	r2, r0
    60fc:	1dfb      	adds	r3, r7, #7
    60fe:	701a      	strb	r2, [r3, #0]
    6100:	1dbb      	adds	r3, r7, #6
    6102:	1c0a      	adds	r2, r1, #0
    6104:	701a      	strb	r2, [r3, #0]
	                           GCLK_CLKCTRL_ID(channel) | GCLK_CLKCTRL_GEN(source) | (1 << GCLK_CLKCTRL_CLKEN_Pos));
    6106:	1dfb      	adds	r3, r7, #7
    6108:	781b      	ldrb	r3, [r3, #0]
    610a:	b29b      	uxth	r3, r3
    610c:	223f      	movs	r2, #63	; 0x3f
    610e:	4013      	ands	r3, r2
    6110:	b29a      	uxth	r2, r3
    6112:	1dbb      	adds	r3, r7, #6
    6114:	781b      	ldrb	r3, [r3, #0]
    6116:	b29b      	uxth	r3, r3
    6118:	021b      	lsls	r3, r3, #8
    611a:	b299      	uxth	r1, r3
    611c:	23f0      	movs	r3, #240	; 0xf0
    611e:	011b      	lsls	r3, r3, #4
    6120:	400b      	ands	r3, r1
    6122:	b29b      	uxth	r3, r3
    6124:	4313      	orrs	r3, r2
    6126:	b29b      	uxth	r3, r3
	hri_gclk_write_CLKCTRL_reg(GCLK,
    6128:	2280      	movs	r2, #128	; 0x80
    612a:	01d2      	lsls	r2, r2, #7
    612c:	4313      	orrs	r3, r2
    612e:	b29b      	uxth	r3, r3
    6130:	4a04      	ldr	r2, [pc, #16]	; (6144 <_gclk_enable_channel+0x50>)
    6132:	0019      	movs	r1, r3
    6134:	0010      	movs	r0, r2
    6136:	f7ff fc73 	bl	5a20 <hri_gclk_write_CLKCTRL_reg>
}
    613a:	46c0      	nop			; (mov r8, r8)
    613c:	46bd      	mov	sp, r7
    613e:	b002      	add	sp, #8
    6140:	bd80      	pop	{r7, pc}
    6142:	46c0      	nop			; (mov r8, r8)
    6144:	40000c00 	.word	0x40000c00

00006148 <_pm_get_ahb_index>:
{
    6148:	b580      	push	{r7, lr}
    614a:	b082      	sub	sp, #8
    614c:	af00      	add	r7, sp, #0
    614e:	6078      	str	r0, [r7, #4]
	if ((uint32_t)module == (uint32_t)PM_BUS_APBA) {
    6150:	687b      	ldr	r3, [r7, #4]
    6152:	2b01      	cmp	r3, #1
    6154:	d101      	bne.n	615a <_pm_get_ahb_index+0x12>
		return 0;
    6156:	2300      	movs	r3, #0
    6158:	e017      	b.n	618a <_pm_get_ahb_index+0x42>
	} else if ((uint32_t)module == (uint32_t)PM_BUS_APBB) {
    615a:	687b      	ldr	r3, [r7, #4]
    615c:	2b02      	cmp	r3, #2
    615e:	d101      	bne.n	6164 <_pm_get_ahb_index+0x1c>
		return 1;
    6160:	2301      	movs	r3, #1
    6162:	e012      	b.n	618a <_pm_get_ahb_index+0x42>
	} else if ((uint32_t)module == (uint32_t)PM_BUS_APBC) {
    6164:	687b      	ldr	r3, [r7, #4]
    6166:	2b03      	cmp	r3, #3
    6168:	d101      	bne.n	616e <_pm_get_ahb_index+0x26>
		return 2;
    616a:	2302      	movs	r3, #2
    616c:	e00d      	b.n	618a <_pm_get_ahb_index+0x42>
	if ((uint32_t)module == (uint32_t)DSU) {
    616e:	687b      	ldr	r3, [r7, #4]
    6170:	4a08      	ldr	r2, [pc, #32]	; (6194 <_pm_get_ahb_index+0x4c>)
    6172:	4293      	cmp	r3, r2
    6174:	d101      	bne.n	617a <_pm_get_ahb_index+0x32>
		return 3;
    6176:	2303      	movs	r3, #3
    6178:	e007      	b.n	618a <_pm_get_ahb_index+0x42>
	} else if ((uint32_t)module == (uint32_t)NVMCTRL) {
    617a:	687b      	ldr	r3, [r7, #4]
    617c:	4a06      	ldr	r2, [pc, #24]	; (6198 <_pm_get_ahb_index+0x50>)
    617e:	4293      	cmp	r3, r2
    6180:	d101      	bne.n	6186 <_pm_get_ahb_index+0x3e>
		return 4;
    6182:	2304      	movs	r3, #4
    6184:	e001      	b.n	618a <_pm_get_ahb_index+0x42>
	return ERR_INVALID_ARG;
    6186:	230d      	movs	r3, #13
    6188:	425b      	negs	r3, r3
}
    618a:	0018      	movs	r0, r3
    618c:	46bd      	mov	sp, r7
    618e:	b002      	add	sp, #8
    6190:	bd80      	pop	{r7, pc}
    6192:	46c0      	nop			; (mov r8, r8)
    6194:	41002000 	.word	0x41002000
    6198:	41004000 	.word	0x41004000

0000619c <_pm_get_apbb_index>:
{
    619c:	b580      	push	{r7, lr}
    619e:	b082      	sub	sp, #8
    61a0:	af00      	add	r7, sp, #0
    61a2:	6078      	str	r0, [r7, #4]
	if ((uint32_t)module == (uint32_t)PAC1) {
    61a4:	687a      	ldr	r2, [r7, #4]
    61a6:	2382      	movs	r3, #130	; 0x82
    61a8:	05db      	lsls	r3, r3, #23
    61aa:	429a      	cmp	r2, r3
    61ac:	d101      	bne.n	61b2 <_pm_get_apbb_index+0x16>
		return 0;
    61ae:	2300      	movs	r3, #0
    61b0:	e013      	b.n	61da <_pm_get_apbb_index+0x3e>
	} else if ((uint32_t)module == (uint32_t)DSU) {
    61b2:	687b      	ldr	r3, [r7, #4]
    61b4:	4a0b      	ldr	r2, [pc, #44]	; (61e4 <_pm_get_apbb_index+0x48>)
    61b6:	4293      	cmp	r3, r2
    61b8:	d101      	bne.n	61be <_pm_get_apbb_index+0x22>
		return 1;
    61ba:	2301      	movs	r3, #1
    61bc:	e00d      	b.n	61da <_pm_get_apbb_index+0x3e>
	} else if ((uint32_t)module == (uint32_t)NVMCTRL) {
    61be:	687b      	ldr	r3, [r7, #4]
    61c0:	4a09      	ldr	r2, [pc, #36]	; (61e8 <_pm_get_apbb_index+0x4c>)
    61c2:	4293      	cmp	r3, r2
    61c4:	d101      	bne.n	61ca <_pm_get_apbb_index+0x2e>
		return 2;
    61c6:	2302      	movs	r3, #2
    61c8:	e007      	b.n	61da <_pm_get_apbb_index+0x3e>
	if ((uint32_t)module == (uint32_t)PORT) {
    61ca:	687b      	ldr	r3, [r7, #4]
    61cc:	4a07      	ldr	r2, [pc, #28]	; (61ec <_pm_get_apbb_index+0x50>)
    61ce:	4293      	cmp	r3, r2
    61d0:	d101      	bne.n	61d6 <_pm_get_apbb_index+0x3a>
		return 3;
    61d2:	2303      	movs	r3, #3
    61d4:	e001      	b.n	61da <_pm_get_apbb_index+0x3e>
	return ERR_INVALID_ARG;
    61d6:	230d      	movs	r3, #13
    61d8:	425b      	negs	r3, r3
}
    61da:	0018      	movs	r0, r3
    61dc:	46bd      	mov	sp, r7
    61de:	b002      	add	sp, #8
    61e0:	bd80      	pop	{r7, pc}
    61e2:	46c0      	nop			; (mov r8, r8)
    61e4:	41002000 	.word	0x41002000
    61e8:	41004000 	.word	0x41004000
    61ec:	41004400 	.word	0x41004400

000061f0 <_pm_enable_bus_clock>:
{
    61f0:	b580      	push	{r7, lr}
    61f2:	b084      	sub	sp, #16
    61f4:	af00      	add	r7, sp, #0
    61f6:	0002      	movs	r2, r0
    61f8:	6039      	str	r1, [r7, #0]
    61fa:	1dfb      	adds	r3, r7, #7
    61fc:	701a      	strb	r2, [r3, #0]
	uint32_t peripheral = ((uint32_t)module & 0x0000ff00) >> 10;
    61fe:	683b      	ldr	r3, [r7, #0]
    6200:	0a9b      	lsrs	r3, r3, #10
    6202:	223f      	movs	r2, #63	; 0x3f
    6204:	4013      	ands	r3, r2
    6206:	60fb      	str	r3, [r7, #12]
	switch (bus) {
    6208:	1dfb      	adds	r3, r7, #7
    620a:	781b      	ldrb	r3, [r3, #0]
    620c:	2b01      	cmp	r3, #1
    620e:	d01e      	beq.n	624e <_pm_enable_bus_clock+0x5e>
    6210:	dc02      	bgt.n	6218 <_pm_enable_bus_clock+0x28>
    6212:	2b00      	cmp	r3, #0
    6214:	d005      	beq.n	6222 <_pm_enable_bus_clock+0x32>
    6216:	e044      	b.n	62a2 <_pm_enable_bus_clock+0xb2>
    6218:	2b02      	cmp	r3, #2
    621a:	d022      	beq.n	6262 <_pm_enable_bus_clock+0x72>
    621c:	2b03      	cmp	r3, #3
    621e:	d036      	beq.n	628e <_pm_enable_bus_clock+0x9e>
    6220:	e03f      	b.n	62a2 <_pm_enable_bus_clock+0xb2>
		if (_pm_get_ahb_index(module) >= 0) {
    6222:	683b      	ldr	r3, [r7, #0]
    6224:	0018      	movs	r0, r3
    6226:	f7ff ff8f 	bl	6148 <_pm_get_ahb_index>
    622a:	1e03      	subs	r3, r0, #0
    622c:	db40      	blt.n	62b0 <_pm_enable_bus_clock+0xc0>
			peripheral = (uint32_t)_pm_get_ahb_index(module);
    622e:	683b      	ldr	r3, [r7, #0]
    6230:	0018      	movs	r0, r3
    6232:	f7ff ff89 	bl	6148 <_pm_get_ahb_index>
    6236:	0003      	movs	r3, r0
    6238:	60fb      	str	r3, [r7, #12]
			PM->AHBMASK.reg |= 1 << peripheral;
    623a:	4b21      	ldr	r3, [pc, #132]	; (62c0 <_pm_enable_bus_clock+0xd0>)
    623c:	4a20      	ldr	r2, [pc, #128]	; (62c0 <_pm_enable_bus_clock+0xd0>)
    623e:	6952      	ldr	r2, [r2, #20]
    6240:	2001      	movs	r0, #1
    6242:	68f9      	ldr	r1, [r7, #12]
    6244:	4088      	lsls	r0, r1
    6246:	0001      	movs	r1, r0
    6248:	430a      	orrs	r2, r1
    624a:	615a      	str	r2, [r3, #20]
		break;
    624c:	e030      	b.n	62b0 <_pm_enable_bus_clock+0xc0>
		PM->APBAMASK.reg |= 1 << peripheral;
    624e:	4b1c      	ldr	r3, [pc, #112]	; (62c0 <_pm_enable_bus_clock+0xd0>)
    6250:	4a1b      	ldr	r2, [pc, #108]	; (62c0 <_pm_enable_bus_clock+0xd0>)
    6252:	6992      	ldr	r2, [r2, #24]
    6254:	2001      	movs	r0, #1
    6256:	68f9      	ldr	r1, [r7, #12]
    6258:	4088      	lsls	r0, r1
    625a:	0001      	movs	r1, r0
    625c:	430a      	orrs	r2, r1
    625e:	619a      	str	r2, [r3, #24]
		break;
    6260:	e029      	b.n	62b6 <_pm_enable_bus_clock+0xc6>
		if (_pm_get_apbb_index(module) >= 0) {
    6262:	683b      	ldr	r3, [r7, #0]
    6264:	0018      	movs	r0, r3
    6266:	f7ff ff99 	bl	619c <_pm_get_apbb_index>
    626a:	1e03      	subs	r3, r0, #0
    626c:	db22      	blt.n	62b4 <_pm_enable_bus_clock+0xc4>
			peripheral = (uint32_t)_pm_get_apbb_index(module);
    626e:	683b      	ldr	r3, [r7, #0]
    6270:	0018      	movs	r0, r3
    6272:	f7ff ff93 	bl	619c <_pm_get_apbb_index>
    6276:	0003      	movs	r3, r0
    6278:	60fb      	str	r3, [r7, #12]
			PM->APBBMASK.reg |= 1 << peripheral;
    627a:	4b11      	ldr	r3, [pc, #68]	; (62c0 <_pm_enable_bus_clock+0xd0>)
    627c:	4a10      	ldr	r2, [pc, #64]	; (62c0 <_pm_enable_bus_clock+0xd0>)
    627e:	69d2      	ldr	r2, [r2, #28]
    6280:	2001      	movs	r0, #1
    6282:	68f9      	ldr	r1, [r7, #12]
    6284:	4088      	lsls	r0, r1
    6286:	0001      	movs	r1, r0
    6288:	430a      	orrs	r2, r1
    628a:	61da      	str	r2, [r3, #28]
		break;
    628c:	e012      	b.n	62b4 <_pm_enable_bus_clock+0xc4>
		PM->APBCMASK.reg |= 1 << peripheral;
    628e:	4b0c      	ldr	r3, [pc, #48]	; (62c0 <_pm_enable_bus_clock+0xd0>)
    6290:	4a0b      	ldr	r2, [pc, #44]	; (62c0 <_pm_enable_bus_clock+0xd0>)
    6292:	6a12      	ldr	r2, [r2, #32]
    6294:	2001      	movs	r0, #1
    6296:	68f9      	ldr	r1, [r7, #12]
    6298:	4088      	lsls	r0, r1
    629a:	0001      	movs	r1, r0
    629c:	430a      	orrs	r2, r1
    629e:	621a      	str	r2, [r3, #32]
		break;
    62a0:	e009      	b.n	62b6 <_pm_enable_bus_clock+0xc6>
		ASSERT(false);
    62a2:	4b08      	ldr	r3, [pc, #32]	; (62c4 <_pm_enable_bus_clock+0xd4>)
    62a4:	228d      	movs	r2, #141	; 0x8d
    62a6:	0019      	movs	r1, r3
    62a8:	2000      	movs	r0, #0
    62aa:	f7fd ff6d 	bl	4188 <assert>
		break;
    62ae:	e002      	b.n	62b6 <_pm_enable_bus_clock+0xc6>
		break;
    62b0:	46c0      	nop			; (mov r8, r8)
    62b2:	e000      	b.n	62b6 <_pm_enable_bus_clock+0xc6>
		break;
    62b4:	46c0      	nop			; (mov r8, r8)
}
    62b6:	46c0      	nop			; (mov r8, r8)
    62b8:	46bd      	mov	sp, r7
    62ba:	b004      	add	sp, #16
    62bc:	bd80      	pop	{r7, pc}
    62be:	46c0      	nop			; (mov r8, r8)
    62c0:	40000400 	.word	0x40000400
    62c4:	00007e94 	.word	0x00007e94

000062c8 <RF_IRQ_Enable>:



struct io_descriptor *io;

void RF_IRQ_Enable(void){
    62c8:	b580      	push	{r7, lr}
    62ca:	af00      	add	r7, sp, #0
	ext_irq_register(RF_IRQ, RF_int_Handler);
    62cc:	4b05      	ldr	r3, [pc, #20]	; (62e4 <RF_IRQ_Enable+0x1c>)
    62ce:	0019      	movs	r1, r3
    62d0:	203e      	movs	r0, #62	; 0x3e
    62d2:	f7fd fbbf 	bl	3a54 <ext_irq_register>
	//ext_irq_register(RF_IRQ, NULL);
	//gpio_toggle_pin_level(LED_G);
	//spi_m_sync_get_io_descriptor(&VFD_SPI, &iospi);
	spi_m_sync_enable(&RF_SPI);
    62d6:	4b04      	ldr	r3, [pc, #16]	; (62e8 <RF_IRQ_Enable+0x20>)
    62d8:	0018      	movs	r0, r3
    62da:	f7fd fda5 	bl	3e28 <spi_m_sync_enable>
	
	
}
    62de:	46c0      	nop			; (mov r8, r8)
    62e0:	46bd      	mov	sp, r7
    62e2:	bd80      	pop	{r7, pc}
    62e4:	00006301 	.word	0x00006301
    62e8:	200007d0 	.word	0x200007d0

000062ec <rf_isReady>:


uint8_t int_count = 0;
uint8_t rf_isReady(){
    62ec:	b580      	push	{r7, lr}
    62ee:	af00      	add	r7, sp, #0
	return int_count;
    62f0:	4b02      	ldr	r3, [pc, #8]	; (62fc <rf_isReady+0x10>)
    62f2:	781b      	ldrb	r3, [r3, #0]
}
    62f4:	0018      	movs	r0, r3
    62f6:	46bd      	mov	sp, r7
    62f8:	bd80      	pop	{r7, pc}
    62fa:	46c0      	nop			; (mov r8, r8)
    62fc:	200007b8 	.word	0x200007b8

00006300 <RF_int_Handler>:

void RF_int_Handler(void){
    6300:	b580      	push	{r7, lr}
    6302:	af00      	add	r7, sp, #0
	int_count++;
    6304:	4b05      	ldr	r3, [pc, #20]	; (631c <RF_int_Handler+0x1c>)
    6306:	781b      	ldrb	r3, [r3, #0]
    6308:	3301      	adds	r3, #1
    630a:	b2da      	uxtb	r2, r3
    630c:	4b03      	ldr	r3, [pc, #12]	; (631c <RF_int_Handler+0x1c>)
    630e:	701a      	strb	r2, [r3, #0]
	//gpio_toggle_pin_level(LED);
	data_ready();
    6310:	f000 fb84 	bl	6a1c <data_ready>
}
    6314:	46c0      	nop			; (mov r8, r8)
    6316:	46bd      	mov	sp, r7
    6318:	bd80      	pop	{r7, pc}
    631a:	46c0      	nop			; (mov r8, r8)
    631c:	200007b8 	.word	0x200007b8

00006320 <RFM69_ReadBuff>:
	io_write(io, &addr, 1);
	io_read(io,&addr,1);
	return addr;
}

void RFM69_ReadBuff(uint8_t* buff, uint16_t len){
    6320:	b580      	push	{r7, lr}
    6322:	b082      	sub	sp, #8
    6324:	af00      	add	r7, sp, #0
    6326:	6078      	str	r0, [r7, #4]
    6328:	000a      	movs	r2, r1
    632a:	1cbb      	adds	r3, r7, #2
    632c:	801a      	strh	r2, [r3, #0]
	spi_m_sync_get_io_descriptor(&RF_SPI, &io);
    632e:	4a09      	ldr	r2, [pc, #36]	; (6354 <RFM69_ReadBuff+0x34>)
    6330:	4b09      	ldr	r3, [pc, #36]	; (6358 <RFM69_ReadBuff+0x38>)
    6332:	0011      	movs	r1, r2
    6334:	0018      	movs	r0, r3
    6336:	f7fd fe21 	bl	3f7c <spi_m_sync_get_io_descriptor>
	//spi_m_sync_enable(&VFD_SPI);
	io_read(io,buff,len);
    633a:	4b06      	ldr	r3, [pc, #24]	; (6354 <RFM69_ReadBuff+0x34>)
    633c:	6818      	ldr	r0, [r3, #0]
    633e:	1cbb      	adds	r3, r7, #2
    6340:	881a      	ldrh	r2, [r3, #0]
    6342:	687b      	ldr	r3, [r7, #4]
    6344:	0019      	movs	r1, r3
    6346:	f7fd fd07 	bl	3d58 <io_read>
}
    634a:	46c0      	nop			; (mov r8, r8)
    634c:	46bd      	mov	sp, r7
    634e:	b002      	add	sp, #8
    6350:	bd80      	pop	{r7, pc}
    6352:	46c0      	nop			; (mov r8, r8)
    6354:	20000800 	.word	0x20000800
    6358:	200007d0 	.word	0x200007d0

0000635c <RFM_69_sel>:



void RFM_69_sel(bool arg){
    635c:	b580      	push	{r7, lr}
    635e:	b082      	sub	sp, #8
    6360:	af00      	add	r7, sp, #0
    6362:	0002      	movs	r2, r0
    6364:	1dfb      	adds	r3, r7, #7
    6366:	701a      	strb	r2, [r3, #0]
	gpio_set_pin_level(RF_CS , arg);
    6368:	1dfb      	adds	r3, r7, #7
    636a:	781b      	ldrb	r3, [r3, #0]
    636c:	0019      	movs	r1, r3
    636e:	201c      	movs	r0, #28
    6370:	f7ff fea3 	bl	60ba <gpio_set_pin_level>
}
    6374:	46c0      	nop			; (mov r8, r8)
    6376:	46bd      	mov	sp, r7
    6378:	b002      	add	sp, #8
    637a:	bd80      	pop	{r7, pc}

0000637c <SPI_write>:

void SPI_write(uint8_t arg){
    637c:	b580      	push	{r7, lr}
    637e:	b084      	sub	sp, #16
    6380:	af00      	add	r7, sp, #0
    6382:	0002      	movs	r2, r0
    6384:	1dfb      	adds	r3, r7, #7
    6386:	701a      	strb	r2, [r3, #0]
	uint8_t *addr_ptr = &arg;
    6388:	1dfb      	adds	r3, r7, #7
    638a:	60fb      	str	r3, [r7, #12]
	struct io_descriptor *io;
	spi_m_sync_get_io_descriptor(&RF_SPI, &io); ///<<< EXP
    638c:	2308      	movs	r3, #8
    638e:	18fa      	adds	r2, r7, r3
    6390:	4b09      	ldr	r3, [pc, #36]	; (63b8 <SPI_write+0x3c>)
    6392:	0011      	movs	r1, r2
    6394:	0018      	movs	r0, r3
    6396:	f7fd fdf1 	bl	3f7c <spi_m_sync_get_io_descriptor>
	spi_m_sync_enable(&RF_SPI);
    639a:	4b07      	ldr	r3, [pc, #28]	; (63b8 <SPI_write+0x3c>)
    639c:	0018      	movs	r0, r3
    639e:	f7fd fd43 	bl	3e28 <spi_m_sync_enable>
	io_write(io, &arg, 1);	
    63a2:	68bb      	ldr	r3, [r7, #8]
    63a4:	1df9      	adds	r1, r7, #7
    63a6:	2201      	movs	r2, #1
    63a8:	0018      	movs	r0, r3
    63aa:	f7fd fcad 	bl	3d08 <io_write>
}
    63ae:	46c0      	nop			; (mov r8, r8)
    63b0:	46bd      	mov	sp, r7
    63b2:	b004      	add	sp, #16
    63b4:	bd80      	pop	{r7, pc}
    63b6:	46c0      	nop			; (mov r8, r8)
    63b8:	200007d0 	.word	0x200007d0

000063bc <SPI_read>:


uint8_t SPI_read(){
    63bc:	b580      	push	{r7, lr}
    63be:	b082      	sub	sp, #8
    63c0:	af00      	add	r7, sp, #0
	uint8_t data_byte = 0;
    63c2:	1dfb      	adds	r3, r7, #7
    63c4:	2200      	movs	r2, #0
    63c6:	701a      	strb	r2, [r3, #0]
	spi_m_sync_get_io_descriptor(&RF_SPI, &io); ///<<< EXP
    63c8:	4a09      	ldr	r2, [pc, #36]	; (63f0 <SPI_read+0x34>)
    63ca:	4b0a      	ldr	r3, [pc, #40]	; (63f4 <SPI_read+0x38>)
    63cc:	0011      	movs	r1, r2
    63ce:	0018      	movs	r0, r3
    63d0:	f7fd fdd4 	bl	3f7c <spi_m_sync_get_io_descriptor>
	io_read(io,&data_byte,1);
    63d4:	4b06      	ldr	r3, [pc, #24]	; (63f0 <SPI_read+0x34>)
    63d6:	681b      	ldr	r3, [r3, #0]
    63d8:	1df9      	adds	r1, r7, #7
    63da:	2201      	movs	r2, #1
    63dc:	0018      	movs	r0, r3
    63de:	f7fd fcbb 	bl	3d58 <io_read>
	return data_byte;
    63e2:	1dfb      	adds	r3, r7, #7
    63e4:	781b      	ldrb	r3, [r3, #0]
}
    63e6:	0018      	movs	r0, r3
    63e8:	46bd      	mov	sp, r7
    63ea:	b002      	add	sp, #8
    63ec:	bd80      	pop	{r7, pc}
    63ee:	46c0      	nop			; (mov r8, r8)
    63f0:	20000800 	.word	0x20000800
    63f4:	200007d0 	.word	0x200007d0

000063f8 <set_led>:
}
void toggle_led(){
	gpio_toggle_pin_level(LED_G);
}

void set_led(){
    63f8:	b580      	push	{r7, lr}
    63fa:	af00      	add	r7, sp, #0
	gpio_set_pin_level(LED_G, false);
    63fc:	2100      	movs	r1, #0
    63fe:	2020      	movs	r0, #32
    6400:	f7ff fe5b 	bl	60ba <gpio_set_pin_level>
}
    6404:	46c0      	nop			; (mov r8, r8)
    6406:	46bd      	mov	sp, r7
    6408:	bd80      	pop	{r7, pc}

0000640a <reset_led>:
void reset_led(){
    640a:	b580      	push	{r7, lr}
    640c:	af00      	add	r7, sp, #0
	gpio_set_pin_level(LED_G, true);
    640e:	2101      	movs	r1, #1
    6410:	2020      	movs	r0, #32
    6412:	f7ff fe52 	bl	60ba <gpio_set_pin_level>
}
    6416:	46c0      	nop			; (mov r8, r8)
    6418:	46bd      	mov	sp, r7
    641a:	bd80      	pop	{r7, pc}

0000641c <EXT_SPI_init>:

//Display section
void EXT_SPI_init(void)
{
    641c:	b580      	push	{r7, lr}
    641e:	af00      	add	r7, sp, #0
	_pm_enable_bus_clock(PM_BUS_APBC, SERCOM0);
    6420:	4b38      	ldr	r3, [pc, #224]	; (6504 <EXT_SPI_init+0xe8>)
    6422:	0019      	movs	r1, r3
    6424:	2003      	movs	r0, #3
    6426:	f7ff fee3 	bl	61f0 <_pm_enable_bus_clock>
	_gclk_enable_channel(SERCOM0_GCLK_ID_CORE, CONF_GCLK_SERCOM0_CORE_SRC);
    642a:	2100      	movs	r1, #0
    642c:	200d      	movs	r0, #13
    642e:	f7ff fe61 	bl	60f4 <_gclk_enable_channel>
	
	
	spi_m_sync_init(&EXT_SPI, SERCOM0);
    6432:	4a34      	ldr	r2, [pc, #208]	; (6504 <EXT_SPI_init+0xe8>)
    6434:	4b34      	ldr	r3, [pc, #208]	; (6508 <EXT_SPI_init+0xec>)
    6436:	0011      	movs	r1, r2
    6438:	0018      	movs	r0, r3
    643a:	f7fd fcb5 	bl	3da8 <spi_m_sync_init>
	spi_m_sync_get_io_descriptor(&EXT_SPI, &io);
    643e:	4a33      	ldr	r2, [pc, #204]	; (650c <EXT_SPI_init+0xf0>)
    6440:	4b31      	ldr	r3, [pc, #196]	; (6508 <EXT_SPI_init+0xec>)
    6442:	0011      	movs	r1, r2
    6444:	0018      	movs	r0, r3
    6446:	f7fd fd99 	bl	3f7c <spi_m_sync_get_io_descriptor>
	
	gpio_set_pin_level(PA04, false);
    644a:	2100      	movs	r1, #0
    644c:	2004      	movs	r0, #4
    644e:	f7ff fe34 	bl	60ba <gpio_set_pin_level>
	gpio_set_pin_direction(PA04, GPIO_DIRECTION_OUT);
    6452:	2102      	movs	r1, #2
    6454:	2004      	movs	r0, #4
    6456:	f7ff fe13 	bl	6080 <gpio_set_pin_direction>
	gpio_set_pin_function(PA04, PINMUX_PA04D_SERCOM0_PAD0);
    645a:	4b2d      	ldr	r3, [pc, #180]	; (6510 <EXT_SPI_init+0xf4>)
    645c:	0019      	movs	r1, r3
    645e:	2004      	movs	r0, #4
    6460:	f7ff fdff 	bl	6062 <gpio_set_pin_function>
	gpio_set_pin_level(PA05, false);
    6464:	2100      	movs	r1, #0
    6466:	2005      	movs	r0, #5
    6468:	f7ff fe27 	bl	60ba <gpio_set_pin_level>
	gpio_set_pin_direction(PA05, GPIO_DIRECTION_OUT);
    646c:	2102      	movs	r1, #2
    646e:	2005      	movs	r0, #5
    6470:	f7ff fe06 	bl	6080 <gpio_set_pin_direction>
	gpio_set_pin_function(PA05, PINMUX_PA05D_SERCOM0_PAD1);
    6474:	4b27      	ldr	r3, [pc, #156]	; (6514 <EXT_SPI_init+0xf8>)
    6476:	0019      	movs	r1, r3
    6478:	2005      	movs	r0, #5
    647a:	f7ff fdf2 	bl	6062 <gpio_set_pin_function>
	gpio_set_pin_direction(PA06, GPIO_DIRECTION_IN);
    647e:	2101      	movs	r1, #1
    6480:	2006      	movs	r0, #6
    6482:	f7ff fdfd 	bl	6080 <gpio_set_pin_direction>
	gpio_set_pin_pull_mode(PA06, GPIO_PULL_OFF);
    6486:	2100      	movs	r1, #0
    6488:	2006      	movs	r0, #6
    648a:	f7ff fdcf 	bl	602c <gpio_set_pin_pull_mode>
	gpio_set_pin_function(PA06, PINMUX_PA06D_SERCOM0_PAD2);
    648e:	4b22      	ldr	r3, [pc, #136]	; (6518 <EXT_SPI_init+0xfc>)
    6490:	0019      	movs	r1, r3
    6492:	2006      	movs	r0, #6
    6494:	f7ff fde5 	bl	6062 <gpio_set_pin_function>
	gpio_set_pin_level(VFD_RST, true);
    6498:	2101      	movs	r1, #1
    649a:	2007      	movs	r0, #7
    649c:	f7ff fe0d 	bl	60ba <gpio_set_pin_level>
	gpio_set_pin_level(FILAMENT_EN, true);
    64a0:	2101      	movs	r1, #1
    64a2:	2026      	movs	r0, #38	; 0x26
    64a4:	f7ff fe09 	bl	60ba <gpio_set_pin_level>
	
	//io_write(io, example_VFD_SPI, 12);

	//VFD additional IO setup
	gpio_set_pin_level(VFD_RST, true);
    64a8:	2101      	movs	r1, #1
    64aa:	2007      	movs	r0, #7
    64ac:	f7ff fe05 	bl	60ba <gpio_set_pin_level>
	gpio_set_pin_direction(VFD_RST, GPIO_DIRECTION_OUT);
    64b0:	2102      	movs	r1, #2
    64b2:	2007      	movs	r0, #7
    64b4:	f7ff fde4 	bl	6080 <gpio_set_pin_direction>
	gpio_set_pin_function(VFD_RST, GPIO_PIN_FUNCTION_OFF);
    64b8:	2301      	movs	r3, #1
    64ba:	425b      	negs	r3, r3
    64bc:	0019      	movs	r1, r3
    64be:	2007      	movs	r0, #7
    64c0:	f7ff fdcf 	bl	6062 <gpio_set_pin_function>
	
	gpio_set_pin_level(FILAMENT_EN, true);
    64c4:	2101      	movs	r1, #1
    64c6:	2026      	movs	r0, #38	; 0x26
    64c8:	f7ff fdf7 	bl	60ba <gpio_set_pin_level>
	gpio_set_pin_direction(FILAMENT_EN, GPIO_DIRECTION_OUT);
    64cc:	2102      	movs	r1, #2
    64ce:	2026      	movs	r0, #38	; 0x26
    64d0:	f7ff fdd6 	bl	6080 <gpio_set_pin_direction>
	gpio_set_pin_function(FILAMENT_EN, GPIO_PIN_FUNCTION_OFF);	
    64d4:	2301      	movs	r3, #1
    64d6:	425b      	negs	r3, r3
    64d8:	0019      	movs	r1, r3
    64da:	2026      	movs	r0, #38	; 0x26
    64dc:	f7ff fdc1 	bl	6062 <gpio_set_pin_function>
	
	gpio_set_pin_level(VFD_CS, true);
    64e0:	2101      	movs	r1, #1
    64e2:	2029      	movs	r0, #41	; 0x29
    64e4:	f7ff fde9 	bl	60ba <gpio_set_pin_level>
	gpio_set_pin_direction(VFD_CS, GPIO_DIRECTION_OUT);
    64e8:	2102      	movs	r1, #2
    64ea:	2029      	movs	r0, #41	; 0x29
    64ec:	f7ff fdc8 	bl	6080 <gpio_set_pin_direction>
	gpio_set_pin_function(VFD_CS, GPIO_PIN_FUNCTION_OFF);
    64f0:	2301      	movs	r3, #1
    64f2:	425b      	negs	r3, r3
    64f4:	0019      	movs	r1, r3
    64f6:	2029      	movs	r0, #41	; 0x29
    64f8:	f7ff fdb3 	bl	6062 <gpio_set_pin_function>
	
		
}
    64fc:	46c0      	nop			; (mov r8, r8)
    64fe:	46bd      	mov	sp, r7
    6500:	bd80      	pop	{r7, pc}
    6502:	46c0      	nop			; (mov r8, r8)
    6504:	42000800 	.word	0x42000800
    6508:	200007e8 	.word	0x200007e8
    650c:	20000800 	.word	0x20000800
    6510:	00040003 	.word	0x00040003
    6514:	00050003 	.word	0x00050003
    6518:	00060003 	.word	0x00060003

0000651c <vfd_write_data>:
void vfd_write_data(uint8_t* buff, uint16_t len){
    651c:	b580      	push	{r7, lr}
    651e:	b082      	sub	sp, #8
    6520:	af00      	add	r7, sp, #0
    6522:	6078      	str	r0, [r7, #4]
    6524:	000a      	movs	r2, r1
    6526:	1cbb      	adds	r3, r7, #2
    6528:	801a      	strh	r2, [r3, #0]
	//struct io_descriptor *io;
	spi_m_sync_get_io_descriptor(&EXT_SPI, &io);
    652a:	4a0b      	ldr	r2, [pc, #44]	; (6558 <vfd_write_data+0x3c>)
    652c:	4b0b      	ldr	r3, [pc, #44]	; (655c <vfd_write_data+0x40>)
    652e:	0011      	movs	r1, r2
    6530:	0018      	movs	r0, r3
    6532:	f7fd fd23 	bl	3f7c <spi_m_sync_get_io_descriptor>
	spi_m_sync_enable(&EXT_SPI);
    6536:	4b09      	ldr	r3, [pc, #36]	; (655c <vfd_write_data+0x40>)
    6538:	0018      	movs	r0, r3
    653a:	f7fd fc75 	bl	3e28 <spi_m_sync_enable>
	io_write(io, buff, len);
    653e:	4b06      	ldr	r3, [pc, #24]	; (6558 <vfd_write_data+0x3c>)
    6540:	6818      	ldr	r0, [r3, #0]
    6542:	1cbb      	adds	r3, r7, #2
    6544:	881a      	ldrh	r2, [r3, #0]
    6546:	687b      	ldr	r3, [r7, #4]
    6548:	0019      	movs	r1, r3
    654a:	f7fd fbdd 	bl	3d08 <io_write>
	
}
    654e:	46c0      	nop			; (mov r8, r8)
    6550:	46bd      	mov	sp, r7
    6552:	b002      	add	sp, #8
    6554:	bd80      	pop	{r7, pc}
    6556:	46c0      	nop			; (mov r8, r8)
    6558:	20000800 	.word	0x20000800
    655c:	200007e8 	.word	0x200007e8

00006560 <vfd_cs_set>:

void vfd_cs_set(bool state){
    6560:	b580      	push	{r7, lr}
    6562:	b082      	sub	sp, #8
    6564:	af00      	add	r7, sp, #0
    6566:	0002      	movs	r2, r0
    6568:	1dfb      	adds	r3, r7, #7
    656a:	701a      	strb	r2, [r3, #0]
	gpio_set_pin_level(VFD_CS, !state);
    656c:	1dfb      	adds	r3, r7, #7
    656e:	781b      	ldrb	r3, [r3, #0]
    6570:	1e5a      	subs	r2, r3, #1
    6572:	4193      	sbcs	r3, r2
    6574:	b2db      	uxtb	r3, r3
    6576:	2201      	movs	r2, #1
    6578:	4053      	eors	r3, r2
    657a:	b2db      	uxtb	r3, r3
    657c:	1c1a      	adds	r2, r3, #0
    657e:	2301      	movs	r3, #1
    6580:	4013      	ands	r3, r2
    6582:	b2db      	uxtb	r3, r3
    6584:	0019      	movs	r1, r3
    6586:	2029      	movs	r0, #41	; 0x29
    6588:	f7ff fd97 	bl	60ba <gpio_set_pin_level>
}
    658c:	46c0      	nop			; (mov r8, r8)
    658e:	46bd      	mov	sp, r7
    6590:	b002      	add	sp, #8
    6592:	bd80      	pop	{r7, pc}

00006594 <u8x8_avr_gpio_and_delay>:

uint8_t u8x8_avr_gpio_and_delay(u8x8_t *u8x8, uint8_t msg, uint8_t arg_int, void *arg_ptr){
    6594:	b580      	push	{r7, lr}
    6596:	b084      	sub	sp, #16
    6598:	af00      	add	r7, sp, #0
    659a:	60f8      	str	r0, [r7, #12]
    659c:	0008      	movs	r0, r1
    659e:	0011      	movs	r1, r2
    65a0:	607b      	str	r3, [r7, #4]
    65a2:	230b      	movs	r3, #11
    65a4:	18fb      	adds	r3, r7, r3
    65a6:	1c02      	adds	r2, r0, #0
    65a8:	701a      	strb	r2, [r3, #0]
    65aa:	230a      	movs	r3, #10
    65ac:	18fb      	adds	r3, r7, r3
    65ae:	1c0a      	adds	r2, r1, #0
    65b0:	701a      	strb	r2, [r3, #0]
	//uint8_t cycles;

	switch(msg)
    65b2:	230b      	movs	r3, #11
    65b4:	18fb      	adds	r3, r7, r3
    65b6:	781b      	ldrb	r3, [r3, #0]
    65b8:	2b2a      	cmp	r3, #42	; 0x2a
    65ba:	d009      	beq.n	65d0 <u8x8_avr_gpio_and_delay+0x3c>
    65bc:	dc02      	bgt.n	65c4 <u8x8_avr_gpio_and_delay+0x30>
    65be:	2b29      	cmp	r3, #41	; 0x29
    65c0:	d008      	beq.n	65d4 <u8x8_avr_gpio_and_delay+0x40>
    65c2:	e003      	b.n	65cc <u8x8_avr_gpio_and_delay+0x38>
    65c4:	2b2b      	cmp	r3, #43	; 0x2b
    65c6:	d007      	beq.n	65d8 <u8x8_avr_gpio_and_delay+0x44>
    65c8:	2b2c      	cmp	r3, #44	; 0x2c
    65ca:	d007      	beq.n	65dc <u8x8_avr_gpio_and_delay+0x48>
		case U8X8_MSG_DELAY_10MICRO:    // delay arg_int * 10 micro seconds
		break;
		case U8X8_MSG_DELAY_MILLI:      // delay arg_int * 1 milli second
		break;
		default:
		return 0;
    65cc:	2300      	movs	r3, #0
    65ce:	e007      	b.n	65e0 <u8x8_avr_gpio_and_delay+0x4c>
		break;
    65d0:	46c0      	nop			; (mov r8, r8)
    65d2:	e004      	b.n	65de <u8x8_avr_gpio_and_delay+0x4a>
		break;
    65d4:	46c0      	nop			; (mov r8, r8)
    65d6:	e002      	b.n	65de <u8x8_avr_gpio_and_delay+0x4a>
		break;
    65d8:	46c0      	nop			; (mov r8, r8)
    65da:	e000      	b.n	65de <u8x8_avr_gpio_and_delay+0x4a>
		break;
    65dc:	46c0      	nop			; (mov r8, r8)
	}
	return 0;
    65de:	2300      	movs	r3, #0
}
    65e0:	0018      	movs	r0, r3
    65e2:	46bd      	mov	sp, r7
    65e4:	b004      	add	sp, #16
    65e6:	bd80      	pop	{r7, pc}

000065e8 <vfd_spi>:
uint8_t vfd_spi(u8x8_t *u8x8, uint8_t msg, uint8_t arg_int, void *arg_ptr)
{
    65e8:	b580      	push	{r7, lr}
    65ea:	b084      	sub	sp, #16
    65ec:	af00      	add	r7, sp, #0
    65ee:	60f8      	str	r0, [r7, #12]
    65f0:	0008      	movs	r0, r1
    65f2:	0011      	movs	r1, r2
    65f4:	607b      	str	r3, [r7, #4]
    65f6:	230b      	movs	r3, #11
    65f8:	18fb      	adds	r3, r7, r3
    65fa:	1c02      	adds	r2, r0, #0
    65fc:	701a      	strb	r2, [r3, #0]
    65fe:	230a      	movs	r3, #10
    6600:	18fb      	adds	r3, r7, r3
    6602:	1c0a      	adds	r2, r1, #0
    6604:	701a      	strb	r2, [r3, #0]
	
	switch(msg)
    6606:	230b      	movs	r3, #11
    6608:	18fb      	adds	r3, r7, r3
    660a:	781b      	ldrb	r3, [r3, #0]
    660c:	3b14      	subs	r3, #20
    660e:	2b0c      	cmp	r3, #12
    6610:	d823      	bhi.n	665a <vfd_spi+0x72>
    6612:	009a      	lsls	r2, r3, #2
    6614:	4b14      	ldr	r3, [pc, #80]	; (6668 <vfd_spi+0x80>)
    6616:	18d3      	adds	r3, r2, r3
    6618:	681b      	ldr	r3, [r3, #0]
    661a:	469f      	mov	pc, r3
	{
		case U8X8_MSG_BYTE_SEND:
		vfd_write_data(arg_ptr, arg_int);
    661c:	230a      	movs	r3, #10
    661e:	18fb      	adds	r3, r7, r3
    6620:	781b      	ldrb	r3, [r3, #0]
    6622:	b29a      	uxth	r2, r3
    6624:	687b      	ldr	r3, [r7, #4]
    6626:	0011      	movs	r1, r2
    6628:	0018      	movs	r0, r3
    662a:	f7ff ff77 	bl	651c <vfd_write_data>
		break;
    662e:	e016      	b.n	665e <vfd_spi+0x76>
		case U8X8_MSG_BYTE_INIT:
		/* disable chipselect */
		vfd_cs_set(false);
    6630:	2000      	movs	r0, #0
    6632:	f7ff ff95 	bl	6560 <vfd_cs_set>
		break;
    6636:	e012      	b.n	665e <vfd_spi+0x76>
		case U8X8_MSG_BYTE_SET_DC:
		u8x8_gpio_SetDC(u8x8, arg_int);
    6638:	230a      	movs	r3, #10
    663a:	18fb      	adds	r3, r7, r3
    663c:	781a      	ldrb	r2, [r3, #0]
    663e:	68fb      	ldr	r3, [r7, #12]
    6640:	214a      	movs	r1, #74	; 0x4a
    6642:	0018      	movs	r0, r3
    6644:	f7fc fbe0 	bl	2e08 <u8x8_gpio_call>
		break;
    6648:	e009      	b.n	665e <vfd_spi+0x76>
		case U8X8_MSG_BYTE_START_TRANSFER:
		vfd_cs_set(true);
    664a:	2001      	movs	r0, #1
    664c:	f7ff ff88 	bl	6560 <vfd_cs_set>
		break;
    6650:	e005      	b.n	665e <vfd_spi+0x76>
		case U8X8_MSG_BYTE_END_TRANSFER:
		vfd_cs_set(false);
    6652:	2000      	movs	r0, #0
    6654:	f7ff ff84 	bl	6560 <vfd_cs_set>
		break;
    6658:	e001      	b.n	665e <vfd_spi+0x76>
		default:
		return 0;
    665a:	2300      	movs	r3, #0
    665c:	e000      	b.n	6660 <vfd_spi+0x78>
	}
	return 1;
    665e:	2301      	movs	r3, #1
}
    6660:	0018      	movs	r0, r3
    6662:	46bd      	mov	sp, r7
    6664:	b004      	add	sp, #16
    6666:	bd80      	pop	{r7, pc}
    6668:	00007eac 	.word	0x00007eac

0000666c <RF_SPI_init>:

//RF_Section
void RF_SPI_init(void){
    666c:	b580      	push	{r7, lr}
    666e:	af00      	add	r7, sp, #0
	_pm_enable_bus_clock(PM_BUS_APBC, SERCOM1);
    6670:	4b56      	ldr	r3, [pc, #344]	; (67cc <RF_SPI_init+0x160>)
    6672:	0019      	movs	r1, r3
    6674:	2003      	movs	r0, #3
    6676:	f7ff fdbb 	bl	61f0 <_pm_enable_bus_clock>
	_gclk_enable_channel(SERCOM1_GCLK_ID_CORE, CONF_GCLK_SERCOM1_CORE_SRC);
    667a:	2100      	movs	r1, #0
    667c:	200e      	movs	r0, #14
    667e:	f7ff fd39 	bl	60f4 <_gclk_enable_channel>
	
	spi_m_sync_init(&RF_SPI, SERCOM1);
    6682:	4a52      	ldr	r2, [pc, #328]	; (67cc <RF_SPI_init+0x160>)
    6684:	4b52      	ldr	r3, [pc, #328]	; (67d0 <RF_SPI_init+0x164>)
    6686:	0011      	movs	r1, r2
    6688:	0018      	movs	r0, r3
    668a:	f7fd fb8d 	bl	3da8 <spi_m_sync_init>
	spi_m_sync_get_io_descriptor(&RF_SPI, &io);
    668e:	4a51      	ldr	r2, [pc, #324]	; (67d4 <RF_SPI_init+0x168>)
    6690:	4b4f      	ldr	r3, [pc, #316]	; (67d0 <RF_SPI_init+0x164>)
    6692:	0011      	movs	r1, r2
    6694:	0018      	movs	r0, r3
    6696:	f7fd fc71 	bl	3f7c <spi_m_sync_get_io_descriptor>
	
	gpio_set_pin_level(PA00, false);
    669a:	2100      	movs	r1, #0
    669c:	2000      	movs	r0, #0
    669e:	f7ff fd0c 	bl	60ba <gpio_set_pin_level>
	gpio_set_pin_direction(PA00, GPIO_DIRECTION_OUT);
    66a2:	2102      	movs	r1, #2
    66a4:	2000      	movs	r0, #0
    66a6:	f7ff fceb 	bl	6080 <gpio_set_pin_direction>
	gpio_set_pin_function(PA00, PINMUX_PA00D_SERCOM1_PAD0);
    66aa:	2103      	movs	r1, #3
    66ac:	2000      	movs	r0, #0
    66ae:	f7ff fcd8 	bl	6062 <gpio_set_pin_function>
	gpio_set_pin_level(PA01, false);
    66b2:	2100      	movs	r1, #0
    66b4:	2001      	movs	r0, #1
    66b6:	f7ff fd00 	bl	60ba <gpio_set_pin_level>
	gpio_set_pin_direction(PA01, GPIO_DIRECTION_OUT);
    66ba:	2102      	movs	r1, #2
    66bc:	2001      	movs	r0, #1
    66be:	f7ff fcdf 	bl	6080 <gpio_set_pin_direction>
	gpio_set_pin_function(PA01, PINMUX_PA01D_SERCOM1_PAD1);
    66c2:	4b45      	ldr	r3, [pc, #276]	; (67d8 <RF_SPI_init+0x16c>)
    66c4:	0019      	movs	r1, r3
    66c6:	2001      	movs	r0, #1
    66c8:	f7ff fccb 	bl	6062 <gpio_set_pin_function>
	gpio_set_pin_direction(PA18, GPIO_DIRECTION_IN);
    66cc:	2101      	movs	r1, #1
    66ce:	2012      	movs	r0, #18
    66d0:	f7ff fcd6 	bl	6080 <gpio_set_pin_direction>

	gpio_set_pin_pull_mode(PA18, GPIO_PULL_OFF);
    66d4:	2100      	movs	r1, #0
    66d6:	2012      	movs	r0, #18
    66d8:	f7ff fca8 	bl	602c <gpio_set_pin_pull_mode>
	gpio_set_pin_function(PA18, PINMUX_PA18C_SERCOM1_PAD2);
    66dc:	4b3f      	ldr	r3, [pc, #252]	; (67dc <RF_SPI_init+0x170>)
    66de:	0019      	movs	r1, r3
    66e0:	2012      	movs	r0, #18
    66e2:	f7ff fcbe 	bl	6062 <gpio_set_pin_function>
	//Gpio setup
	
	gpio_set_pin_level(RF_RST, false);
    66e6:	2100      	movs	r1, #0
    66e8:	2002      	movs	r0, #2
    66ea:	f7ff fce6 	bl	60ba <gpio_set_pin_level>
	gpio_set_pin_direction(RF_RST, GPIO_DIRECTION_OUT);
    66ee:	2102      	movs	r1, #2
    66f0:	2002      	movs	r0, #2
    66f2:	f7ff fcc5 	bl	6080 <gpio_set_pin_direction>
	gpio_set_pin_function(RF_RST, GPIO_PIN_FUNCTION_OFF);
    66f6:	2301      	movs	r3, #1
    66f8:	425b      	negs	r3, r3
    66fa:	0019      	movs	r1, r3
    66fc:	2002      	movs	r0, #2
    66fe:	f7ff fcb0 	bl	6062 <gpio_set_pin_function>
	gpio_set_pin_level(RF_RST, true);
    6702:	2101      	movs	r1, #1
    6704:	2002      	movs	r0, #2
    6706:	f7ff fcd8 	bl	60ba <gpio_set_pin_level>
	delay_ms(10);
    670a:	200a      	movs	r0, #10
    670c:	f7fd f95e 	bl	39cc <delay_ms>
	gpio_set_pin_level(RF_RST, false);
    6710:	2100      	movs	r1, #0
    6712:	2002      	movs	r0, #2
    6714:	f7ff fcd1 	bl	60ba <gpio_set_pin_level>
	
	//Radio additional IO setup
	gpio_set_pin_level(RF_CS, true);
    6718:	2101      	movs	r1, #1
    671a:	201c      	movs	r0, #28
    671c:	f7ff fccd 	bl	60ba <gpio_set_pin_level>
	gpio_set_pin_direction(RF_CS, GPIO_DIRECTION_OUT);
    6720:	2102      	movs	r1, #2
    6722:	201c      	movs	r0, #28
    6724:	f7ff fcac 	bl	6080 <gpio_set_pin_direction>
	gpio_set_pin_function(RF_CS, GPIO_PIN_FUNCTION_OFF);
    6728:	2301      	movs	r3, #1
    672a:	425b      	negs	r3, r3
    672c:	0019      	movs	r1, r3
    672e:	201c      	movs	r0, #28
    6730:	f7ff fc97 	bl	6062 <gpio_set_pin_function>
	
	//SPI Flash additional IO setup
	gpio_set_pin_level(ROM_CS, true);
    6734:	2101      	movs	r1, #1
    6736:	2017      	movs	r0, #23
    6738:	f7ff fcbf 	bl	60ba <gpio_set_pin_level>
	gpio_set_pin_direction(ROM_CS, GPIO_DIRECTION_OUT);
    673c:	2102      	movs	r1, #2
    673e:	2017      	movs	r0, #23
    6740:	f7ff fc9e 	bl	6080 <gpio_set_pin_direction>
	gpio_set_pin_function(ROM_CS, GPIO_PIN_FUNCTION_OFF);
    6744:	2301      	movs	r3, #1
    6746:	425b      	negs	r3, r3
    6748:	0019      	movs	r1, r3
    674a:	2017      	movs	r0, #23
    674c:	f7ff fc89 	bl	6062 <gpio_set_pin_function>
	
	//MicroSD Flash additional IO setup
	gpio_set_pin_level(LED_SD, false);
    6750:	2100      	movs	r1, #0
    6752:	2003      	movs	r0, #3
    6754:	f7ff fcb1 	bl	60ba <gpio_set_pin_level>
	gpio_set_pin_direction(LED_SD, GPIO_DIRECTION_OUT);
    6758:	2102      	movs	r1, #2
    675a:	2003      	movs	r0, #3
    675c:	f7ff fc90 	bl	6080 <gpio_set_pin_direction>
	gpio_set_pin_function(LED_SD, GPIO_PIN_FUNCTION_OFF);
    6760:	2301      	movs	r3, #1
    6762:	425b      	negs	r3, r3
    6764:	0019      	movs	r1, r3
    6766:	2003      	movs	r0, #3
    6768:	f7ff fc7b 	bl	6062 <gpio_set_pin_function>
	
	gpio_set_pin_level(SD_CS, true);
    676c:	2101      	movs	r1, #1
    676e:	2024      	movs	r0, #36	; 0x24
    6770:	f7ff fca3 	bl	60ba <gpio_set_pin_level>
	gpio_set_pin_direction(SD_CS, GPIO_DIRECTION_OUT);
    6774:	2102      	movs	r1, #2
    6776:	2024      	movs	r0, #36	; 0x24
    6778:	f7ff fc82 	bl	6080 <gpio_set_pin_direction>
	gpio_set_pin_function(SD_CS, GPIO_PIN_FUNCTION_OFF);
    677c:	2301      	movs	r3, #1
    677e:	425b      	negs	r3, r3
    6780:	0019      	movs	r1, r3
    6782:	2024      	movs	r0, #36	; 0x24
    6784:	f7ff fc6d 	bl	6062 <gpio_set_pin_function>

	gpio_set_pin_direction(SD_DETECT, GPIO_DIRECTION_IN);
    6788:	2101      	movs	r1, #1
    678a:	2025      	movs	r0, #37	; 0x25
    678c:	f7ff fc78 	bl	6080 <gpio_set_pin_direction>
	gpio_set_pin_pull_mode(SD_DETECT, GPIO_PULL_OFF);
    6790:	2100      	movs	r1, #0
    6792:	2025      	movs	r0, #37	; 0x25
    6794:	f7ff fc4a 	bl	602c <gpio_set_pin_pull_mode>
	gpio_set_pin_function(SD_DETECT, GPIO_PIN_FUNCTION_OFF);
    6798:	2301      	movs	r3, #1
    679a:	425b      	negs	r3, r3
    679c:	0019      	movs	r1, r3
    679e:	2025      	movs	r0, #37	; 0x25
    67a0:	f7ff fc5f 	bl	6062 <gpio_set_pin_function>

	gpio_set_pin_direction(RF_IRQ, GPIO_DIRECTION_IN);
    67a4:	2101      	movs	r1, #1
    67a6:	203e      	movs	r0, #62	; 0x3e
    67a8:	f7ff fc6a 	bl	6080 <gpio_set_pin_direction>
	gpio_set_pin_pull_mode(RF_IRQ, GPIO_PULL_DOWN);
    67ac:	2102      	movs	r1, #2
    67ae:	203e      	movs	r0, #62	; 0x3e
    67b0:	f7ff fc3c 	bl	602c <gpio_set_pin_pull_mode>
	gpio_set_pin_function(RF_IRQ, PINMUX_PB30A_EIC_EXTINT14);
    67b4:	23f8      	movs	r3, #248	; 0xf8
    67b6:	039b      	lsls	r3, r3, #14
    67b8:	0019      	movs	r1, r3
    67ba:	203e      	movs	r0, #62	; 0x3e
    67bc:	f7ff fc51 	bl	6062 <gpio_set_pin_function>
	RF_IRQ_Enable();
    67c0:	f7ff fd82 	bl	62c8 <RF_IRQ_Enable>
	
}
    67c4:	46c0      	nop			; (mov r8, r8)
    67c6:	46bd      	mov	sp, r7
    67c8:	bd80      	pop	{r7, pc}
    67ca:	46c0      	nop			; (mov r8, r8)
    67cc:	42000c00 	.word	0x42000c00
    67d0:	200007d0 	.word	0x200007d0
    67d4:	20000800 	.word	0x20000800
    67d8:	00010003 	.word	0x00010003
    67dc:	00120002 	.word	0x00120002

000067e0 <rfm69_init>:
uint8_t promiscuousMode = 0;
unsigned long millis_current;

// freqBand must be selected from 315, 433, 868, 915
void rfm69_init(uint16_t freqBand, uint8_t nodeID, uint8_t networkID)
{
    67e0:	b590      	push	{r4, r7, lr}
    67e2:	b085      	sub	sp, #20
    67e4:	af00      	add	r7, sp, #0
    67e6:	0004      	movs	r4, r0
    67e8:	0008      	movs	r0, r1
    67ea:	0011      	movs	r1, r2
    67ec:	1dbb      	adds	r3, r7, #6
    67ee:	1c22      	adds	r2, r4, #0
    67f0:	801a      	strh	r2, [r3, #0]
    67f2:	1d7b      	adds	r3, r7, #5
    67f4:	1c02      	adds	r2, r0, #0
    67f6:	701a      	strb	r2, [r3, #0]
    67f8:	1d3b      	adds	r3, r7, #4
    67fa:	1c0a      	adds	r2, r1, #0
    67fc:	701a      	strb	r2, [r3, #0]

	uint8_t tmp_data = readReg(REG_VERSION);
    67fe:	230f      	movs	r3, #15
    6800:	18fc      	adds	r4, r7, r3
    6802:	2010      	movs	r0, #16
    6804:	f000 f87f 	bl	6906 <readReg>
    6808:	0003      	movs	r3, r0
    680a:	7023      	strb	r3, [r4, #0]
	//tmp_data = readReg(REG_OPMODE);
	
	writeReg(REG_OPMODE, RF_OPMODE_STANDBY);
    680c:	2104      	movs	r1, #4
    680e:	2001      	movs	r0, #1
    6810:	f000 f898 	bl	6944 <writeReg>
	
	tmp_data = readReg(REG_IRQFLAGS1);
    6814:	230f      	movs	r3, #15
    6816:	18fc      	adds	r4, r7, r3
    6818:	2027      	movs	r0, #39	; 0x27
    681a:	f000 f874 	bl	6906 <readReg>
    681e:	0003      	movs	r3, r0
    6820:	7023      	strb	r3, [r4, #0]
	
	writeReg(REG_FIFOTHRESH, 0x8f);
    6822:	218f      	movs	r1, #143	; 0x8f
    6824:	203c      	movs	r0, #60	; 0x3c
    6826:	f000 f88d 	bl	6944 <writeReg>
	writeReg(REG_TESTDAGC, 0x30);
    682a:	2130      	movs	r1, #48	; 0x30
    682c:	206f      	movs	r0, #111	; 0x6f
    682e:	f000 f889 	bl	6944 <writeReg>
	writeReg(REG_TESTPA1, 0x55); //only for HW
    6832:	2155      	movs	r1, #85	; 0x55
    6834:	205a      	movs	r0, #90	; 0x5a
    6836:	f000 f885 	bl	6944 <writeReg>
	writeReg(REG_TESTPA2, 0x70); //only for HW
    683a:	2170      	movs	r1, #112	; 0x70
    683c:	205c      	movs	r0, #92	; 0x5c
    683e:	f000 f881 	bl	6944 <writeReg>
	
	tmp_data = readReg(REG_SYNCCONFIG);
    6842:	230f      	movs	r3, #15
    6844:	18fc      	adds	r4, r7, r3
    6846:	202e      	movs	r0, #46	; 0x2e
    6848:	f000 f85d 	bl	6906 <readReg>
    684c:	0003      	movs	r3, r0
    684e:	7023      	strb	r3, [r4, #0]
	writeReg(REG_SYNCVALUE1, 0x2d);
    6850:	212d      	movs	r1, #45	; 0x2d
    6852:	202f      	movs	r0, #47	; 0x2f
    6854:	f000 f876 	bl	6944 <writeReg>
	writeReg(REG_SYNCVALUE2, 0xd4);
    6858:	21d4      	movs	r1, #212	; 0xd4
    685a:	2030      	movs	r0, #48	; 0x30
    685c:	f000 f872 	bl	6944 <writeReg>
	writeReg(REG_SYNCCONFIG, 0x88);
    6860:	2188      	movs	r1, #136	; 0x88
    6862:	202e      	movs	r0, #46	; 0x2e
    6864:	f000 f86e 	bl	6944 <writeReg>
	
	writeReg(REG_DATAMODUL, RF_DATAMODUL_MODULATIONSHAPING_01);
    6868:	2101      	movs	r1, #1
    686a:	2002      	movs	r0, #2
    686c:	f000 f86a 	bl	6944 <writeReg>
	writeReg(REG_BITRATEMSB, 0x00);
    6870:	2100      	movs	r1, #0
    6872:	2003      	movs	r0, #3
    6874:	f000 f866 	bl	6944 <writeReg>
	writeReg(REG_BITRATELSB, 0x80);
    6878:	2180      	movs	r1, #128	; 0x80
    687a:	2004      	movs	r0, #4
    687c:	f000 f862 	bl	6944 <writeReg>
	writeReg(REG_FDEVMSB, 0x10);
    6880:	2110      	movs	r1, #16
    6882:	2005      	movs	r0, #5
    6884:	f000 f85e 	bl	6944 <writeReg>
	writeReg(REG_FDEVLSB, 0x00);
    6888:	2100      	movs	r1, #0
    688a:	2006      	movs	r0, #6
    688c:	f000 f85a 	bl	6944 <writeReg>
	
	writeReg(REG_RXBW, RF_RXBW_DCCFREQ_111);
    6890:	21e0      	movs	r1, #224	; 0xe0
    6892:	2019      	movs	r0, #25
    6894:	f000 f856 	bl	6944 <writeReg>
	writeReg(REG_AFCBW, RF_AFCBW_DCCFREQAFC_111);
    6898:	21e0      	movs	r1, #224	; 0xe0
    689a:	201a      	movs	r0, #26
    689c:	f000 f852 	bl	6944 <writeReg>
	writeReg(REG_PACKETCONFIG1, 0xD0);
    68a0:	21d0      	movs	r1, #208	; 0xd0
    68a2:	2037      	movs	r0, #55	; 0x37
    68a4:	f000 f84e 	bl	6944 <writeReg>
	
	writeReg(REG_PREAMBLEMSB, 0x00);
    68a8:	2100      	movs	r1, #0
    68aa:	202c      	movs	r0, #44	; 0x2c
    68ac:	f000 f84a 	bl	6944 <writeReg>
	writeReg(REG_PREAMBLELSB , 0x04);
    68b0:	2104      	movs	r1, #4
    68b2:	202d      	movs	r0, #45	; 0x2d
    68b4:	f000 f846 	bl	6944 <writeReg>
	
	writeReg(REG_FRFMSB, RF_FRFMSB_868);
    68b8:	21d9      	movs	r1, #217	; 0xd9
    68ba:	2007      	movs	r0, #7
    68bc:	f000 f842 	bl	6944 <writeReg>
	writeReg(REG_FRFMID, RF_FRFMID_868);
    68c0:	2100      	movs	r1, #0
    68c2:	2008      	movs	r0, #8
    68c4:	f000 f83e 	bl	6944 <writeReg>
	writeReg(REG_FRFLSB, RF_FRFLSB_868);
    68c8:	2100      	movs	r1, #0
    68ca:	2009      	movs	r0, #9
    68cc:	f000 f83a 	bl	6944 <writeReg>
	
	tmp_data = readReg(REG_PACKETCONFIG2); //2
    68d0:	230f      	movs	r3, #15
    68d2:	18fc      	adds	r4, r7, r3
    68d4:	203d      	movs	r0, #61	; 0x3d
    68d6:	f000 f816 	bl	6906 <readReg>
    68da:	0003      	movs	r3, r0
    68dc:	7023      	strb	r3, [r4, #0]
	writeReg(REG_PACKETCONFIG2, RF_PACKET2_AUTORXRESTART_ON);
    68de:	2102      	movs	r1, #2
    68e0:	203d      	movs	r0, #61	; 0x3d
    68e2:	f000 f82f 	bl	6944 <writeReg>

	writeReg(REG_PALEVEL, RF_PALEVEL_OUTPUTPOWER_11111);
    68e6:	211f      	movs	r1, #31
    68e8:	2011      	movs	r0, #17
    68ea:	f000 f82b 	bl	6944 <writeReg>
	writeReg(REG_DIOMAPPING1 , RF_DIOMAPPING1_DIO0_01);
    68ee:	2140      	movs	r1, #64	; 0x40
    68f0:	2025      	movs	r0, #37	; 0x25
    68f2:	f000 f827 	bl	6944 <writeReg>
	
	//tmp_data = readReg(REG_OPMODE);
	writeReg(REG_OPMODE, RF_OPMODE_RECEIVER);
    68f6:	2110      	movs	r1, #16
    68f8:	2001      	movs	r0, #1
    68fa:	f000 f823 	bl	6944 <writeReg>
    //while ((readReg(REG_IRQFLAGS1) & RF_IRQFLAGS1_MODEREADY) == 0x00);

    //address = nodeID;
    //setAddress(address);            // setting this node id
    //setNetwork(networkID);
}
    68fe:	46c0      	nop			; (mov r8, r8)
    6900:	46bd      	mov	sp, r7
    6902:	b005      	add	sp, #20
    6904:	bd90      	pop	{r4, r7, pc}

00006906 <readReg>:
    setMode(oldMode);
}

// Read byte from register
uint8_t readReg(uint8_t addr)
{
    6906:	b590      	push	{r4, r7, lr}
    6908:	b085      	sub	sp, #20
    690a:	af00      	add	r7, sp, #0
    690c:	0002      	movs	r2, r0
    690e:	1dfb      	adds	r3, r7, #7
    6910:	701a      	strb	r2, [r3, #0]
    RF_select();
    6912:	f000 f873 	bl	69fc <RF_select>
    SPI_write(addr & 0x7F);
    6916:	1dfb      	adds	r3, r7, #7
    6918:	781b      	ldrb	r3, [r3, #0]
    691a:	227f      	movs	r2, #127	; 0x7f
    691c:	4013      	ands	r3, r2
    691e:	b2db      	uxtb	r3, r3
    6920:	0018      	movs	r0, r3
    6922:	f7ff fd2b 	bl	637c <SPI_write>
    uint8_t regval = SPI_read();
    6926:	230f      	movs	r3, #15
    6928:	18fc      	adds	r4, r7, r3
    692a:	f7ff fd47 	bl	63bc <SPI_read>
    692e:	0003      	movs	r3, r0
    6930:	7023      	strb	r3, [r4, #0]
    RF_unselect();
    6932:	f000 f86b 	bl	6a0c <RF_unselect>
    return regval;
    6936:	230f      	movs	r3, #15
    6938:	18fb      	adds	r3, r7, r3
    693a:	781b      	ldrb	r3, [r3, #0]
}
    693c:	0018      	movs	r0, r3
    693e:	46bd      	mov	sp, r7
    6940:	b005      	add	sp, #20
    6942:	bd90      	pop	{r4, r7, pc}

00006944 <writeReg>:

// Write byte to register
void writeReg(uint8_t addr, uint8_t value)
{
    6944:	b580      	push	{r7, lr}
    6946:	b082      	sub	sp, #8
    6948:	af00      	add	r7, sp, #0
    694a:	0002      	movs	r2, r0
    694c:	1dfb      	adds	r3, r7, #7
    694e:	701a      	strb	r2, [r3, #0]
    6950:	1dbb      	adds	r3, r7, #6
    6952:	1c0a      	adds	r2, r1, #0
    6954:	701a      	strb	r2, [r3, #0]
    RF_select();
    6956:	f000 f851 	bl	69fc <RF_select>
    SPI_write(addr | 0x80);
    695a:	1dfb      	adds	r3, r7, #7
    695c:	781b      	ldrb	r3, [r3, #0]
    695e:	2280      	movs	r2, #128	; 0x80
    6960:	4252      	negs	r2, r2
    6962:	4313      	orrs	r3, r2
    6964:	b2db      	uxtb	r3, r3
    6966:	0018      	movs	r0, r3
    6968:	f7ff fd08 	bl	637c <SPI_write>
    SPI_write(value);
    696c:	1dbb      	adds	r3, r7, #6
    696e:	781b      	ldrb	r3, [r3, #0]
    6970:	0018      	movs	r0, r3
    6972:	f7ff fd03 	bl	637c <SPI_write>
    RF_unselect();
    6976:	f000 f849 	bl	6a0c <RF_unselect>
}
    697a:	46c0      	nop			; (mov r8, r8)
    697c:	46bd      	mov	sp, r7
    697e:	b002      	add	sp, #8
    6980:	bd80      	pop	{r7, pc}
	...

00006984 <setHighPower>:
    }
}
    
// for RFM69HW only: you must call setHighPower(1) after rfm69_init() or else transmission won't work
void setHighPower(uint8_t onOff) 
{
    6984:	b580      	push	{r7, lr}
    6986:	b082      	sub	sp, #8
    6988:	af00      	add	r7, sp, #0
    698a:	0002      	movs	r2, r0
    698c:	1dfb      	adds	r3, r7, #7
    698e:	701a      	strb	r2, [r3, #0]
    isRFM69HW = onOff;
    6990:	4b18      	ldr	r3, [pc, #96]	; (69f4 <setHighPower+0x70>)
    6992:	1dfa      	adds	r2, r7, #7
    6994:	7812      	ldrb	r2, [r2, #0]
    6996:	701a      	strb	r2, [r3, #0]
    writeReg(REG_OCP, isRFM69HW ? RF_OCP_OFF : RF_OCP_ON);
    6998:	4b16      	ldr	r3, [pc, #88]	; (69f4 <setHighPower+0x70>)
    699a:	781b      	ldrb	r3, [r3, #0]
    699c:	2b00      	cmp	r3, #0
    699e:	d001      	beq.n	69a4 <setHighPower+0x20>
    69a0:	230f      	movs	r3, #15
    69a2:	e000      	b.n	69a6 <setHighPower+0x22>
    69a4:	231a      	movs	r3, #26
    69a6:	0019      	movs	r1, r3
    69a8:	2013      	movs	r0, #19
    69aa:	f7ff ffcb 	bl	6944 <writeReg>

    if (isRFM69HW == 1) // turning ON
    69ae:	4b11      	ldr	r3, [pc, #68]	; (69f4 <setHighPower+0x70>)
    69b0:	781b      	ldrb	r3, [r3, #0]
    69b2:	2b01      	cmp	r3, #1
    69b4:	d110      	bne.n	69d8 <setHighPower+0x54>
        writeReg(REG_PALEVEL, (readReg(REG_PALEVEL) & 0x1F) | RF_PALEVEL_PA1_ON | RF_PALEVEL_PA2_ON); // enable P1 & P2 amplifier stages
    69b6:	2011      	movs	r0, #17
    69b8:	f7ff ffa5 	bl	6906 <readReg>
    69bc:	0003      	movs	r3, r0
    69be:	b25b      	sxtb	r3, r3
    69c0:	221f      	movs	r2, #31
    69c2:	4013      	ands	r3, r2
    69c4:	b25b      	sxtb	r3, r3
    69c6:	2260      	movs	r2, #96	; 0x60
    69c8:	4313      	orrs	r3, r2
    69ca:	b25b      	sxtb	r3, r3
    69cc:	b2db      	uxtb	r3, r3
    69ce:	0019      	movs	r1, r3
    69d0:	2011      	movs	r0, #17
    69d2:	f7ff ffb7 	bl	6944 <writeReg>
    else
        writeReg(REG_PALEVEL, RF_PALEVEL_PA0_ON | RF_PALEVEL_PA1_OFF | RF_PALEVEL_PA2_OFF | powerLevel); // enable P0 only
}
    69d6:	e009      	b.n	69ec <setHighPower+0x68>
        writeReg(REG_PALEVEL, RF_PALEVEL_PA0_ON | RF_PALEVEL_PA1_OFF | RF_PALEVEL_PA2_OFF | powerLevel); // enable P0 only
    69d8:	4b07      	ldr	r3, [pc, #28]	; (69f8 <setHighPower+0x74>)
    69da:	781b      	ldrb	r3, [r3, #0]
    69dc:	2280      	movs	r2, #128	; 0x80
    69de:	4252      	negs	r2, r2
    69e0:	4313      	orrs	r3, r2
    69e2:	b2db      	uxtb	r3, r3
    69e4:	0019      	movs	r1, r3
    69e6:	2011      	movs	r0, #17
    69e8:	f7ff ffac 	bl	6944 <writeReg>
}
    69ec:	46c0      	nop			; (mov r8, r8)
    69ee:	46bd      	mov	sp, r7
    69f0:	b002      	add	sp, #8
    69f2:	bd80      	pop	{r7, pc}
    69f4:	20000010 	.word	0x20000010
    69f8:	20000011 	.word	0x20000011

000069fc <RF_select>:
    //if (!inISR) sei();
}

// Enable SPI transfer
void RF_select()
{
    69fc:	b580      	push	{r7, lr}
    69fe:	af00      	add	r7, sp, #0
    RFM_69_sel(false);
    6a00:	2000      	movs	r0, #0
    6a02:	f7ff fcab 	bl	635c <RFM_69_sel>
}
    6a06:	46c0      	nop			; (mov r8, r8)
    6a08:	46bd      	mov	sp, r7
    6a0a:	bd80      	pop	{r7, pc}

00006a0c <RF_unselect>:

// Disable SPI transfer
void RF_unselect()
{
    6a0c:	b580      	push	{r7, lr}
    6a0e:	af00      	add	r7, sp, #0
     RFM_69_sel(true);
    6a10:	2001      	movs	r0, #1
    6a12:	f7ff fca3 	bl	635c <RFM_69_sel>
}
    6a16:	46c0      	nop			; (mov r8, r8)
    6a18:	46bd      	mov	sp, r7
    6a1a:	bd80      	pop	{r7, pc}

00006a1c <data_ready>:

// Interrupt Service Routine

void data_ready()
{
    6a1c:	b590      	push	{r4, r7, lr}
    6a1e:	b083      	sub	sp, #12
    6a20:	af00      	add	r7, sp, #0
	set_led();
    6a22:	f7ff fce9 	bl	63f8 <set_led>
	//delay_ms(10);
	uint8_t read_data = readReg(REG_IRQFLAGS2);
    6a26:	1dfc      	adds	r4, r7, #7
    6a28:	2028      	movs	r0, #40	; 0x28
    6a2a:	f7ff ff6c 	bl	6906 <readReg>
    6a2e:	0003      	movs	r3, r0
    6a30:	7023      	strb	r3, [r4, #0]
	read_data = readReg(REG_RSSIVALUE);
    6a32:	1dfc      	adds	r4, r7, #7
    6a34:	2024      	movs	r0, #36	; 0x24
    6a36:	f7ff ff66 	bl	6906 <readReg>
    6a3a:	0003      	movs	r3, r0
    6a3c:	7023      	strb	r3, [r4, #0]
	read_data = readReg(REG_OPMODE);
    6a3e:	1dfc      	adds	r4, r7, #7
    6a40:	2001      	movs	r0, #1
    6a42:	f7ff ff60 	bl	6906 <readReg>
    6a46:	0003      	movs	r3, r0
    6a48:	7023      	strb	r3, [r4, #0]
	writeReg(REG_OPMODE , RF69_MODE_TX);
    6a4a:	2104      	movs	r1, #4
    6a4c:	2001      	movs	r0, #1
    6a4e:	f7ff ff79 	bl	6944 <writeReg>
	read_data = readReg(REG_IRQFLAGS1);
    6a52:	1dfc      	adds	r4, r7, #7
    6a54:	2027      	movs	r0, #39	; 0x27
    6a56:	f7ff ff56 	bl	6906 <readReg>
    6a5a:	0003      	movs	r3, r0
    6a5c:	7023      	strb	r3, [r4, #0]
	
	
	RF_select();
    6a5e:	f7ff ffcd 	bl	69fc <RF_select>
	SPI_write(REG_FIFO);
    6a62:	2000      	movs	r0, #0
    6a64:	f7ff fc8a 	bl	637c <SPI_write>
	
	RFM69_ReadBuff(&rx_header, 5);
    6a68:	4b16      	ldr	r3, [pc, #88]	; (6ac4 <data_ready+0xa8>)
    6a6a:	2105      	movs	r1, #5
    6a6c:	0018      	movs	r0, r3
    6a6e:	f7ff fc57 	bl	6320 <RFM69_ReadBuff>
	RFM69_ReadBuff(&DATA, rx_header[0]);
    6a72:	4b14      	ldr	r3, [pc, #80]	; (6ac4 <data_ready+0xa8>)
    6a74:	781b      	ldrb	r3, [r3, #0]
    6a76:	b2db      	uxtb	r3, r3
    6a78:	b29a      	uxth	r2, r3
    6a7a:	4b13      	ldr	r3, [pc, #76]	; (6ac8 <data_ready+0xac>)
    6a7c:	0011      	movs	r1, r2
    6a7e:	0018      	movs	r0, r3
    6a80:	f7ff fc4e 	bl	6320 <RFM69_ReadBuff>
	//for (uint8_t i = 0; i < 37; i++)
	//{
	//DATA[i] = SPI_read();
	//}
	//if (DATALEN < RF69_MAX_DATA_LEN) DATA[DATALEN] = 0; // add null at end of string
	RF_unselect();
    6a84:	f7ff ffc2 	bl	6a0c <RF_unselect>
	rx_ready = 1;
    6a88:	4b10      	ldr	r3, [pc, #64]	; (6acc <data_ready+0xb0>)
    6a8a:	2201      	movs	r2, #1
    6a8c:	701a      	strb	r2, [r3, #0]
	//Треба перевірити перший байт, там довжина посилки
	
	
	
	writeReg(REG_DIOMAPPING1 , 0x40);
    6a8e:	2140      	movs	r1, #64	; 0x40
    6a90:	2025      	movs	r0, #37	; 0x25
    6a92:	f7ff ff57 	bl	6944 <writeReg>
	read_data = readReg(REG_OPMODE);
    6a96:	1dfc      	adds	r4, r7, #7
    6a98:	2001      	movs	r0, #1
    6a9a:	f7ff ff34 	bl	6906 <readReg>
    6a9e:	0003      	movs	r3, r0
    6aa0:	7023      	strb	r3, [r4, #0]
	writeReg(REG_OPMODE , 0x10);
    6aa2:	2110      	movs	r1, #16
    6aa4:	2001      	movs	r0, #1
    6aa6:	f7ff ff4d 	bl	6944 <writeReg>
	while (readReg(REG_IRQFLAGS1) == 0xD9);
    6aaa:	46c0      	nop			; (mov r8, r8)
    6aac:	2027      	movs	r0, #39	; 0x27
    6aae:	f7ff ff2a 	bl	6906 <readReg>
    6ab2:	0003      	movs	r3, r0
    6ab4:	2bd9      	cmp	r3, #217	; 0xd9
    6ab6:	d0f9      	beq.n	6aac <data_ready+0x90>
        //RF_unselect();
        //setMode(RF69_MODE_STANDBY);
    //}
    //RSSI = readRSSI(0);
    //inISR = 0;
	reset_led();
    6ab8:	f7ff fca7 	bl	640a <reset_led>
}
    6abc:	46c0      	nop			; (mov r8, r8)
    6abe:	46bd      	mov	sp, r7
    6ac0:	b003      	add	sp, #12
    6ac2:	bd90      	pop	{r4, r7, pc}
    6ac4:	20000850 	.word	0x20000850
    6ac8:	20000808 	.word	0x20000808
    6acc:	20000847 	.word	0x20000847

00006ad0 <hri_port_toggle_OUT_reg>:
{
    6ad0:	b580      	push	{r7, lr}
    6ad2:	b084      	sub	sp, #16
    6ad4:	af00      	add	r7, sp, #0
    6ad6:	60f8      	str	r0, [r7, #12]
    6ad8:	607a      	str	r2, [r7, #4]
    6ada:	230b      	movs	r3, #11
    6adc:	18fb      	adds	r3, r7, r3
    6ade:	1c0a      	adds	r2, r1, #0
    6ae0:	701a      	strb	r2, [r3, #0]
	((Port *)hw)->Group[submodule_index].OUTTGL.reg = mask;
    6ae2:	230b      	movs	r3, #11
    6ae4:	18fb      	adds	r3, r7, r3
    6ae6:	781b      	ldrb	r3, [r3, #0]
    6ae8:	68fa      	ldr	r2, [r7, #12]
    6aea:	01db      	lsls	r3, r3, #7
    6aec:	18d3      	adds	r3, r2, r3
    6aee:	331c      	adds	r3, #28
    6af0:	687a      	ldr	r2, [r7, #4]
    6af2:	601a      	str	r2, [r3, #0]
}
    6af4:	46c0      	nop			; (mov r8, r8)
    6af6:	46bd      	mov	sp, r7
    6af8:	b004      	add	sp, #16
    6afa:	bd80      	pop	{r7, pc}

00006afc <_gpio_toggle_level>:
{
    6afc:	b580      	push	{r7, lr}
    6afe:	b082      	sub	sp, #8
    6b00:	af00      	add	r7, sp, #0
    6b02:	0002      	movs	r2, r0
    6b04:	6039      	str	r1, [r7, #0]
    6b06:	1dfb      	adds	r3, r7, #7
    6b08:	701a      	strb	r2, [r3, #0]
	hri_port_toggle_OUT_reg(PORT_IOBUS, port, mask);
    6b0a:	683a      	ldr	r2, [r7, #0]
    6b0c:	1dfb      	adds	r3, r7, #7
    6b0e:	7819      	ldrb	r1, [r3, #0]
    6b10:	23c0      	movs	r3, #192	; 0xc0
    6b12:	05db      	lsls	r3, r3, #23
    6b14:	0018      	movs	r0, r3
    6b16:	f7ff ffdb 	bl	6ad0 <hri_port_toggle_OUT_reg>
}
    6b1a:	46c0      	nop			; (mov r8, r8)
    6b1c:	46bd      	mov	sp, r7
    6b1e:	b002      	add	sp, #8
    6b20:	bd80      	pop	{r7, pc}

00006b22 <gpio_toggle_pin_level>:
 * Toggle the pin levels on pins defined by bit mask
 *
 * \param[in] pin       The pin number for device
 */
static inline void gpio_toggle_pin_level(const uint8_t pin)
{
    6b22:	b580      	push	{r7, lr}
    6b24:	b082      	sub	sp, #8
    6b26:	af00      	add	r7, sp, #0
    6b28:	0002      	movs	r2, r0
    6b2a:	1dfb      	adds	r3, r7, #7
    6b2c:	701a      	strb	r2, [r3, #0]
	_gpio_toggle_level((enum gpio_port)GPIO_PORT(pin), 1U << GPIO_PIN(pin));
    6b2e:	1dfb      	adds	r3, r7, #7
    6b30:	781b      	ldrb	r3, [r3, #0]
    6b32:	095b      	lsrs	r3, r3, #5
    6b34:	b2d8      	uxtb	r0, r3
    6b36:	1dfb      	adds	r3, r7, #7
    6b38:	781b      	ldrb	r3, [r3, #0]
    6b3a:	221f      	movs	r2, #31
    6b3c:	4013      	ands	r3, r2
    6b3e:	2201      	movs	r2, #1
    6b40:	409a      	lsls	r2, r3
    6b42:	0013      	movs	r3, r2
    6b44:	0019      	movs	r1, r3
    6b46:	f7ff ffd9 	bl	6afc <_gpio_toggle_level>
}
    6b4a:	46c0      	nop			; (mov r8, r8)
    6b4c:	46bd      	mov	sp, r7
    6b4e:	b002      	add	sp, #8
    6b50:	bd80      	pop	{r7, pc}
	...

00006b54 <main>:
u8g2_t u8g2;

uint16_t seco, mine, hour;

int main(void)
{
    6b54:	b5f0      	push	{r4, r5, r6, r7, lr}
    6b56:	b0a5      	sub	sp, #148	; 0x94
    6b58:	af04      	add	r7, sp, #16
	/* Initializes MCU, drivers and middleware */
	atmel_start_init();
    6b5a:	f7f9 fad3 	bl	104 <atmel_start_init>
	
	EXT_SPI_init();
    6b5e:	f7ff fc5d 	bl	641c <EXT_SPI_init>
	
	RF_SPI_init();
    6b62:	f7ff fd83 	bl	666c <RF_SPI_init>
	
	rfm69_init(868, NODEID, NETWORKID);
    6b66:	23d9      	movs	r3, #217	; 0xd9
    6b68:	009b      	lsls	r3, r3, #2
    6b6a:	2221      	movs	r2, #33	; 0x21
    6b6c:	2103      	movs	r1, #3
    6b6e:	0018      	movs	r0, r3
    6b70:	f7ff fe36 	bl	67e0 <rfm69_init>
	setHighPower(true);
    6b74:	2001      	movs	r0, #1
    6b76:	f7ff ff05 	bl	6984 <setHighPower>
	
	
	
	//EXTERNAL_IRQ_0_example();
	
	uint8_t debug_str[] = "                    \n\r";
    6b7a:	2368      	movs	r3, #104	; 0x68
    6b7c:	18fb      	adds	r3, r7, r3
    6b7e:	4a9f      	ldr	r2, [pc, #636]	; (6dfc <main+0x2a8>)
    6b80:	ca13      	ldmia	r2!, {r0, r1, r4}
    6b82:	c313      	stmia	r3!, {r0, r1, r4}
    6b84:	ca03      	ldmia	r2!, {r0, r1}
    6b86:	c303      	stmia	r3!, {r0, r1}
    6b88:	8811      	ldrh	r1, [r2, #0]
    6b8a:	8019      	strh	r1, [r3, #0]
    6b8c:	7892      	ldrb	r2, [r2, #2]
    6b8e:	709a      	strb	r2, [r3, #2]
	uint8_t rf_str[] =    "                    \n\r";
    6b90:	2350      	movs	r3, #80	; 0x50
    6b92:	18fb      	adds	r3, r7, r3
    6b94:	4a99      	ldr	r2, [pc, #612]	; (6dfc <main+0x2a8>)
    6b96:	ca13      	ldmia	r2!, {r0, r1, r4}
    6b98:	c313      	stmia	r3!, {r0, r1, r4}
    6b9a:	ca03      	ldmia	r2!, {r0, r1}
    6b9c:	c303      	stmia	r3!, {r0, r1}
    6b9e:	8811      	ldrh	r1, [r2, #0]
    6ba0:	8019      	strh	r1, [r3, #0]
    6ba2:	7892      	ldrb	r2, [r2, #2]
    6ba4:	709a      	strb	r2, [r3, #2]
	
	
	
	//LED_Panel
		uint8_t addr;
		uint8_t panel_addr = 0x64;
    6ba6:	237f      	movs	r3, #127	; 0x7f
    6ba8:	18fb      	adds	r3, r7, r3
    6baa:	2264      	movs	r2, #100	; 0x64
    6bac:	701a      	strb	r2, [r3, #0]
		#define  r_part 2
		#define  g_part 1
		#define  b_part 3
		
		uint8_t reset_cmd[] = {0xa5, 0x5a};
    6bae:	234c      	movs	r3, #76	; 0x4c
    6bb0:	18fb      	adds	r3, r7, r3
    6bb2:	4a93      	ldr	r2, [pc, #588]	; (6e00 <main+0x2ac>)
    6bb4:	8812      	ldrh	r2, [r2, #0]
    6bb6:	801a      	strh	r2, [r3, #0]
		uint8_t init_cmd[] = {0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0xAA, 0xAA, 0xAA, 0xAA};
    6bb8:	2330      	movs	r3, #48	; 0x30
    6bba:	18fb      	adds	r3, r7, r3
    6bbc:	4a91      	ldr	r2, [pc, #580]	; (6e04 <main+0x2b0>)
    6bbe:	ca13      	ldmia	r2!, {r0, r1, r4}
    6bc0:	c313      	stmia	r3!, {r0, r1, r4}
    6bc2:	ca13      	ldmia	r2!, {r0, r1, r4}
    6bc4:	c313      	stmia	r3!, {r0, r1, r4}
    6bc6:	7812      	ldrb	r2, [r2, #0]
    6bc8:	701a      	strb	r2, [r3, #0]
		uint8_t led_data[] = {0xa2, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f};
    6bca:	231c      	movs	r3, #28
    6bcc:	18fb      	adds	r3, r7, r3
    6bce:	4a8e      	ldr	r2, [pc, #568]	; (6e08 <main+0x2b4>)
    6bd0:	ca13      	ldmia	r2!, {r0, r1, r4}
    6bd2:	c313      	stmia	r3!, {r0, r1, r4}
    6bd4:	6811      	ldr	r1, [r2, #0]
    6bd6:	6019      	str	r1, [r3, #0]
    6bd8:	7912      	ldrb	r2, [r2, #4]
    6bda:	711a      	strb	r2, [r3, #4]
		
		uint8_t led1[]= {0xa2, 0, 0, 0};
    6bdc:	2318      	movs	r3, #24
    6bde:	18fb      	adds	r3, r7, r3
    6be0:	22a2      	movs	r2, #162	; 0xa2
    6be2:	701a      	strb	r2, [r3, #0]
    6be4:	2318      	movs	r3, #24
    6be6:	18fb      	adds	r3, r7, r3
    6be8:	2200      	movs	r2, #0
    6bea:	705a      	strb	r2, [r3, #1]
    6bec:	2318      	movs	r3, #24
    6bee:	18fb      	adds	r3, r7, r3
    6bf0:	2200      	movs	r2, #0
    6bf2:	709a      	strb	r2, [r3, #2]
    6bf4:	2318      	movs	r3, #24
    6bf6:	18fb      	adds	r3, r7, r3
    6bf8:	2200      	movs	r2, #0
    6bfa:	70da      	strb	r2, [r3, #3]
		uint8_t led2[]= {0xa5, 0, 0, 0};
    6bfc:	2314      	movs	r3, #20
    6bfe:	18fb      	adds	r3, r7, r3
    6c00:	22a5      	movs	r2, #165	; 0xa5
    6c02:	701a      	strb	r2, [r3, #0]
    6c04:	2314      	movs	r3, #20
    6c06:	18fb      	adds	r3, r7, r3
    6c08:	2200      	movs	r2, #0
    6c0a:	705a      	strb	r2, [r3, #1]
    6c0c:	2314      	movs	r3, #20
    6c0e:	18fb      	adds	r3, r7, r3
    6c10:	2200      	movs	r2, #0
    6c12:	709a      	strb	r2, [r3, #2]
    6c14:	2314      	movs	r3, #20
    6c16:	18fb      	adds	r3, r7, r3
    6c18:	2200      	movs	r2, #0
    6c1a:	70da      	strb	r2, [r3, #3]
		
		uint8_t led3[]= {0xa8, 0, 0, 0};
    6c1c:	2310      	movs	r3, #16
    6c1e:	18fb      	adds	r3, r7, r3
    6c20:	22a8      	movs	r2, #168	; 0xa8
    6c22:	701a      	strb	r2, [r3, #0]
    6c24:	2310      	movs	r3, #16
    6c26:	18fb      	adds	r3, r7, r3
    6c28:	2200      	movs	r2, #0
    6c2a:	705a      	strb	r2, [r3, #1]
    6c2c:	2310      	movs	r3, #16
    6c2e:	18fb      	adds	r3, r7, r3
    6c30:	2200      	movs	r2, #0
    6c32:	709a      	strb	r2, [r3, #2]
    6c34:	2310      	movs	r3, #16
    6c36:	18fb      	adds	r3, r7, r3
    6c38:	2200      	movs	r2, #0
    6c3a:	70da      	strb	r2, [r3, #3]
		uint8_t led4[]= {0xab, 0, 25, 0};
    6c3c:	230c      	movs	r3, #12
    6c3e:	18fb      	adds	r3, r7, r3
    6c40:	4a72      	ldr	r2, [pc, #456]	; (6e0c <main+0x2b8>)
    6c42:	6812      	ldr	r2, [r2, #0]
    6c44:	601a      	str	r2, [r3, #0]
		uint8_t led5[]= {0xae, 0, 25, 0};
    6c46:	2308      	movs	r3, #8
    6c48:	18fb      	adds	r3, r7, r3
    6c4a:	4a71      	ldr	r2, [pc, #452]	; (6e10 <main+0x2bc>)
    6c4c:	6812      	ldr	r2, [r2, #0]
    6c4e:	601a      	str	r2, [r3, #0]
		uint8_t ext_led[] = {0xb1, 64};
    6c50:	1d3b      	adds	r3, r7, #4
    6c52:	4a70      	ldr	r2, [pc, #448]	; (6e14 <main+0x2c0>)
    6c54:	8812      	ldrh	r2, [r2, #0]
    6c56:	801a      	strh	r2, [r3, #0]
	//End LED Panel
	
	
	
	u8g2_Setup_gp1287ai_256x50_f(&u8g2, U8G2_R0, vfd_spi, u8x8_avr_gpio_and_delay);
    6c58:	4b6f      	ldr	r3, [pc, #444]	; (6e18 <main+0x2c4>)
    6c5a:	4a70      	ldr	r2, [pc, #448]	; (6e1c <main+0x2c8>)
    6c5c:	4970      	ldr	r1, [pc, #448]	; (6e20 <main+0x2cc>)
    6c5e:	4871      	ldr	r0, [pc, #452]	; (6e24 <main+0x2d0>)
    6c60:	f7f9 fe58 	bl	914 <u8g2_Setup_gp1287ai_256x50_f>
	u8g2_InitDisplay(&u8g2);
    6c64:	4b6f      	ldr	r3, [pc, #444]	; (6e24 <main+0x2d0>)
    6c66:	0018      	movs	r0, r3
    6c68:	f7fb fe25 	bl	28b6 <u8x8_InitDisplay>
	
	u8g2_SetPowerSave(&u8g2, 0);
    6c6c:	4b6d      	ldr	r3, [pc, #436]	; (6e24 <main+0x2d0>)
    6c6e:	2100      	movs	r1, #0
    6c70:	0018      	movs	r0, r3
    6c72:	f7fb fe2f 	bl	28d4 <u8x8_SetPowerSave>
	u8g2_SetContrast(&u8g2, 5);
    6c76:	4b6b      	ldr	r3, [pc, #428]	; (6e24 <main+0x2d0>)
    6c78:	2105      	movs	r1, #5
    6c7a:	0018      	movs	r0, r3
    6c7c:	f7fb fe3d 	bl	28fa <u8x8_SetContrast>
	//WDT_CLEAR_CLEAR(0x5a);
	
	u8g2_ClearBuffer(&u8g2);
    6c80:	4b68      	ldr	r3, [pc, #416]	; (6e24 <main+0x2d0>)
    6c82:	0018      	movs	r0, r3
    6c84:	f7f9 fbb9 	bl	3fa <u8g2_ClearBuffer>
	//WDT->CLEAR.reg=0x5a;
	//u8g2_SetFont(&u8g2, u8g2_font_ncenB14_tr);
	//u8g2_SetFont(&u8g2, u8g2_font_courR08_tr);
	//u8g2_SetFont(&u8g2, u8g2_font_cu12_t_symbols);
	u8g2_SetFont(&u8g2, u8g2_font_Terminal_tr);
    6c88:	4a67      	ldr	r2, [pc, #412]	; (6e28 <main+0x2d4>)
    6c8a:	4b66      	ldr	r3, [pc, #408]	; (6e24 <main+0x2d0>)
    6c8c:	0011      	movs	r1, r2
    6c8e:	0018      	movs	r0, r3
    6c90:	f7fa fddc 	bl	184c <u8g2_SetFont>
	//u8g2_SetFont(&u8g2, u8g2_font_battery19_tn); //battery icons
	
	/* Replace with your application code */
	
		
	 GCLK->CLKCTRL.reg = GCLK_CLKCTRL_ID_WDT |
    6c94:	4b65      	ldr	r3, [pc, #404]	; (6e2c <main+0x2d8>)
    6c96:	4a66      	ldr	r2, [pc, #408]	; (6e30 <main+0x2dc>)
    6c98:	805a      	strh	r2, [r3, #2]
	 GCLK_CLKCTRL_CLKEN |
	 GCLK_CLKCTRL_GEN_GCLK3;	
	//WDT->INTENSET.bit.EW  = 0;      // Enable early warning interrupt
	//WDT->EWCTRL.bit.EWOFFSET = 0x0B;  // Early Warning Interrupt Time Offset 0xA
	//WDT->CONFIG.bit.PER    = 0xB;  // Set period for chip reset 0xB 16384 clock cycles
	WDT->CLEAR.bit.CLEAR = 0xA5;
    6c9a:	4b66      	ldr	r3, [pc, #408]	; (6e34 <main+0x2e0>)
    6c9c:	22a5      	movs	r2, #165	; 0xa5
    6c9e:	721a      	strb	r2, [r3, #8]
	//while(WDT->STATUS.bit.SYNCBUSY);

	
	while (1) {
	
		WDT->CLEAR.bit.CLEAR = 0xA5;
    6ca0:	4b64      	ldr	r3, [pc, #400]	; (6e34 <main+0x2e0>)
    6ca2:	22a5      	movs	r2, #165	; 0xa5
    6ca4:	721a      	strb	r2, [r3, #8]
		while(WDT->STATUS.bit.SYNCBUSY);
    6ca6:	46c0      	nop			; (mov r8, r8)
    6ca8:	4b62      	ldr	r3, [pc, #392]	; (6e34 <main+0x2e0>)
    6caa:	79db      	ldrb	r3, [r3, #7]
    6cac:	061b      	lsls	r3, r3, #24
    6cae:	0fdb      	lsrs	r3, r3, #31
    6cb0:	b2db      	uxtb	r3, r3
    6cb2:	2b00      	cmp	r3, #0
    6cb4:	d1f8      	bne.n	6ca8 <main+0x154>
		gpio_toggle_pin_level(LED_G);		
    6cb6:	2020      	movs	r0, #32
    6cb8:	f7ff ff33 	bl	6b22 <gpio_toggle_pin_level>
		//
		//gpio_toggle_pin_level(LED_G);
		//gpio_toggle_pin_level(LED_SD);
		//gpio_toggle_pin_level(LED_R);
		
		u8g2_ClearBuffer(&u8g2);
    6cbc:	4b59      	ldr	r3, [pc, #356]	; (6e24 <main+0x2d0>)
    6cbe:	0018      	movs	r0, r3
    6cc0:	f7f9 fb9b 	bl	3fa <u8g2_ClearBuffer>
		u8g2_DrawRFrame(&u8g2, 0, 0, 256 ,48, 5);
    6cc4:	2380      	movs	r3, #128	; 0x80
    6cc6:	005a      	lsls	r2, r3, #1
    6cc8:	4856      	ldr	r0, [pc, #344]	; (6e24 <main+0x2d0>)
    6cca:	2305      	movs	r3, #5
    6ccc:	9301      	str	r3, [sp, #4]
    6cce:	2330      	movs	r3, #48	; 0x30
    6cd0:	9300      	str	r3, [sp, #0]
    6cd2:	0013      	movs	r3, r2
    6cd4:	2200      	movs	r2, #0
    6cd6:	2100      	movs	r1, #0
    6cd8:	f7f9 fa1b 	bl	112 <u8g2_DrawRFrame>
		u8g2_DrawStr(&u8g2, 60, 11, (char *)"ATMEL SAMD20 (48MHz)");
    6cdc:	4b56      	ldr	r3, [pc, #344]	; (6e38 <main+0x2e4>)
    6cde:	4851      	ldr	r0, [pc, #324]	; (6e24 <main+0x2d0>)
    6ce0:	220b      	movs	r2, #11
    6ce2:	213c      	movs	r1, #60	; 0x3c
    6ce4:	f7fa fd0c 	bl	1700 <u8g2_DrawStr>
		u8g2_DrawLine(&u8g2, 3,12, 252,12);
    6ce8:	484e      	ldr	r0, [pc, #312]	; (6e24 <main+0x2d0>)
    6cea:	230c      	movs	r3, #12
    6cec:	9300      	str	r3, [sp, #0]
    6cee:	23fc      	movs	r3, #252	; 0xfc
    6cf0:	220c      	movs	r2, #12
    6cf2:	2103      	movs	r1, #3
    6cf4:	f7fb f830 	bl	1d58 <u8g2_DrawLine>
		
		
		sprintf(debug_str, "INT:%04d; tim:%03d:%02d:%02d " , rf_isReady(), hour,mine,seco);
    6cf8:	f7ff faf8 	bl	62ec <rf_isReady>
    6cfc:	0003      	movs	r3, r0
    6cfe:	001c      	movs	r4, r3
    6d00:	4b4e      	ldr	r3, [pc, #312]	; (6e3c <main+0x2e8>)
    6d02:	881b      	ldrh	r3, [r3, #0]
    6d04:	001d      	movs	r5, r3
    6d06:	4b4e      	ldr	r3, [pc, #312]	; (6e40 <main+0x2ec>)
    6d08:	881b      	ldrh	r3, [r3, #0]
    6d0a:	001a      	movs	r2, r3
    6d0c:	4b4d      	ldr	r3, [pc, #308]	; (6e44 <main+0x2f0>)
    6d0e:	881b      	ldrh	r3, [r3, #0]
    6d10:	494d      	ldr	r1, [pc, #308]	; (6e48 <main+0x2f4>)
    6d12:	2068      	movs	r0, #104	; 0x68
    6d14:	1838      	adds	r0, r7, r0
    6d16:	9301      	str	r3, [sp, #4]
    6d18:	9200      	str	r2, [sp, #0]
    6d1a:	002b      	movs	r3, r5
    6d1c:	0022      	movs	r2, r4
    6d1e:	f000 f963 	bl	6fe8 <siprintf>
		u8g2_DrawStr(&u8g2, 3, 23, (char *)debug_str);
    6d22:	2368      	movs	r3, #104	; 0x68
    6d24:	18fb      	adds	r3, r7, r3
    6d26:	483f      	ldr	r0, [pc, #252]	; (6e24 <main+0x2d0>)
    6d28:	2217      	movs	r2, #23
    6d2a:	2103      	movs	r1, #3
    6d2c:	f7fa fce8 	bl	1700 <u8g2_DrawStr>
		u8g2_DrawStr(&u8g2, 3, 34, (char *)rf_str);
    6d30:	2350      	movs	r3, #80	; 0x50
    6d32:	18fb      	adds	r3, r7, r3
    6d34:	483b      	ldr	r0, [pc, #236]	; (6e24 <main+0x2d0>)
    6d36:	2222      	movs	r2, #34	; 0x22
    6d38:	2103      	movs	r1, #3
    6d3a:	f7fa fce1 	bl	1700 <u8g2_DrawStr>
		u8g2_DrawStr(&u8g2, 3, 44, (char *)DATA);
    6d3e:	4b43      	ldr	r3, [pc, #268]	; (6e4c <main+0x2f8>)
    6d40:	4838      	ldr	r0, [pc, #224]	; (6e24 <main+0x2d0>)
    6d42:	222c      	movs	r2, #44	; 0x2c
    6d44:	2103      	movs	r1, #3
    6d46:	f7fa fcdb 	bl	1700 <u8g2_DrawStr>
		u8g2_SendBuffer(&u8g2);
    6d4a:	4b36      	ldr	r3, [pc, #216]	; (6e24 <main+0x2d0>)
    6d4c:	0018      	movs	r0, r3
    6d4e:	f7f9 fbf9 	bl	544 <u8g2_SendBuffer>
		
		//seco == 999 ? seco=0 : seco++;
		seco++;
    6d52:	4b3c      	ldr	r3, [pc, #240]	; (6e44 <main+0x2f0>)
    6d54:	881b      	ldrh	r3, [r3, #0]
    6d56:	3301      	adds	r3, #1
    6d58:	b29a      	uxth	r2, r3
    6d5a:	4b3a      	ldr	r3, [pc, #232]	; (6e44 <main+0x2f0>)
    6d5c:	801a      	strh	r2, [r3, #0]
		if(seco==60){
    6d5e:	4b39      	ldr	r3, [pc, #228]	; (6e44 <main+0x2f0>)
    6d60:	881b      	ldrh	r3, [r3, #0]
    6d62:	2b3c      	cmp	r3, #60	; 0x3c
    6d64:	d116      	bne.n	6d94 <main+0x240>
			u8g2_InitDisplay(&u8g2);
    6d66:	4b2f      	ldr	r3, [pc, #188]	; (6e24 <main+0x2d0>)
    6d68:	0018      	movs	r0, r3
    6d6a:	f7fb fda4 	bl	28b6 <u8x8_InitDisplay>
			u8g2_SetPowerSave(&u8g2, 0);
    6d6e:	4b2d      	ldr	r3, [pc, #180]	; (6e24 <main+0x2d0>)
    6d70:	2100      	movs	r1, #0
    6d72:	0018      	movs	r0, r3
    6d74:	f7fb fdae 	bl	28d4 <u8x8_SetPowerSave>
			u8g2_SetContrast(&u8g2, 5);
    6d78:	4b2a      	ldr	r3, [pc, #168]	; (6e24 <main+0x2d0>)
    6d7a:	2105      	movs	r1, #5
    6d7c:	0018      	movs	r0, r3
    6d7e:	f7fb fdbc 	bl	28fa <u8x8_SetContrast>
			
			mine++;
    6d82:	4b2f      	ldr	r3, [pc, #188]	; (6e40 <main+0x2ec>)
    6d84:	881b      	ldrh	r3, [r3, #0]
    6d86:	3301      	adds	r3, #1
    6d88:	b29a      	uxth	r2, r3
    6d8a:	4b2d      	ldr	r3, [pc, #180]	; (6e40 <main+0x2ec>)
    6d8c:	801a      	strh	r2, [r3, #0]
			seco=0;
    6d8e:	4b2d      	ldr	r3, [pc, #180]	; (6e44 <main+0x2f0>)
    6d90:	2200      	movs	r2, #0
    6d92:	801a      	strh	r2, [r3, #0]
		}
		if(mine==60){
    6d94:	4b2a      	ldr	r3, [pc, #168]	; (6e40 <main+0x2ec>)
    6d96:	881b      	ldrh	r3, [r3, #0]
    6d98:	2b3c      	cmp	r3, #60	; 0x3c
    6d9a:	d108      	bne.n	6dae <main+0x25a>
			hour++;
    6d9c:	4b27      	ldr	r3, [pc, #156]	; (6e3c <main+0x2e8>)
    6d9e:	881b      	ldrh	r3, [r3, #0]
    6da0:	3301      	adds	r3, #1
    6da2:	b29a      	uxth	r2, r3
    6da4:	4b25      	ldr	r3, [pc, #148]	; (6e3c <main+0x2e8>)
    6da6:	801a      	strh	r2, [r3, #0]
			mine=0;
    6da8:	4b25      	ldr	r3, [pc, #148]	; (6e40 <main+0x2ec>)
    6daa:	2200      	movs	r2, #0
    6dac:	801a      	strh	r2, [r3, #0]
		}
		if (rx_ready) {
    6dae:	4b28      	ldr	r3, [pc, #160]	; (6e50 <main+0x2fc>)
    6db0:	781b      	ldrb	r3, [r3, #0]
    6db2:	b2db      	uxtb	r3, r3
    6db4:	2b00      	cmp	r3, #0
    6db6:	d100      	bne.n	6dba <main+0x266>
    6db8:	e772      	b.n	6ca0 <main+0x14c>
			sprintf((char *)rf_str , "%02d/%02d/%02d/%02d/%02d    ",  rx_header[0], rx_header[1], rx_header[2],  rx_header[3],  rx_header[4]);
    6dba:	4b26      	ldr	r3, [pc, #152]	; (6e54 <main+0x300>)
    6dbc:	781b      	ldrb	r3, [r3, #0]
    6dbe:	b2db      	uxtb	r3, r3
    6dc0:	001d      	movs	r5, r3
    6dc2:	4b24      	ldr	r3, [pc, #144]	; (6e54 <main+0x300>)
    6dc4:	785b      	ldrb	r3, [r3, #1]
    6dc6:	b2db      	uxtb	r3, r3
    6dc8:	001e      	movs	r6, r3
    6dca:	4b22      	ldr	r3, [pc, #136]	; (6e54 <main+0x300>)
    6dcc:	789b      	ldrb	r3, [r3, #2]
    6dce:	b2db      	uxtb	r3, r3
    6dd0:	001a      	movs	r2, r3
    6dd2:	4b20      	ldr	r3, [pc, #128]	; (6e54 <main+0x300>)
    6dd4:	78db      	ldrb	r3, [r3, #3]
    6dd6:	b2db      	uxtb	r3, r3
    6dd8:	001c      	movs	r4, r3
    6dda:	4b1e      	ldr	r3, [pc, #120]	; (6e54 <main+0x300>)
    6ddc:	791b      	ldrb	r3, [r3, #4]
    6dde:	b2db      	uxtb	r3, r3
    6de0:	491d      	ldr	r1, [pc, #116]	; (6e58 <main+0x304>)
    6de2:	2050      	movs	r0, #80	; 0x50
    6de4:	1838      	adds	r0, r7, r0
    6de6:	9302      	str	r3, [sp, #8]
    6de8:	9401      	str	r4, [sp, #4]
    6dea:	9200      	str	r2, [sp, #0]
    6dec:	0033      	movs	r3, r6
    6dee:	002a      	movs	r2, r5
    6df0:	f000 f8fa 	bl	6fe8 <siprintf>
			//u8g2_DrawRFrame(&u8g2, 200, 4, 40 ,40, 5);
			//u8g2_DrawStr(&u8g2, 3, 34, (char *)debug_str);
			//u8g2_DrawStr(&u8g2, 3, 44, (char *)DATA);
			
			//u8g2_SendBuffer(&u8g2);
			rx_ready = 0;
    6df4:	4b16      	ldr	r3, [pc, #88]	; (6e50 <main+0x2fc>)
    6df6:	2200      	movs	r2, #0
    6df8:	701a      	strb	r2, [r3, #0]
		WDT->CLEAR.bit.CLEAR = 0xA5;
    6dfa:	e751      	b.n	6ca0 <main+0x14c>
    6dfc:	00007f38 	.word	0x00007f38
    6e00:	00007f50 	.word	0x00007f50
    6e04:	00007f54 	.word	0x00007f54
    6e08:	00007f70 	.word	0x00007f70
    6e0c:	00007f84 	.word	0x00007f84
    6e10:	00007f88 	.word	0x00007f88
    6e14:	00007f8c 	.word	0x00007f8c
    6e18:	00006595 	.word	0x00006595
    6e1c:	000065e9 	.word	0x000065e9
    6e20:	00007cbc 	.word	0x00007cbc
    6e24:	20000860 	.word	0x20000860
    6e28:	00007828 	.word	0x00007828
    6e2c:	40000c00 	.word	0x40000c00
    6e30:	00004301 	.word	0x00004301
    6e34:	40001000 	.word	0x40001000
    6e38:	00007ee0 	.word	0x00007ee0
    6e3c:	200008f4 	.word	0x200008f4
    6e40:	2000085c 	.word	0x2000085c
    6e44:	200008f6 	.word	0x200008f6
    6e48:	00007ef8 	.word	0x00007ef8
    6e4c:	20000808 	.word	0x20000808
    6e50:	20000847 	.word	0x20000847
    6e54:	20000850 	.word	0x20000850
    6e58:	00007f18 	.word	0x00007f18

00006e5c <__udivsi3>:
    6e5c:	2200      	movs	r2, #0
    6e5e:	0843      	lsrs	r3, r0, #1
    6e60:	428b      	cmp	r3, r1
    6e62:	d374      	bcc.n	6f4e <__udivsi3+0xf2>
    6e64:	0903      	lsrs	r3, r0, #4
    6e66:	428b      	cmp	r3, r1
    6e68:	d35f      	bcc.n	6f2a <__udivsi3+0xce>
    6e6a:	0a03      	lsrs	r3, r0, #8
    6e6c:	428b      	cmp	r3, r1
    6e6e:	d344      	bcc.n	6efa <__udivsi3+0x9e>
    6e70:	0b03      	lsrs	r3, r0, #12
    6e72:	428b      	cmp	r3, r1
    6e74:	d328      	bcc.n	6ec8 <__udivsi3+0x6c>
    6e76:	0c03      	lsrs	r3, r0, #16
    6e78:	428b      	cmp	r3, r1
    6e7a:	d30d      	bcc.n	6e98 <__udivsi3+0x3c>
    6e7c:	22ff      	movs	r2, #255	; 0xff
    6e7e:	0209      	lsls	r1, r1, #8
    6e80:	ba12      	rev	r2, r2
    6e82:	0c03      	lsrs	r3, r0, #16
    6e84:	428b      	cmp	r3, r1
    6e86:	d302      	bcc.n	6e8e <__udivsi3+0x32>
    6e88:	1212      	asrs	r2, r2, #8
    6e8a:	0209      	lsls	r1, r1, #8
    6e8c:	d065      	beq.n	6f5a <__udivsi3+0xfe>
    6e8e:	0b03      	lsrs	r3, r0, #12
    6e90:	428b      	cmp	r3, r1
    6e92:	d319      	bcc.n	6ec8 <__udivsi3+0x6c>
    6e94:	e000      	b.n	6e98 <__udivsi3+0x3c>
    6e96:	0a09      	lsrs	r1, r1, #8
    6e98:	0bc3      	lsrs	r3, r0, #15
    6e9a:	428b      	cmp	r3, r1
    6e9c:	d301      	bcc.n	6ea2 <__udivsi3+0x46>
    6e9e:	03cb      	lsls	r3, r1, #15
    6ea0:	1ac0      	subs	r0, r0, r3
    6ea2:	4152      	adcs	r2, r2
    6ea4:	0b83      	lsrs	r3, r0, #14
    6ea6:	428b      	cmp	r3, r1
    6ea8:	d301      	bcc.n	6eae <__udivsi3+0x52>
    6eaa:	038b      	lsls	r3, r1, #14
    6eac:	1ac0      	subs	r0, r0, r3
    6eae:	4152      	adcs	r2, r2
    6eb0:	0b43      	lsrs	r3, r0, #13
    6eb2:	428b      	cmp	r3, r1
    6eb4:	d301      	bcc.n	6eba <__udivsi3+0x5e>
    6eb6:	034b      	lsls	r3, r1, #13
    6eb8:	1ac0      	subs	r0, r0, r3
    6eba:	4152      	adcs	r2, r2
    6ebc:	0b03      	lsrs	r3, r0, #12
    6ebe:	428b      	cmp	r3, r1
    6ec0:	d301      	bcc.n	6ec6 <__udivsi3+0x6a>
    6ec2:	030b      	lsls	r3, r1, #12
    6ec4:	1ac0      	subs	r0, r0, r3
    6ec6:	4152      	adcs	r2, r2
    6ec8:	0ac3      	lsrs	r3, r0, #11
    6eca:	428b      	cmp	r3, r1
    6ecc:	d301      	bcc.n	6ed2 <__udivsi3+0x76>
    6ece:	02cb      	lsls	r3, r1, #11
    6ed0:	1ac0      	subs	r0, r0, r3
    6ed2:	4152      	adcs	r2, r2
    6ed4:	0a83      	lsrs	r3, r0, #10
    6ed6:	428b      	cmp	r3, r1
    6ed8:	d301      	bcc.n	6ede <__udivsi3+0x82>
    6eda:	028b      	lsls	r3, r1, #10
    6edc:	1ac0      	subs	r0, r0, r3
    6ede:	4152      	adcs	r2, r2
    6ee0:	0a43      	lsrs	r3, r0, #9
    6ee2:	428b      	cmp	r3, r1
    6ee4:	d301      	bcc.n	6eea <__udivsi3+0x8e>
    6ee6:	024b      	lsls	r3, r1, #9
    6ee8:	1ac0      	subs	r0, r0, r3
    6eea:	4152      	adcs	r2, r2
    6eec:	0a03      	lsrs	r3, r0, #8
    6eee:	428b      	cmp	r3, r1
    6ef0:	d301      	bcc.n	6ef6 <__udivsi3+0x9a>
    6ef2:	020b      	lsls	r3, r1, #8
    6ef4:	1ac0      	subs	r0, r0, r3
    6ef6:	4152      	adcs	r2, r2
    6ef8:	d2cd      	bcs.n	6e96 <__udivsi3+0x3a>
    6efa:	09c3      	lsrs	r3, r0, #7
    6efc:	428b      	cmp	r3, r1
    6efe:	d301      	bcc.n	6f04 <__udivsi3+0xa8>
    6f00:	01cb      	lsls	r3, r1, #7
    6f02:	1ac0      	subs	r0, r0, r3
    6f04:	4152      	adcs	r2, r2
    6f06:	0983      	lsrs	r3, r0, #6
    6f08:	428b      	cmp	r3, r1
    6f0a:	d301      	bcc.n	6f10 <__udivsi3+0xb4>
    6f0c:	018b      	lsls	r3, r1, #6
    6f0e:	1ac0      	subs	r0, r0, r3
    6f10:	4152      	adcs	r2, r2
    6f12:	0943      	lsrs	r3, r0, #5
    6f14:	428b      	cmp	r3, r1
    6f16:	d301      	bcc.n	6f1c <__udivsi3+0xc0>
    6f18:	014b      	lsls	r3, r1, #5
    6f1a:	1ac0      	subs	r0, r0, r3
    6f1c:	4152      	adcs	r2, r2
    6f1e:	0903      	lsrs	r3, r0, #4
    6f20:	428b      	cmp	r3, r1
    6f22:	d301      	bcc.n	6f28 <__udivsi3+0xcc>
    6f24:	010b      	lsls	r3, r1, #4
    6f26:	1ac0      	subs	r0, r0, r3
    6f28:	4152      	adcs	r2, r2
    6f2a:	08c3      	lsrs	r3, r0, #3
    6f2c:	428b      	cmp	r3, r1
    6f2e:	d301      	bcc.n	6f34 <__udivsi3+0xd8>
    6f30:	00cb      	lsls	r3, r1, #3
    6f32:	1ac0      	subs	r0, r0, r3
    6f34:	4152      	adcs	r2, r2
    6f36:	0883      	lsrs	r3, r0, #2
    6f38:	428b      	cmp	r3, r1
    6f3a:	d301      	bcc.n	6f40 <__udivsi3+0xe4>
    6f3c:	008b      	lsls	r3, r1, #2
    6f3e:	1ac0      	subs	r0, r0, r3
    6f40:	4152      	adcs	r2, r2
    6f42:	0843      	lsrs	r3, r0, #1
    6f44:	428b      	cmp	r3, r1
    6f46:	d301      	bcc.n	6f4c <__udivsi3+0xf0>
    6f48:	004b      	lsls	r3, r1, #1
    6f4a:	1ac0      	subs	r0, r0, r3
    6f4c:	4152      	adcs	r2, r2
    6f4e:	1a41      	subs	r1, r0, r1
    6f50:	d200      	bcs.n	6f54 <__udivsi3+0xf8>
    6f52:	4601      	mov	r1, r0
    6f54:	4152      	adcs	r2, r2
    6f56:	4610      	mov	r0, r2
    6f58:	4770      	bx	lr
    6f5a:	e7ff      	b.n	6f5c <__udivsi3+0x100>
    6f5c:	b501      	push	{r0, lr}
    6f5e:	2000      	movs	r0, #0
    6f60:	f000 f806 	bl	6f70 <__aeabi_idiv0>
    6f64:	bd02      	pop	{r1, pc}
    6f66:	46c0      	nop			; (mov r8, r8)

00006f68 <__aeabi_uidivmod>:
    6f68:	2900      	cmp	r1, #0
    6f6a:	d0f7      	beq.n	6f5c <__udivsi3+0x100>
    6f6c:	e776      	b.n	6e5c <__udivsi3>
    6f6e:	4770      	bx	lr

00006f70 <__aeabi_idiv0>:
    6f70:	4770      	bx	lr
    6f72:	46c0      	nop			; (mov r8, r8)

00006f74 <ffs>:
    6f74:	2300      	movs	r3, #0
    6f76:	b510      	push	{r4, lr}
    6f78:	4298      	cmp	r0, r3
    6f7a:	d007      	beq.n	6f8c <ffs+0x18>
    6f7c:	001a      	movs	r2, r3
    6f7e:	2101      	movs	r1, #1
    6f80:	0004      	movs	r4, r0
    6f82:	4114      	asrs	r4, r2
    6f84:	1c53      	adds	r3, r2, #1
    6f86:	001a      	movs	r2, r3
    6f88:	420c      	tst	r4, r1
    6f8a:	d0f9      	beq.n	6f80 <ffs+0xc>
    6f8c:	0018      	movs	r0, r3
    6f8e:	bd10      	pop	{r4, pc}

00006f90 <__libc_init_array>:
    6f90:	b570      	push	{r4, r5, r6, lr}
    6f92:	2600      	movs	r6, #0
    6f94:	4d0c      	ldr	r5, [pc, #48]	; (6fc8 <__libc_init_array+0x38>)
    6f96:	4c0d      	ldr	r4, [pc, #52]	; (6fcc <__libc_init_array+0x3c>)
    6f98:	1b64      	subs	r4, r4, r5
    6f9a:	10a4      	asrs	r4, r4, #2
    6f9c:	42a6      	cmp	r6, r4
    6f9e:	d109      	bne.n	6fb4 <__libc_init_array+0x24>
    6fa0:	2600      	movs	r6, #0
    6fa2:	f001 f83f 	bl	8024 <_init>
    6fa6:	4d0a      	ldr	r5, [pc, #40]	; (6fd0 <__libc_init_array+0x40>)
    6fa8:	4c0a      	ldr	r4, [pc, #40]	; (6fd4 <__libc_init_array+0x44>)
    6faa:	1b64      	subs	r4, r4, r5
    6fac:	10a4      	asrs	r4, r4, #2
    6fae:	42a6      	cmp	r6, r4
    6fb0:	d105      	bne.n	6fbe <__libc_init_array+0x2e>
    6fb2:	bd70      	pop	{r4, r5, r6, pc}
    6fb4:	00b3      	lsls	r3, r6, #2
    6fb6:	58eb      	ldr	r3, [r5, r3]
    6fb8:	4798      	blx	r3
    6fba:	3601      	adds	r6, #1
    6fbc:	e7ee      	b.n	6f9c <__libc_init_array+0xc>
    6fbe:	00b3      	lsls	r3, r6, #2
    6fc0:	58eb      	ldr	r3, [r5, r3]
    6fc2:	4798      	blx	r3
    6fc4:	3601      	adds	r6, #1
    6fc6:	e7f2      	b.n	6fae <__libc_init_array+0x1e>
    6fc8:	00008030 	.word	0x00008030
    6fcc:	00008030 	.word	0x00008030
    6fd0:	00008030 	.word	0x00008030
    6fd4:	00008034 	.word	0x00008034

00006fd8 <memset>:
    6fd8:	0003      	movs	r3, r0
    6fda:	1882      	adds	r2, r0, r2
    6fdc:	4293      	cmp	r3, r2
    6fde:	d100      	bne.n	6fe2 <memset+0xa>
    6fe0:	4770      	bx	lr
    6fe2:	7019      	strb	r1, [r3, #0]
    6fe4:	3301      	adds	r3, #1
    6fe6:	e7f9      	b.n	6fdc <memset+0x4>

00006fe8 <siprintf>:
    6fe8:	b40e      	push	{r1, r2, r3}
    6fea:	b510      	push	{r4, lr}
    6fec:	b09d      	sub	sp, #116	; 0x74
    6fee:	a902      	add	r1, sp, #8
    6ff0:	9002      	str	r0, [sp, #8]
    6ff2:	6108      	str	r0, [r1, #16]
    6ff4:	480b      	ldr	r0, [pc, #44]	; (7024 <siprintf+0x3c>)
    6ff6:	2482      	movs	r4, #130	; 0x82
    6ff8:	6088      	str	r0, [r1, #8]
    6ffa:	6148      	str	r0, [r1, #20]
    6ffc:	2001      	movs	r0, #1
    6ffe:	4240      	negs	r0, r0
    7000:	ab1f      	add	r3, sp, #124	; 0x7c
    7002:	81c8      	strh	r0, [r1, #14]
    7004:	4808      	ldr	r0, [pc, #32]	; (7028 <siprintf+0x40>)
    7006:	cb04      	ldmia	r3!, {r2}
    7008:	00a4      	lsls	r4, r4, #2
    700a:	6800      	ldr	r0, [r0, #0]
    700c:	9301      	str	r3, [sp, #4]
    700e:	818c      	strh	r4, [r1, #12]
    7010:	f000 f8cc 	bl	71ac <_svfiprintf_r>
    7014:	2300      	movs	r3, #0
    7016:	9a02      	ldr	r2, [sp, #8]
    7018:	7013      	strb	r3, [r2, #0]
    701a:	b01d      	add	sp, #116	; 0x74
    701c:	bc10      	pop	{r4}
    701e:	bc08      	pop	{r3}
    7020:	b003      	add	sp, #12
    7022:	4718      	bx	r3
    7024:	7fffffff 	.word	0x7fffffff
    7028:	20000014 	.word	0x20000014

0000702c <_malloc_r>:
    702c:	2303      	movs	r3, #3
    702e:	b570      	push	{r4, r5, r6, lr}
    7030:	1ccd      	adds	r5, r1, #3
    7032:	439d      	bics	r5, r3
    7034:	3508      	adds	r5, #8
    7036:	0006      	movs	r6, r0
    7038:	2d0c      	cmp	r5, #12
    703a:	d21e      	bcs.n	707a <_malloc_r+0x4e>
    703c:	250c      	movs	r5, #12
    703e:	42a9      	cmp	r1, r5
    7040:	d81d      	bhi.n	707e <_malloc_r+0x52>
    7042:	0030      	movs	r0, r6
    7044:	f000 fb76 	bl	7734 <__malloc_lock>
    7048:	4a25      	ldr	r2, [pc, #148]	; (70e0 <_malloc_r+0xb4>)
    704a:	6814      	ldr	r4, [r2, #0]
    704c:	0021      	movs	r1, r4
    704e:	2900      	cmp	r1, #0
    7050:	d119      	bne.n	7086 <_malloc_r+0x5a>
    7052:	4c24      	ldr	r4, [pc, #144]	; (70e4 <_malloc_r+0xb8>)
    7054:	6823      	ldr	r3, [r4, #0]
    7056:	2b00      	cmp	r3, #0
    7058:	d103      	bne.n	7062 <_malloc_r+0x36>
    705a:	0030      	movs	r0, r6
    705c:	f000 fb32 	bl	76c4 <_sbrk_r>
    7060:	6020      	str	r0, [r4, #0]
    7062:	0029      	movs	r1, r5
    7064:	0030      	movs	r0, r6
    7066:	f000 fb2d 	bl	76c4 <_sbrk_r>
    706a:	1c43      	adds	r3, r0, #1
    706c:	d12c      	bne.n	70c8 <_malloc_r+0x9c>
    706e:	230c      	movs	r3, #12
    7070:	0030      	movs	r0, r6
    7072:	6033      	str	r3, [r6, #0]
    7074:	f000 fb5f 	bl	7736 <__malloc_unlock>
    7078:	e003      	b.n	7082 <_malloc_r+0x56>
    707a:	2d00      	cmp	r5, #0
    707c:	dadf      	bge.n	703e <_malloc_r+0x12>
    707e:	230c      	movs	r3, #12
    7080:	6033      	str	r3, [r6, #0]
    7082:	2000      	movs	r0, #0
    7084:	bd70      	pop	{r4, r5, r6, pc}
    7086:	680b      	ldr	r3, [r1, #0]
    7088:	1b5b      	subs	r3, r3, r5
    708a:	d41a      	bmi.n	70c2 <_malloc_r+0x96>
    708c:	2b0b      	cmp	r3, #11
    708e:	d903      	bls.n	7098 <_malloc_r+0x6c>
    7090:	600b      	str	r3, [r1, #0]
    7092:	18cc      	adds	r4, r1, r3
    7094:	6025      	str	r5, [r4, #0]
    7096:	e003      	b.n	70a0 <_malloc_r+0x74>
    7098:	428c      	cmp	r4, r1
    709a:	d10e      	bne.n	70ba <_malloc_r+0x8e>
    709c:	6863      	ldr	r3, [r4, #4]
    709e:	6013      	str	r3, [r2, #0]
    70a0:	0030      	movs	r0, r6
    70a2:	f000 fb48 	bl	7736 <__malloc_unlock>
    70a6:	0020      	movs	r0, r4
    70a8:	2207      	movs	r2, #7
    70aa:	300b      	adds	r0, #11
    70ac:	1d23      	adds	r3, r4, #4
    70ae:	4390      	bics	r0, r2
    70b0:	1ac3      	subs	r3, r0, r3
    70b2:	d0e7      	beq.n	7084 <_malloc_r+0x58>
    70b4:	425a      	negs	r2, r3
    70b6:	50e2      	str	r2, [r4, r3]
    70b8:	e7e4      	b.n	7084 <_malloc_r+0x58>
    70ba:	684b      	ldr	r3, [r1, #4]
    70bc:	6063      	str	r3, [r4, #4]
    70be:	000c      	movs	r4, r1
    70c0:	e7ee      	b.n	70a0 <_malloc_r+0x74>
    70c2:	000c      	movs	r4, r1
    70c4:	6849      	ldr	r1, [r1, #4]
    70c6:	e7c2      	b.n	704e <_malloc_r+0x22>
    70c8:	2303      	movs	r3, #3
    70ca:	1cc4      	adds	r4, r0, #3
    70cc:	439c      	bics	r4, r3
    70ce:	42a0      	cmp	r0, r4
    70d0:	d0e0      	beq.n	7094 <_malloc_r+0x68>
    70d2:	1a21      	subs	r1, r4, r0
    70d4:	0030      	movs	r0, r6
    70d6:	f000 faf5 	bl	76c4 <_sbrk_r>
    70da:	1c43      	adds	r3, r0, #1
    70dc:	d1da      	bne.n	7094 <_malloc_r+0x68>
    70de:	e7c6      	b.n	706e <_malloc_r+0x42>
    70e0:	200007bc 	.word	0x200007bc
    70e4:	200007c0 	.word	0x200007c0

000070e8 <__ssputs_r>:
    70e8:	b5f0      	push	{r4, r5, r6, r7, lr}
    70ea:	688e      	ldr	r6, [r1, #8]
    70ec:	b085      	sub	sp, #20
    70ee:	0007      	movs	r7, r0
    70f0:	000c      	movs	r4, r1
    70f2:	9203      	str	r2, [sp, #12]
    70f4:	9301      	str	r3, [sp, #4]
    70f6:	429e      	cmp	r6, r3
    70f8:	d839      	bhi.n	716e <__ssputs_r+0x86>
    70fa:	2390      	movs	r3, #144	; 0x90
    70fc:	898a      	ldrh	r2, [r1, #12]
    70fe:	00db      	lsls	r3, r3, #3
    7100:	421a      	tst	r2, r3
    7102:	d034      	beq.n	716e <__ssputs_r+0x86>
    7104:	2503      	movs	r5, #3
    7106:	6909      	ldr	r1, [r1, #16]
    7108:	6823      	ldr	r3, [r4, #0]
    710a:	1a5b      	subs	r3, r3, r1
    710c:	9302      	str	r3, [sp, #8]
    710e:	6963      	ldr	r3, [r4, #20]
    7110:	9802      	ldr	r0, [sp, #8]
    7112:	435d      	muls	r5, r3
    7114:	0feb      	lsrs	r3, r5, #31
    7116:	195d      	adds	r5, r3, r5
    7118:	9b01      	ldr	r3, [sp, #4]
    711a:	106d      	asrs	r5, r5, #1
    711c:	3301      	adds	r3, #1
    711e:	181b      	adds	r3, r3, r0
    7120:	42ab      	cmp	r3, r5
    7122:	d900      	bls.n	7126 <__ssputs_r+0x3e>
    7124:	001d      	movs	r5, r3
    7126:	0553      	lsls	r3, r2, #21
    7128:	d532      	bpl.n	7190 <__ssputs_r+0xa8>
    712a:	0029      	movs	r1, r5
    712c:	0038      	movs	r0, r7
    712e:	f7ff ff7d 	bl	702c <_malloc_r>
    7132:	1e06      	subs	r6, r0, #0
    7134:	d109      	bne.n	714a <__ssputs_r+0x62>
    7136:	230c      	movs	r3, #12
    7138:	603b      	str	r3, [r7, #0]
    713a:	2340      	movs	r3, #64	; 0x40
    713c:	2001      	movs	r0, #1
    713e:	89a2      	ldrh	r2, [r4, #12]
    7140:	4240      	negs	r0, r0
    7142:	4313      	orrs	r3, r2
    7144:	81a3      	strh	r3, [r4, #12]
    7146:	b005      	add	sp, #20
    7148:	bdf0      	pop	{r4, r5, r6, r7, pc}
    714a:	9a02      	ldr	r2, [sp, #8]
    714c:	6921      	ldr	r1, [r4, #16]
    714e:	f000 fad6 	bl	76fe <memcpy>
    7152:	89a3      	ldrh	r3, [r4, #12]
    7154:	4a14      	ldr	r2, [pc, #80]	; (71a8 <__ssputs_r+0xc0>)
    7156:	401a      	ands	r2, r3
    7158:	2380      	movs	r3, #128	; 0x80
    715a:	4313      	orrs	r3, r2
    715c:	81a3      	strh	r3, [r4, #12]
    715e:	9b02      	ldr	r3, [sp, #8]
    7160:	6126      	str	r6, [r4, #16]
    7162:	18f6      	adds	r6, r6, r3
    7164:	6026      	str	r6, [r4, #0]
    7166:	6165      	str	r5, [r4, #20]
    7168:	9e01      	ldr	r6, [sp, #4]
    716a:	1aed      	subs	r5, r5, r3
    716c:	60a5      	str	r5, [r4, #8]
    716e:	9b01      	ldr	r3, [sp, #4]
    7170:	42b3      	cmp	r3, r6
    7172:	d200      	bcs.n	7176 <__ssputs_r+0x8e>
    7174:	001e      	movs	r6, r3
    7176:	0032      	movs	r2, r6
    7178:	9903      	ldr	r1, [sp, #12]
    717a:	6820      	ldr	r0, [r4, #0]
    717c:	f000 fac8 	bl	7710 <memmove>
    7180:	68a3      	ldr	r3, [r4, #8]
    7182:	2000      	movs	r0, #0
    7184:	1b9b      	subs	r3, r3, r6
    7186:	60a3      	str	r3, [r4, #8]
    7188:	6823      	ldr	r3, [r4, #0]
    718a:	199e      	adds	r6, r3, r6
    718c:	6026      	str	r6, [r4, #0]
    718e:	e7da      	b.n	7146 <__ssputs_r+0x5e>
    7190:	002a      	movs	r2, r5
    7192:	0038      	movs	r0, r7
    7194:	f000 fb1a 	bl	77cc <_realloc_r>
    7198:	1e06      	subs	r6, r0, #0
    719a:	d1e0      	bne.n	715e <__ssputs_r+0x76>
    719c:	6921      	ldr	r1, [r4, #16]
    719e:	0038      	movs	r0, r7
    71a0:	f000 faca 	bl	7738 <_free_r>
    71a4:	e7c7      	b.n	7136 <__ssputs_r+0x4e>
    71a6:	46c0      	nop			; (mov r8, r8)
    71a8:	fffffb7f 	.word	0xfffffb7f

000071ac <_svfiprintf_r>:
    71ac:	b5f0      	push	{r4, r5, r6, r7, lr}
    71ae:	b09f      	sub	sp, #124	; 0x7c
    71b0:	9002      	str	r0, [sp, #8]
    71b2:	9305      	str	r3, [sp, #20]
    71b4:	898b      	ldrh	r3, [r1, #12]
    71b6:	000f      	movs	r7, r1
    71b8:	0016      	movs	r6, r2
    71ba:	061b      	lsls	r3, r3, #24
    71bc:	d511      	bpl.n	71e2 <_svfiprintf_r+0x36>
    71be:	690b      	ldr	r3, [r1, #16]
    71c0:	2b00      	cmp	r3, #0
    71c2:	d10e      	bne.n	71e2 <_svfiprintf_r+0x36>
    71c4:	2140      	movs	r1, #64	; 0x40
    71c6:	f7ff ff31 	bl	702c <_malloc_r>
    71ca:	6038      	str	r0, [r7, #0]
    71cc:	6138      	str	r0, [r7, #16]
    71ce:	2800      	cmp	r0, #0
    71d0:	d105      	bne.n	71de <_svfiprintf_r+0x32>
    71d2:	230c      	movs	r3, #12
    71d4:	9a02      	ldr	r2, [sp, #8]
    71d6:	3801      	subs	r0, #1
    71d8:	6013      	str	r3, [r2, #0]
    71da:	b01f      	add	sp, #124	; 0x7c
    71dc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    71de:	2340      	movs	r3, #64	; 0x40
    71e0:	617b      	str	r3, [r7, #20]
    71e2:	2300      	movs	r3, #0
    71e4:	ad06      	add	r5, sp, #24
    71e6:	616b      	str	r3, [r5, #20]
    71e8:	3320      	adds	r3, #32
    71ea:	766b      	strb	r3, [r5, #25]
    71ec:	3310      	adds	r3, #16
    71ee:	76ab      	strb	r3, [r5, #26]
    71f0:	0034      	movs	r4, r6
    71f2:	7823      	ldrb	r3, [r4, #0]
    71f4:	2b00      	cmp	r3, #0
    71f6:	d147      	bne.n	7288 <_svfiprintf_r+0xdc>
    71f8:	1ba3      	subs	r3, r4, r6
    71fa:	9304      	str	r3, [sp, #16]
    71fc:	d00d      	beq.n	721a <_svfiprintf_r+0x6e>
    71fe:	1ba3      	subs	r3, r4, r6
    7200:	0032      	movs	r2, r6
    7202:	0039      	movs	r1, r7
    7204:	9802      	ldr	r0, [sp, #8]
    7206:	f7ff ff6f 	bl	70e8 <__ssputs_r>
    720a:	1c43      	adds	r3, r0, #1
    720c:	d100      	bne.n	7210 <_svfiprintf_r+0x64>
    720e:	e0b5      	b.n	737c <_svfiprintf_r+0x1d0>
    7210:	696a      	ldr	r2, [r5, #20]
    7212:	9b04      	ldr	r3, [sp, #16]
    7214:	4694      	mov	ip, r2
    7216:	4463      	add	r3, ip
    7218:	616b      	str	r3, [r5, #20]
    721a:	7823      	ldrb	r3, [r4, #0]
    721c:	2b00      	cmp	r3, #0
    721e:	d100      	bne.n	7222 <_svfiprintf_r+0x76>
    7220:	e0ac      	b.n	737c <_svfiprintf_r+0x1d0>
    7222:	2201      	movs	r2, #1
    7224:	2300      	movs	r3, #0
    7226:	4252      	negs	r2, r2
    7228:	606a      	str	r2, [r5, #4]
    722a:	a902      	add	r1, sp, #8
    722c:	3254      	adds	r2, #84	; 0x54
    722e:	1852      	adds	r2, r2, r1
    7230:	3401      	adds	r4, #1
    7232:	602b      	str	r3, [r5, #0]
    7234:	60eb      	str	r3, [r5, #12]
    7236:	60ab      	str	r3, [r5, #8]
    7238:	7013      	strb	r3, [r2, #0]
    723a:	65ab      	str	r3, [r5, #88]	; 0x58
    723c:	4e58      	ldr	r6, [pc, #352]	; (73a0 <_svfiprintf_r+0x1f4>)
    723e:	2205      	movs	r2, #5
    7240:	7821      	ldrb	r1, [r4, #0]
    7242:	0030      	movs	r0, r6
    7244:	f000 fa50 	bl	76e8 <memchr>
    7248:	1c62      	adds	r2, r4, #1
    724a:	2800      	cmp	r0, #0
    724c:	d120      	bne.n	7290 <_svfiprintf_r+0xe4>
    724e:	6829      	ldr	r1, [r5, #0]
    7250:	06cb      	lsls	r3, r1, #27
    7252:	d504      	bpl.n	725e <_svfiprintf_r+0xb2>
    7254:	2353      	movs	r3, #83	; 0x53
    7256:	ae02      	add	r6, sp, #8
    7258:	3020      	adds	r0, #32
    725a:	199b      	adds	r3, r3, r6
    725c:	7018      	strb	r0, [r3, #0]
    725e:	070b      	lsls	r3, r1, #28
    7260:	d504      	bpl.n	726c <_svfiprintf_r+0xc0>
    7262:	2353      	movs	r3, #83	; 0x53
    7264:	202b      	movs	r0, #43	; 0x2b
    7266:	ae02      	add	r6, sp, #8
    7268:	199b      	adds	r3, r3, r6
    726a:	7018      	strb	r0, [r3, #0]
    726c:	7823      	ldrb	r3, [r4, #0]
    726e:	2b2a      	cmp	r3, #42	; 0x2a
    7270:	d016      	beq.n	72a0 <_svfiprintf_r+0xf4>
    7272:	2000      	movs	r0, #0
    7274:	210a      	movs	r1, #10
    7276:	9b09      	ldr	r3, [sp, #36]	; 0x24
    7278:	7822      	ldrb	r2, [r4, #0]
    727a:	3a30      	subs	r2, #48	; 0x30
    727c:	2a09      	cmp	r2, #9
    727e:	d955      	bls.n	732c <_svfiprintf_r+0x180>
    7280:	2800      	cmp	r0, #0
    7282:	d015      	beq.n	72b0 <_svfiprintf_r+0x104>
    7284:	9309      	str	r3, [sp, #36]	; 0x24
    7286:	e013      	b.n	72b0 <_svfiprintf_r+0x104>
    7288:	2b25      	cmp	r3, #37	; 0x25
    728a:	d0b5      	beq.n	71f8 <_svfiprintf_r+0x4c>
    728c:	3401      	adds	r4, #1
    728e:	e7b0      	b.n	71f2 <_svfiprintf_r+0x46>
    7290:	2301      	movs	r3, #1
    7292:	1b80      	subs	r0, r0, r6
    7294:	4083      	lsls	r3, r0
    7296:	6829      	ldr	r1, [r5, #0]
    7298:	0014      	movs	r4, r2
    729a:	430b      	orrs	r3, r1
    729c:	602b      	str	r3, [r5, #0]
    729e:	e7cd      	b.n	723c <_svfiprintf_r+0x90>
    72a0:	9b05      	ldr	r3, [sp, #20]
    72a2:	1d18      	adds	r0, r3, #4
    72a4:	681b      	ldr	r3, [r3, #0]
    72a6:	9005      	str	r0, [sp, #20]
    72a8:	2b00      	cmp	r3, #0
    72aa:	db39      	blt.n	7320 <_svfiprintf_r+0x174>
    72ac:	9309      	str	r3, [sp, #36]	; 0x24
    72ae:	0014      	movs	r4, r2
    72b0:	7823      	ldrb	r3, [r4, #0]
    72b2:	2b2e      	cmp	r3, #46	; 0x2e
    72b4:	d10b      	bne.n	72ce <_svfiprintf_r+0x122>
    72b6:	7863      	ldrb	r3, [r4, #1]
    72b8:	1c62      	adds	r2, r4, #1
    72ba:	2b2a      	cmp	r3, #42	; 0x2a
    72bc:	d13e      	bne.n	733c <_svfiprintf_r+0x190>
    72be:	9b05      	ldr	r3, [sp, #20]
    72c0:	3402      	adds	r4, #2
    72c2:	1d1a      	adds	r2, r3, #4
    72c4:	681b      	ldr	r3, [r3, #0]
    72c6:	9205      	str	r2, [sp, #20]
    72c8:	2b00      	cmp	r3, #0
    72ca:	db34      	blt.n	7336 <_svfiprintf_r+0x18a>
    72cc:	9307      	str	r3, [sp, #28]
    72ce:	4e35      	ldr	r6, [pc, #212]	; (73a4 <_svfiprintf_r+0x1f8>)
    72d0:	7821      	ldrb	r1, [r4, #0]
    72d2:	2203      	movs	r2, #3
    72d4:	0030      	movs	r0, r6
    72d6:	f000 fa07 	bl	76e8 <memchr>
    72da:	2800      	cmp	r0, #0
    72dc:	d006      	beq.n	72ec <_svfiprintf_r+0x140>
    72de:	2340      	movs	r3, #64	; 0x40
    72e0:	1b80      	subs	r0, r0, r6
    72e2:	4083      	lsls	r3, r0
    72e4:	682a      	ldr	r2, [r5, #0]
    72e6:	3401      	adds	r4, #1
    72e8:	4313      	orrs	r3, r2
    72ea:	602b      	str	r3, [r5, #0]
    72ec:	7821      	ldrb	r1, [r4, #0]
    72ee:	2206      	movs	r2, #6
    72f0:	482d      	ldr	r0, [pc, #180]	; (73a8 <_svfiprintf_r+0x1fc>)
    72f2:	1c66      	adds	r6, r4, #1
    72f4:	7629      	strb	r1, [r5, #24]
    72f6:	f000 f9f7 	bl	76e8 <memchr>
    72fa:	2800      	cmp	r0, #0
    72fc:	d046      	beq.n	738c <_svfiprintf_r+0x1e0>
    72fe:	4b2b      	ldr	r3, [pc, #172]	; (73ac <_svfiprintf_r+0x200>)
    7300:	2b00      	cmp	r3, #0
    7302:	d12f      	bne.n	7364 <_svfiprintf_r+0x1b8>
    7304:	6829      	ldr	r1, [r5, #0]
    7306:	9b05      	ldr	r3, [sp, #20]
    7308:	2207      	movs	r2, #7
    730a:	05c9      	lsls	r1, r1, #23
    730c:	d528      	bpl.n	7360 <_svfiprintf_r+0x1b4>
    730e:	189b      	adds	r3, r3, r2
    7310:	4393      	bics	r3, r2
    7312:	3308      	adds	r3, #8
    7314:	9305      	str	r3, [sp, #20]
    7316:	696b      	ldr	r3, [r5, #20]
    7318:	9a03      	ldr	r2, [sp, #12]
    731a:	189b      	adds	r3, r3, r2
    731c:	616b      	str	r3, [r5, #20]
    731e:	e767      	b.n	71f0 <_svfiprintf_r+0x44>
    7320:	425b      	negs	r3, r3
    7322:	60eb      	str	r3, [r5, #12]
    7324:	2302      	movs	r3, #2
    7326:	430b      	orrs	r3, r1
    7328:	602b      	str	r3, [r5, #0]
    732a:	e7c0      	b.n	72ae <_svfiprintf_r+0x102>
    732c:	434b      	muls	r3, r1
    732e:	3401      	adds	r4, #1
    7330:	189b      	adds	r3, r3, r2
    7332:	2001      	movs	r0, #1
    7334:	e7a0      	b.n	7278 <_svfiprintf_r+0xcc>
    7336:	2301      	movs	r3, #1
    7338:	425b      	negs	r3, r3
    733a:	e7c7      	b.n	72cc <_svfiprintf_r+0x120>
    733c:	2300      	movs	r3, #0
    733e:	0014      	movs	r4, r2
    7340:	200a      	movs	r0, #10
    7342:	001a      	movs	r2, r3
    7344:	606b      	str	r3, [r5, #4]
    7346:	7821      	ldrb	r1, [r4, #0]
    7348:	3930      	subs	r1, #48	; 0x30
    734a:	2909      	cmp	r1, #9
    734c:	d903      	bls.n	7356 <_svfiprintf_r+0x1aa>
    734e:	2b00      	cmp	r3, #0
    7350:	d0bd      	beq.n	72ce <_svfiprintf_r+0x122>
    7352:	9207      	str	r2, [sp, #28]
    7354:	e7bb      	b.n	72ce <_svfiprintf_r+0x122>
    7356:	4342      	muls	r2, r0
    7358:	3401      	adds	r4, #1
    735a:	1852      	adds	r2, r2, r1
    735c:	2301      	movs	r3, #1
    735e:	e7f2      	b.n	7346 <_svfiprintf_r+0x19a>
    7360:	3307      	adds	r3, #7
    7362:	e7d5      	b.n	7310 <_svfiprintf_r+0x164>
    7364:	ab05      	add	r3, sp, #20
    7366:	9300      	str	r3, [sp, #0]
    7368:	003a      	movs	r2, r7
    736a:	4b11      	ldr	r3, [pc, #68]	; (73b0 <_svfiprintf_r+0x204>)
    736c:	0029      	movs	r1, r5
    736e:	9802      	ldr	r0, [sp, #8]
    7370:	e000      	b.n	7374 <_svfiprintf_r+0x1c8>
    7372:	bf00      	nop
    7374:	9003      	str	r0, [sp, #12]
    7376:	9b03      	ldr	r3, [sp, #12]
    7378:	3301      	adds	r3, #1
    737a:	d1cc      	bne.n	7316 <_svfiprintf_r+0x16a>
    737c:	89bb      	ldrh	r3, [r7, #12]
    737e:	980b      	ldr	r0, [sp, #44]	; 0x2c
    7380:	065b      	lsls	r3, r3, #25
    7382:	d400      	bmi.n	7386 <_svfiprintf_r+0x1da>
    7384:	e729      	b.n	71da <_svfiprintf_r+0x2e>
    7386:	2001      	movs	r0, #1
    7388:	4240      	negs	r0, r0
    738a:	e726      	b.n	71da <_svfiprintf_r+0x2e>
    738c:	ab05      	add	r3, sp, #20
    738e:	9300      	str	r3, [sp, #0]
    7390:	003a      	movs	r2, r7
    7392:	4b07      	ldr	r3, [pc, #28]	; (73b0 <_svfiprintf_r+0x204>)
    7394:	0029      	movs	r1, r5
    7396:	9802      	ldr	r0, [sp, #8]
    7398:	f000 f87a 	bl	7490 <_printf_i>
    739c:	e7ea      	b.n	7374 <_svfiprintf_r+0x1c8>
    739e:	46c0      	nop			; (mov r8, r8)
    73a0:	00007ff0 	.word	0x00007ff0
    73a4:	00007ff6 	.word	0x00007ff6
    73a8:	00007ffa 	.word	0x00007ffa
    73ac:	00000000 	.word	0x00000000
    73b0:	000070e9 	.word	0x000070e9

000073b4 <_printf_common>:
    73b4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    73b6:	0015      	movs	r5, r2
    73b8:	9301      	str	r3, [sp, #4]
    73ba:	688a      	ldr	r2, [r1, #8]
    73bc:	690b      	ldr	r3, [r1, #16]
    73be:	9000      	str	r0, [sp, #0]
    73c0:	000c      	movs	r4, r1
    73c2:	4293      	cmp	r3, r2
    73c4:	da00      	bge.n	73c8 <_printf_common+0x14>
    73c6:	0013      	movs	r3, r2
    73c8:	0022      	movs	r2, r4
    73ca:	602b      	str	r3, [r5, #0]
    73cc:	3243      	adds	r2, #67	; 0x43
    73ce:	7812      	ldrb	r2, [r2, #0]
    73d0:	2a00      	cmp	r2, #0
    73d2:	d001      	beq.n	73d8 <_printf_common+0x24>
    73d4:	3301      	adds	r3, #1
    73d6:	602b      	str	r3, [r5, #0]
    73d8:	6823      	ldr	r3, [r4, #0]
    73da:	069b      	lsls	r3, r3, #26
    73dc:	d502      	bpl.n	73e4 <_printf_common+0x30>
    73de:	682b      	ldr	r3, [r5, #0]
    73e0:	3302      	adds	r3, #2
    73e2:	602b      	str	r3, [r5, #0]
    73e4:	2706      	movs	r7, #6
    73e6:	6823      	ldr	r3, [r4, #0]
    73e8:	401f      	ands	r7, r3
    73ea:	d027      	beq.n	743c <_printf_common+0x88>
    73ec:	0023      	movs	r3, r4
    73ee:	3343      	adds	r3, #67	; 0x43
    73f0:	781b      	ldrb	r3, [r3, #0]
    73f2:	1e5a      	subs	r2, r3, #1
    73f4:	4193      	sbcs	r3, r2
    73f6:	6822      	ldr	r2, [r4, #0]
    73f8:	0692      	lsls	r2, r2, #26
    73fa:	d430      	bmi.n	745e <_printf_common+0xaa>
    73fc:	0022      	movs	r2, r4
    73fe:	9901      	ldr	r1, [sp, #4]
    7400:	3243      	adds	r2, #67	; 0x43
    7402:	9800      	ldr	r0, [sp, #0]
    7404:	9e08      	ldr	r6, [sp, #32]
    7406:	47b0      	blx	r6
    7408:	1c43      	adds	r3, r0, #1
    740a:	d025      	beq.n	7458 <_printf_common+0xa4>
    740c:	2306      	movs	r3, #6
    740e:	6820      	ldr	r0, [r4, #0]
    7410:	682a      	ldr	r2, [r5, #0]
    7412:	68e1      	ldr	r1, [r4, #12]
    7414:	4003      	ands	r3, r0
    7416:	2500      	movs	r5, #0
    7418:	2b04      	cmp	r3, #4
    741a:	d103      	bne.n	7424 <_printf_common+0x70>
    741c:	1a8d      	subs	r5, r1, r2
    741e:	43eb      	mvns	r3, r5
    7420:	17db      	asrs	r3, r3, #31
    7422:	401d      	ands	r5, r3
    7424:	68a3      	ldr	r3, [r4, #8]
    7426:	6922      	ldr	r2, [r4, #16]
    7428:	4293      	cmp	r3, r2
    742a:	dd01      	ble.n	7430 <_printf_common+0x7c>
    742c:	1a9b      	subs	r3, r3, r2
    742e:	18ed      	adds	r5, r5, r3
    7430:	2700      	movs	r7, #0
    7432:	42bd      	cmp	r5, r7
    7434:	d120      	bne.n	7478 <_printf_common+0xc4>
    7436:	2000      	movs	r0, #0
    7438:	e010      	b.n	745c <_printf_common+0xa8>
    743a:	3701      	adds	r7, #1
    743c:	68e3      	ldr	r3, [r4, #12]
    743e:	682a      	ldr	r2, [r5, #0]
    7440:	1a9b      	subs	r3, r3, r2
    7442:	429f      	cmp	r7, r3
    7444:	dad2      	bge.n	73ec <_printf_common+0x38>
    7446:	0022      	movs	r2, r4
    7448:	2301      	movs	r3, #1
    744a:	3219      	adds	r2, #25
    744c:	9901      	ldr	r1, [sp, #4]
    744e:	9800      	ldr	r0, [sp, #0]
    7450:	9e08      	ldr	r6, [sp, #32]
    7452:	47b0      	blx	r6
    7454:	1c43      	adds	r3, r0, #1
    7456:	d1f0      	bne.n	743a <_printf_common+0x86>
    7458:	2001      	movs	r0, #1
    745a:	4240      	negs	r0, r0
    745c:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    745e:	2030      	movs	r0, #48	; 0x30
    7460:	18e1      	adds	r1, r4, r3
    7462:	3143      	adds	r1, #67	; 0x43
    7464:	7008      	strb	r0, [r1, #0]
    7466:	0021      	movs	r1, r4
    7468:	1c5a      	adds	r2, r3, #1
    746a:	3145      	adds	r1, #69	; 0x45
    746c:	7809      	ldrb	r1, [r1, #0]
    746e:	18a2      	adds	r2, r4, r2
    7470:	3243      	adds	r2, #67	; 0x43
    7472:	3302      	adds	r3, #2
    7474:	7011      	strb	r1, [r2, #0]
    7476:	e7c1      	b.n	73fc <_printf_common+0x48>
    7478:	0022      	movs	r2, r4
    747a:	2301      	movs	r3, #1
    747c:	321a      	adds	r2, #26
    747e:	9901      	ldr	r1, [sp, #4]
    7480:	9800      	ldr	r0, [sp, #0]
    7482:	9e08      	ldr	r6, [sp, #32]
    7484:	47b0      	blx	r6
    7486:	1c43      	adds	r3, r0, #1
    7488:	d0e6      	beq.n	7458 <_printf_common+0xa4>
    748a:	3701      	adds	r7, #1
    748c:	e7d1      	b.n	7432 <_printf_common+0x7e>
	...

00007490 <_printf_i>:
    7490:	b5f0      	push	{r4, r5, r6, r7, lr}
    7492:	b08b      	sub	sp, #44	; 0x2c
    7494:	9206      	str	r2, [sp, #24]
    7496:	000a      	movs	r2, r1
    7498:	3243      	adds	r2, #67	; 0x43
    749a:	9307      	str	r3, [sp, #28]
    749c:	9005      	str	r0, [sp, #20]
    749e:	9204      	str	r2, [sp, #16]
    74a0:	7e0a      	ldrb	r2, [r1, #24]
    74a2:	000c      	movs	r4, r1
    74a4:	9b10      	ldr	r3, [sp, #64]	; 0x40
    74a6:	2a6e      	cmp	r2, #110	; 0x6e
    74a8:	d100      	bne.n	74ac <_printf_i+0x1c>
    74aa:	e08f      	b.n	75cc <_printf_i+0x13c>
    74ac:	d817      	bhi.n	74de <_printf_i+0x4e>
    74ae:	2a63      	cmp	r2, #99	; 0x63
    74b0:	d02c      	beq.n	750c <_printf_i+0x7c>
    74b2:	d808      	bhi.n	74c6 <_printf_i+0x36>
    74b4:	2a00      	cmp	r2, #0
    74b6:	d100      	bne.n	74ba <_printf_i+0x2a>
    74b8:	e099      	b.n	75ee <_printf_i+0x15e>
    74ba:	2a58      	cmp	r2, #88	; 0x58
    74bc:	d054      	beq.n	7568 <_printf_i+0xd8>
    74be:	0026      	movs	r6, r4
    74c0:	3642      	adds	r6, #66	; 0x42
    74c2:	7032      	strb	r2, [r6, #0]
    74c4:	e029      	b.n	751a <_printf_i+0x8a>
    74c6:	2a64      	cmp	r2, #100	; 0x64
    74c8:	d001      	beq.n	74ce <_printf_i+0x3e>
    74ca:	2a69      	cmp	r2, #105	; 0x69
    74cc:	d1f7      	bne.n	74be <_printf_i+0x2e>
    74ce:	6821      	ldr	r1, [r4, #0]
    74d0:	681a      	ldr	r2, [r3, #0]
    74d2:	0608      	lsls	r0, r1, #24
    74d4:	d523      	bpl.n	751e <_printf_i+0x8e>
    74d6:	1d11      	adds	r1, r2, #4
    74d8:	6019      	str	r1, [r3, #0]
    74da:	6815      	ldr	r5, [r2, #0]
    74dc:	e025      	b.n	752a <_printf_i+0x9a>
    74de:	2a73      	cmp	r2, #115	; 0x73
    74e0:	d100      	bne.n	74e4 <_printf_i+0x54>
    74e2:	e088      	b.n	75f6 <_printf_i+0x166>
    74e4:	d808      	bhi.n	74f8 <_printf_i+0x68>
    74e6:	2a6f      	cmp	r2, #111	; 0x6f
    74e8:	d029      	beq.n	753e <_printf_i+0xae>
    74ea:	2a70      	cmp	r2, #112	; 0x70
    74ec:	d1e7      	bne.n	74be <_printf_i+0x2e>
    74ee:	2220      	movs	r2, #32
    74f0:	6809      	ldr	r1, [r1, #0]
    74f2:	430a      	orrs	r2, r1
    74f4:	6022      	str	r2, [r4, #0]
    74f6:	e003      	b.n	7500 <_printf_i+0x70>
    74f8:	2a75      	cmp	r2, #117	; 0x75
    74fa:	d020      	beq.n	753e <_printf_i+0xae>
    74fc:	2a78      	cmp	r2, #120	; 0x78
    74fe:	d1de      	bne.n	74be <_printf_i+0x2e>
    7500:	0022      	movs	r2, r4
    7502:	2178      	movs	r1, #120	; 0x78
    7504:	3245      	adds	r2, #69	; 0x45
    7506:	7011      	strb	r1, [r2, #0]
    7508:	4a6c      	ldr	r2, [pc, #432]	; (76bc <_printf_i+0x22c>)
    750a:	e030      	b.n	756e <_printf_i+0xde>
    750c:	000e      	movs	r6, r1
    750e:	681a      	ldr	r2, [r3, #0]
    7510:	3642      	adds	r6, #66	; 0x42
    7512:	1d11      	adds	r1, r2, #4
    7514:	6019      	str	r1, [r3, #0]
    7516:	6813      	ldr	r3, [r2, #0]
    7518:	7033      	strb	r3, [r6, #0]
    751a:	2301      	movs	r3, #1
    751c:	e079      	b.n	7612 <_printf_i+0x182>
    751e:	0649      	lsls	r1, r1, #25
    7520:	d5d9      	bpl.n	74d6 <_printf_i+0x46>
    7522:	1d11      	adds	r1, r2, #4
    7524:	6019      	str	r1, [r3, #0]
    7526:	2300      	movs	r3, #0
    7528:	5ed5      	ldrsh	r5, [r2, r3]
    752a:	2d00      	cmp	r5, #0
    752c:	da03      	bge.n	7536 <_printf_i+0xa6>
    752e:	232d      	movs	r3, #45	; 0x2d
    7530:	9a04      	ldr	r2, [sp, #16]
    7532:	426d      	negs	r5, r5
    7534:	7013      	strb	r3, [r2, #0]
    7536:	4b62      	ldr	r3, [pc, #392]	; (76c0 <_printf_i+0x230>)
    7538:	270a      	movs	r7, #10
    753a:	9303      	str	r3, [sp, #12]
    753c:	e02f      	b.n	759e <_printf_i+0x10e>
    753e:	6820      	ldr	r0, [r4, #0]
    7540:	6819      	ldr	r1, [r3, #0]
    7542:	0605      	lsls	r5, r0, #24
    7544:	d503      	bpl.n	754e <_printf_i+0xbe>
    7546:	1d08      	adds	r0, r1, #4
    7548:	6018      	str	r0, [r3, #0]
    754a:	680d      	ldr	r5, [r1, #0]
    754c:	e005      	b.n	755a <_printf_i+0xca>
    754e:	0640      	lsls	r0, r0, #25
    7550:	d5f9      	bpl.n	7546 <_printf_i+0xb6>
    7552:	680d      	ldr	r5, [r1, #0]
    7554:	1d08      	adds	r0, r1, #4
    7556:	6018      	str	r0, [r3, #0]
    7558:	b2ad      	uxth	r5, r5
    755a:	4b59      	ldr	r3, [pc, #356]	; (76c0 <_printf_i+0x230>)
    755c:	2708      	movs	r7, #8
    755e:	9303      	str	r3, [sp, #12]
    7560:	2a6f      	cmp	r2, #111	; 0x6f
    7562:	d018      	beq.n	7596 <_printf_i+0x106>
    7564:	270a      	movs	r7, #10
    7566:	e016      	b.n	7596 <_printf_i+0x106>
    7568:	3145      	adds	r1, #69	; 0x45
    756a:	700a      	strb	r2, [r1, #0]
    756c:	4a54      	ldr	r2, [pc, #336]	; (76c0 <_printf_i+0x230>)
    756e:	9203      	str	r2, [sp, #12]
    7570:	681a      	ldr	r2, [r3, #0]
    7572:	6821      	ldr	r1, [r4, #0]
    7574:	1d10      	adds	r0, r2, #4
    7576:	6018      	str	r0, [r3, #0]
    7578:	6815      	ldr	r5, [r2, #0]
    757a:	0608      	lsls	r0, r1, #24
    757c:	d522      	bpl.n	75c4 <_printf_i+0x134>
    757e:	07cb      	lsls	r3, r1, #31
    7580:	d502      	bpl.n	7588 <_printf_i+0xf8>
    7582:	2320      	movs	r3, #32
    7584:	4319      	orrs	r1, r3
    7586:	6021      	str	r1, [r4, #0]
    7588:	2710      	movs	r7, #16
    758a:	2d00      	cmp	r5, #0
    758c:	d103      	bne.n	7596 <_printf_i+0x106>
    758e:	2320      	movs	r3, #32
    7590:	6822      	ldr	r2, [r4, #0]
    7592:	439a      	bics	r2, r3
    7594:	6022      	str	r2, [r4, #0]
    7596:	0023      	movs	r3, r4
    7598:	2200      	movs	r2, #0
    759a:	3343      	adds	r3, #67	; 0x43
    759c:	701a      	strb	r2, [r3, #0]
    759e:	6863      	ldr	r3, [r4, #4]
    75a0:	60a3      	str	r3, [r4, #8]
    75a2:	2b00      	cmp	r3, #0
    75a4:	db5c      	blt.n	7660 <_printf_i+0x1d0>
    75a6:	2204      	movs	r2, #4
    75a8:	6821      	ldr	r1, [r4, #0]
    75aa:	4391      	bics	r1, r2
    75ac:	6021      	str	r1, [r4, #0]
    75ae:	2d00      	cmp	r5, #0
    75b0:	d158      	bne.n	7664 <_printf_i+0x1d4>
    75b2:	9e04      	ldr	r6, [sp, #16]
    75b4:	2b00      	cmp	r3, #0
    75b6:	d064      	beq.n	7682 <_printf_i+0x1f2>
    75b8:	0026      	movs	r6, r4
    75ba:	9b03      	ldr	r3, [sp, #12]
    75bc:	3642      	adds	r6, #66	; 0x42
    75be:	781b      	ldrb	r3, [r3, #0]
    75c0:	7033      	strb	r3, [r6, #0]
    75c2:	e05e      	b.n	7682 <_printf_i+0x1f2>
    75c4:	0648      	lsls	r0, r1, #25
    75c6:	d5da      	bpl.n	757e <_printf_i+0xee>
    75c8:	b2ad      	uxth	r5, r5
    75ca:	e7d8      	b.n	757e <_printf_i+0xee>
    75cc:	6809      	ldr	r1, [r1, #0]
    75ce:	681a      	ldr	r2, [r3, #0]
    75d0:	0608      	lsls	r0, r1, #24
    75d2:	d505      	bpl.n	75e0 <_printf_i+0x150>
    75d4:	1d11      	adds	r1, r2, #4
    75d6:	6019      	str	r1, [r3, #0]
    75d8:	6813      	ldr	r3, [r2, #0]
    75da:	6962      	ldr	r2, [r4, #20]
    75dc:	601a      	str	r2, [r3, #0]
    75de:	e006      	b.n	75ee <_printf_i+0x15e>
    75e0:	0649      	lsls	r1, r1, #25
    75e2:	d5f7      	bpl.n	75d4 <_printf_i+0x144>
    75e4:	1d11      	adds	r1, r2, #4
    75e6:	6019      	str	r1, [r3, #0]
    75e8:	6813      	ldr	r3, [r2, #0]
    75ea:	8aa2      	ldrh	r2, [r4, #20]
    75ec:	801a      	strh	r2, [r3, #0]
    75ee:	2300      	movs	r3, #0
    75f0:	9e04      	ldr	r6, [sp, #16]
    75f2:	6123      	str	r3, [r4, #16]
    75f4:	e054      	b.n	76a0 <_printf_i+0x210>
    75f6:	681a      	ldr	r2, [r3, #0]
    75f8:	1d11      	adds	r1, r2, #4
    75fa:	6019      	str	r1, [r3, #0]
    75fc:	6816      	ldr	r6, [r2, #0]
    75fe:	2100      	movs	r1, #0
    7600:	6862      	ldr	r2, [r4, #4]
    7602:	0030      	movs	r0, r6
    7604:	f000 f870 	bl	76e8 <memchr>
    7608:	2800      	cmp	r0, #0
    760a:	d001      	beq.n	7610 <_printf_i+0x180>
    760c:	1b80      	subs	r0, r0, r6
    760e:	6060      	str	r0, [r4, #4]
    7610:	6863      	ldr	r3, [r4, #4]
    7612:	6123      	str	r3, [r4, #16]
    7614:	2300      	movs	r3, #0
    7616:	9a04      	ldr	r2, [sp, #16]
    7618:	7013      	strb	r3, [r2, #0]
    761a:	e041      	b.n	76a0 <_printf_i+0x210>
    761c:	6923      	ldr	r3, [r4, #16]
    761e:	0032      	movs	r2, r6
    7620:	9906      	ldr	r1, [sp, #24]
    7622:	9805      	ldr	r0, [sp, #20]
    7624:	9d07      	ldr	r5, [sp, #28]
    7626:	47a8      	blx	r5
    7628:	1c43      	adds	r3, r0, #1
    762a:	d043      	beq.n	76b4 <_printf_i+0x224>
    762c:	6823      	ldr	r3, [r4, #0]
    762e:	2500      	movs	r5, #0
    7630:	079b      	lsls	r3, r3, #30
    7632:	d40f      	bmi.n	7654 <_printf_i+0x1c4>
    7634:	9b09      	ldr	r3, [sp, #36]	; 0x24
    7636:	68e0      	ldr	r0, [r4, #12]
    7638:	4298      	cmp	r0, r3
    763a:	da3d      	bge.n	76b8 <_printf_i+0x228>
    763c:	0018      	movs	r0, r3
    763e:	e03b      	b.n	76b8 <_printf_i+0x228>
    7640:	0022      	movs	r2, r4
    7642:	2301      	movs	r3, #1
    7644:	3219      	adds	r2, #25
    7646:	9906      	ldr	r1, [sp, #24]
    7648:	9805      	ldr	r0, [sp, #20]
    764a:	9e07      	ldr	r6, [sp, #28]
    764c:	47b0      	blx	r6
    764e:	1c43      	adds	r3, r0, #1
    7650:	d030      	beq.n	76b4 <_printf_i+0x224>
    7652:	3501      	adds	r5, #1
    7654:	68e3      	ldr	r3, [r4, #12]
    7656:	9a09      	ldr	r2, [sp, #36]	; 0x24
    7658:	1a9b      	subs	r3, r3, r2
    765a:	429d      	cmp	r5, r3
    765c:	dbf0      	blt.n	7640 <_printf_i+0x1b0>
    765e:	e7e9      	b.n	7634 <_printf_i+0x1a4>
    7660:	2d00      	cmp	r5, #0
    7662:	d0a9      	beq.n	75b8 <_printf_i+0x128>
    7664:	9e04      	ldr	r6, [sp, #16]
    7666:	0028      	movs	r0, r5
    7668:	0039      	movs	r1, r7
    766a:	f7ff fc7d 	bl	6f68 <__aeabi_uidivmod>
    766e:	9b03      	ldr	r3, [sp, #12]
    7670:	3e01      	subs	r6, #1
    7672:	5c5b      	ldrb	r3, [r3, r1]
    7674:	0028      	movs	r0, r5
    7676:	7033      	strb	r3, [r6, #0]
    7678:	0039      	movs	r1, r7
    767a:	f7ff fbef 	bl	6e5c <__udivsi3>
    767e:	1e05      	subs	r5, r0, #0
    7680:	d1f1      	bne.n	7666 <_printf_i+0x1d6>
    7682:	2f08      	cmp	r7, #8
    7684:	d109      	bne.n	769a <_printf_i+0x20a>
    7686:	6823      	ldr	r3, [r4, #0]
    7688:	07db      	lsls	r3, r3, #31
    768a:	d506      	bpl.n	769a <_printf_i+0x20a>
    768c:	6863      	ldr	r3, [r4, #4]
    768e:	6922      	ldr	r2, [r4, #16]
    7690:	4293      	cmp	r3, r2
    7692:	dc02      	bgt.n	769a <_printf_i+0x20a>
    7694:	2330      	movs	r3, #48	; 0x30
    7696:	3e01      	subs	r6, #1
    7698:	7033      	strb	r3, [r6, #0]
    769a:	9b04      	ldr	r3, [sp, #16]
    769c:	1b9b      	subs	r3, r3, r6
    769e:	6123      	str	r3, [r4, #16]
    76a0:	9b07      	ldr	r3, [sp, #28]
    76a2:	aa09      	add	r2, sp, #36	; 0x24
    76a4:	9300      	str	r3, [sp, #0]
    76a6:	0021      	movs	r1, r4
    76a8:	9b06      	ldr	r3, [sp, #24]
    76aa:	9805      	ldr	r0, [sp, #20]
    76ac:	f7ff fe82 	bl	73b4 <_printf_common>
    76b0:	1c43      	adds	r3, r0, #1
    76b2:	d1b3      	bne.n	761c <_printf_i+0x18c>
    76b4:	2001      	movs	r0, #1
    76b6:	4240      	negs	r0, r0
    76b8:	b00b      	add	sp, #44	; 0x2c
    76ba:	bdf0      	pop	{r4, r5, r6, r7, pc}
    76bc:	00008012 	.word	0x00008012
    76c0:	00008001 	.word	0x00008001

000076c4 <_sbrk_r>:
    76c4:	2300      	movs	r3, #0
    76c6:	b570      	push	{r4, r5, r6, lr}
    76c8:	4c06      	ldr	r4, [pc, #24]	; (76e4 <_sbrk_r+0x20>)
    76ca:	0005      	movs	r5, r0
    76cc:	0008      	movs	r0, r1
    76ce:	6023      	str	r3, [r4, #0]
    76d0:	f7fc fd70 	bl	41b4 <_sbrk>
    76d4:	1c43      	adds	r3, r0, #1
    76d6:	d103      	bne.n	76e0 <_sbrk_r+0x1c>
    76d8:	6823      	ldr	r3, [r4, #0]
    76da:	2b00      	cmp	r3, #0
    76dc:	d000      	beq.n	76e0 <_sbrk_r+0x1c>
    76de:	602b      	str	r3, [r5, #0]
    76e0:	bd70      	pop	{r4, r5, r6, pc}
    76e2:	46c0      	nop			; (mov r8, r8)
    76e4:	200008f8 	.word	0x200008f8

000076e8 <memchr>:
    76e8:	b2c9      	uxtb	r1, r1
    76ea:	1882      	adds	r2, r0, r2
    76ec:	4290      	cmp	r0, r2
    76ee:	d101      	bne.n	76f4 <memchr+0xc>
    76f0:	2000      	movs	r0, #0
    76f2:	4770      	bx	lr
    76f4:	7803      	ldrb	r3, [r0, #0]
    76f6:	428b      	cmp	r3, r1
    76f8:	d0fb      	beq.n	76f2 <memchr+0xa>
    76fa:	3001      	adds	r0, #1
    76fc:	e7f6      	b.n	76ec <memchr+0x4>

000076fe <memcpy>:
    76fe:	2300      	movs	r3, #0
    7700:	b510      	push	{r4, lr}
    7702:	429a      	cmp	r2, r3
    7704:	d100      	bne.n	7708 <memcpy+0xa>
    7706:	bd10      	pop	{r4, pc}
    7708:	5ccc      	ldrb	r4, [r1, r3]
    770a:	54c4      	strb	r4, [r0, r3]
    770c:	3301      	adds	r3, #1
    770e:	e7f8      	b.n	7702 <memcpy+0x4>

00007710 <memmove>:
    7710:	b510      	push	{r4, lr}
    7712:	4288      	cmp	r0, r1
    7714:	d902      	bls.n	771c <memmove+0xc>
    7716:	188b      	adds	r3, r1, r2
    7718:	4298      	cmp	r0, r3
    771a:	d308      	bcc.n	772e <memmove+0x1e>
    771c:	2300      	movs	r3, #0
    771e:	429a      	cmp	r2, r3
    7720:	d007      	beq.n	7732 <memmove+0x22>
    7722:	5ccc      	ldrb	r4, [r1, r3]
    7724:	54c4      	strb	r4, [r0, r3]
    7726:	3301      	adds	r3, #1
    7728:	e7f9      	b.n	771e <memmove+0xe>
    772a:	5c8b      	ldrb	r3, [r1, r2]
    772c:	5483      	strb	r3, [r0, r2]
    772e:	3a01      	subs	r2, #1
    7730:	d2fb      	bcs.n	772a <memmove+0x1a>
    7732:	bd10      	pop	{r4, pc}

00007734 <__malloc_lock>:
    7734:	4770      	bx	lr

00007736 <__malloc_unlock>:
    7736:	4770      	bx	lr

00007738 <_free_r>:
    7738:	b570      	push	{r4, r5, r6, lr}
    773a:	0005      	movs	r5, r0
    773c:	2900      	cmp	r1, #0
    773e:	d010      	beq.n	7762 <_free_r+0x2a>
    7740:	1f0c      	subs	r4, r1, #4
    7742:	6823      	ldr	r3, [r4, #0]
    7744:	2b00      	cmp	r3, #0
    7746:	da00      	bge.n	774a <_free_r+0x12>
    7748:	18e4      	adds	r4, r4, r3
    774a:	0028      	movs	r0, r5
    774c:	f7ff fff2 	bl	7734 <__malloc_lock>
    7750:	4a1d      	ldr	r2, [pc, #116]	; (77c8 <_free_r+0x90>)
    7752:	6813      	ldr	r3, [r2, #0]
    7754:	2b00      	cmp	r3, #0
    7756:	d105      	bne.n	7764 <_free_r+0x2c>
    7758:	6063      	str	r3, [r4, #4]
    775a:	6014      	str	r4, [r2, #0]
    775c:	0028      	movs	r0, r5
    775e:	f7ff ffea 	bl	7736 <__malloc_unlock>
    7762:	bd70      	pop	{r4, r5, r6, pc}
    7764:	42a3      	cmp	r3, r4
    7766:	d909      	bls.n	777c <_free_r+0x44>
    7768:	6821      	ldr	r1, [r4, #0]
    776a:	1860      	adds	r0, r4, r1
    776c:	4283      	cmp	r3, r0
    776e:	d1f3      	bne.n	7758 <_free_r+0x20>
    7770:	6818      	ldr	r0, [r3, #0]
    7772:	685b      	ldr	r3, [r3, #4]
    7774:	1841      	adds	r1, r0, r1
    7776:	6021      	str	r1, [r4, #0]
    7778:	e7ee      	b.n	7758 <_free_r+0x20>
    777a:	0013      	movs	r3, r2
    777c:	685a      	ldr	r2, [r3, #4]
    777e:	2a00      	cmp	r2, #0
    7780:	d001      	beq.n	7786 <_free_r+0x4e>
    7782:	42a2      	cmp	r2, r4
    7784:	d9f9      	bls.n	777a <_free_r+0x42>
    7786:	6819      	ldr	r1, [r3, #0]
    7788:	1858      	adds	r0, r3, r1
    778a:	42a0      	cmp	r0, r4
    778c:	d10b      	bne.n	77a6 <_free_r+0x6e>
    778e:	6820      	ldr	r0, [r4, #0]
    7790:	1809      	adds	r1, r1, r0
    7792:	1858      	adds	r0, r3, r1
    7794:	6019      	str	r1, [r3, #0]
    7796:	4282      	cmp	r2, r0
    7798:	d1e0      	bne.n	775c <_free_r+0x24>
    779a:	6810      	ldr	r0, [r2, #0]
    779c:	6852      	ldr	r2, [r2, #4]
    779e:	1841      	adds	r1, r0, r1
    77a0:	6019      	str	r1, [r3, #0]
    77a2:	605a      	str	r2, [r3, #4]
    77a4:	e7da      	b.n	775c <_free_r+0x24>
    77a6:	42a0      	cmp	r0, r4
    77a8:	d902      	bls.n	77b0 <_free_r+0x78>
    77aa:	230c      	movs	r3, #12
    77ac:	602b      	str	r3, [r5, #0]
    77ae:	e7d5      	b.n	775c <_free_r+0x24>
    77b0:	6821      	ldr	r1, [r4, #0]
    77b2:	1860      	adds	r0, r4, r1
    77b4:	4282      	cmp	r2, r0
    77b6:	d103      	bne.n	77c0 <_free_r+0x88>
    77b8:	6810      	ldr	r0, [r2, #0]
    77ba:	6852      	ldr	r2, [r2, #4]
    77bc:	1841      	adds	r1, r0, r1
    77be:	6021      	str	r1, [r4, #0]
    77c0:	6062      	str	r2, [r4, #4]
    77c2:	605c      	str	r4, [r3, #4]
    77c4:	e7ca      	b.n	775c <_free_r+0x24>
    77c6:	46c0      	nop			; (mov r8, r8)
    77c8:	200007bc 	.word	0x200007bc

000077cc <_realloc_r>:
    77cc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    77ce:	0007      	movs	r7, r0
    77d0:	000d      	movs	r5, r1
    77d2:	0016      	movs	r6, r2
    77d4:	2900      	cmp	r1, #0
    77d6:	d105      	bne.n	77e4 <_realloc_r+0x18>
    77d8:	0011      	movs	r1, r2
    77da:	f7ff fc27 	bl	702c <_malloc_r>
    77de:	0004      	movs	r4, r0
    77e0:	0020      	movs	r0, r4
    77e2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    77e4:	2a00      	cmp	r2, #0
    77e6:	d103      	bne.n	77f0 <_realloc_r+0x24>
    77e8:	f7ff ffa6 	bl	7738 <_free_r>
    77ec:	0034      	movs	r4, r6
    77ee:	e7f7      	b.n	77e0 <_realloc_r+0x14>
    77f0:	f000 f812 	bl	7818 <_malloc_usable_size_r>
    77f4:	002c      	movs	r4, r5
    77f6:	4286      	cmp	r6, r0
    77f8:	d9f2      	bls.n	77e0 <_realloc_r+0x14>
    77fa:	0031      	movs	r1, r6
    77fc:	0038      	movs	r0, r7
    77fe:	f7ff fc15 	bl	702c <_malloc_r>
    7802:	1e04      	subs	r4, r0, #0
    7804:	d0ec      	beq.n	77e0 <_realloc_r+0x14>
    7806:	0029      	movs	r1, r5
    7808:	0032      	movs	r2, r6
    780a:	f7ff ff78 	bl	76fe <memcpy>
    780e:	0029      	movs	r1, r5
    7810:	0038      	movs	r0, r7
    7812:	f7ff ff91 	bl	7738 <_free_r>
    7816:	e7e3      	b.n	77e0 <_realloc_r+0x14>

00007818 <_malloc_usable_size_r>:
    7818:	1f0b      	subs	r3, r1, #4
    781a:	681b      	ldr	r3, [r3, #0]
    781c:	1f18      	subs	r0, r3, #4
    781e:	2b00      	cmp	r3, #0
    7820:	da01      	bge.n	7826 <_malloc_usable_size_r+0xe>
    7822:	580b      	ldr	r3, [r1, r0]
    7824:	18c0      	adds	r0, r0, r3
    7826:	4770      	bx	lr

00007828 <u8g2_font_Terminal_tr>:
    7828:	005f 0303 0404 0401 0c05 000c 09fe 09fe     _...............
    7838:	0100 036d 0402 2077 0005 02b1 0c21 b194     ..m...w ....!...
    7848:	7246 4838 22c4 0009 0722 dd35 c242 2322     Fr8H."..".5.B."#
    7858:	9b17 4391 32a4 8491 a12e 48c9 9222 248a     ...C.2.....H"..$
    7868:	9076 241c 0107 0f24 efb6 464a b111 254e     v..$..$...JF..N%
    7878:	9222 2684 2502 b813 272f a11c c485 b152     "..&.%../'....R.
    7888:	2c54 8595 e12a 0008 0d26 b16c 1887 74d2     T,..*...&.l....t
    7898:	8b38 11b4 2707 3206 c27d 2800 9409 4ab1     8....'.2}..(...J
    78a8:	a4a2 029b 0a29 b194 a642 8ba4 0012 072a     ....)...B.....*.
    78b8:	9d33 9222 2b03 560a 4af7 3228 4509 2c00     3."..+.V.J(2.E.,
    78c8:	3407 66af 0252 062d fb16 00c2 062e 9123     .4.fR.-.......#.
    78d8:	00c2 0c2f d185 494e 9226 6489 0032 0f30     ../...NI&..d2.0.
    78e8:	1197 22a7 5523 112c 894b a926 3100 9609     ..."#U,.K.&..1..
    78f8:	2ef1 d444 0327 0c32 f196 2286 0922 3a65     ..D.'.2...."".e:
    7908:	021d 0e33 f196 2286 2a12 854d 0924 0005     ..3....".*M.$...
    7918:	0e34 1197 3853 4923 2494 a947 0090 0d35     4...S8#I.$G...5.
    7928:	f196 10e2 ac54 490a 0a12 3600 960d 4af1     ....T..I...6...J
    7938:	28a6 88ac 2498 0014 0c37 1197 20e3 49a3     .(...$..7.... .I
    7948:	5a85 00d5 0e38 f196 2286 9262 4450 124c     .Z..8...."b.PDL.
    7958:	000a 0e39 f196 2286 9262 84d4 d932 0008     ..9...."b...2...
    7968:	063a 9163 6cc2 093b af74 1d66 2934 3c01     :.c..l;.t.f.4).<
    7978:	7409 2eb1 5124 0b53 073d f546 0ec2 3e35     .t..$QS.=.F...5>
    7988:	7409 22b1 45a6 0629 0e3f f196 2286 ca12     .t.".E).?...."..
    7998:	e514 a130 0008 0e40 b16c 1887 c916 260e     ..0...@.l......&
    79a8:	4dbd 0344 0c41 f196 464a 3111 461d 024c     .MD.A...JF.1.FL.
    79b8:	1142 1197 a4c3 9222 2488 1525 4491 8874     B....."..$%..Dt.
    79c8:	4300 970e 8b11 a224 b551 4449 0a22 4400     .C....$.Q.ID"..D
    79d8:	9713 c311 22a4 8892 2224 4889 9222 0e88     ....."..$".H"...
    79e8:	0011 1245 1197 22e3 c892 9222 4d18 9312     ..E....".."..M..
    79f8:	4445 0107 1146 1197 22e3 c892 9222 4d18     ED..F....".."..M
    7a08:	9312 690a 4700 970e 8b11 a224 9551 126a     ...i.G....$.Q.j.
    7a18:	a891 4800 960a 42f1 e9c4 e230 4924 9409     ...H...B..0.$I..
    7a28:	82b1 d222 0217 0f4a 1197 288f 22d5 8892     .."...J....(."..
    7a38:	2224 0911 4b00 9712 6311 1124 9449 2224     $"...K...c$.I.$"
    7a48:	449a 1124 4a89 4c02 970b 8311 d528 445b     .D$..J.L....(.[D
    7a58:	1074 0d4d 1197 5643 1c39 112a 371a 4e01     t.M...CV9.*..7.N
    7a68:	970d 4311 2b46 2859 1aa6 009b 0c4f 1197     ...CF+Y(....O...
    7a78:	266b e351 a24d 0236 0f50 1197 a4c3 9222     k&Q.M.6.P.....".
    7a88:	2488 a925 0d22 5100 b70d 6b0d 5126 69e3     .$%."..Q...k&Q.i
    7a98:	a352 090a 1052 1197 a4c3 9222 2488 8925     R...R....."..$%.
    7aa8:	4548 1254 0e53 f196 2286 9d62 444a 0924     HET.S...."b.JD$.
    7ab8:	0005 0b54 f196 22e2 0909 46f5 5501 960a     ..T...."...F.U..
    7ac8:	42f1 9fc4 1424 5600 960b 42f1 4fc4 9a12     .B..$..V...B.O..
    7ad8:	0008 0f57 1197 c643 844b d112 1124 2449     ..W...C.K...$.I$
    7ae8:	5800 970d 4311 26c6 9b51 d449 04d8 0c59     .X...C.&Q.I...Y.
    7af8:	f196 c442 4249 aa13 0051 0e5a 1197 20e3     ..B.IB..Q.Z.... 
    7b08:	4922 aa85 d9b2 0041 085b b194 a4c2 044f     "I....A.[.....O.
    7b18:	0c5c d185 2642 0994 4265 0099 085d b194     \...B&..eB..]...
    7b28:	a482 064f 095e 1b47 3a2f a893 5f09 1606     ..O.^.G./:..._..
    7b38:	c2ed 6000 3206 c27d 6100 670d 8711 aa2c     ...`.2}..a.g..,.
    7b48:	2488 d122 0044 0f62 1197 aa63 525a 4911     .$".D.b...c.ZR.I
    7b58:	1244 6511 6302 660b 86f1 2222 492a 0028     D..e.c.f..""*I(.
    7b68:	1064 1197 aa6f 1154 4449 9112 2444 089a     d...o.T.ID..D$..
    7b78:	0c65 f166 2286 0c3a 1245 000a 0d66 f196     e.f..":.E...f...
    7b88:	246a 9451 8495 246a 6700 8710 670d 9242     j$Q...j$.g...gB.
    7b98:	2488 5122 2255 9112 6800 970f 6311 45aa     .$"QU"...h...c.E
    7ba8:	5134 8892 a224 0092 0969 b194 2446 e91d     4Q..$...i...F$..
    7bb8:	6a42 b60d 52ed 341d 48d4 4922 0028 0f6b     Bj...R.4.H"I(.k.
    7bc8:	1197 aa63 5124 49a2 2a44 92a2 6c00 9408     ..c.$Q.ID*...l..
    7bd8:	62b1 5fa4 6d08 670e c311 8922 2250 0894     .b._.m.g..".P"..
    7be8:	4225 6e13 6609 a2f1 e222 0049 0a6f f166     %B.n.f..".I.o.f.
    7bf8:	2286 24e2 00a1 1070 0d87 3243 1152 4449     .".$..p...C2R.ID
    7c08:	9112 24a4 01a4 0f71 0d87 4267 8892 2224     ...$..q...gB..$"
    7c18:	4889 1554 7212 670c 6311 9222 a8ac 690a     .HT..r.g.c"....i
    7c28:	7300 660d 86f1 9222 2588 0922 0005 0c74     .s.f.."..%"...t.
    7c38:	f186 282a 08b3 88b5 0026 0f75 1167 2443     ..*(....&.u.g.C$
    7c48:	4911 1244 4491 9a24 7608 660a 42f1 49c4     .ID..D$..v.f.B.I
    7c58:	1342 7701 670d 4311 12c6 44a1 4934 0024     B..w.g.C...D4I$.
    7c68:	0c78 1167 2643 1b51 24ce 026a 0f79 0d87     x.g.C&Q..$j.y...
    7c78:	2447 4911 1244 a891 44a8 7a03 6609 e2f1     G$.ID....D.z.f..
    7c88:	24a6 1d93 0b7b d195 a44e 1226 84ca 7c0a     .$..{...N.&....|
    7c98:	9207 e271 0081 0c7d d195 a842 1426 44c9     ..q...}...B.&..D
    7ca8:	006a 0a7e 3738 4467 9091 0026 0000 0400     j.~.87gD..&.....
    7cb8:	ffff 0000                                   ....

00007cbc <u8g2_cb_r0>:
    7cbc:	2443 0000 245b 0000 249f 0000 2764 0000     C$..[$...$..d'..
    7ccc:	2740 0000 2752 0000 2764 0000 2764 0000     @'..R'..d'..d'..
    7cdc:	2764 0000                                   d'..

00007ce0 <u8x8_gp1287ai_display_info>:
    7ce0:	0100 78f0 0101 783c 0900 003d 0403 783c     ...x..<x..=...<x
    7cf0:	0720 0000 0100 0032                          .....2.

00007cf8 <u8x8_d_gp1287ai_init_seq>:
    7cf8:	1518 1955 01fe 1518 161e 1910 1518 1633     ..U...........3.
    7d08:	1640 1900 1518 1607 16ff 168c 1600 1604     @...............
    7d18:	1600 1600 1901 1518 168d 1604 16fc 1600     ................
    7d28:	1980 1518 1605 1600 1914 1518 19aa 0ffe     ................
    7d38:	1518 1603 1600 1920 1518 160b 1600 193c     ...... .......<.
    7d48:	1518 1609 1900 1518 1610 1900 1518 1601     ................
    7d58:	1900 1518 1986 00ff                         ........

00007d60 <u8x8_d_gp1287ai_standby_seq>:
    7d60:	1518 1986 00ff 0000                         ........

00007d68 <u8x8_d_gp1287ai_wakeup_seq>:
    7d68:	1518 19b6 01fe 1518 1601 1900 00ff 0000     ................
    7d78:	2e2e 682f 6c70 702f 726f 2f74 7068 5f6c     ../hpl/port/hpl_
    7d88:	7067 6f69 625f 7361 2e65 0068 2e2e 682f     gpio_base.h.../h
    7d98:	6c70 702f 2f6d 7068 5f6c 6d70 625f 7361     pl/pm/hpl_pm_bas
    7da8:	2e65 0068 2e2e 682f 6c61 732f 6372 682f     e.h.../hal/src/h
    7db8:	6c61 695f 2e6f 0063 2e2e 682f 6c61 732f     al_io.c.../hal/s
    7dc8:	6372 682f 6c61 735f 6970 6d5f 735f 6e79     rc/hal_spi_m_syn
    7dd8:	2e63 0063 2e2e 682f 6c61 732f 6372 682f     c.c.../hal/src/h
    7de8:	6c61 755f 6173 7472 735f 6e79 2e63 0063     al_usart_sync.c.
    7df8:	4288 0000 4266 0000 4250 0000 4232 0000     .B..fB..PB..2B..
    7e08:	421a 0000                                   .B..

00007e0c <_map>:
    7e0c:	0001 0000 0021 0000 000a 0000 000a 0000     ....!...........
    7e1c:	000e 0000 003e 0000 2e2e 682f 6c70 652f     ....>...../hpl/e
    7e2c:	6369 682f 6c70 655f 6369 632e 0000 0000     ic/hpl_eic.c....
    7e3c:	2e2e 682f 6c70 732f 7265 6f63 2f6d 7068     ../hpl/sercom/hp
    7e4c:	5f6c 6573 6372 6d6f 632e 0000               l_sercom.c..

00007e58 <sercomspi_regs>:
    7e58:	000c 0020 0000 0002 0000 0000 0017 0000     .. .............
    7e68:	000c 0020 0000 0002 0000 0000 00ef 0100     .. .............
    7e78:	2e2e 682f 6c70 702f 726f 2f74 7068 5f6c     ../hpl/port/hpl_
    7e88:	7067 6f69 625f 7361 2e65 0068 2e2e 682f     gpio_base.h.../h
    7e98:	6c70 702f 2f6d 7068 5f6c 6d70 625f 7361     pl/pm/hpl_pm_bas
    7ea8:	2e65 0068 6630 0000 665a 0000 665a 0000     e.h.0f..Zf..Zf..
    7eb8:	661c 0000 664a 0000 6652 0000 665a 0000     .f..Jf..Rf..Zf..
    7ec8:	665a 0000 665a 0000 665a 0000 665a 0000     Zf..Zf..Zf..Zf..
    7ed8:	665a 0000 6638 0000 5441 454d 204c 4153     Zf..8f..ATMEL SA
    7ee8:	444d 3032 2820 3834 484d 297a 0000 0000     MD20 (48MHz)....
    7ef8:	4e49 3a54 3025 6434 203b 6974 3a6d 3025     INT:%04d; tim:%0
    7f08:	6433 253a 3230 3a64 3025 6432 0020 0000     3d:%02d:%02d ...
    7f18:	3025 6432 252f 3230 2f64 3025 6432 252f     %02d/%02d/%02d/%
    7f28:	3230 2f64 3025 6432 2020 2020 0000 0000     02d/%02d    ....
    7f38:	2020 2020 2020 2020 2020 2020 2020 2020                     
    7f48:	2020 2020 0d0a 0000 5aa5 0000 0180 0000         .....Z......
	...
    7f64:	0000 ff00 aa00 aaaa 00aa 0000 0fa2 0f0f     ................
    7f74:	0f0f 0f0f 0f0f 0f0f 0f0f 0f0f 000f 0000     ................
    7f84:	00ab 0019 00ae 0019 40b1 0000               .........@..

00007f90 <__sf_fake_stderr>:
	...

00007fb0 <__sf_fake_stdin>:
	...

00007fd0 <__sf_fake_stdout>:
	...
    7ff0:	2d23 2b30 0020 6c68 004c 6665 4567 4746     #-0+ .hlL.efgEFG
    8000:	3000 3231 3433 3635 3837 4139 4342 4544     .0123456789ABCDE
    8010:	0046 3130 3332 3534 3736 3938 6261 6463     F.0123456789abcd
    8020:	6665 0000                                   ef..

00008024 <_init>:
    8024:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    8026:	46c0      	nop			; (mov r8, r8)
    8028:	bcf8      	pop	{r3, r4, r5, r6, r7}
    802a:	bc08      	pop	{r3}
    802c:	469e      	mov	lr, r3
    802e:	4770      	bx	lr

00008030 <__init_array_start>:
    8030:	000000cd 	.word	0x000000cd

00008034 <_fini>:
    8034:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    8036:	46c0      	nop			; (mov r8, r8)
    8038:	bcf8      	pop	{r3, r4, r5, r6, r7}
    803a:	bc08      	pop	{r3}
    803c:	469e      	mov	lr, r3
    803e:	4770      	bx	lr

00008040 <__fini_array_start>:
    8040:	000000a5 	.word	0x000000a5
